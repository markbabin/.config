/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./api/index.ts":
/*!**********************!*\
  !*** ./api/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports[\"default\"] = joplin;\n\n\n//# sourceURL=webpack://joplin-plugin-freehand-drawing/./api/index.ts?");

/***/ }),

/***/ "./api/types.ts":
/*!**********************!*\
  !*** ./api/types.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/* eslint-disable multiline-comment-style */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ContentScriptType = exports.SettingStorage = exports.AppType = exports.SettingItemSubType = exports.SettingItemType = exports.ToolbarButtonLocation = exports.isContextMenuItemLocation = exports.MenuItemLocation = exports.ModelType = exports.ImportModuleOutputFormat = exports.FileSystemItem = void 0;\n// =================================================================\n// Interop API types\n// =================================================================\nvar FileSystemItem;\n(function (FileSystemItem) {\n    FileSystemItem[\"File\"] = \"file\";\n    FileSystemItem[\"Directory\"] = \"directory\";\n})(FileSystemItem || (exports.FileSystemItem = FileSystemItem = {}));\nvar ImportModuleOutputFormat;\n(function (ImportModuleOutputFormat) {\n    ImportModuleOutputFormat[\"Markdown\"] = \"md\";\n    ImportModuleOutputFormat[\"Html\"] = \"html\";\n})(ImportModuleOutputFormat || (exports.ImportModuleOutputFormat = ImportModuleOutputFormat = {}));\nvar ModelType;\n(function (ModelType) {\n    ModelType[ModelType[\"Note\"] = 1] = \"Note\";\n    ModelType[ModelType[\"Folder\"] = 2] = \"Folder\";\n    ModelType[ModelType[\"Setting\"] = 3] = \"Setting\";\n    ModelType[ModelType[\"Resource\"] = 4] = \"Resource\";\n    ModelType[ModelType[\"Tag\"] = 5] = \"Tag\";\n    ModelType[ModelType[\"NoteTag\"] = 6] = \"NoteTag\";\n    ModelType[ModelType[\"Search\"] = 7] = \"Search\";\n    ModelType[ModelType[\"Alarm\"] = 8] = \"Alarm\";\n    ModelType[ModelType[\"MasterKey\"] = 9] = \"MasterKey\";\n    ModelType[ModelType[\"ItemChange\"] = 10] = \"ItemChange\";\n    ModelType[ModelType[\"NoteResource\"] = 11] = \"NoteResource\";\n    ModelType[ModelType[\"ResourceLocalState\"] = 12] = \"ResourceLocalState\";\n    ModelType[ModelType[\"Revision\"] = 13] = \"Revision\";\n    ModelType[ModelType[\"Migration\"] = 14] = \"Migration\";\n    ModelType[ModelType[\"SmartFilter\"] = 15] = \"SmartFilter\";\n    ModelType[ModelType[\"Command\"] = 16] = \"Command\";\n})(ModelType || (exports.ModelType = ModelType = {}));\nvar MenuItemLocation;\n(function (MenuItemLocation) {\n    MenuItemLocation[\"File\"] = \"file\";\n    MenuItemLocation[\"Edit\"] = \"edit\";\n    MenuItemLocation[\"View\"] = \"view\";\n    MenuItemLocation[\"Note\"] = \"note\";\n    MenuItemLocation[\"Tools\"] = \"tools\";\n    MenuItemLocation[\"Help\"] = \"help\";\n    /**\n     * @deprecated Do not use - same as NoteListContextMenu\n     */\n    MenuItemLocation[\"Context\"] = \"context\";\n    // If adding an item here, don't forget to update isContextMenuItemLocation()\n    /**\n     * When a command is called from the note list context menu, the\n     * command will receive the following arguments:\n     *\n     * - `noteIds:string[]`: IDs of the notes that were right-clicked on.\n     */\n    MenuItemLocation[\"NoteListContextMenu\"] = \"noteListContextMenu\";\n    MenuItemLocation[\"EditorContextMenu\"] = \"editorContextMenu\";\n    /**\n     * When a command is called from a folder context menu, the\n     * command will receive the following arguments:\n     *\n     * - `folderId:string`: ID of the folder that was right-clicked on\n     */\n    MenuItemLocation[\"FolderContextMenu\"] = \"folderContextMenu\";\n    /**\n     * When a command is called from a tag context menu, the\n     * command will receive the following arguments:\n     *\n     * - `tagId:string`: ID of the tag that was right-clicked on\n     */\n    MenuItemLocation[\"TagContextMenu\"] = \"tagContextMenu\";\n})(MenuItemLocation || (exports.MenuItemLocation = MenuItemLocation = {}));\nfunction isContextMenuItemLocation(location) {\n    return [\n        MenuItemLocation.Context,\n        MenuItemLocation.NoteListContextMenu,\n        MenuItemLocation.EditorContextMenu,\n        MenuItemLocation.FolderContextMenu,\n        MenuItemLocation.TagContextMenu,\n    ].includes(location);\n}\nexports.isContextMenuItemLocation = isContextMenuItemLocation;\nvar ToolbarButtonLocation;\n(function (ToolbarButtonLocation) {\n    /**\n     * This toolbar in the top right corner of the application. It applies to the note as a whole, including its metadata.\n     */\n    ToolbarButtonLocation[\"NoteToolbar\"] = \"noteToolbar\";\n    /**\n     * This toolbar is right above the text editor. It applies to the note body only.\n     */\n    ToolbarButtonLocation[\"EditorToolbar\"] = \"editorToolbar\";\n})(ToolbarButtonLocation || (exports.ToolbarButtonLocation = ToolbarButtonLocation = {}));\n// =================================================================\n// Settings types\n// =================================================================\nvar SettingItemType;\n(function (SettingItemType) {\n    SettingItemType[SettingItemType[\"Int\"] = 1] = \"Int\";\n    SettingItemType[SettingItemType[\"String\"] = 2] = \"String\";\n    SettingItemType[SettingItemType[\"Bool\"] = 3] = \"Bool\";\n    SettingItemType[SettingItemType[\"Array\"] = 4] = \"Array\";\n    SettingItemType[SettingItemType[\"Object\"] = 5] = \"Object\";\n    SettingItemType[SettingItemType[\"Button\"] = 6] = \"Button\";\n})(SettingItemType || (exports.SettingItemType = SettingItemType = {}));\nvar SettingItemSubType;\n(function (SettingItemSubType) {\n    SettingItemSubType[\"FilePathAndArgs\"] = \"file_path_and_args\";\n    SettingItemSubType[\"FilePath\"] = \"file_path\";\n    SettingItemSubType[\"DirectoryPath\"] = \"directory_path\";\n})(SettingItemSubType || (exports.SettingItemSubType = SettingItemSubType = {}));\nvar AppType;\n(function (AppType) {\n    AppType[\"Desktop\"] = \"desktop\";\n    AppType[\"Mobile\"] = \"mobile\";\n    AppType[\"Cli\"] = \"cli\";\n})(AppType || (exports.AppType = AppType = {}));\nvar SettingStorage;\n(function (SettingStorage) {\n    SettingStorage[SettingStorage[\"Database\"] = 1] = \"Database\";\n    SettingStorage[SettingStorage[\"File\"] = 2] = \"File\";\n})(SettingStorage || (exports.SettingStorage = SettingStorage = {}));\nvar ContentScriptType;\n(function (ContentScriptType) {\n    /**\n     * Registers a new Markdown-It plugin, which should follow the template\n     * below.\n     *\n     * ```javascript\n     * module.exports = {\n     *     default: function(context) {\n     *         return {\n     *             plugin: function(markdownIt, pluginOptions) {\n     *                 // ...\n     *             },\n     *             assets: {\n     *                 // ...\n     *             },\n     *         }\n     *     }\n     * }\n     * ```\n     *\n     * See [the\n     * demo](https://github.com/laurent22/joplin/tree/dev/packages/app-cli/tests/support/plugins/content_script)\n     * for a simple Markdown-it plugin example.\n     *\n     * ## Exported members\n     *\n     * - The `context` argument is currently unused but could be used later on\n     *   to provide access to your own plugin so that the content script and\n     *   plugin can communicate.\n     *\n     * - The **required** `plugin` key is the actual Markdown-It plugin - check\n     *   the [official doc](https://github.com/markdown-it/markdown-it) for more\n     *   information.\n     *\n     * - Using the **optional** `assets` key you may specify assets such as JS\n     *   or CSS that should be loaded in the rendered HTML document. Check for\n     *   example the Joplin [Mermaid\n     *   plugin](https://github.com/laurent22/joplin/blob/dev/packages/renderer/MdToHtml/rules/mermaid.ts)\n     *   to see how the data should be structured.\n     *\n     * ## Getting the settings from the renderer\n     *\n     * You can access your plugin settings from the renderer by calling\n     * `pluginOptions.settingValue(\"your-setting-key')`.\n     *\n     * ## Posting messages from the content script to your plugin\n     *\n     * The application provides the following function to allow executing\n     * commands from the rendered HTML code:\n     *\n     * ```javascript\n     * const response = await webviewApi.postMessage(contentScriptId, message);\n     * ```\n     *\n     * - `contentScriptId` is the ID you've defined when you registered the\n     *   content script. You can retrieve it from the\n     *   {@link ContentScriptContext | context}.\n     * - `message` can be any basic JavaScript type (number, string, plain\n     *   object), but it cannot be a function or class instance.\n     *\n     * When you post a message, the plugin can send back a `response` thus\n     * allowing two-way communication:\n     *\n     * ```javascript\n     * await joplin.contentScripts.onMessage(contentScriptId, (message) => {\n     *     // Process message\n     *     return response; // Can be any object, string or number\n     * });\n     * ```\n     *\n     * See {@link JoplinContentScripts.onMessage} for more details, as well as\n     * the [postMessage\n     * demo](https://github.com/laurent22/joplin/tree/dev/packages/app-cli/tests/support/plugins/post_messages).\n     *\n     * ## Registering an existing Markdown-it plugin\n     *\n     * To include a regular Markdown-It plugin, that doesn't make use of any\n     * Joplin-specific features, you would simply create a file such as this:\n     *\n     * ```javascript\n     * module.exports = {\n     *     default: function(context) {\n     *         return {\n     *             plugin: require('markdown-it-toc-done-right');\n     *         }\n     *     }\n     * }\n     * ```\n     */\n    ContentScriptType[\"MarkdownItPlugin\"] = \"markdownItPlugin\";\n    /**\n     * Registers a new CodeMirror plugin, which should follow the template\n     * below.\n     *\n     * ```javascript\n     * module.exports = {\n     *     default: function(context) {\n     *         return {\n     *             plugin: function(CodeMirror) {\n     *                 // ...\n     *             },\n     *             codeMirrorResources: [],\n     *             codeMirrorOptions: {\n     *                                  // ...\n     *                       },\n     *             assets: {\n     *                 // ...\n     *             },\n     *         }\n     *     }\n     * }\n     * ```\n     *\n     * - The `context` argument is currently unused but could be used later on\n     *   to provide access to your own plugin so that the content script and\n     *   plugin can communicate.\n     *\n     * - The `plugin` key is your CodeMirror plugin. This is where you can\n     *   register new commands with CodeMirror or interact with the CodeMirror\n     *   instance as needed.\n     *\n     * - The `codeMirrorResources` key is an array of CodeMirror resources that\n     *   will be loaded and attached to the CodeMirror module. These are made up\n     *   of addons, keymaps, and modes. For example, for a plugin that want's to\n     *   enable clojure highlighting in code blocks. `codeMirrorResources` would\n     *   be set to `['mode/clojure/clojure']`.\n     *\n     * - The `codeMirrorOptions` key contains all the\n     *   [CodeMirror](https://codemirror.net/doc/manual.html#config) options\n     *   that will be set or changed by this plugin. New options can alse be\n     *   declared via\n     *   [`CodeMirror.defineOption`](https://codemirror.net/doc/manual.html#defineOption),\n     *   and then have their value set here. For example, a plugin that enables\n     *   line numbers would set `codeMirrorOptions` to `{'lineNumbers': true}`.\n     *\n     * - Using the **optional** `assets` key you may specify **only** CSS assets\n     *   that should be loaded in the rendered HTML document. Check for example\n     *   the Joplin [Mermaid\n     *   plugin](https://github.com/laurent22/joplin/blob/dev/packages/renderer/MdToHtml/rules/mermaid.ts)\n     *   to see how the data should be structured.\n     *\n     * One of the `plugin`, `codeMirrorResources`, or `codeMirrorOptions` keys\n     * must be provided for the plugin to be valid. Having multiple or all\n     * provided is also okay.\n     *\n     * See also the [demo\n     * plugin](https://github.com/laurent22/joplin/tree/dev/packages/app-cli/tests/support/plugins/codemirror_content_script)\n     * for an example of all these keys being used in one plugin.\n     *\n     * ## Posting messages from the content script to your plugin\n     *\n     * In order to post messages to the plugin, you can use the postMessage\n     * function passed to the {@link ContentScriptContext | context}.\n     *\n     * ```javascript\n     * const response = await context.postMessage('messageFromCodeMirrorContentScript');\n     * ```\n     *\n     * When you post a message, the plugin can send back a `response` thus\n     * allowing two-way communication:\n     *\n     * ```javascript\n     * await joplin.contentScripts.onMessage(contentScriptId, (message) => {\n     *     // Process message\n     *     return response; // Can be any object, string or number\n     * });\n     * ```\n     *\n     * See {@link JoplinContentScripts.onMessage} for more details, as well as\n     * the [postMessage\n     * demo](https://github.com/laurent22/joplin/tree/dev/packages/app-cli/tests/support/plugins/post_messages).\n     *\n     */\n    ContentScriptType[\"CodeMirrorPlugin\"] = \"codeMirrorPlugin\";\n})(ContentScriptType || (exports.ContentScriptType = ContentScriptType = {}));\n\n\n//# sourceURL=webpack://joplin-plugin-freehand-drawing/./api/types.ts?");

/***/ }),

/***/ "./src/Resource.ts":
/*!*************************!*\
  !*** ./src/Resource.ts ***!
  \*************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Resource = void 0;\nconst api_1 = __webpack_require__(/*! api */ \"./api/index.ts\");\nconst fs = api_1.default.require('fs-extra');\nclass Resource {\n    constructor(props) {\n        var _a;\n        this.tmpdir = props.tmpdir;\n        this.resourceId = props.resourceId;\n        this.mime = props.mime;\n        this.title = props.title;\n        this.fileExt = props.fileExt;\n        this.tempfilePath = (_a = props.tempfilePath) !== null && _a !== void 0 ? _a : null;\n    }\n    // Fetch file data associated with this resource from the Joplin database\n    getDataAsString(encoding = 'utf8') {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = yield api_1.default.data.get(['resources', this.resourceId, 'file']);\n            const stringData = Buffer.from(data.body).toString(encoding);\n            return stringData;\n        });\n    }\n    updateData(data) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.tempfilePath) {\n                yield fs.rm(this.tempfilePath);\n                this.tempfilePath = null;\n            }\n            const tempfilePath = yield this.tmpdir.newFile(data, this.fileExt);\n            const fileData = [{ path: tempfilePath }];\n            const query = null;\n            const metadata = {\n                mime: this.mime,\n                title: this.title,\n                updated_time: Date.now(),\n                user_updated_time: Date.now(),\n                // Remove the leading '.'\n                file_extension: this.fileExt ? /^[.]?(.*)$/.exec(this.fileExt)[1] : null,\n            }; // Don't update metadata\n            yield api_1.default.data.put(['resources', this.resourceId], query, metadata, fileData);\n            this.tempfilePath = tempfilePath;\n        });\n    }\n    htmlSafeTitle() {\n        // Ref: https://stackoverflow.com/a/7382028\n        return this.title\n            .replace(/[&]/g, '&amp;')\n            .replace(/[<]/g, '&lt;')\n            .replace(/[>]/g, '&gt;')\n            .replace(/[\"]/g, '&quot;')\n            .replace(/[']/g, '&#39;');\n    }\n    // Given a URL in the form\n    // file://.../resourceuuid#dataHere?dataHere\n    // or\n    // :/resourceuuid\n    // returns a Resource representing the content\n    // of that URL, **if the resource already exists**.\n    // [fileExt] should include the leading '.'.\n    static fromURL(tmpdir, url, fileExt, mimeType) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            // Extract the ID\n            const fileURLMatch = /^(?:file|joplin[-a-z]+):\\/\\/.*\\/([a-zA-Z0-9]+)[.]\\w+(?:[?#]|$)/.exec(url);\n            const resourceLinkMatch = /^:\\/([a-zA-Z0-9]+)$/.exec(url);\n            let resourceId = null;\n            if (fileURLMatch) {\n                resourceId = fileURLMatch[1];\n            }\n            else if (resourceLinkMatch) {\n                resourceId = resourceLinkMatch[1];\n            }\n            else if (/^[a-z0-9]{32}$/.exec(url)) {\n                resourceId = url;\n            }\n            if (resourceId === null) {\n                return null;\n            }\n            // Fetch resource data\n            // Note: Fetched data does not include a mime type/file_extension\n            const resourceData = yield api_1.default.data.get(['resources', resourceId]);\n            if (!resourceData) {\n                return null;\n            }\n            return new Resource({\n                tmpdir,\n                resourceId: resourceData.id,\n                mime: (_a = resourceData.mime) !== null && _a !== void 0 ? _a : mimeType,\n                title: resourceData.title,\n                fileExt: fileExt,\n                // The resource was loaded through Joplin, and thus has no assoicated tempfile.\n                tempfilePath: undefined,\n            });\n        });\n    }\n    static ofData(tmpdir, data, title, fileExtension) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const query = null;\n            const metadata = {\n                title: title.endsWith(fileExtension) ? title : `${title}${fileExtension}`,\n                created_time: Date.now(),\n                updated_time: Date.now(),\n                file_extension: fileExtension,\n            };\n            const filePath = yield tmpdir.newFile(data, fileExtension);\n            const fileData = [{ path: filePath }];\n            const result = yield api_1.default.data.post(['resources'], query, metadata, fileData);\n            const resource = new Resource({\n                tmpdir: tmpdir,\n                resourceId: result.id,\n                mime: result.mime,\n                title: result.title,\n                fileExt: fileExtension,\n            });\n            return resource;\n        });\n    }\n}\nexports.Resource = Resource;\nexports[\"default\"] = Resource;\n\n\n//# sourceURL=webpack://joplin-plugin-freehand-drawing/./src/Resource.ts?");

/***/ }),

/***/ "./src/TemporaryDirectory.ts":
/*!***********************************!*\
  !*** ./src/TemporaryDirectory.ts ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst api_1 = __webpack_require__(/*! api */ \"./api/index.ts\");\nconst os_1 = __webpack_require__(/*! os */ \"os\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst fs = api_1.default.require('fs-extra');\nconst appTmpDirectories = [];\nclass TemporaryDirectory {\n    constructor(path) {\n        this.path = path;\n        this.fileIdCounter = 0;\n        appTmpDirectories.push(this);\n    }\n    // Returns a new path to a temporary file in this directory.\n    // [fileExtension], if given, should include the leading '.'.\n    nextFilepath(fileExtension = '') {\n        if (this.path === null) {\n            throw new Error('Temporary directory does not exist. Possible use after destroySync.');\n        }\n        this.fileIdCounter++;\n        return path.join(this.path, `tmp${this.fileIdCounter}${fileExtension !== null && fileExtension !== void 0 ? fileExtension : ''}`);\n    }\n    newFile(data, fileExtension = '') {\n        return __awaiter(this, void 0, void 0, function* () {\n            const path = this.nextFilepath(fileExtension);\n            const file = yield fs.open(path, 'w');\n            yield fs.writeFile(file, data);\n            yield fs.close(file);\n            return path;\n        });\n    }\n    // Destroys this directory and all files it contains\n    destroySync() {\n        if (this.path) {\n            fs.rmSync(this.path, { recursive: true });\n            this.path = null;\n        }\n    }\n    static create() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const prefix = 'joplin-js-draw';\n            const directoryPath = yield fs.mkdtemp(path.join((0, os_1.tmpdir)(), prefix));\n            return new TemporaryDirectory(directoryPath);\n        });\n    }\n}\nexports[\"default\"] = TemporaryDirectory;\nconst cleanTempDirs = () => {\n    for (const dir of appTmpDirectories) {\n        dir.destroySync();\n    }\n};\nif (typeof window !== 'undefined') {\n    window.addEventListener('beforeunload', () => {\n        cleanTempDirs();\n    });\n}\nelse {\n    process.on('exit', () => {\n        cleanTempDirs();\n    });\n}\n\n\n//# sourceURL=webpack://joplin-plugin-freehand-drawing/./src/TemporaryDirectory.ts?");

/***/ }),

/***/ "./src/autosave.ts":
/*!*************************!*\
  !*** ./src/autosave.ts ***!
  \*************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getAutosave = exports.hasAutosave = exports.clearAutosave = exports.autosave = void 0;\nconst api_1 = __webpack_require__(/*! api */ \"./api/index.ts\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst fs = api_1.default.require('fs-extra');\nconst getAutosaveDir = () => __awaiter(void 0, void 0, void 0, function* () {\n    const dataDir = yield api_1.default.plugins.dataDir();\n    const autosavePath = path.join(dataDir, 'autosaves');\n    return autosavePath;\n});\nconst makeAutosaveDir = () => __awaiter(void 0, void 0, void 0, function* () {\n    const autosavePath = yield getAutosaveDir();\n    if (!(yield fs.pathExists(autosavePath))) {\n        yield fs.mkdir(autosavePath);\n    }\n    return autosavePath;\n});\nconst autosaveFilename = 'autosave.svg';\nconst autosave = (data) => __awaiter(void 0, void 0, void 0, function* () {\n    const autosaveDir = yield makeAutosaveDir();\n    yield fs.writeFile(path.join(autosaveDir, autosaveFilename), data);\n});\nexports.autosave = autosave;\nconst clearAutosave = () => __awaiter(void 0, void 0, void 0, function* () {\n    const autosavePath = yield getAutosaveDir();\n    if (yield fs.pathExists(autosavePath)) {\n        yield fs.remove(autosavePath);\n    }\n});\nexports.clearAutosave = clearAutosave;\nconst hasAutosave = () => __awaiter(void 0, void 0, void 0, function* () {\n    const autosavePath = yield getAutosaveDir();\n    if (yield fs.pathExists(path.join(autosavePath, autosaveFilename))) {\n        return true;\n    }\n    return false;\n});\nexports.hasAutosave = hasAutosave;\nconst getAutosave = () => __awaiter(void 0, void 0, void 0, function* () {\n    if (yield (0, exports.hasAutosave)()) {\n        const autosavePath = yield getAutosaveDir();\n        const data = yield fs.readFile(path.join(autosavePath, autosaveFilename), 'utf-8');\n        return data;\n    }\n    return null;\n});\nexports.getAutosave = getAutosave;\n\n\n//# sourceURL=webpack://joplin-plugin-freehand-drawing/./src/autosave.ts?");

/***/ }),

/***/ "./src/constants.ts":
/*!**************************!*\
  !*** ./src/constants.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.pluginPrefix = void 0;\n// A string that can be used to prefix various resources used by the plugin to avoid\n// name conflict.\nexports.pluginPrefix = 'jop-freehand-drawing-jsdraw-plugin-';\n\n\n//# sourceURL=webpack://joplin-plugin-freehand-drawing/./src/constants.ts?");

/***/ }),

/***/ "./src/dialog/AbstractDrawingView.ts":
/*!*******************************************!*\
  !*** ./src/dialog/AbstractDrawingView.ts ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst autosave_1 = __webpack_require__(/*! ../autosave */ \"./src/autosave.ts\");\nconst localization_1 = __webpack_require__(/*! ../localization */ \"./src/localization.ts\");\nconst types_1 = __webpack_require__(/*! ../types */ \"./src/types.ts\");\nconst promptForImages_1 = __webpack_require__(/*! ../util/promptForImages */ \"./src/util/promptForImages.ts\");\nclass AbstractDrawingView {\n    constructor(tempDir) {\n        this.tempDir = tempDir;\n        this.autosaveInterval = 120 * 1000; // ms\n        this.toolbarType = types_1.ToolbarType.Default;\n        this.styleMode = types_1.EditorStyle.MatchJoplin;\n        this.keybindings = Object.create(null);\n    }\n    /** Resets the dialog prior to use. This can be called multiple times. */\n    initializeDialog() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Sometimes, the dialog doesn't load properly.\n            // Add a cancel button to hide it and try loading again.\n            yield this.setDialogButtons([{ id: 'cancel' }]);\n            // Script path is from the root of the plugin directory\n            yield this.addScript('./dialog/webview/webview.js');\n            yield this.addScript('./dialog/webview/webview.css');\n        });\n    }\n    /** Sets the autosave interval in milliseconds. Takes effect on the next editor launch. */\n    setAutosaveInterval(interval) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.autosaveInterval = interval;\n        });\n    }\n    /** Sets the toolbar to be displayed in the dialog. Takes effect on the next editor launch. */\n    setToolbarType(type) {\n        this.toolbarType = type;\n    }\n    /** Changes the editor's style. Takes effect on the next launch of the editor. */\n    setStyleMode(style) {\n        this.styleMode = style;\n    }\n    /** Sets the keyboard shortcuts. Takes effect when the editor is next launched. */\n    setKeyboardShortcuts(keybindings) {\n        for (const id in keybindings) {\n            this.keybindings[id] = [...keybindings[id]];\n        }\n    }\n    /**\n     * Displays a dialog that allows the user to insert a drawing.\n     *\n     * @returns true if the drawing was saved at least once.\n     */\n    promptForDrawing(options) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.initializeDialog();\n            let saveOption = (_a = options.initialSaveMethod) !== null && _a !== void 0 ? _a : null;\n            let didSave = false;\n            if (!options.saveCallbacks.saveAsNew) {\n                saveOption = types_1.SaveMethod.Overwrite;\n            }\n            const save = (data) => __awaiter(this, void 0, void 0, function* () {\n                try {\n                    if (saveOption === types_1.SaveMethod.SaveAsNew) {\n                        if (options.saveCallbacks.saveAsNew) {\n                            yield options.saveCallbacks.saveAsNew(data);\n                        }\n                        else {\n                            throw new Error('saveAsNew save callback not defined');\n                        }\n                    }\n                    else if (saveOption === types_1.SaveMethod.Overwrite) {\n                        yield options.saveCallbacks.overwrite(data);\n                    }\n                    else {\n                        throw new Error('saveOption must be either saveAsNew or overwrite');\n                    }\n                    this.postMessage({\n                        type: types_1.MessageType.SaveCompleted,\n                    });\n                    didSave = true;\n                }\n                catch (error) {\n                    console.error('js-draw', error);\n                    alert('Not saved: ' + error);\n                }\n            });\n            const result = new Promise((resolve, reject) => {\n                let saveData = null;\n                this.onMessage((message) => __awaiter(this, void 0, void 0, function* () {\n                    if (message.type === 'saveSVG' && !saveOption) {\n                        saveData = message.data;\n                        this.setDialogButtons([\n                            {\n                                id: 'ok',\n                                title: localization_1.default.saveAndClose,\n                            },\n                        ]);\n                        return {\n                            type: types_1.ResponseType.SaveResponse,\n                            waitingForSaveType: true,\n                        };\n                    }\n                    else if (message.type === 'saveSVG' && saveOption) {\n                        void save(message.data);\n                        saveData = null;\n                        return {\n                            type: types_1.ResponseType.SaveResponse,\n                            waitingForSaveType: false,\n                        };\n                    }\n                    else if (message.type === types_1.MessageType.SetSaveMethod) {\n                        saveOption = message.method;\n                    }\n                    else if (message.type === types_1.MessageType.GetInitialData) {\n                        // The drawing dialog has loaded -- we don't need the exit button.\n                        this.setDialogButtons([]);\n                        return {\n                            type: types_1.ResponseType.InitialDataResponse,\n                            autosaveIntervalMS: this.autosaveInterval,\n                            toolbarType: this.toolbarType,\n                            initialData: options.initialData,\n                            styleMode: this.styleMode,\n                            keyboardShortcuts: this.keybindings,\n                        };\n                    }\n                    else if (message.type === types_1.MessageType.ShowCloseButton) {\n                        this.setDialogButtons([\n                            {\n                                id: message.isSaved ? 'ok' : 'cancel',\n                                title: message.isSaved ? localization_1.default.close : localization_1.default.discardChanges,\n                            },\n                        ]);\n                    }\n                    else if (message.type === types_1.MessageType.HideButtons) {\n                        this.setDialogButtons([]);\n                        saveData = null;\n                    }\n                    else if (message.type === types_1.MessageType.AutosaveSVG) {\n                        void (0, autosave_1.clearAutosave)().then(() => {\n                            void (0, autosave_1.autosave)(message.data);\n                        });\n                    }\n                    else if (message.type === types_1.MessageType.ShowImagePicker) {\n                        const task = (0, promptForImages_1.default)(this.tempDir);\n                        return {\n                            type: types_1.ResponseType.ImagePickerTaskResponse,\n                            taskId: task.id,\n                        };\n                    }\n                    else if (message.type === types_1.MessageType.CancelImagePicker) {\n                        const task = (0, promptForImages_1.taskById)(message.taskId);\n                        if (task)\n                            task.cancel();\n                        return true;\n                    }\n                    else if (message.type === types_1.MessageType.GetImagePickerResult) {\n                        const task = (0, promptForImages_1.taskById)(message.taskId);\n                        if (task) {\n                            const images = yield task.task;\n                            return {\n                                type: types_1.ResponseType.ImagePickerResponse,\n                                images,\n                            };\n                        }\n                        else {\n                            throw new Error(`No such task: ${message.taskId}`);\n                        }\n                        return true;\n                    }\n                    else if (message.type === types_1.MessageType.CleanUpImagePickerResult) {\n                        (0, promptForImages_1.cleanUpTaskResult)(message.taskId);\n                        return true;\n                    }\n                    return true;\n                }));\n                this.showDialog().then((result) => __awaiter(this, void 0, void 0, function* () {\n                    var _a, _b, _c;\n                    if (saveData && result.id === 'ok') {\n                        saveOption !== null && saveOption !== void 0 ? saveOption : (saveOption = (_c = (_b = (_a = result.formData) === null || _a === void 0 ? void 0 : _a.saveOptions) === null || _b === void 0 ? void 0 : _b.saveOption) !== null && _c !== void 0 ? _c : types_1.SaveMethod.SaveAsNew);\n                        yield save(saveData);\n                        resolve(true);\n                    }\n                    else if (!saveData || result.id === 'cancel') {\n                        resolve(didSave);\n                    }\n                    else {\n                        reject(`Unknown button ID ${result.id}`);\n                    }\n                }));\n            });\n            return yield result;\n        });\n    }\n}\nexports[\"default\"] = AbstractDrawingView;\n\n\n//# sourceURL=webpack://joplin-plugin-freehand-drawing/./src/dialog/AbstractDrawingView.ts?");

/***/ }),

/***/ "./src/dialog/DrawingDialog.ts":
/*!*************************************!*\
  !*** ./src/dialog/DrawingDialog.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst api_1 = __webpack_require__(/*! api */ \"./api/index.ts\");\nconst constants_1 = __webpack_require__(/*! ../constants */ \"./src/constants.ts\");\nconst AbstractDrawingView_1 = __webpack_require__(/*! ./AbstractDrawingView */ \"./src/dialog/AbstractDrawingView.ts\");\nconst dialogs = api_1.default.views.dialogs;\nclass DrawingDialog extends AbstractDrawingView_1.default {\n    constructor() {\n        super(...arguments);\n        this.canFullscreen = true;\n        this.isFullscreen = false;\n    }\n    /** @returns a reference to the singleton instance of the DrawingDialog. */\n    static getInstance(tempDir) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!DrawingDialog.instance) {\n                DrawingDialog.instance = new DrawingDialog(tempDir);\n                DrawingDialog.instance.handle = yield dialogs.create(`${constants_1.pluginPrefix}jsDrawDialog`);\n                yield DrawingDialog.instance.initializeDialog();\n            }\n            return DrawingDialog.instance;\n        });\n    }\n    initializeDialog() {\n        const _super = Object.create(null, {\n            initializeDialog: { get: () => super.initializeDialog }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            yield _super.initializeDialog.call(this);\n            yield dialogs.setHtml(this.handle, '');\n            yield dialogs.setFitToContent(this.handle, false);\n            yield this.setFullscreen(false);\n        });\n    }\n    /**\n     * Sets whether this dialog is automatically set to fullscreen mode when the\n     * editor is visible.\n     */\n    setCanFullscreen(canFullscreen) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.canFullscreen = canFullscreen;\n            if (!canFullscreen) {\n                this.setFullscreen(false);\n            }\n        });\n    }\n    /** Set whether this drawing dialog takes up the entire Joplin window. */\n    setFullscreen(fullscreen) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.isFullscreen === fullscreen) {\n                return;\n            }\n            if (!this.canFullscreen && fullscreen) {\n                return;\n            }\n            this.isFullscreen = fullscreen;\n            const installationDir = yield api_1.default.plugins.installationDir();\n            const cssFile = fullscreen ? 'dialogFullscreen.css' : 'dialogNonfullscreen.css';\n            yield api_1.default.window.loadChromeCssFile(installationDir + '/dialog/userchromeStyles/' + cssFile);\n        });\n    }\n    /**\n     * Sets the buttons visible at the bottom of the dialog and toggles fullscreen if necessary (to ensure the buttons)\n     * are visible.\n     */\n    setDialogButtons(buttons) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // No buttons? Allow fullscreen.\n            yield this.setFullscreen(buttons.length === 0);\n            yield dialogs.setButtons(this.handle, buttons);\n        });\n    }\n    addScript(path) {\n        return dialogs.addScript(this.handle, path);\n    }\n    postMessage(message) {\n        api_1.default.views.panels.postMessage(this.handle, message);\n    }\n    onMessage(onMessageHandler) {\n        api_1.default.views.panels.onMessage(this.handle, onMessageHandler);\n    }\n    showDialog() {\n        return dialogs.open(this.handle);\n    }\n}\nexports[\"default\"] = DrawingDialog;\n\n\n//# sourceURL=webpack://joplin-plugin-freehand-drawing/./src/dialog/DrawingDialog.ts?");

/***/ }),

/***/ "./src/dialog/DrawingWindow.ts":
/*!*************************************!*\
  !*** ./src/dialog/DrawingWindow.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst AbstractDrawingView_1 = __webpack_require__(/*! ./AbstractDrawingView */ \"./src/dialog/AbstractDrawingView.ts\");\nconst path_1 = __webpack_require__(/*! path */ \"path\");\nconst api_1 = __webpack_require__(/*! api */ \"./api/index.ts\");\nclass DrawingWindow extends AbstractDrawingView_1.default {\n    constructor() {\n        super(...arguments);\n        this.scriptPaths = [];\n        this.win = undefined;\n        this.onCloseListener = (_result) => { };\n        this.messageOrigin = undefined;\n    }\n    getBaseURL() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const installationDir = yield api_1.default.plugins.installationDir();\n            return `file://${path_1.posix.normalize(installationDir)}/dialog/window/index.html`;\n        });\n    }\n    getMessageOrigin() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            (_a = this.messageOrigin) !== null && _a !== void 0 ? _a : (this.messageOrigin = new URL(yield this.getBaseURL()).origin);\n            return this.messageOrigin;\n        });\n    }\n    addScript(path) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const scriptPath = (0, path_1.resolve)(yield api_1.default.plugins.installationDir(), path);\n            this.scriptPaths.push(scriptPath);\n            (_a = this.win) === null || _a === void 0 ? void 0 : _a.postMessage({ kind: 'addScript', src: scriptPath }, yield this.getMessageOrigin());\n        });\n    }\n    setDialogButtons(buttons) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            (_a = this.win) === null || _a === void 0 ? void 0 : _a.postMessage({ kind: 'setButtons', buttons }, yield this.getMessageOrigin());\n        });\n    }\n    postMessage(message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.win) {\n                this.win.postMessage({ message }, yield this.getMessageOrigin());\n            }\n        });\n    }\n    onMessage(onMessageHandler) {\n        var _a;\n        if (!this.win) {\n            this.eventListener = onMessageHandler;\n        }\n        else {\n            (_a = this.win) === null || _a === void 0 ? void 0 : _a.addEventListener('message', (event) => __awaiter(this, void 0, void 0, function* () {\n                var _b;\n                if (event.origin !== (yield this.getMessageOrigin())) {\n                    return;\n                }\n                const id = event.data.id;\n                if (id) {\n                    const response = yield onMessageHandler(event.data.message);\n                    console.log(event.data.message, response);\n                    (_b = this.win) === null || _b === void 0 ? void 0 : _b.postMessage({ responseId: id, response });\n                }\n                else if (event.data.kind === 'dialogResult') {\n                    this.onCloseListener(event.data.result);\n                }\n            }));\n        }\n    }\n    showDialog() {\n        const _super = Object.create(null, {\n            initializeDialog: { get: () => super.initializeDialog }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            const installationDir = yield api_1.default.plugins.installationDir();\n            const dialog = window.open(`file://${path_1.posix.normalize(installationDir)}/dialog/window/index.html`, '_blank', 'autoHideMenuBar=true');\n            this.win = dialog;\n            yield new Promise((resolve) => {\n                dialog.addEventListener('load', () => resolve());\n            });\n            if (this.eventListener) {\n                this.onMessage(this.eventListener);\n            }\n            yield _super.initializeDialog.call(this);\n            return new Promise((resolve) => {\n                this.onCloseListener = (result) => resolve(result);\n            });\n        });\n    }\n}\nexports[\"default\"] = DrawingWindow;\n\n\n//# sourceURL=webpack://joplin-plugin-freehand-drawing/./src/dialog/DrawingWindow.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst api_1 = __webpack_require__(/*! api */ \"./api/index.ts\");\nconst types_1 = __webpack_require__(/*! api/types */ \"./api/types.ts\");\nconst autosave_1 = __webpack_require__(/*! ./autosave */ \"./src/autosave.ts\");\nconst localization_1 = __webpack_require__(/*! ./localization */ \"./src/localization.ts\");\nconst Resource_1 = __webpack_require__(/*! ./Resource */ \"./src/Resource.ts\");\nconst TemporaryDirectory_1 = __webpack_require__(/*! ./TemporaryDirectory */ \"./src/TemporaryDirectory.ts\");\nconst waitFor_1 = __webpack_require__(/*! ./util/waitFor */ \"./src/util/waitFor.ts\");\nconst DrawingDialog_1 = __webpack_require__(/*! ./dialog/DrawingDialog */ \"./src/dialog/DrawingDialog.ts\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"./src/constants.ts\");\nconst types_2 = __webpack_require__(/*! ./types */ \"./src/types.ts\");\nconst isVersionGreater_1 = __webpack_require__(/*! ./util/isVersionGreater */ \"./src/util/isVersionGreater.ts\");\nconst DrawingWindow_1 = __webpack_require__(/*! ./dialog/DrawingWindow */ \"./src/dialog/DrawingWindow.ts\");\nconst settings_1 = __webpack_require__(/*! ./settings */ \"./src/settings.ts\");\n// While learning how to use the Joplin plugin API,\n// * https://github.com/herdsothom/joplin-insert-date/blob/main/src/index.ts\n// * and https://github.com/marc0l92/joplin-plugin-drawio\n// were both wonderful references.\n// Returns true if the CodeMirror editor is active.\nconst isMarkdownEditor = () => __awaiter(void 0, void 0, void 0, function* () {\n    return ((yield api_1.default.commands.execute('editor.execCommand', {\n        name: 'js-draw--isCodeMirrorActive',\n    })) === 'active');\n});\nconst saveRichTextEditorSelection = () => __awaiter(void 0, void 0, void 0, function* () {\n    // For saving the selection if switching between editors.\n    // We want the selection placeholder to be able to compile to a regular expression. Avoid\n    // non-alphanumeric characters.\n    const selectionPointIdText = `placeholderid${Math.random()}${Math.random()}`.replace(/[.]/g, 'x');\n    yield api_1.default.commands.execute('editor.execCommand', {\n        name: 'mceInsertContent',\n        value: selectionPointIdText,\n    });\n    return selectionPointIdText;\n});\nconst needsToSwitchEditorsBeforeInsertingText = () => __awaiter(void 0, void 0, void 0, function* () {\n    // Newer versions of Joplin don't have the bug that required switching editors\n    // before inserting text.\n    const version = yield api_1.default.versionInfo();\n    return !(0, isVersionGreater_1.default)(version.version, '2.13.4') && !(yield isMarkdownEditor());\n});\n/**\n * Inserts `textToInsert` at the point of current selection, **or**, if `richTextEditorSelectionMarker`\n * is given and the rich text editor is currently open, replaces `richTextEditorSelectionMarker` with\n * `textToInsert`.\n *\n * `richTextEditorSelectionMarker` works around a bug in the rich text editor. See\n * https://github.com/laurent22/joplin/issues/7547\n */\nconst insertText = (textToInsert, richTextEditorSelectionMarker) => __awaiter(void 0, void 0, void 0, function* () {\n    const needsEditorSwitch = yield needsToSwitchEditorsBeforeInsertingText();\n    // MCE or Joplin has a bug where inserting markdown code for an SVG image removes\n    // the image data. See https://github.com/laurent22/joplin/issues/7547.\n    if (needsEditorSwitch) {\n        // Switch to the markdown editor.\n        yield api_1.default.commands.execute('toggleEditors');\n        // Delay: Ensure we're really in the CodeMirror editor.\n        yield (0, waitFor_1.default)(100);\n        // Jump to the rich text editor selection\n        yield api_1.default.commands.execute('editor.execCommand', {\n            name: 'js-draw--cmSelectAndDelete',\n            args: [richTextEditorSelectionMarker],\n        });\n    }\n    yield api_1.default.commands.execute('insertText', textToInsert);\n    // Try to switch back to the original editor\n    if (needsEditorSwitch) {\n        yield api_1.default.commands.execute('toggleEditors');\n    }\n});\napi_1.default.plugins.register({\n    onStart: function () {\n        return __awaiter(this, void 0, void 0, function* () {\n            const tmpdir = yield TemporaryDirectory_1.default.create();\n            const drawingDialog = yield DrawingDialog_1.default.getInstance(tmpdir);\n            yield (0, settings_1.registerAndApplySettings)(drawingDialog);\n            const insertNewDrawing = (svgData, richTextEditorSelectionData) => __awaiter(this, void 0, void 0, function* () {\n                const resource = yield Resource_1.default.ofData(tmpdir, svgData, localization_1.default.defaultImageTitle, '.svg');\n                const textToInsert = `![${resource.htmlSafeTitle()}](:/${resource.resourceId})`;\n                yield insertText(textToInsert, richTextEditorSelectionData);\n                return resource;\n            });\n            const getDialog = (inNewWindow) => __awaiter(this, void 0, void 0, function* () {\n                let dialog = drawingDialog;\n                if (inNewWindow) {\n                    dialog = new DrawingWindow_1.default(tmpdir);\n                    yield (0, settings_1.applySettingsTo)(dialog);\n                }\n                return dialog;\n            });\n            const editDrawing = (resourceUrl, allowSaveAsCopy = true, inNewWindow) => __awaiter(this, void 0, void 0, function* () {\n                const expectedMime = 'image/svg+xml';\n                const originalResource = yield Resource_1.default.fromURL(tmpdir, resourceUrl, '.svg', expectedMime);\n                if (!originalResource) {\n                    throw new Error('Invalid resource URL!');\n                }\n                if (originalResource.mime !== expectedMime) {\n                    alert(localization_1.default.notAnEditableImage(resourceUrl, originalResource.mime));\n                    return null;\n                }\n                let resource = originalResource;\n                const saveAsNewCallback = (data) => __awaiter(this, void 0, void 0, function* () {\n                    console.log('Image editor: Inserting new drawing...');\n                    resource = yield insertNewDrawing(data);\n                });\n                const dialog = yield getDialog(inNewWindow);\n                const saved = yield dialog.promptForDrawing({\n                    initialData: yield resource.getDataAsString(),\n                    saveCallbacks: {\n                        overwrite: (data) => __awaiter(this, void 0, void 0, function* () {\n                            console.log('Image editor: Overwriting resource...');\n                            yield resource.updateData(data);\n                        }),\n                        saveAsNew: allowSaveAsCopy ? saveAsNewCallback : null,\n                    },\n                });\n                return saved ? resource : null;\n            });\n            const editOrInsertDrawing = (inNewWindow) => __awaiter(this, void 0, void 0, function* () {\n                const selection = yield api_1.default.commands.execute('selectedText');\n                // If selecting a resource URL, edit that. Else, insert a new drawing.\n                if (selection && (/^:\\/[a-zA-Z0-9]+$/.exec(selection) || /^[a-z0-9]{32}$/.exec(selection))) {\n                    console.log('Attempting to edit selected resource,', selection);\n                    // TODO: Update the cache-breaker for the resource.\n                    yield editDrawing(selection, false, inNewWindow);\n                }\n                else {\n                    let savedSelection = undefined;\n                    if (yield needsToSwitchEditorsBeforeInsertingText()) {\n                        savedSelection = yield saveRichTextEditorSelection();\n                    }\n                    const dialog = yield getDialog(inNewWindow);\n                    let savedResource = null;\n                    const saved = yield dialog.promptForDrawing({\n                        initialData: undefined,\n                        saveCallbacks: {\n                            saveAsNew: (svgData) => __awaiter(this, void 0, void 0, function* () {\n                                savedResource = yield insertNewDrawing(svgData, savedSelection);\n                            }),\n                            overwrite: (svgData) => __awaiter(this, void 0, void 0, function* () {\n                                if (!savedResource) {\n                                    throw new Error('A new drawing must be saved once before it can be overwritten');\n                                }\n                                yield savedResource.updateData(svgData);\n                            }),\n                        },\n                        // Save as new without a prompt (can't overwrite at first)\n                        initialSaveMethod: types_2.SaveMethod.SaveAsNew,\n                    });\n                    // If the user canceled the drawing,\n                    if (!saved) {\n                        // Clear the selection marker, if it exists.\n                        if (savedSelection) {\n                            yield insertText('', savedSelection);\n                        }\n                        return;\n                    }\n                }\n            });\n            const editInSameWindowCommand = `${constants_1.pluginPrefix}insertDrawing`;\n            yield api_1.default.commands.register({\n                name: editInSameWindowCommand,\n                label: localization_1.default.insertDrawing,\n                enabledCondition: 'oneNoteSelected && !noteIsReadOnly',\n                iconName: 'fas fa-pen-alt',\n                execute: () => __awaiter(this, void 0, void 0, function* () {\n                    yield editOrInsertDrawing(false);\n                }),\n            });\n            const editInNewWindowCommand = `${constants_1.pluginPrefix}insertDrawing__newWindow`;\n            yield api_1.default.commands.register({\n                name: editInNewWindowCommand,\n                label: localization_1.default.insertDrawingInNewWindow,\n                iconName: 'fas fa-pen-alt',\n                execute: () => __awaiter(this, void 0, void 0, function* () {\n                    yield editOrInsertDrawing(true);\n                }),\n            });\n            yield api_1.default.views.toolbarButtons.create(editInSameWindowCommand, editInSameWindowCommand, types_1.ToolbarButtonLocation.EditorToolbar);\n            // Add to the edit menu. This allows users to assign a custom keyboard shortcut to the action.\n            const toolMenuInsertDrawingButtonId = `${constants_1.pluginPrefix}insertDrawingToolMenuBtn`;\n            yield api_1.default.views.menuItems.create(toolMenuInsertDrawingButtonId, editInSameWindowCommand, types_1.MenuItemLocation.Edit);\n            const restoreAutosaveCommand = `${constants_1.pluginPrefix}restoreAutosave`;\n            const deleteAutosaveCommand = `${constants_1.pluginPrefix}deleteAutosave`;\n            yield api_1.default.commands.register({\n                name: restoreAutosaveCommand,\n                label: localization_1.default.restoreFromAutosave,\n                iconName: 'fas fa-floppy-disk',\n                execute: () => __awaiter(this, void 0, void 0, function* () {\n                    const svgData = yield (0, autosave_1.getAutosave)();\n                    if (!svgData) {\n                        yield api_1.default.views.dialogs.showMessageBox(localization_1.default.noSuchAutosaveExists);\n                        return;\n                    }\n                    yield insertNewDrawing(svgData);\n                }),\n            });\n            yield api_1.default.commands.register({\n                name: deleteAutosaveCommand,\n                label: localization_1.default.deleteAutosave,\n                iconName: 'fas fa-trash-can',\n                execute: () => __awaiter(this, void 0, void 0, function* () {\n                    yield (0, autosave_1.clearAutosave)();\n                }),\n            });\n            const markdownItContentScriptId = 'jsdraw__markdownIt_editDrawingButton';\n            yield api_1.default.contentScripts.register(types_1.ContentScriptType.MarkdownItPlugin, markdownItContentScriptId, './contentScripts/markdownIt.js');\n            const codeMirrorContentScriptId = 'jsdraw__codeMirrorContentScriptId';\n            yield api_1.default.contentScripts.register(types_1.ContentScriptType.CodeMirrorPlugin, codeMirrorContentScriptId, './contentScripts/codeMirror.js');\n            yield api_1.default.contentScripts.onMessage(markdownItContentScriptId, (resourceUrl) => __awaiter(this, void 0, void 0, function* () {\n                var _a;\n                return (_a = (yield editDrawing(resourceUrl, true, false))) === null || _a === void 0 ? void 0 : _a.resourceId;\n            }));\n        });\n    },\n});\n\n\n//# sourceURL=webpack://joplin-plugin-freehand-drawing/./src/index.ts?");

/***/ }),

/***/ "./src/localization.ts":
/*!*****************************!*\
  !*** ./src/localization.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst defaultStrings = {\n    insertDrawing: 'Insert Drawing',\n    insertDrawingInNewWindow: 'Insert drawing in new window',\n    restoreFromAutosave: 'Restore from autosaved drawing',\n    deleteAutosave: 'Delete all autosaved drawings',\n    noSuchAutosaveExists: 'No autosave exists',\n    discardChanges: 'Discard changes',\n    defaultImageTitle: 'Freehand Drawing',\n    edit: 'Edit',\n    close: 'Close',\n    saveAndClose: 'Save and close',\n    overwriteExisting: 'Overwrite existing',\n    saveAsNewDrawing: 'Save as a new drawing',\n    clickBelowToContinue: 'Done! Click below to continue.',\n    discardUnsavedChanges: 'Discard unsaved changes?',\n    resumeEditing: 'Resume editing',\n    saveAndResumeEditing: 'Save and resume editing',\n    saveChanges: 'Save changes',\n    exitInstructions: 'All changes saved! Click below to exit.',\n    settingsPaneDescription: 'Settings for the Freehand Drawing image editor.',\n    setting__disableFullScreen: 'Dialog mode',\n    setting__disableFullScreenDescription: 'Enabling this setting causes the editor to only partially fill the Joplin window.',\n    setting__autosaveIntervalSettingLabel: 'Autosave interval (minutes)',\n    setting__autosaveIntervalSettingDescription: 'Adjusts how often a backup copy of the current drawing is created. The most recent autosave can be restored by searching for \":restore autosave\" in the command palette (ctrl+shift+p or cmd+shift+p on MacOS) and clicking \"Restore from autosaved drawing\". If this setting is set to zero, autosaves are created every two minutes.',\n    setting__themeLabel: 'Theme',\n    setting__toolbarTypeLabel: 'Toolbar type',\n    setting__toolbarTypeDescription: 'This setting switches between possible toolbar user interfaces for the image editor.',\n    setting__keyboardShortcuts: 'Keyboard shortcuts',\n    toolbarTypeDefault: 'Default',\n    toolbarTypeSidebar: 'Sidebar',\n    toolbarTypeDropdown: 'Dropdown',\n    styleMatchJoplin: 'Match Joplin',\n    styleJsDrawLight: 'Light',\n    styleJsDrawDark: 'Dark',\n    images: 'Images',\n    pdfs: 'PDFs',\n    allFiles: 'All Files',\n    loadLargePdf: (pageCount) => `A selected file is a large PDF (${pageCount} pages). Loading it may take some time and increase the size of the current drawing. Continue?`,\n    notAnEditableImage: (resourceId, resourceType) => `Resource ${resourceId} is not an editable image. Unable to edit resource of type ${resourceType}.`,\n};\nconst localizations = {\n    de: Object.assign(Object.assign({}, defaultStrings), { insertDrawing: 'Zeichnung einfügen', restoreFromAutosave: 'Automatische Sicherung wiederherstellen', deleteAutosave: 'Alle automatischen Sicherungen löschen', noSuchAutosaveExists: 'Keine automatischen Sicherungen vorhanden', discardChanges: 'Änderungen verwerfen', defaultImageTitle: 'Freihand-Zeichnen', edit: 'Bearbeiten', close: 'Schließen', overwriteExisting: 'Existierende Zeichnung überschreiben', saveAsNewDrawing: 'Als neue Zeichnung speichern', clickBelowToContinue: 'Fertig! Klicke auf „Ok“ um fortzufahen.', discardUnsavedChanges: 'Ungespeicherte Änderungen verwerfen?', resumeEditing: 'Bearbeiten fortfahren', notAnEditableImage: (resourceId, resourceType) => `Die Ressource ${resourceId} ist kein bearbeitbares Bild. Ressource vom Typ ${resourceType} kann nicht bearbeitet werden.` }),\n    en: defaultStrings,\n    es: Object.assign(Object.assign({}, defaultStrings), { insertDrawing: 'Añada dibujo', restoreFromAutosave: 'Resturar al autoguardado', deleteAutosave: 'Borrar el autoguardado', noSuchAutosaveExists: 'No autoguardado existe', discardChanges: 'Descartar cambios', defaultImageTitle: 'Dibujo', edit: 'Editar', close: 'Cerrar', saveAndClose: 'Guardar y cerrar', overwriteExisting: 'Sobrescribir existente', saveAsNewDrawing: 'Guardar como dibujo nuevo', clickBelowToContinue: 'Guardado. Ponga «ok» para continuar.', discardUnsavedChanges: '¿Descartar cambios no guardados?', resumeEditing: 'Continuar editando', saveAndResumeEditing: 'Guardar y continuar editando' }),\n};\nlet localization;\nconst languages = [...navigator.languages];\nfor (const language of navigator.languages) {\n    const localeSep = language.indexOf('-');\n    if (localeSep !== -1) {\n        languages.push(language.substring(0, localeSep));\n    }\n}\nfor (const locale of languages) {\n    if (locale in localizations) {\n        localization = localizations[locale];\n        break;\n    }\n}\nif (!localization) {\n    console.log('No supported localization found. Falling back to default.');\n    localization = defaultStrings;\n}\nexports[\"default\"] = localization;\n\n\n//# sourceURL=webpack://joplin-plugin-freehand-drawing/./src/localization.ts?");

/***/ }),

/***/ "./src/settings.ts":
/*!*************************!*\
  !*** ./src/settings.ts ***!
  \*************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.registerAndApplySettings = exports.applySettingsTo = void 0;\nconst api_1 = __webpack_require__(/*! api */ \"./api/index.ts\");\nconst localization_1 = __webpack_require__(/*! ./localization */ \"./src/localization.ts\");\nconst types_1 = __webpack_require__(/*! api/types */ \"./api/types.ts\");\nconst types_2 = __webpack_require__(/*! ./types */ \"./src/types.ts\");\n// Joplin adds a prefix to the setting in settings.json for us.\nconst editorFillsWindowKey = 'disable-editor-fills-window';\nconst autosaveIntervalKey = 'autosave-interval-minutes';\nconst toolbarTypeKey = 'toolbar-type';\nconst styleModeKey = 'style-mode';\nconst keyboardShortcutsKey = 'keyboard-shortcuts';\nconst applySettingsTo = (drawingDialog) => __awaiter(void 0, void 0, void 0, function* () {\n    let autosaveIntervalMinutes = yield api_1.default.settings.value(autosaveIntervalKey);\n    // Default to two minutes.\n    if (!autosaveIntervalMinutes) {\n        autosaveIntervalMinutes = 2;\n    }\n    yield drawingDialog.setAutosaveInterval(autosaveIntervalMinutes * 60 * 1000);\n    const toolbarType = (yield api_1.default.settings.value(toolbarTypeKey));\n    drawingDialog.setToolbarType(toolbarType);\n    const styleMode = (yield api_1.default.settings.value(styleModeKey));\n    drawingDialog.setStyleMode(styleMode);\n    drawingDialog.setKeyboardShortcuts(yield api_1.default.settings.value(keyboardShortcutsKey));\n});\nexports.applySettingsTo = applySettingsTo;\nconst registerAndApplySettings = (drawingDialog) => __awaiter(void 0, void 0, void 0, function* () {\n    const jsDrawSectionName = 'js-draw';\n    yield api_1.default.settings.registerSection(jsDrawSectionName, {\n        label: 'Freehand Drawing',\n        iconName: 'fas fa-pen-alt',\n        description: localization_1.default.settingsPaneDescription,\n    });\n    // Editor fullscreen setting\n    yield api_1.default.settings.registerSettings({\n        [toolbarTypeKey]: {\n            public: true,\n            section: jsDrawSectionName,\n            advanced: true,\n            label: localization_1.default.setting__toolbarTypeLabel,\n            description: localization_1.default.setting__toolbarTypeDescription,\n            isEnum: true,\n            type: types_1.SettingItemType.Int,\n            value: 0,\n            options: {\n                0: localization_1.default.toolbarTypeDefault,\n                1: localization_1.default.toolbarTypeSidebar,\n                2: localization_1.default.toolbarTypeDropdown,\n            },\n        },\n        [styleModeKey]: {\n            public: true,\n            section: jsDrawSectionName,\n            label: localization_1.default.setting__themeLabel,\n            isEnum: true,\n            type: types_1.SettingItemType.String,\n            value: types_2.EditorStyle.MatchJoplin,\n            options: {\n                [types_2.EditorStyle.MatchJoplin]: localization_1.default.styleMatchJoplin,\n                [types_2.EditorStyle.JsDrawLight]: localization_1.default.styleJsDrawLight,\n                [types_2.EditorStyle.JsDrawDark]: localization_1.default.styleJsDrawDark,\n            },\n        },\n        [editorFillsWindowKey]: {\n            public: true,\n            section: jsDrawSectionName,\n            advanced: true,\n            label: localization_1.default.setting__disableFullScreen,\n            description: localization_1.default.setting__disableFullScreenDescription,\n            storage: types_1.SettingStorage.File,\n            type: types_1.SettingItemType.Bool,\n            value: false,\n        },\n        [autosaveIntervalKey]: {\n            public: true,\n            section: jsDrawSectionName,\n            advanced: true,\n            label: localization_1.default.setting__autosaveIntervalSettingLabel,\n            description: localization_1.default.setting__autosaveIntervalSettingDescription,\n            storage: types_1.SettingStorage.File,\n            type: types_1.SettingItemType.Int,\n            value: 2,\n        },\n        [keyboardShortcutsKey]: {\n            public: false,\n            section: jsDrawSectionName,\n            label: localization_1.default.setting__keyboardShortcuts,\n            storage: types_1.SettingStorage.File,\n            type: types_1.SettingItemType.Object,\n            value: {},\n        },\n    });\n    const applySettings = () => __awaiter(void 0, void 0, void 0, function* () {\n        const fullscreenDisabled = yield api_1.default.settings.value(editorFillsWindowKey);\n        yield drawingDialog.setCanFullscreen(!fullscreenDisabled);\n        (0, exports.applySettingsTo)(drawingDialog);\n    });\n    yield api_1.default.settings.onChange((_event) => {\n        void applySettings();\n    });\n    yield applySettings();\n});\nexports.registerAndApplySettings = registerAndApplySettings;\n\n\n//# sourceURL=webpack://joplin-plugin-freehand-drawing/./src/settings.ts?");

/***/ }),

/***/ "./src/types.ts":
/*!**********************!*\
  !*** ./src/types.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EditorStyle = exports.ToolbarType = exports.ResponseType = exports.SaveMethod = exports.MessageType = void 0;\nvar MessageType;\n(function (MessageType) {\n    MessageType[\"GetInitialData\"] = \"getInitialData\";\n    MessageType[\"SaveSVG\"] = \"saveSVG\";\n    MessageType[\"SaveCompleted\"] = \"saveCompleted\";\n    MessageType[\"AutosaveSVG\"] = \"autosaveSVG\";\n    MessageType[\"SetSaveMethod\"] = \"setSaveMethod\";\n    MessageType[\"ResumeEditing\"] = \"resumeEditing\";\n    MessageType[\"ShowSaveAndCloseButton\"] = \"showSaveAndCloseButton\";\n    MessageType[\"ShowCloseButton\"] = \"showCloseButton\";\n    MessageType[\"HideButtons\"] = \"removeButtons\";\n    MessageType[\"ShowImagePicker\"] = \"showImagePicker\";\n    MessageType[\"GetImagePickerResult\"] = \"getImagePicker\";\n    MessageType[\"CancelImagePicker\"] = \"cancelImagePicker\";\n    MessageType[\"CleanUpImagePickerResult\"] = \"cleanUpImagePicker\";\n})(MessageType || (exports.MessageType = MessageType = {}));\nvar SaveMethod;\n(function (SaveMethod) {\n    SaveMethod[\"SaveAsNew\"] = \"saveAsNew\";\n    SaveMethod[\"Overwrite\"] = \"overwrite\";\n})(SaveMethod || (exports.SaveMethod = SaveMethod = {}));\nvar ResponseType;\n(function (ResponseType) {\n    ResponseType[\"InitialDataResponse\"] = \"initialDataResponse\";\n    ResponseType[\"SaveResponse\"] = \"saveResponse\";\n    ResponseType[\"ImagePickerTaskResponse\"] = \"imagePickerStartedResponse\";\n    ResponseType[\"ImagePickerResponse\"] = \"imagePickerResponse\";\n})(ResponseType || (exports.ResponseType = ResponseType = {}));\nvar ToolbarType;\n(function (ToolbarType) {\n    ToolbarType[ToolbarType[\"Default\"] = 0] = \"Default\";\n    ToolbarType[ToolbarType[\"Sidebar\"] = 1] = \"Sidebar\";\n    ToolbarType[ToolbarType[\"Dropdown\"] = 2] = \"Dropdown\";\n})(ToolbarType || (exports.ToolbarType = ToolbarType = {}));\nvar EditorStyle;\n(function (EditorStyle) {\n    EditorStyle[\"MatchJoplin\"] = \"match-joplin-theme\";\n    EditorStyle[\"JsDrawLight\"] = \"js-draw-default-light\";\n    EditorStyle[\"JsDrawDark\"] = \"js-draw-default-dark\";\n})(EditorStyle || (exports.EditorStyle = EditorStyle = {}));\n\n\n//# sourceURL=webpack://joplin-plugin-freehand-drawing/./src/types.ts?");

/***/ }),

/***/ "./src/util/isVersionGreater.ts":
/*!**************************************!*\
  !*** ./src/util/isVersionGreater.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * Returns true iff `a` is greater than `b`, where both `a` and `b` are\n * semver versions.\n */\nconst isVersionGreater = (a, b) => {\n    const versionRegex = /^(\\d+)\\.(\\d+)\\.(\\d+)(-.*)?$/;\n    const parsedVersionA = versionRegex.exec(a);\n    const parsedVersionB = versionRegex.exec(b);\n    if (!parsedVersionA || !parsedVersionB) {\n        console.warn(`Invalid version, ${parsedVersionA} or ${parsedVersionB} (expected number.number.number).`);\n        return false;\n    }\n    const majorA = parseInt(parsedVersionA[1]);\n    const minorA = parseInt(parsedVersionA[2]);\n    const patchA = parseInt(parsedVersionA[3]);\n    const majorB = parseInt(parsedVersionB[1]);\n    const minorB = parseInt(parsedVersionB[2]);\n    const patchB = parseInt(parsedVersionB[3]);\n    return (majorA > majorB ||\n        (majorA === majorB && (minorA > minorB || (minorA === minorB && patchA > patchB))));\n};\nexports[\"default\"] = isVersionGreater;\n\n\n//# sourceURL=webpack://joplin-plugin-freehand-drawing/./src/util/isVersionGreater.ts?");

/***/ }),

/***/ "./src/util/promptForImages.ts":
/*!*************************************!*\
  !*** ./src/util/promptForImages.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.cleanUpTaskResult = exports.taskById = exports.promptForImages = void 0;\nconst api_1 = __webpack_require__(/*! api */ \"./api/index.ts\");\nconst path_1 = __webpack_require__(/*! path */ \"path\");\nconst localization_1 = __webpack_require__(/*! ../localization */ \"./src/localization.ts\");\nconst isVersionGreater_1 = __webpack_require__(/*! ./isVersionGreater */ \"./src/util/isVersionGreater.ts\");\nconst { remove } = api_1.default.require('fs-extra');\nlet nextTaskId = 0;\nconst runningTasks = new Map();\nconst cleanUpTaskResultCallbacks = new Map();\nconst shouldLoadLargePdf = (pageCount) => __awaiter(void 0, void 0, void 0, function* () {\n    if (pageCount < 20)\n        return true;\n    const dialogResult = yield api_1.default.views.dialogs.showMessageBox(localization_1.default.loadLargePdf(pageCount));\n    const okIndex = 0;\n    return dialogResult === okIndex;\n});\nconst getFilters = () => __awaiter(void 0, void 0, void 0, function* () {\n    var _a;\n    const filters = [{ name: localization_1.default.images, extensions: ['jpeg', 'jpg', 'png', 'gif'] }];\n    const supportsPdf = (0, isVersionGreater_1.default)((_a = (yield api_1.default.versionInfo())) === null || _a === void 0 ? void 0 : _a.version, '3.0.2');\n    if (supportsPdf) {\n        filters.push({ name: localization_1.default.pdfs, extensions: ['pdf'] });\n    }\n    filters.push({ name: localization_1.default.allFiles, extensions: ['*'] });\n    return filters;\n});\nconst promptForImages = (tempDir) => {\n    const taskId = nextTaskId++;\n    let cancelled = false;\n    const taskRecord = {\n        id: taskId,\n        cancel: () => {\n            cancelled = true;\n        },\n        task: (() => __awaiter(void 0, void 0, void 0, function* () {\n            const cleanUpTasks = [];\n            try {\n                const filePaths = yield api_1.default.views.dialogs.showOpenDialog({\n                    properties: ['openFile', 'multiSelections'],\n                    filters: yield getFilters(),\n                });\n                if (!filePaths) {\n                    return null;\n                }\n                const images = [];\n                for (const path of filePaths) {\n                    if (cancelled)\n                        return null;\n                    if ((0, path_1.extname)(path).toLowerCase() === '.pdf') {\n                        const pdfInfo = yield api_1.default.imaging.getPdfInfoFromPath(path);\n                        if (!(yield shouldLoadLargePdf(pdfInfo.pageCount))) {\n                            cancelled = true;\n                            return null;\n                        }\n                        const pageHandles = [];\n                        const step = 30;\n                        for (let i = 0; i <= pdfInfo.pageCount; i += step) {\n                            const minPage = i + 1;\n                            const maxPage = Math.min(pdfInfo.pageCount, i + step);\n                            const handles = yield api_1.default.imaging.createFromPdfPath(path, { minPage, maxPage });\n                            pageHandles.push(...handles);\n                            if (cancelled)\n                                return null;\n                        }\n                        for (const handle of pageHandles) {\n                            if (cancelled)\n                                return null;\n                            const pdfPagePath = tempDir.nextFilepath('.jpg');\n                            yield api_1.default.imaging.toJpgFile(handle, pdfPagePath);\n                            images.push({\n                                path: pdfPagePath,\n                                name: (0, path_1.basename)(pdfPagePath),\n                                mime: 'image/jpeg',\n                            });\n                            cleanUpTasks.push(() => __awaiter(void 0, void 0, void 0, function* () {\n                                yield remove(pdfPagePath);\n                                console.info('clean up: removed', pdfPagePath);\n                            }));\n                        }\n                    }\n                    else {\n                        images.push({ path, name: (0, path_1.basename)(path) });\n                    }\n                }\n                return images;\n            }\n            finally {\n                runningTasks.delete(taskId);\n                cleanUpTaskResultCallbacks.set(taskId, () => {\n                    for (const task of cleanUpTasks) {\n                        void task();\n                    }\n                });\n            }\n        }))(),\n    };\n    runningTasks.set(taskId, taskRecord);\n    return taskRecord;\n};\nexports.promptForImages = promptForImages;\nconst taskById = (id) => {\n    return runningTasks.get(id);\n};\nexports.taskById = taskById;\nconst cleanUpTaskResult = (taskId) => {\n    const cleanUpCallback = cleanUpTaskResultCallbacks.get(taskId);\n    if (cleanUpCallback) {\n        cleanUpCallback();\n        cleanUpTaskResultCallbacks.delete(taskId);\n    }\n};\nexports.cleanUpTaskResult = cleanUpTaskResult;\nexports[\"default\"] = exports.promptForImages;\n\n\n//# sourceURL=webpack://joplin-plugin-freehand-drawing/./src/util/promptForImages.ts?");

/***/ }),

/***/ "./src/util/waitFor.ts":
/*!*****************************!*\
  !*** ./src/util/waitFor.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// Wait a delay in milliseconds.\nconst waitFor = (timeout) => {\n    return new Promise((resolve) => {\n        setTimeout(() => resolve(), timeout);\n    });\n};\nexports[\"default\"] = waitFor;\n\n\n//# sourceURL=webpack://joplin-plugin-freehand-drawing/./src/util/waitFor.ts?");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("os");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("path");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;