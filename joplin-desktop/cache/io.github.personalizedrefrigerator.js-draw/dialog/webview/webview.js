/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@js-draw/material-icons/dist/cjs/icons/Check.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@js-draw/material-icons/dist/cjs/icons/Check.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n// The following icon is part of the Material Icon pack and is licensed under\n// the Apache 2.0 license.\n// You should have received a copy of this license along with the software.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Check = void 0;\nexports.Check = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" height=\\\"48\\\" viewBox=\\\"0 -960 960 960\\\" width=\\\"48\\\"><path style=\\\"fill: var(--icon-color);\\\" d=\\\"M378-246 154-470l43-43 181 181 384-384 43 43-427 427Z\\\"/></svg>\";\nexports[\"default\"] = exports.Check;\n\n\n//# sourceURL=webpack://default/./node_modules/@js-draw/material-icons/dist/cjs/icons/Check.js?");

/***/ }),

/***/ "./node_modules/@js-draw/material-icons/dist/cjs/icons/Close.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@js-draw/material-icons/dist/cjs/icons/Close.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n// The following icon is part of the Material Icon pack and is licensed under\n// the Apache 2.0 license.\n// You should have received a copy of this license along with the software.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Close = void 0;\nexports.Close = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" height=\\\"48\\\" viewBox=\\\"0 -960 960 960\\\" width=\\\"48\\\"><path style=\\\"fill: var(--icon-color);\\\" d=\\\"m249-207-42-42 231-231-231-231 42-42 231 231 231-231 42 42-231 231 231 231-42 42-231-231-231 231Z\\\"/></svg>\";\nexports[\"default\"] = exports.Close;\n\n\n//# sourceURL=webpack://default/./node_modules/@js-draw/material-icons/dist/cjs/icons/Close.js?");

/***/ }),

/***/ "./node_modules/@js-draw/material-icons/dist/cjs/icons/CloudUpload.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@js-draw/material-icons/dist/cjs/icons/CloudUpload.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n// The following icon is part of the Material Icon pack and is licensed under\n// the Apache 2.0 license.\n// You should have received a copy of this license along with the software.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CloudUpload = void 0;\nexports.CloudUpload = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" height=\\\"48\\\" viewBox=\\\"0 -960 960 960\\\" width=\\\"48\\\"><path style=\\\"fill: var(--icon-color);\\\" d=\\\"M250-160q-86 0-148-62T40-370q0-78 49.5-137.5T217-579q20-97 94-158.5T482-799q113 0 189.5 81.5T748-522v24q72-2 122 46.5T920-329q0 69-50 119t-119 50H510q-24 0-42-18t-18-42v-258l-83 83-43-43 156-156 156 156-43 43-83-83v258h241q45 0 77-32t32-77q0-45-32-77t-77-32h-63v-84q0-89-60.5-153T478-739q-89 0-150 64t-61 153h-19q-62 0-105 43.5T100-371q0 62 43.929 106.5Q187.857-220 250-220h140v60H250Zm230-290Z\\\"/></svg>\";\nexports[\"default\"] = exports.CloudUpload;\n\n\n//# sourceURL=webpack://default/./node_modules/@js-draw/material-icons/dist/cjs/icons/CloudUpload.js?");

/***/ }),

/***/ "./node_modules/@js-draw/material-icons/dist/cjs/icons/ContentCopy.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@js-draw/material-icons/dist/cjs/icons/ContentCopy.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n// The following icon is part of the Material Icon pack and is licensed under\n// the Apache 2.0 license.\n// You should have received a copy of this license along with the software.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ContentCopy = void 0;\nexports.ContentCopy = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" height=\\\"48\\\" viewBox=\\\"0 -960 960 960\\\" width=\\\"48\\\"><path style=\\\"fill: var(--icon-color);\\\" d=\\\"M180-81q-24 0-42-18t-18-42v-603h60v603h474v60H180Zm120-120q-24 0-42-18t-18-42v-560q0-24 18-42t42-18h440q24 0 42 18t18 42v560q0 24-18 42t-42 18H300Zm0-60h440v-560H300v560Zm0 0v-560 560Z\\\"/></svg>\";\nexports[\"default\"] = exports.ContentCopy;\n\n\n//# sourceURL=webpack://default/./node_modules/@js-draw/material-icons/dist/cjs/icons/ContentCopy.js?");

/***/ }),

/***/ "./node_modules/@js-draw/material-icons/dist/cjs/icons/ContentPaste.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@js-draw/material-icons/dist/cjs/icons/ContentPaste.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n// The following icon is part of the Material Icon pack and is licensed under\n// the Apache 2.0 license.\n// You should have received a copy of this license along with the software.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ContentPaste = void 0;\nexports.ContentPaste = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" height=\\\"48\\\" viewBox=\\\"0 0 24 24\\\" width=\\\"48\\\"><path style=\\\"fill: var(--icon-color);\\\" d=\\\"M19 2h-4.18C14.4.84 13.3 0 12 0S9.6.84 9.18 2H5c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-7 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm7 18H5V4h2v3h10V4h2v16z\\\"/></svg>\";\nexports[\"default\"] = exports.ContentPaste;\n\n\n//# sourceURL=webpack://default/./node_modules/@js-draw/material-icons/dist/cjs/icons/ContentPaste.js?");

/***/ }),

/***/ "./node_modules/@js-draw/material-icons/dist/cjs/icons/Delete.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@js-draw/material-icons/dist/cjs/icons/Delete.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n// The following icon is part of the Material Icon pack and is licensed under\n// the Apache 2.0 license.\n// You should have received a copy of this license along with the software.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Delete = void 0;\nexports.Delete = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" height=\\\"48\\\" viewBox=\\\"0 -960 960 960\\\" width=\\\"48\\\"><path style=\\\"fill: var(--icon-color);\\\" d=\\\"M261-120q-24.75 0-42.375-17.625T201-180v-570h-41v-60h188v-30h264v30h188v60h-41v570q0 24-18 42t-42 18H261Zm438-630H261v570h438v-570ZM367-266h60v-399h-60v399Zm166 0h60v-399h-60v399ZM261-750v570-570Z\\\"/></svg>\";\nexports[\"default\"] = exports.Delete;\n\n\n//# sourceURL=webpack://default/./node_modules/@js-draw/material-icons/dist/cjs/icons/Delete.js?");

/***/ }),

/***/ "./node_modules/@js-draw/material-icons/dist/cjs/icons/Draw.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@js-draw/material-icons/dist/cjs/icons/Draw.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n// The following icon is part of the Material Icon pack and is licensed under\n// the Apache 2.0 license.\n// You should have received a copy of this license along with the software.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Draw = void 0;\nexports.Draw = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" height=\\\"48\\\" viewBox=\\\"0 -960 960 960\\\" width=\\\"48\\\"><path style=\\\"fill: var(--icon-color);\\\" d=\\\"M560-120q-12 0-21-9t-9-21q0-13 9-21.5t21-8.5q59 0 99.5-24t40.5-56q0-23-29.5-45T591-339l47-47q63 19 92.5 52.5T760-260q0 67-61 103.5T560-120ZM240-414q-64-14-92-44t-28-62q0-35 26-63t120-62q66-24 85-39t19-35q0-25-22-43t-68-18q-27 0-46 7t-34 22q-8 8-20.5 9.5T157-748q-11-8-11.5-20t7.5-21q17-22 51-36.5t76-14.5q68 0 109 32.5t41 88.5q0 41-28.5 69.5T290-590q-67 25-88.5 39.5T180-520q0 16 27 30.5t81 27.5l-48 48Zm496-154L608-696l45-45q18-18 40-18t40 18l48 48q18 18 18 40t-18 40l-45 45ZM220-180h42l345-345-42-42-345 345v42Zm-60 60v-128l405-405 128 128-405 405H160Zm405-447 42 42-42-42Z\\\"/></svg>\";\nexports[\"default\"] = exports.Draw;\n\n\n//# sourceURL=webpack://default/./node_modules/@js-draw/material-icons/dist/cjs/icons/Draw.js?");

/***/ }),

/***/ "./node_modules/@js-draw/material-icons/dist/cjs/icons/Edit.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@js-draw/material-icons/dist/cjs/icons/Edit.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n// The following icon is part of the Material Icon pack and is licensed under\n// the Apache 2.0 license.\n// You should have received a copy of this license along with the software.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Edit = void 0;\nexports.Edit = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" height=\\\"48\\\" viewBox=\\\"0 -960 960 960\\\" width=\\\"48\\\"><path style=\\\"fill: var(--icon-color);\\\" d=\\\"M180-180h44l443-443-44-44-443 443v44Zm614-486L666-794l42-42q17-17 42-17t42 17l44 44q17 17 17 42t-17 42l-42 42Zm-42 42L248-120H120v-128l504-504 128 128Zm-107-21-22-22 44 44-22-22Z\\\"/></svg>\";\nexports[\"default\"] = exports.Edit;\n\n\n//# sourceURL=webpack://default/./node_modules/@js-draw/material-icons/dist/cjs/icons/Edit.js?");

/***/ }),

/***/ "./node_modules/@js-draw/material-icons/dist/cjs/icons/EditDocument.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@js-draw/material-icons/dist/cjs/icons/EditDocument.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n// The following icon is part of the Material Icon pack and is licensed under\n// the Apache 2.0 license.\n// You should have received a copy of this license along with the software.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EditDocument = void 0;\nexports.EditDocument = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" height=\\\"48\\\" viewBox=\\\"0 -960 960 960\\\" width=\\\"48\\\"><path style=\\\"fill: var(--icon-color);\\\" d=\\\"M220-80q-24 0-42-18t-18-42v-680q0-24 18-42t42-18h340l240 240v156h-60v-116H520v-220H220v680h300v60H220Zm0-60v-680 680Zm536-223 28 28-164 164v51h51l164-164 28 28L687-80H580v-107l176-176Zm107 107L756-363l61-61q9-9 21-9t21 9l65 65q9 9 9 21t-9 21l-61 61Z\\\"/></svg>\";\nexports[\"default\"] = exports.EditDocument;\n\n\n//# sourceURL=webpack://default/./node_modules/@js-draw/material-icons/dist/cjs/icons/EditDocument.js?");

/***/ }),

/***/ "./node_modules/@js-draw/material-icons/dist/cjs/icons/ExpandMore.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@js-draw/material-icons/dist/cjs/icons/ExpandMore.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n// The following icon is part of the Material Icon pack and is licensed under\n// the Apache 2.0 license.\n// You should have received a copy of this license along with the software.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ExpandMore = void 0;\nexports.ExpandMore = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" height=\\\"48\\\" viewBox=\\\"0 -960 960 960\\\" width=\\\"48\\\"><path style=\\\"fill: var(--icon-color);\\\" d=\\\"M480-339.5 234.261-585.239 283-633.978l197 198 197-197 48.739 48.739L480-339.5Z\\\"/></svg>\";\nexports[\"default\"] = exports.ExpandMore;\n\n\n//# sourceURL=webpack://default/./node_modules/@js-draw/material-icons/dist/cjs/icons/ExpandMore.js?");

/***/ }),

/***/ "./node_modules/@js-draw/material-icons/dist/cjs/icons/Imagesmode.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@js-draw/material-icons/dist/cjs/icons/Imagesmode.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n// The following icon is part of the Material Icon pack and is licensed under\n// the Apache 2.0 license.\n// You should have received a copy of this license along with the software.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Imagesmode = void 0;\nexports.Imagesmode = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" height=\\\"48\\\" viewBox=\\\"0 -960 960 960\\\" width=\\\"48\\\"><path style=\\\"fill: var(--icon-color);\\\" d=\\\"M182.152-114.022q-27.599 0-47.865-20.265-20.265-20.266-20.265-47.865v-595.696q0-27.697 20.265-48.033 20.266-20.337 47.865-20.337h595.696q27.697 0 48.033 20.337 20.337 20.336 20.337 48.033v595.696q0 27.599-20.337 47.865-20.336 20.265-48.033 20.265H182.152Zm0-68.13h595.696v-595.696H182.152v595.696Zm50.739-92.696h495.218L578-476.587l-132 171-93-127-120.109 157.739Zm-50.739 92.696v-595.696 595.696Zm157.966-383.783q22.576 0 38.262-15.803 15.685-15.803 15.685-38.38 0-22.576-15.803-38.262-15.803-15.685-38.38-15.685-22.576 0-38.262 15.803-15.685 15.803-15.685 38.38 0 22.576 15.803 38.262 15.803 15.685 38.38 15.685Z\\\"/></svg>\";\nexports[\"default\"] = exports.Imagesmode;\n\n\n//# sourceURL=webpack://default/./node_modules/@js-draw/material-icons/dist/cjs/icons/Imagesmode.js?");

/***/ }),

/***/ "./node_modules/@js-draw/material-icons/dist/cjs/icons/InkEraser.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@js-draw/material-icons/dist/cjs/icons/InkEraser.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n// The following icon is part of the Material Icon pack and is licensed under\n// the Apache 2.0 license.\n// You should have received a copy of this license along with the software.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InkEraser = void 0;\nexports.InkEraser = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" height=\\\"48\\\" viewBox=\\\"0 -960 960 960\\\" width=\\\"48\\\"><path style=\\\"fill: var(--icon-color);\\\" d=\\\"M687.805-222.152h203v68.13h-271.37l68.37-68.13Zm-515.501 68.13-81.478-84.239q-20.431-19.622-19.792-47.235.64-27.613 19.031-47.004l456.326-494.413q18.391-19.391 46.314-19.272 27.923.12 47.404 19.511L841.283-615.5q19.63 19.622 20.63 47.855 1 28.232-18.63 47.623l-341.957 366H172.304Zm302.695-68.13 322.305-349.37-203.413-213.413-452.848 499.174 61.37 63.609h272.586ZM480-480Z\\\"/></svg>\";\nexports[\"default\"] = exports.InkEraser;\n\n\n//# sourceURL=webpack://default/./node_modules/@js-draw/material-icons/dist/cjs/icons/InkEraser.js?");

/***/ }),

/***/ "./node_modules/@js-draw/material-icons/dist/cjs/icons/InkEraserOff.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@js-draw/material-icons/dist/cjs/icons/InkEraserOff.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n// The following icon is part of the Material Icon pack and is licensed under\n// the Apache 2.0 license.\n// You should have received a copy of this license along with the software.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InkEraserOff = void 0;\nexports.InkEraserOff = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" height=\\\"48\\\" viewBox=\\\"0 -960 960 960\\\" width=\\\"48\\\"><path style=\\\"fill: var(--icon-color);\\\" d=\\\"M813-61 605-269 503-160H179l-81-84q-18-17-17.5-41.5T97-327l216-234L61-813l43-43 752 752-43 43ZM206-220h274l83-91-209-209-212 234 64 66Zm482-138-42-42 158-172-207-217-161 179-41-41 160-174q16-17 40.567-17 24.566 0 41.433 17l205 215q17 17 18 42t-16 42L688-358ZM541-505Zm-82 89Z\\\"/></svg>\";\nexports[\"default\"] = exports.InkEraserOff;\n\n\n//# sourceURL=webpack://default/./node_modules/@js-draw/material-icons/dist/cjs/icons/InkEraserOff.js?");

/***/ }),

/***/ "./node_modules/@js-draw/material-icons/dist/cjs/icons/InkHighlighter.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@js-draw/material-icons/dist/cjs/icons/InkHighlighter.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n// The following icon is part of the Material Icon pack and is licensed under\n// the Apache 2.0 license.\n// You should have received a copy of this license along with the software.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InkHighlighter = void 0;\nexports.InkHighlighter = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" height=\\\"48\\\" viewBox=\\\"0 -960 960 960\\\" width=\\\"48\\\"><path style=\\\"fill: var(--icon-color);\\\" d=\\\"M545.63-401.022 431.587-515.065 217.478-301.196l114.283 114.283L545.63-401.022Zm-65.304-163.021 114.283 114.282 214.674-214.674-114.044-114.282-214.913 214.674Zm-72.848-23.87 211 211L389.5-147.935q-21.152 21.153-58.359 21.153-37.206 0-58.119-21.153l-10.761-10.521-44.913 44.674h-155L184.26-235.456l-3.761-4q-24.391-24.153-23.891-61.12.5-36.968 24.891-61.359l225.978-225.978Zm0 0 241.783-241.783q19.63-19.63 48.859-19.63 29.228 0 49.098 19.63l111.043 111.283q19.63 19.63 19.13 51.478-.5 31.848-20.13 51.479L618.478-376.913l-211-211Z\\\"/></svg>\";\nexports[\"default\"] = exports.InkHighlighter;\n\n\n//# sourceURL=webpack://default/./node_modules/@js-draw/material-icons/dist/cjs/icons/InkHighlighter.js?");

/***/ }),

/***/ "./node_modules/@js-draw/material-icons/dist/cjs/icons/InkPen.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@js-draw/material-icons/dist/cjs/icons/InkPen.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n// The following icon is part of the Material Icon pack and is licensed under\n// the Apache 2.0 license.\n// You should have received a copy of this license along with the software.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InkPen = void 0;\nexports.InkPen = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" height=\\\"48\\\" viewBox=\\\"0 -960 960 960\\\" width=\\\"48\\\"><path style=\\\"fill: var(--icon-color);\\\" d=\\\"m480-522 42 42 249-249-42-42-249 249ZM180-180h42l258-258-42-42-258 258v42Zm362-238L418-542l198-198-30-30-234 234-43-43 228-228q25-25 49.5-25.5T637-807l23 23 45-45q11-11 25-11t25 11l73 73q11 11 11 26t-11 26L542-418ZM244-120H120v-124l298-298 124 124-298 298Z\\\"/></svg>\";\nexports[\"default\"] = exports.InkPen;\n\n\n//# sourceURL=webpack://default/./node_modules/@js-draw/material-icons/dist/cjs/icons/InkPen.js?");

/***/ }),

/***/ "./node_modules/@js-draw/material-icons/dist/cjs/icons/PanTool.js":
/*!************************************************************************!*\
  !*** ./node_modules/@js-draw/material-icons/dist/cjs/icons/PanTool.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n// The following icon is part of the Material Icon pack and is licensed under\n// the Apache 2.0 license.\n// You should have received a copy of this license along with the software.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PanTool = void 0;\nexports.PanTool = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" height=\\\"48\\\" viewBox=\\\"0 -960 960 960\\\" width=\\\"48\\\"><path style=\\\"fill: var(--icon-color);\\\" d=\\\"M402.097-34.022q-27.578 0-52.794-12.858-25.216-12.859-40.216-36.337L53.044-468.24l20.928-16q17.985-15 41.322-19 23.336-4 47.801 14.383l114.514 87.312v-411.804q0-13.641 9.439-23.016 9.439-9.375 23.174-9.375t22.952 9.375q9.217 9.375 9.217 23.016v533.978L172.935-404.022l189.934 284.373q6.805 10.323 16.699 15.584 9.893 5.26 22.432 5.26h291.826q37.1 0 62.355-25.254 25.254-25.254 25.254-62.354v-587.413q0-13.641 9.439-23.016 9.439-9.376 23.174-9.376T837-796.842q9.218 9.375 9.218 23.016v587.413q0 63.957-44.218 108.174-44.217 44.217-108.174 44.217H402.097Zm43.946-443.587v-417.174q0-13.641 9.274-23.016 9.273-9.375 23.008-9.375t22.998 9.375q9.264 9.375 9.264 23.016v417.174h-64.544Zm168.196 0v-376.217q0-13.641 9.426-23.016 9.426-9.376 23.141-9.376 13.614 0 22.795 9.376 9.182 9.375 9.182 23.016v376.217h-64.544ZM477.065-288.326Z\\\"/></svg>\";\nexports[\"default\"] = exports.PanTool;\n\n\n//# sourceURL=webpack://default/./node_modules/@js-draw/material-icons/dist/cjs/icons/PanTool.js?");

/***/ }),

/***/ "./node_modules/@js-draw/material-icons/dist/cjs/icons/README.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@js-draw/material-icons/dist/cjs/icons/README.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports[\"default\"] = \"`@js-draw/material-icons`: Material icon integration for `js-draw`.\\n\\nAll icons in `@js-draw/material-icons` were found using [Google WebFonts search](https://fonts.google.com/icons) and downloaded from there.\\n\\nA copy of the license for these icons is included below:\\n\\n```\\n\\n                                 Apache License\\n                           Version 2.0, January 2004\\n                        http://www.apache.org/licenses/\\n\\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\\n\\n   1. Definitions.\\n\\n      \\\"License\\\" shall mean the terms and conditions for use, reproduction,\\n      and distribution as defined by Sections 1 through 9 of this document.\\n\\n      \\\"Licensor\\\" shall mean the copyright owner or entity authorized by\\n      the copyright owner that is granting the License.\\n\\n      \\\"Legal Entity\\\" shall mean the union of the acting entity and all\\n      other entities that control, are controlled by, or are under common\\n      control with that entity. For the purposes of this definition,\\n      \\\"control\\\" means (i) the power, direct or indirect, to cause the\\n      direction or management of such entity, whether by contract or\\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\\n      outstanding shares, or (iii) beneficial ownership of such entity.\\n\\n      \\\"You\\\" (or \\\"Your\\\") shall mean an individual or Legal Entity\\n      exercising permissions granted by this License.\\n\\n      \\\"Source\\\" form shall mean the preferred form for making modifications,\\n      including but not limited to software source code, documentation\\n      source, and configuration files.\\n\\n      \\\"Object\\\" form shall mean any form resulting from mechanical\\n      transformation or translation of a Source form, including but\\n      not limited to compiled object code, generated documentation,\\n      and conversions to other media types.\\n\\n      \\\"Work\\\" shall mean the work of authorship, whether in Source or\\n      Object form, made available under the License, as indicated by a\\n      copyright notice that is included in or attached to the work\\n      (an example is provided in the Appendix below).\\n\\n      \\\"Derivative Works\\\" shall mean any work, whether in Source or Object\\n      form, that is based on (or derived from) the Work and for which the\\n      editorial revisions, annotations, elaborations, or other modifications\\n      represent, as a whole, an original work of authorship. For the purposes\\n      of this License, Derivative Works shall not include works that remain\\n      separable from, or merely link (or bind by name) to the interfaces of,\\n      the Work and Derivative Works thereof.\\n\\n      \\\"Contribution\\\" shall mean any work of authorship, including\\n      the original version of the Work and any modifications or additions\\n      to that Work or Derivative Works thereof, that is intentionally\\n      submitted to Licensor for inclusion in the Work by the copyright owner\\n      or by an individual or Legal Entity authorized to submit on behalf of\\n      the copyright owner. For the purposes of this definition, \\\"submitted\\\"\\n      means any form of electronic, verbal, or written communication sent\\n      to the Licensor or its representatives, including but not limited to\\n      communication on electronic mailing lists, source code control systems,\\n      and issue tracking systems that are managed by, or on behalf of, the\\n      Licensor for the purpose of discussing and improving the Work, but\\n      excluding communication that is conspicuously marked or otherwise\\n      designated in writing by the copyright owner as \\\"Not a Contribution.\\\"\\n\\n      \\\"Contributor\\\" shall mean Licensor and any individual or Legal Entity\\n      on behalf of whom a Contribution has been received by Licensor and\\n      subsequently incorporated within the Work.\\n\\n   2. Grant of Copyright License. Subject to the terms and conditions of\\n      this License, each Contributor hereby grants to You a perpetual,\\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\\n      copyright license to reproduce, prepare Derivative Works of,\\n      publicly display, publicly perform, sublicense, and distribute the\\n      Work and such Derivative Works in Source or Object form.\\n\\n   3. Grant of Patent License. Subject to the terms and conditions of\\n      this License, each Contributor hereby grants to You a perpetual,\\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\\n      (except as stated in this section) patent license to make, have made,\\n      use, offer to sell, sell, import, and otherwise transfer the Work,\\n      where such license applies only to those patent claims licensable\\n      by such Contributor that are necessarily infringed by their\\n      Contribution(s) alone or by combination of their Contribution(s)\\n      with the Work to which such Contribution(s) was submitted. If You\\n      institute patent litigation against any entity (including a\\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\\n      or a Contribution incorporated within the Work constitutes direct\\n      or contributory patent infringement, then any patent licenses\\n      granted to You under this License for that Work shall terminate\\n      as of the date such litigation is filed.\\n\\n   4. Redistribution. You may reproduce and distribute copies of the\\n      Work or Derivative Works thereof in any medium, with or without\\n      modifications, and in Source or Object form, provided that You\\n      meet the following conditions:\\n\\n      (a) You must give any other recipients of the Work or\\n          Derivative Works a copy of this License; and\\n\\n      (b) You must cause any modified files to carry prominent notices\\n          stating that You changed the files; and\\n\\n      (c) You must retain, in the Source form of any Derivative Works\\n          that You distribute, all copyright, patent, trademark, and\\n          attribution notices from the Source form of the Work,\\n          excluding those notices that do not pertain to any part of\\n          the Derivative Works; and\\n\\n      (d) If the Work includes a \\\"NOTICE\\\" text file as part of its\\n          distribution, then any Derivative Works that You distribute must\\n          include a readable copy of the attribution notices contained\\n          within such NOTICE file, excluding those notices that do not\\n          pertain to any part of the Derivative Works, in at least one\\n          of the following places: within a NOTICE text file distributed\\n          as part of the Derivative Works; within the Source form or\\n          documentation, if provided along with the Derivative Works; or,\\n          within a display generated by the Derivative Works, if and\\n          wherever such third-party notices normally appear. The contents\\n          of the NOTICE file are for informational purposes only and\\n          do not modify the License. You may add Your own attribution\\n          notices within Derivative Works that You distribute, alongside\\n          or as an addendum to the NOTICE text from the Work, provided\\n          that such additional attribution notices cannot be construed\\n          as modifying the License.\\n\\n      You may add Your own copyright statement to Your modifications and\\n      may provide additional or different license terms and conditions\\n      for use, reproduction, or distribution of Your modifications, or\\n      for any such Derivative Works as a whole, provided Your use,\\n      reproduction, and distribution of the Work otherwise complies with\\n      the conditions stated in this License.\\n\\n   5. Submission of Contributions. Unless You explicitly state otherwise,\\n      any Contribution intentionally submitted for inclusion in the Work\\n      by You to the Licensor shall be under the terms and conditions of\\n      this License, without any additional terms or conditions.\\n      Notwithstanding the above, nothing herein shall supersede or modify\\n      the terms of any separate license agreement you may have executed\\n      with Licensor regarding such Contributions.\\n\\n   6. Trademarks. This License does not grant permission to use the trade\\n      names, trademarks, service marks, or product names of the Licensor,\\n      except as required for reasonable and customary use in describing the\\n      origin of the Work and reproducing the content of the NOTICE file.\\n\\n   7. Disclaimer of Warranty. Unless required by applicable law or\\n      agreed to in writing, Licensor provides the Work (and each\\n      Contributor provides its Contributions) on an \\\"AS IS\\\" BASIS,\\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\\n      implied, including, without limitation, any warranties or conditions\\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\\n      PARTICULAR PURPOSE. You are solely responsible for determining the\\n      appropriateness of using or redistributing the Work and assume any\\n      risks associated with Your exercise of permissions under this License.\\n\\n   8. Limitation of Liability. In no event and under no legal theory,\\n      whether in tort (including negligence), contract, or otherwise,\\n      unless required by applicable law (such as deliberate and grossly\\n      negligent acts) or agreed to in writing, shall any Contributor be\\n      liable to You for damages, including any direct, indirect, special,\\n      incidental, or consequential damages of any character arising as a\\n      result of this License or out of the use or inability to use the\\n      Work (including but not limited to damages for loss of goodwill,\\n      work stoppage, computer failure or malfunction, or any and all\\n      other commercial damages or losses), even if such Contributor\\n      has been advised of the possibility of such damages.\\n\\n   9. Accepting Warranty or Additional Liability. While redistributing\\n      the Work or Derivative Works thereof, You may choose to offer,\\n      and charge a fee for, acceptance of support, warranty, indemnity,\\n      or other liability obligations and/or rights consistent with this\\n      License. However, in accepting such obligations, You may act only\\n      on Your own behalf and on Your sole responsibility, not on behalf\\n      of any other Contributor, and only if You agree to indemnify,\\n      defend, and hold each Contributor harmless for any liability\\n      incurred by, or claims asserted against, such Contributor by reason\\n      of your accepting any such warranty or additional liability.\\n\\n   END OF TERMS AND CONDITIONS\\n\\n   APPENDIX: How to apply the Apache License to your work.\\n\\n      To apply the Apache License to your work, attach the following\\n      boilerplate notice, with the fields enclosed by brackets \\\"[]\\\"\\n      replaced with your own identifying information. (Don't include\\n      the brackets!)  The text should be enclosed in the appropriate\\n      comment syntax for the file format. We also recommend that a\\n      file or class name and description of purpose be included on the\\n      same \\\"printed page\\\" as the copyright notice for easier\\n      identification within third-party archives.\\n\\n   Copyright [yyyy] [name of copyright owner]\\n\\n   Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n   you may not use this file except in compliance with the License.\\n   You may obtain a copy of the License at\\n\\n       http://www.apache.org/licenses/LICENSE-2.0\\n\\n   Unless required by applicable law or agreed to in writing, software\\n   distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n   See the License for the specific language governing permissions and\\n   limitations under the License.\\n```\\n\";\n\n\n//# sourceURL=webpack://default/./node_modules/@js-draw/material-icons/dist/cjs/icons/README.js?");

/***/ }),

/***/ "./node_modules/@js-draw/material-icons/dist/cjs/icons/Redo.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@js-draw/material-icons/dist/cjs/icons/Redo.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n// The following icon is part of the Material Icon pack and is licensed under\n// the Apache 2.0 license.\n// You should have received a copy of this license along with the software.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Redo = void 0;\nexports.Redo = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" height=\\\"48\\\" viewBox=\\\"0 -960 960 960\\\" width=\\\"48\\\"><path style=\\\"fill: var(--icon-color);\\\" d=\\\"M388.174-194.022q-96.196 0-165.174-65.674-68.978-65.674-68.978-161.347 0-95.435 68.978-161.229 68.978-65.793 165.174-65.793h288.261L566.022-758.478l47.739-47.74L806.218-614 613.761-422.022l-47.739-47.739 110.413-110.174H387.174q-67.848 0-116.435 45.783-48.587 45.782-48.587 113.109 0 67.326 48.587 113.108 48.587 45.783 116.435 45.783h311.674v68.13H388.174Z\\\"/></svg>\";\nexports[\"default\"] = exports.Redo;\n\n\n//# sourceURL=webpack://default/./node_modules/@js-draw/material-icons/dist/cjs/icons/Redo.js?");

/***/ }),

/***/ "./node_modules/@js-draw/material-icons/dist/cjs/icons/Resize.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@js-draw/material-icons/dist/cjs/icons/Resize.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n// The following icon is part of the Material Icon pack and is licensed under\n// the Apache 2.0 license.\n// You should have received a copy of this license along with the software.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Resize = void 0;\nexports.Resize = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" height=\\\"48\\\" viewBox=\\\"0 -960 960 960\\\" width=\\\"48\\\"><path style=\\\"fill: var(--icon-color);\\\" d=\\\"M120-439v-83h60v83h-60Zm0-170v-83h60v83h-60Zm0-171v-60h60v60h-60Zm148 0v-60h83v60h-83Zm171 660v-60h83v60h-83Zm0-660v-60h83v60h-83Zm170 660v-60h83v60h-83Zm171 0v-60h60v60h-60Zm0-148v-83h60v83h-60Zm0-171v-83h60v83h-60Zm0-170v-171H609v-60h231v231h-60ZM120-120v-231h60v171h171v60H120Z\\\"/></svg>\";\nexports[\"default\"] = exports.Resize;\n\n\n//# sourceURL=webpack://default/./node_modules/@js-draw/material-icons/dist/cjs/icons/Resize.js?");

/***/ }),

/***/ "./node_modules/@js-draw/material-icons/dist/cjs/icons/RotateLeft.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@js-draw/material-icons/dist/cjs/icons/RotateLeft.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n// The following icon is part of the Material Icon pack and is licensed under\n// the Apache 2.0 license.\n// You should have received a copy of this license along with the software.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RotateLeft = void 0;\nexports.RotateLeft = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" height=\\\"48\\\" viewBox=\\\"0 -960 960 960\\\" width=\\\"48\\\"><path style=\\\"fill: var(--icon-color);\\\" d=\\\"M435-80q-48-7-93-25t-85-48l43-44q32 24 66 37.5t69 19.5v60Zm90 0v-60q110-21 182.5-103.5T780-443q0-127-86.5-213.5T480-743h-20l79 79-44 44-153-153 153-153 44 44-79 79h20q75 0 140.5 28T735-698q49 49 77 114.5T840-443q0 140-89 241T525-80ZM194-216q-28-38-46.5-84.5T122-398h61q5 38 18.5 73t36.5 65l-44 44Zm-72-272q7-50 25-95.5t47-85.5l44 43q-23 33-36.5 68T183-488h-61Z\\\"/></svg>\";\nexports[\"default\"] = exports.RotateLeft;\n\n\n//# sourceURL=webpack://default/./node_modules/@js-draw/material-icons/dist/cjs/icons/RotateLeft.js?");

/***/ }),

/***/ "./node_modules/@js-draw/material-icons/dist/cjs/icons/ScreenLockRotation.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@js-draw/material-icons/dist/cjs/icons/ScreenLockRotation.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n// The following icon is part of the Material Icon pack and is licensed under\n// the Apache 2.0 license.\n// You should have received a copy of this license along with the software.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ScreenLockRotation = void 0;\nexports.ScreenLockRotation = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" height=\\\"48\\\" viewBox=\\\"0 -960 960 960\\\" width=\\\"48\\\"><path style=\\\"fill: var(--icon-color);\\\" d=\\\"m724.391-486.891 48.979-48.739 52.521 52.521q21.631 21.746 21.631 52.156t-21.631 52.04L672.087-226.348q-22.746 22.631-52.155 22.631-29.41 0-52.041-22.631L249.587-544.891q-22.391-22.152-22.511-51.739-.119-29.588 22.511-52.218l153.565-152.565q22.63-22.63 52.098-22.63 29.467 0 52.098 22.63l47.282 47.522-47.739 48.5-51.521-51.522L295.087-596.63l325.022 325.782 160.043-160.043-55.761-56ZM533.574-30.761q-98.76 0-186.047-37.5-87.288-37.5-152.168-102.88-64.881-65.381-102.38-152.638-37.5-87.257-37.5-185.982h62.63q0 78.565 28.163 148.75t76.967 124.587q48.804 54.402 115.272 89.663 66.467 35.261 142.554 43.978L355.848-228 401-273.152 631.152-43.053Q608.253-37 585.237-33.88t-51.663 3.12ZM664.63-602.63q-15 0-27.5-12.5t-12.5-27.5v-120q0-15 12.5-27.5t27.5-12.5h1v-42q0-33 22.5-55.5t55.5-22.5q33 0 55.5 22.5t22.5 55.5v42h2q15 0 27.5 12.5t12.5 27.5v120q0 15-12.5 27.5t-27.5 12.5h-159Zm39-200h80v-42.106q0-17.894-11-28.894t-29-11q-18 0-29 11t-11 28.894v42.106ZM540.239-513.761Z\\\"/></svg>\";\nexports[\"default\"] = exports.ScreenLockRotation;\n\n\n//# sourceURL=webpack://default/./node_modules/@js-draw/material-icons/dist/cjs/icons/ScreenLockRotation.js?");

/***/ }),

/***/ "./node_modules/@js-draw/material-icons/dist/cjs/icons/Select.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@js-draw/material-icons/dist/cjs/icons/Select.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n// The following icon is part of the Material Icon pack and is licensed under\n// the Apache 2.0 license.\n// You should have received a copy of this license along with the software.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Select = void 0;\nexports.Select = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" height=\\\"48\\\" viewBox=\\\"0 -960 960 960\\\" width=\\\"48\\\"><path style=\\\"fill: var(--icon-color);\\\" d=\\\"M180-120q-24 0-42-18t-18-42h60v60Zm-60-120v-125h60v125h-60Zm0-185v-111h60v111h-60Zm0-171v-124h60v124h-60Zm0-184q0-24 18-42t42-18v60h-60Zm120 660v-60h125v60H240Zm0-660v-60h125v60H240Zm185 660v-60h111v60H425Zm0-660v-60h111v60H425Zm171 660v-60h124v60H596Zm0-660v-60h124v60H596Zm184 660v-60h60q0 24-18 42t-42 18Zm0-120v-125h60v125h-60Zm0-185v-111h60v111h-60Zm0-171v-124h60v124h-60Zm0-184v-60q24 0 42 18t18 42h-60Z\\\"/></svg>\";\nexports[\"default\"] = exports.Select;\n\n\n//# sourceURL=webpack://default/./node_modules/@js-draw/material-icons/dist/cjs/icons/Select.js?");

/***/ }),

/***/ "./node_modules/@js-draw/material-icons/dist/cjs/icons/Shapes.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@js-draw/material-icons/dist/cjs/icons/Shapes.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n// The following icon is part of the Material Icon pack and is licensed under\n// the Apache 2.0 license.\n// You should have received a copy of this license along with the software.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Shapes = void 0;\nexports.Shapes = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" height=\\\"48\\\" viewBox=\\\"0 -960 960 960\\\" width=\\\"48\\\"><path style=\\\"fill: var(--icon-color);\\\" d=\\\"M600-360Zm-280 98q10 2 19.5 2H360q5.5 0 10.25-.25T380-261v121h440v-440H699q.5-5 .75-9.75T700-600v-20.5q0-9.5-2-19.5h122q24.75 0 42.375 17.625T880-580v440q0 24.75-17.625 42.375T820-80H380q-24.75 0-42.375-17.625T320-140v-122Zm40-58q-117 0-198.5-81.5T80-600q0-117 81.5-198.5T360-880q117 0 198.5 81.5T640-600q0 117-81.5 198.5T360-320Zm-.212-60Q451-380 515.5-444.288q64.5-64.288 64.5-155.5T515.712-755.5q-64.288-64.5-155.5-64.5T204.5-755.712q-64.5 64.288-64.5 155.5T204.288-444.5q64.288 64.5 155.5 64.5ZM360-600Z\\\"/></svg>\";\nexports[\"default\"] = exports.Shapes;\n\n\n//# sourceURL=webpack://default/./node_modules/@js-draw/material-icons/dist/cjs/icons/Shapes.js?");

/***/ }),

/***/ "./node_modules/@js-draw/material-icons/dist/cjs/icons/Title.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@js-draw/material-icons/dist/cjs/icons/Title.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n// The following icon is part of the Material Icon pack and is licensed under\n// the Apache 2.0 license.\n// You should have received a copy of this license along with the software.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Title = void 0;\nexports.Title = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" height=\\\"48\\\" viewBox=\\\"0 -960 960 960\\\" width=\\\"48\\\"><path style=\\\"fill: var(--icon-color);\\\" d=\\\"M425.935-154.022v-544.065H194.022v-108.131h572.196v108.131H534.304v544.065H425.935Z\\\"/></svg>\";\nexports[\"default\"] = exports.Title;\n\n\n//# sourceURL=webpack://default/./node_modules/@js-draw/material-icons/dist/cjs/icons/Title.js?");

/***/ }),

/***/ "./node_modules/@js-draw/material-icons/dist/cjs/icons/TouchApp.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@js-draw/material-icons/dist/cjs/icons/TouchApp.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n// The following icon is part of the Material Icon pack and is licensed under\n// the Apache 2.0 license.\n// You should have received a copy of this license along with the software.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TouchApp = void 0;\nexports.TouchApp = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" height=\\\"48\\\" viewBox=\\\"0 -960 960 960\\\" width=\\\"48\\\"><path style=\\\"fill: var(--icon-color);\\\" d=\\\"M439.5-74.022q-32.2 0-61.652-13.247-29.452-13.248-49.153-38.535L109.543-404.913l27.218-27.065q15.888-15.545 38.194-18.773 22.306-3.227 42.219 7.49l93.978 49.652v-357.348q0-13.915 9.653-23.512 9.653-9.596 23.66-9.596 14.008 0 23.456 9.596 9.449 9.597 9.449 23.512v467.631l-150.935-80.348 156.478 197.761q10.486 12.622 25.085 19.028 14.599 6.407 31.024 6.407H652.87q36.463 0 61.677-25.04t25.214-61.692v-163.942q0-27.891-19.091-46.815-19.092-18.924-46.888-18.924H457.37v-66.457h216.058q55.15 0 93.97 38.647t38.82 93.549v164.022q0 64.195-44.577 108.652-44.576 44.456-108.664 44.456H439.5ZM191.761-662.609q-11.535-19.444-17.746-41.981-6.211-22.538-6.211-46.401 0-73.357 51.604-124.77 51.603-51.413 124.818-51.413t124.853 51.635q51.638 51.635 51.638 124.895 0 23.799-6.211 46.238t-17.745 41.797l-57.5-33.108q7-12 11-26t4-29.478q0-45.522-32.118-77.522-32.118-32-78-32t-77.882 32.083q-32 32.083-32 77.917 0 15 4 29t11 26l-57.5 33.108Zm291.456 330.696Z\\\"/></svg>\";\nexports[\"default\"] = exports.TouchApp;\n\n\n//# sourceURL=webpack://default/./node_modules/@js-draw/material-icons/dist/cjs/icons/TouchApp.js?");

/***/ }),

/***/ "./node_modules/@js-draw/material-icons/dist/cjs/icons/Undo.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@js-draw/material-icons/dist/cjs/icons/Undo.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n// The following icon is part of the Material Icon pack and is licensed under\n// the Apache 2.0 license.\n// You should have received a copy of this license along with the software.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Undo = void 0;\nexports.Undo = \"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" height=\\\"48\\\" viewBox=\\\"0 -960 960 960\\\" width=\\\"48\\\"><path style=\\\"fill: var(--icon-color);\\\" d=\\\"M261.152-194.022v-68.13h311.674q67.848 0 116.435-45.783 48.587-45.782 48.587-113.108 0-67.087-48.587-112.99-48.587-45.902-116.435-45.902H283.805l110.173 110.174-47.739 47.739L154.022-614l192.217-192.218 47.739 47.74-110.173 110.413h288.021q96.196 0 165.294 65.674 69.098 65.674 69.098 161.348 0 95.434-69.098 161.228-69.098 65.793-165.294 65.793H261.152Z\\\"/></svg>\";\nexports[\"default\"] = exports.Undo;\n\n\n//# sourceURL=webpack://default/./node_modules/@js-draw/material-icons/dist/cjs/icons/Undo.js?");

/***/ }),

/***/ "./node_modules/@js-draw/material-icons/dist/cjs/lib.js":
/*!**************************************************************!*\
  !*** ./node_modules/@js-draw/material-icons/dist/cjs/lib.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * # `@js-draw/material-icons`\n *\n * Provides a material icon theme for `js-draw`.\n *\n * @example\n * ```ts,runnable\n * import { Editor, makeEdgeToolbar } from 'js-draw';\n * import { MaterialIconProvider } from '@js-draw/material-icons';\n *\n * // Apply js-draw CSS\n * import 'js-draw/styles';\n *\n * const editor = new Editor(document.body, {\n *   iconProvider: new MaterialIconProvider(),\n * });\n *\n * // Ensure that there is enough room for the toolbar\n * editor.getRootElement().style.minHeight = '500px';\n *\n * // Add a toolbar\n * const toolbar = makeEdgeToolbar(editor);\n *\n * // ...with the default elements\n * toolbar.addDefaults();\n * ```\n *\n * @see\n * {@link MaterialIconProvider}\n *\n * @packageDocumentation\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.makeMaterialIconProviderClass = exports.MaterialIconProvider = void 0;\nconst js_draw_1 = __webpack_require__(/*! js-draw */ \"./node_modules/js-draw/dist/cjs/lib.js\");\nconst makeMaterialIconProvider_1 = __importDefault(__webpack_require__(/*! ./makeMaterialIconProvider */ \"./node_modules/@js-draw/material-icons/dist/cjs/makeMaterialIconProvider.js\"));\nexports.makeMaterialIconProviderClass = makeMaterialIconProvider_1.default;\n/**\n * An {@link js-draw!IconProvider | IconProvider} that uses [material icons](https://github.com/google/material-design-icons).\n */\nconst MaterialIconProvider = (0, makeMaterialIconProvider_1.default)({\n    IconProvider: js_draw_1.IconProvider,\n    EraserMode: js_draw_1.EraserMode,\n});\nexports.MaterialIconProvider = MaterialIconProvider;\nexports[\"default\"] = MaterialIconProvider;\n\n\n//# sourceURL=webpack://default/./node_modules/@js-draw/material-icons/dist/cjs/lib.js?");

/***/ }),

/***/ "./node_modules/@js-draw/material-icons/dist/cjs/makeMaterialIconProvider.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@js-draw/material-icons/dist/cjs/makeMaterialIconProvider.js ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst README_1 = __importDefault(__webpack_require__(/*! ./icons/README */ \"./node_modules/@js-draw/material-icons/dist/cjs/icons/README.js\"));\nconst ExpandMore_1 = __importDefault(__webpack_require__(/*! ./icons/ExpandMore */ \"./node_modules/@js-draw/material-icons/dist/cjs/icons/ExpandMore.js\"));\nconst Undo_1 = __importDefault(__webpack_require__(/*! ./icons/Undo */ \"./node_modules/@js-draw/material-icons/dist/cjs/icons/Undo.js\"));\nconst Redo_1 = __importDefault(__webpack_require__(/*! ./icons/Redo */ \"./node_modules/@js-draw/material-icons/dist/cjs/icons/Redo.js\"));\nconst InkEraser_1 = __importDefault(__webpack_require__(/*! ./icons/InkEraser */ \"./node_modules/@js-draw/material-icons/dist/cjs/icons/InkEraser.js\"));\nconst InkEraserOff_1 = __importDefault(__webpack_require__(/*! ./icons/InkEraserOff */ \"./node_modules/@js-draw/material-icons/dist/cjs/icons/InkEraserOff.js\"));\nconst PanTool_1 = __importDefault(__webpack_require__(/*! ./icons/PanTool */ \"./node_modules/@js-draw/material-icons/dist/cjs/icons/PanTool.js\"));\nconst TouchApp_1 = __importDefault(__webpack_require__(/*! ./icons/TouchApp */ \"./node_modules/@js-draw/material-icons/dist/cjs/icons/TouchApp.js\"));\nconst ScreenLockRotation_1 = __importDefault(__webpack_require__(/*! ./icons/ScreenLockRotation */ \"./node_modules/@js-draw/material-icons/dist/cjs/icons/ScreenLockRotation.js\"));\nconst Imagesmode_1 = __importDefault(__webpack_require__(/*! ./icons/Imagesmode */ \"./node_modules/@js-draw/material-icons/dist/cjs/icons/Imagesmode.js\"));\nconst Title_1 = __importDefault(__webpack_require__(/*! ./icons/Title */ \"./node_modules/@js-draw/material-icons/dist/cjs/icons/Title.js\"));\nconst Resize_1 = __importDefault(__webpack_require__(/*! ./icons/Resize */ \"./node_modules/@js-draw/material-icons/dist/cjs/icons/Resize.js\"));\nconst Delete_1 = __importDefault(__webpack_require__(/*! ./icons/Delete */ \"./node_modules/@js-draw/material-icons/dist/cjs/icons/Delete.js\"));\nconst ContentCopy_1 = __importDefault(__webpack_require__(/*! ./icons/ContentCopy */ \"./node_modules/@js-draw/material-icons/dist/cjs/icons/ContentCopy.js\"));\nconst EditDocument_1 = __importDefault(__webpack_require__(/*! ./icons/EditDocument */ \"./node_modules/@js-draw/material-icons/dist/cjs/icons/EditDocument.js\"));\nconst Check_1 = __importDefault(__webpack_require__(/*! ./icons/Check */ \"./node_modules/@js-draw/material-icons/dist/cjs/icons/Check.js\"));\nconst InkHighlighter_1 = __importDefault(__webpack_require__(/*! ./icons/InkHighlighter */ \"./node_modules/@js-draw/material-icons/dist/cjs/icons/InkHighlighter.js\"));\nconst Edit_1 = __importDefault(__webpack_require__(/*! ./icons/Edit */ \"./node_modules/@js-draw/material-icons/dist/cjs/icons/Edit.js\"));\nconst CloudUpload_1 = __importDefault(__webpack_require__(/*! ./icons/CloudUpload */ \"./node_modules/@js-draw/material-icons/dist/cjs/icons/CloudUpload.js\"));\nconst RotateLeft_1 = __importDefault(__webpack_require__(/*! ./icons/RotateLeft */ \"./node_modules/@js-draw/material-icons/dist/cjs/icons/RotateLeft.js\"));\nconst Select_1 = __importDefault(__webpack_require__(/*! ./icons/Select */ \"./node_modules/@js-draw/material-icons/dist/cjs/icons/Select.js\"));\nconst Close_1 = __importDefault(__webpack_require__(/*! ./icons/Close */ \"./node_modules/@js-draw/material-icons/dist/cjs/icons/Close.js\"));\nconst Shapes_1 = __importDefault(__webpack_require__(/*! ./icons/Shapes */ \"./node_modules/@js-draw/material-icons/dist/cjs/icons/Shapes.js\"));\nconst Draw_1 = __importDefault(__webpack_require__(/*! ./icons/Draw */ \"./node_modules/@js-draw/material-icons/dist/cjs/icons/Draw.js\"));\nconst InkPen_1 = __importDefault(__webpack_require__(/*! ./icons/InkPen */ \"./node_modules/@js-draw/material-icons/dist/cjs/icons/InkPen.js\"));\nconst ContentPaste_1 = __importDefault(__webpack_require__(/*! ./icons/ContentPaste */ \"./node_modules/@js-draw/material-icons/dist/cjs/icons/ContentPaste.js\"));\n/**\n * Converts an icon to an HTML element.\n *\n * This function accepts an \"opaque\" type to avoid unsafely creating icon DOM elements\n * from untrusted strings.\n */\nconst icon = (data) => {\n    const icon = document.createElement('div');\n    // eslint-disable-next-line no-unsanitized/property -- data must not be user-provided (enforced with a custom type).\n    icon.innerHTML = data;\n    return icon.childNodes[0];\n};\n/**\n * Creates a `MaterialIconProvider` class bound to a particular instance of the `js-draw`\n * library.\n *\n * **Example**:\n * ```ts,runnable\n * import * as jsdraw from 'js-draw';\n * import { makeMaterialIconProviderClass } from '@js-draw/material-icons';\n * const MaterialIconProvider = makeMaterialIconProviderClass(jsdraw);\n *\n * (new jsdraw.Editor(\n *     document.body, { iconProvider: new MaterialIconProvider() },\n * )).addToolbar();\n * ```\n *\n * If you only have one instance of `js-draw` (which is almost always the case), prefer\n * `new` {@link MaterialIconProvider}.\n *\n * @returns an uninstantiated subclass of {@link js-draw!IconProvider | IconProvider}.\n */\nconst makeMaterialIconProviderClass = ({ IconProvider, EraserMode, }) => class extends IconProvider {\n    makeUndoIcon() {\n        return icon(Undo_1.default);\n    }\n    makeRedoIcon() {\n        return icon(Redo_1.default);\n    }\n    makeDropdownIcon() {\n        return icon(ExpandMore_1.default);\n    }\n    makeEraserIcon(_eraserSize, mode) {\n        return icon(mode === EraserMode.PartialStroke ? InkEraserOff_1.default : InkEraser_1.default);\n    }\n    makeSelectionIcon() {\n        return icon(Select_1.default);\n    }\n    makeRotateIcon() {\n        return icon(RotateLeft_1.default);\n    }\n    makeHandToolIcon() {\n        return icon(PanTool_1.default);\n    }\n    makeTouchPanningIcon() {\n        return icon(TouchApp_1.default);\n    }\n    // makeAllDevicePanningIcon(): IconElemType;\n    // makeZoomIcon(): IconElemType;\n    makeRotationLockIcon() {\n        return icon(ScreenLockRotation_1.default);\n    }\n    makeInsertImageIcon() {\n        return icon(Imagesmode_1.default);\n    }\n    makeUploadFileIcon() {\n        return icon(CloudUpload_1.default);\n    }\n    makeTextIcon(_textStyle) {\n        return icon(Title_1.default);\n    }\n    makePenIcon(style) {\n        let baseIcon = this.isRoundedTipPen(style) ? Edit_1.default : InkHighlighter_1.default;\n        if (this.isPolylinePen(style)) {\n            baseIcon = InkPen_1.default;\n        }\n        const svg = icon(baseIcon);\n        svg.setAttribute('viewBox', '0 -880 960 1000');\n        const line = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n        line.setAttribute('d', `\n\t\t\tM110,-25 L850,-25\n\t\t`);\n        line.style.stroke = style.color.toHexString();\n        line.style.strokeWidth = `${Math.sqrt(style.thickness) * 20}`;\n        if (!this.isRoundedTipPen(style)) {\n            line.style.strokeLinecap = 'square';\n        }\n        else {\n            line.style.strokeLinecap = 'round';\n        }\n        svg.insertAdjacentElement('afterbegin', line);\n        // Add a grid background to make transparency visible\n        if (style.color.a < 1) {\n            const checkerboard = this.makeCheckerboardPattern();\n            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');\n            defs.appendChild(checkerboard.patternDefElement);\n            svg.appendChild(defs);\n            const lineBackground = line.cloneNode();\n            lineBackground.style.stroke = checkerboard.patternRef;\n            svg.insertAdjacentElement('afterbegin', lineBackground);\n        }\n        return svg;\n    }\n    // makeIconFromFactory(pen: Pen, factory: ComponentBuilderFactory, includeTransparencyGrid?: boolean): IconElemType;\n    // makePipetteIcon(color?: Color4): IconElemType;\n    // makeFormatSelectionIcon(): IconElemType;\n    makeShapeAutocorrectIcon() {\n        return icon(Shapes_1.default);\n    }\n    makeStrokeSmoothingIcon() {\n        return icon(Draw_1.default);\n    }\n    makeResizeImageToSelectionIcon() {\n        return icon(Resize_1.default);\n    }\n    makeDuplicateSelectionIcon() {\n        return icon(ContentCopy_1.default);\n    }\n    makeCopyIcon() {\n        return icon(ContentCopy_1.default);\n    }\n    makePasteIcon() {\n        return icon(ContentPaste_1.default);\n    }\n    makeDeleteSelectionIcon() {\n        return icon(Delete_1.default);\n    }\n    makeCloseIcon() {\n        return icon(Close_1.default);\n    }\n    makeSaveIcon() {\n        return icon(Check_1.default);\n    }\n    makeConfigureDocumentIcon() {\n        return icon(EditDocument_1.default);\n    }\n    // makeOverflowIcon(): IconElemType;\n    licenseInfo() {\n        return README_1.default;\n    }\n};\nexports[\"default\"] = makeMaterialIconProviderClass;\n\n\n//# sourceURL=webpack://default/./node_modules/@js-draw/material-icons/dist/cjs/makeMaterialIconProvider.js?");

/***/ }),

/***/ "./node_modules/@js-draw/math/dist/cjs/Color4.js":
/*!*******************************************************!*\
  !*** ./node_modules/@js-draw/math/dist/cjs/Color4.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Color4 = void 0;\nconst Vec3_1 = __importDefault(__webpack_require__(/*! ./Vec3 */ \"./node_modules/@js-draw/math/dist/cjs/Vec3.js\"));\n/**\n * Represents a color.\n *\n * @example\n * ```ts,runnable,console\n * import { Color4 } from '@js-draw/math';\n *\n * console.log('Red:', Color4.fromString('#f00'));\n * console.log('Also red:', Color4.ofRGB(1, 0, 0), Color4.red);\n * console.log('Mixing red and blue:', Color4.red.mix(Color4.blue, 0.5));\n * console.log('To string:', Color4.orange.toHexString());\n * ```\n */\nclass Color4 {\n    constructor(\n    /** Red component. Should be in the range [0, 1]. */\n    r, \n    /** Green component. ${\\tt g} \\in [0, 1]$ */\n    g, \n    /** Blue component. ${\\tt b} \\in [0, 1]$ */\n    b, \n    /** Alpha/transparent component. ${\\tt a} \\in [0, 1]$. 0 = transparent */\n    a) {\n        this.r = r;\n        this.g = g;\n        this.b = b;\n        this.a = a;\n        this.hexString = null;\n    }\n    /**\n     * Create a color from red, green, blue components. The color is fully opaque (`a = 1.0`).\n     *\n     * Each component should be in the range [0, 1].\n     */\n    static ofRGB(red, green, blue) {\n        return Color4.ofRGBA(red, green, blue, 1.0);\n    }\n    /**\n     * Creates a color from red, green, blue, and transparency components. Each component should\n     * be in the range $[0, 1]$.\n     */\n    static ofRGBA(red, green, blue, alpha) {\n        red = Math.max(0, Math.min(red, 1));\n        green = Math.max(0, Math.min(green, 1));\n        blue = Math.max(0, Math.min(blue, 1));\n        alpha = Math.max(0, Math.min(alpha, 1));\n        return new Color4(red, green, blue, alpha);\n    }\n    /**\n     * Creates a color from an RGB (or RGBA) array.\n     *\n     * This is similar to {@link ofRGB} and {@link ofRGBA}, but, by default, takes values\n     * that range from 0 to 255.\n     *\n     * If the array values instead range from 0-1, pass `maxValue` as `1`.\n     */\n    static fromRGBArray(array, maxValue = 255) {\n        const red = array[0];\n        const green = array[1] ?? red;\n        const blue = array[2] ?? red;\n        let alpha = 255;\n        if (3 < array.length) {\n            alpha = array[3];\n        }\n        return Color4.ofRGBA(red / maxValue, green / maxValue, blue / maxValue, alpha / maxValue);\n    }\n    /**\n     * Creates a `Color4` from a three or four-component hexadecimal\n     * [color string](https://en.wikipedia.org/wiki/Web_colors#Hex_triplet).\n     *\n     * Example:\n     * ```ts,runnable,console\n     * import { Color4 } from '@js-draw/math';\n     * console.log(Color4.fromHex('#ff0'));\n     * ```\n     */\n    static fromHex(hexString) {\n        // Remove starting '#' (if present)\n        hexString = (hexString.match(/^[#]?(.*)$/) ?? [])[1];\n        hexString = hexString.toUpperCase();\n        if (!hexString.match(/^[0-9A-F]+$/)) {\n            throw new Error(`${hexString} is not in a valid format.`);\n        }\n        // RGBA or RGB\n        if (hexString.length === 3 || hexString.length === 4) {\n            // Each character is a component\n            const components = hexString.split('');\n            // Convert to RRGGBBAA or RRGGBB format\n            hexString = components.map((component) => `${component}0`).join('');\n        }\n        if (hexString.length === 6) {\n            // Alpha component\n            hexString += 'FF';\n        }\n        const components = [];\n        for (let i = 2; i <= hexString.length; i += 2) {\n            const chunk = hexString.substring(i - 2, i);\n            components.push(parseInt(chunk, 16) / 255);\n        }\n        if (components.length !== 4) {\n            throw new Error(`Unable to parse ${hexString}: Wrong number of components.`);\n        }\n        return Color4.ofRGBA(components[0], components[1], components[2], components[3]);\n    }\n    /** Like {@link fromHex}, but can handle additional colors if an `HTMLCanvasElement` is available. */\n    static fromString(text) {\n        if (text.startsWith('#')) {\n            return Color4.fromHex(text);\n        }\n        if (text === 'none' || text === 'transparent') {\n            return Color4.transparent;\n        }\n        if (text === '') {\n            return Color4.black;\n        }\n        // rgba?: Match both rgb and rgba strings.\n        // ([,0-9.]+): Match any string of only numeric, '.' and ',' characters.\n        const rgbRegex = /^rgba?\\(([,0-9.]+)\\)$/i;\n        const rgbMatch = text.replace(/\\s*/g, '').match(rgbRegex);\n        if (rgbMatch) {\n            const componentsListStr = rgbMatch[1];\n            const componentsList = JSON.parse(`[ ${componentsListStr} ]`);\n            if (componentsList.length === 3) {\n                return Color4.ofRGB(componentsList[0] / 255, componentsList[1] / 255, componentsList[2] / 255);\n            }\n            else if (componentsList.length === 4) {\n                return Color4.ofRGBA(componentsList[0] / 255, componentsList[1] / 255, componentsList[2] / 255, componentsList[3]);\n            }\n            else {\n                throw new Error(`RGB string, ${text}, has wrong number of components: ${componentsList.length}`);\n            }\n        }\n        // Otherwise, try to use an HTMLCanvasElement to determine the color.\n        // Note: We may be unable to create an HTMLCanvasElement if running as a unit test.\n        const canvas = document.createElement('canvas');\n        canvas.width = 1;\n        canvas.height = 1;\n        const ctx = canvas.getContext('2d');\n        // Default to black if no canvas is available.\n        if (!ctx) {\n            return Color4.black;\n        }\n        ctx.fillStyle = text;\n        ctx.fillRect(0, 0, 1, 1);\n        const data = ctx.getImageData(0, 0, 1, 1);\n        const red = data.data[0] / 255;\n        const green = data.data[1] / 255;\n        const blue = data.data[2] / 255;\n        const alpha = data.data[3] / 255;\n        return Color4.ofRGBA(red, green, blue, alpha);\n    }\n    /** @returns true if `this` and `other` are approximately equal. */\n    eq(other) {\n        if (other == null) {\n            return false;\n        }\n        // If both completely transparent,\n        if (this.a === 0 && other.a === 0) {\n            return true;\n        }\n        return this.toHexString() === other.toHexString();\n    }\n    /**\n     * If `fractionTo` is not in the range $[0, 1]$, it will be clamped to the nearest number\n     * in that range. For example, `a.mix(b, -1)` is equivalent to `a.mix(b, 0)`.\n     *\n     * @returns a color `fractionTo` of the way from this color to `other`.\n     *\n     * @example\n     * ```ts\n     * Color4.ofRGB(1, 0, 0).mix(Color4.ofRGB(0, 1, 0), 0.1) // -> Color4(0.9, 0.1, 0)\n     * ```\n     */\n    mix(other, fractionTo) {\n        fractionTo = Math.min(Math.max(fractionTo, 0), 1);\n        const fractionOfThis = 1 - fractionTo;\n        return new Color4(this.r * fractionOfThis + other.r * fractionTo, this.g * fractionOfThis + other.g * fractionTo, this.b * fractionOfThis + other.b * fractionTo, this.a * fractionOfThis + other.a * fractionTo);\n    }\n    /**\n     * Ignoring this color's alpha component, returns a vector with components,\n     * $$\n     * \\begin{pmatrix} \\colorbox{#F44}{\\tt r} \\\\ \\colorbox{#4F4}{\\tt g} \\\\ \\colorbox{#44F}{\\tt b} \\end{pmatrix}\n     * $$\n     */\n    get rgb() {\n        return Vec3_1.default.of(this.r, this.g, this.b);\n    }\n    /**\n     * Returns the [relative luminance](https://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef)\n     * of this color in the sRGB color space.\n     *\n     * Ignores the alpha component.\n     */\n    relativeLuminance() {\n        // References:\n        // - https://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef\n        // - https://stackoverflow.com/a/9733420\n        // Normalize the components, as per above\n        const components = [this.r, this.g, this.b].map((component) => {\n            if (component < 0.03928) {\n                return component / 12.92;\n            }\n            else {\n                return Math.pow((component + 0.055) / 1.055, 2.4);\n            }\n        });\n        // From w3.org,\n        // > For the sRGB colorspace, the relative luminance of a color is\n        // > defined as L = 0.2126 * R + 0.7152 * G + 0.0722 * B\n        // where R, G, B are defined in components above.\n        return 0.2126 * components[0] + 0.7152 * components[1] + 0.0722 * components[2];\n    }\n    /**\n     * Returns the [contrast ratio](https://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef)\n     * between `colorA` and `colorB`.\n     */\n    static contrastRatio(colorA, colorB) {\n        const L1 = colorA.relativeLuminance();\n        const L2 = colorB.relativeLuminance();\n        return (Math.max(L1, L2) + 0.05) / (Math.min(L1, L2) + 0.05);\n    }\n    /**\n     * @returns the component-wise average of `colors`, or `Color4.transparent` if `colors` is empty.\n     */\n    static average(colors) {\n        let averageA = 0;\n        let averageR = 0;\n        let averageG = 0;\n        let averageB = 0;\n        for (const color of colors) {\n            averageA += color.a;\n            averageR += color.r;\n            averageG += color.g;\n            averageB += color.b;\n        }\n        if (colors.length > 0) {\n            averageA /= colors.length;\n            averageR /= colors.length;\n            averageG /= colors.length;\n            averageB /= colors.length;\n        }\n        return new Color4(averageR, averageG, averageB, averageA);\n    }\n    /**\n     * Converts to (hue, saturation, value).\n     * See also https://en.wikipedia.org/wiki/HSL_and_HSV#General_approach\n     *\n     * The resultant hue is represented in radians and is thus in $[0, 2\\pi]$.\n     */\n    asHSV() {\n        // Ref: https://en.wikipedia.org/wiki/HSL_and_HSV#General_approach\n        //\n        // HUE:\n        // First, consider the unit cube. Rotate it such that one vertex is at the origin\n        // of a plane and its three neighboring vertices are equidistant from that plane:\n        //\n        //         /\\\n        //       /  | \\\n        //   2 /    3   \\ 1\n        //     \\    |   /\n        //       \\  | /\n        //   .     \\/      .\n        //\n        //        .\n        //\n        // Let z be up and (x, y, 0) be in the plane.\n        //\n        // Label vectors 1,2,3 with R, G, and B, respectively. Let R's projection into the plane\n        // lie along the x axis.\n        //\n        // Because R is a unit vector and R, G, B are equidistant from the plane, they must\n        // form 30-60-90 triangles, which have side lengths proportional to (1, √3, 2)\n        //\n        //       /|\n        //    1/  | (√3)/2\n        //    /   |\n        //      1/2\n        //\n        const minComponent = Math.min(this.r, this.g, this.b);\n        const maxComponent = Math.max(this.r, this.g, this.b);\n        const chroma = maxComponent - minComponent;\n        let hue;\n        // See https://en.wikipedia.org/wiki/HSL_and_HSV#General_approach\n        if (chroma === 0) {\n            hue = 0;\n        }\n        else if (this.r >= this.g && this.r >= this.b) {\n            hue = ((this.g - this.b) / chroma) % 6;\n        }\n        else if (this.g >= this.r && this.g >= this.b) {\n            hue = (this.b - this.r) / chroma + 2;\n        }\n        else {\n            hue = (this.r - this.g) / chroma + 4;\n        }\n        // Convert to degree representation, then to radians.\n        hue *= 60;\n        hue *= Math.PI / 180;\n        // Ensure positivity.\n        if (hue < 0) {\n            hue += Math.PI * 2;\n        }\n        const value = maxComponent;\n        const saturation = value > 0 ? chroma / value : 0;\n        return Vec3_1.default.of(hue, saturation, value);\n    }\n    /**\n     * Creates a new `Color4` from a representation [in $HSV$](https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_RGB).\n     *\n     * [Algorithm](https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_RGB).\n     *\n     * Note that hue must be given **in radians**. While non-standard, this is consistent with\n     * {@link asHSV}.\n     *\n     * `hue` and `value` should range from 0 to 1.\n     *\n     * @param hue $H \\in [0, 2\\pi]$\n     * @param saturation $S_V \\in [0, 1]$\n     * @param value $V \\in [0, 1]$\n     */\n    static fromHSV(hue, saturation, value) {\n        if (hue < 0) {\n            hue += Math.PI * 2;\n        }\n        hue %= Math.PI * 2;\n        // Clamp value and saturation to [0, 1]\n        value = Math.max(0, Math.min(1, value));\n        saturation = Math.max(0, Math.min(1, saturation));\n        // Formula from https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_RGB\n        // Saturation can be thought of as scaled chroma. Unapply the scaling.\n        // See https://en.wikipedia.org/wiki/HSL_and_HSV#Saturation\n        const chroma = value * saturation;\n        // Determines which edge of the projected color cube\n        const huePrime = hue / (Math.PI / 3);\n        const secondLargestComponent = chroma * (1 - Math.abs((huePrime % 2) - 1));\n        let rgb;\n        if (huePrime < 1) {\n            rgb = [chroma, secondLargestComponent, 0];\n        }\n        else if (huePrime < 2) {\n            rgb = [secondLargestComponent, chroma, 0];\n        }\n        else if (huePrime < 3) {\n            rgb = [0, chroma, secondLargestComponent];\n        }\n        else if (huePrime < 4) {\n            rgb = [0, secondLargestComponent, chroma];\n        }\n        else if (huePrime < 5) {\n            rgb = [secondLargestComponent, 0, chroma];\n        }\n        else {\n            rgb = [chroma, 0, secondLargestComponent];\n        }\n        const adjustment = value - chroma;\n        return Color4.ofRGB(rgb[0] + adjustment, rgb[1] + adjustment, rgb[2] + adjustment);\n    }\n    /**\n     * Equivalent to `ofRGB(rgb.x, rgb.y, rgb.z)`.\n     *\n     * All components should be in the range `[0, 1]` (0 to 1 inclusive).\n     */\n    static fromRGBVector(rgb, alpha) {\n        return Color4.ofRGBA(rgb.x, rgb.y, rgb.z, alpha ?? 1);\n    }\n    /**\n     * @returns a hexadecimal color string representation of `this`, in the form `#rrggbbaa`.\n     *\n     * @example\n     * ```\n     * Color4.red.toHexString(); // -> #ff0000ff\n     * ```\n     */\n    toHexString() {\n        if (this.hexString) {\n            return this.hexString;\n        }\n        const componentToHex = (component) => {\n            const res = Math.round(255 * component).toString(16);\n            if (res.length === 1) {\n                return `0${res}`;\n            }\n            return res;\n        };\n        const alpha = componentToHex(this.a);\n        const red = componentToHex(this.r);\n        const green = componentToHex(this.g);\n        const blue = componentToHex(this.b);\n        if (alpha === 'ff') {\n            return `#${red}${green}${blue}`;\n        }\n        this.hexString = `#${red}${green}${blue}${alpha}`;\n        return this.hexString;\n    }\n    toString() {\n        return this.toHexString();\n    }\n}\nexports.Color4 = Color4;\nColor4.transparent = Color4.ofRGBA(0, 0, 0, 0);\nColor4.red = Color4.ofRGB(1.0, 0.0, 0.0);\nColor4.orange = Color4.ofRGB(1.0, 0.65, 0.0);\nColor4.green = Color4.ofRGB(0.0, 1.0, 0.0);\nColor4.blue = Color4.ofRGB(0.0, 0.0, 1.0);\nColor4.purple = Color4.ofRGB(0.5, 0.2, 0.5);\nColor4.yellow = Color4.ofRGB(1, 1, 0.1);\nColor4.clay = Color4.ofRGB(0.8, 0.4, 0.2);\nColor4.black = Color4.ofRGB(0, 0, 0);\nColor4.gray = Color4.ofRGB(0.5, 0.5, 0.5);\nColor4.white = Color4.ofRGB(1, 1, 1);\nexports[\"default\"] = Color4;\n\n\n//# sourceURL=webpack://default/./node_modules/@js-draw/math/dist/cjs/Color4.js?");

/***/ }),

/***/ "./node_modules/@js-draw/math/dist/cjs/Mat33.js":
/*!******************************************************!*\
  !*** ./node_modules/@js-draw/math/dist/cjs/Mat33.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Mat33 = void 0;\nconst Vec2_1 = __webpack_require__(/*! ./Vec2 */ \"./node_modules/@js-draw/math/dist/cjs/Vec2.js\");\nconst Vec3_1 = __importDefault(__webpack_require__(/*! ./Vec3 */ \"./node_modules/@js-draw/math/dist/cjs/Vec3.js\"));\n/**\n * Represents a three dimensional linear transformation or\n * a two-dimensional affine transformation. (An affine transformation scales/rotates/shears\n * **and** translates while a linear transformation just scales/rotates/shears).\n *\n * In addition to other matrices, {@link Mat33}s can be used to transform {@link Vec3}s and {@link Vec2}s.\n *\n * For example, to move the point $(1, 1)$ by 5 units to the left and 6 units up,\n * ```ts,runnable,console\n * import {Mat33, Vec2} from '@js-draw/math';\n *\n * const moveLeftAndUp = Mat33.translation(Vec2.of(5, 6));\n * console.log(moveLeftAndUp);\n * ```\n *\n * This `moveLeftAndUp` matrix could then translate (move) a {@link Vec2} using\n * {@link Mat33.transformVec2}:\n *\n * ```ts,runnable,console\n * ---use-previous---\n * ---visible---\n * console.log(moveLeftAndUp.transformVec2(Vec2.of(1, 1)));\n * console.log(moveLeftAndUp.transformVec2(Vec2.of(-1, 2)));\n * ```\n *\n * It's also possible to create transformation matrices that scale and rotate.\n * A single transform matrix can be created from multiple using matrix multiplication\n * (see {@link Mat33.rightMul}):\n *\n * ```ts,runnable,console\n * ---use-previous---\n * ---visible---\n * // Create a matrix by right multiplying.\n * const scaleThenRotate =\n *   // The resultant matrix first scales by a factor of two\n *   Mat33.scaling2D(2).rightMul(\n *     // ...then rotates by pi/2 radians = 90 degrees.\n *     Mat33.zRotation(Math.PI / 2)\n *   );\n * console.log(scaleThenRotate);\n *\n * // Use scaleThenRotate to scale then rotate a vector.\n * console.log(scaleThenRotate.transformVec2(Vec2.unitX));\n * ```\n */\nclass Mat33 {\n    /**\n     * Creates a matrix from inputs in the form,\n     * $$\n     * \\begin{bmatrix}\n     *   a1 & a2 & a3 \\\\\n     *   b1 & b2 & b3 \\\\\n     *   c1 & c2 & c3\n     * \\end{bmatrix}\n     * $$\n     *\n     * Static constructor methods are also available.\n     * See {@link Mat33.scaling2D}, {@link Mat33.zRotation}, {@link Mat33.translation}, and {@link Mat33.fromCSSMatrix}.\n     */\n    constructor(a1, a2, a3, b1, b2, b3, c1, c2, c3) {\n        this.a1 = a1;\n        this.a2 = a2;\n        this.a3 = a3;\n        this.b1 = b1;\n        this.b2 = b2;\n        this.b3 = b3;\n        this.c1 = c1;\n        this.c2 = c2;\n        this.c3 = c3;\n        this.cachedInverse = undefined;\n        this.rows = [Vec3_1.default.of(a1, a2, a3), Vec3_1.default.of(b1, b2, b3), Vec3_1.default.of(c1, c2, c3)];\n    }\n    /**\n     * Creates a matrix from the given rows:\n     * $$\n     * \\begin{bmatrix}\n     *  \\texttt{r1.x} & \\texttt{r1.y} & \\texttt{r1.z}\\\\\n     *  \\texttt{r2.x} & \\texttt{r2.y} & \\texttt{r2.z}\\\\\n     *  \\texttt{r3.x} & \\texttt{r3.y} & \\texttt{r3.z}\\\\\n     * \\end{bmatrix}\n     * $$\n     */\n    static ofRows(r1, r2, r3) {\n        return new Mat33(r1.x, r1.y, r1.z, r2.x, r2.y, r2.z, r3.x, r3.y, r3.z);\n    }\n    /**\n     * Either returns the inverse of this, or, if this matrix is singular/uninvertable,\n     * returns Mat33.identity.\n     *\n     * This may cache the computed inverse and return the cached version instead of recomputing\n     * it.\n     */\n    inverse() {\n        return this.computeInverse() ?? Mat33.identity;\n    }\n    invertable() {\n        return this.computeInverse() !== null;\n    }\n    computeInverse() {\n        if (this.cachedInverse !== undefined) {\n            return this.cachedInverse;\n        }\n        const toIdentity = [this.rows[0], this.rows[1], this.rows[2]];\n        const toResult = [Vec3_1.default.unitX, Vec3_1.default.unitY, Vec3_1.default.unitZ];\n        // Convert toIdentity to the identity matrix and\n        // toResult to the inverse through elementary row operations\n        for (let cursor = 0; cursor < 3; cursor++) {\n            // Select the [cursor]th diagonal entry\n            let pivot = toIdentity[cursor].at(cursor);\n            // Don't divide by zero (treat very small numbers as zero).\n            const minDivideBy = 1e-10;\n            if (Math.abs(pivot) < minDivideBy) {\n                let swapIndex = -1;\n                // For all other rows,\n                for (let i = 1; i <= 2; i++) {\n                    const otherRowIdx = (cursor + i) % 3;\n                    if (Math.abs(toIdentity[otherRowIdx].at(cursor)) >= minDivideBy) {\n                        swapIndex = otherRowIdx;\n                        break;\n                    }\n                }\n                // Can't swap with another row?\n                if (swapIndex === -1) {\n                    this.cachedInverse = null;\n                    return null;\n                }\n                const tmpIdentityRow = toIdentity[cursor];\n                const tmpResultRow = toResult[cursor];\n                // Swap!\n                toIdentity[cursor] = toIdentity[swapIndex];\n                toResult[cursor] = toResult[swapIndex];\n                toIdentity[swapIndex] = tmpIdentityRow;\n                toResult[swapIndex] = tmpResultRow;\n                pivot = toIdentity[cursor].at(cursor);\n            }\n            // Make toIdentity[k = cursor] = 1\n            let scale = 1.0 / pivot;\n            toIdentity[cursor] = toIdentity[cursor].times(scale);\n            toResult[cursor] = toResult[cursor].times(scale);\n            const cursorToIdentityRow = toIdentity[cursor];\n            const cursorToResultRow = toResult[cursor];\n            // Make toIdentity[k ≠ cursor] = 0\n            for (let i = 1; i <= 2; i++) {\n                const otherRowIdx = (cursor + i) % 3;\n                scale = -toIdentity[otherRowIdx].at(cursor);\n                toIdentity[otherRowIdx] = toIdentity[otherRowIdx].plus(cursorToIdentityRow.times(scale));\n                toResult[otherRowIdx] = toResult[otherRowIdx].plus(cursorToResultRow.times(scale));\n            }\n        }\n        const inverse = Mat33.ofRows(toResult[0], toResult[1], toResult[2]);\n        this.cachedInverse = inverse;\n        return inverse;\n    }\n    transposed() {\n        return new Mat33(this.a1, this.b1, this.c1, this.a2, this.b2, this.c2, this.a3, this.b3, this.c3);\n    }\n    /**\n     * [Right-multiplies](https://en.wikipedia.org/wiki/Matrix_multiplication) this by `other`.\n     *\n     * See also {@link transformVec3} and {@link transformVec2}.\n     *\n     * Example:\n     * ```ts,runnable,console\n     * import {Mat33, Vec2} from '@js-draw/math';\n     * console.log(Mat33.identity.rightMul(Mat33.identity));\n     *\n     * // Create a matrix by right multiplying.\n     * const scaleThenRotate =\n     *   // The resultant matrix first scales by a factor of two\n     *   Mat33.scaling2D(2).rightMul(\n     *     // ...then rotates by pi/4 radians = 45 degrees.\n     *     Mat33.zRotation(Math.PI / 4)\n     *   );\n     * console.log(scaleThenRotate);\n     *\n     * // Use scaleThenRotate to scale then rotate a vector.\n     * console.log(scaleThenRotate.transformVec2(Vec2.unitX));\n     * ```\n     */\n    rightMul(other) {\n        other = other.transposed();\n        const at = (row, col) => {\n            return this.rows[row].dot(other.rows[col]);\n        };\n        return new Mat33(at(0, 0), at(0, 1), at(0, 2), at(1, 0), at(1, 1), at(1, 2), at(2, 0), at(2, 1), at(2, 2));\n    }\n    /**\n     * Applies this as an **affine** transformation to the given vector.\n     * Returns a transformed version of `other`.\n     *\n     * Unlike {@link transformVec3}, this **does** translate the given vector.\n     */\n    transformVec2(other) {\n        // When transforming a Vec2, we want to use the z transformation\n        // components of this for translation:\n        //  ⎡ . . tX ⎤\n        //  ⎢ . . tY ⎥\n        //  ⎣ 0 0 1  ⎦\n        // For this, we need other's z component to be 1 (so that tX and tY\n        // are scaled by 1):\n        let intermediate = Vec3_1.default.of(other.x, other.y, 1);\n        intermediate = this.transformVec3(intermediate);\n        // Drop the z=1 to allow magnitude to work as expected\n        return Vec2_1.Vec2.of(intermediate.x, intermediate.y);\n    }\n    /**\n     * Applies this as a linear transformation to the given vector (doesn't translate).\n     * This is the standard way of transforming vectors in ℝ³.\n     */\n    transformVec3(other) {\n        return Vec3_1.default.of(this.rows[0].dot(other), this.rows[1].dot(other), this.rows[2].dot(other));\n    }\n    /** @returns true iff this is the identity matrix. */\n    isIdentity() {\n        if (this === Mat33.identity) {\n            return true;\n        }\n        return this.eq(Mat33.identity);\n    }\n    /** Returns true iff this = other ± fuzz */\n    eq(other, fuzz = 0) {\n        for (let i = 0; i < 3; i++) {\n            if (!this.rows[i].eq(other.rows[i], fuzz)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Creates a human-readable representation of the matrix.\n     *\n     * Example:\n     * ```ts,runnable,console\n     * import { Mat33 } from '@js-draw/math';\n     * console.log(Mat33.identity.toString());\n     * ```\n     */\n    toString() {\n        let result = '';\n        const maxColumnLens = [0, 0, 0];\n        // Determine the longest item in each column so we can pad the others to that\n        // length.\n        for (const row of this.rows) {\n            for (let i = 0; i < 3; i++) {\n                maxColumnLens[i] = Math.max(maxColumnLens[0], `${row.at(i)}`.length);\n            }\n        }\n        for (let i = 0; i < 3; i++) {\n            if (i === 0) {\n                result += '⎡ ';\n            }\n            else if (i === 1) {\n                result += '⎢ ';\n            }\n            else {\n                result += '⎣ ';\n            }\n            // Add each component of the ith row (after padding it)\n            for (let j = 0; j < 3; j++) {\n                const val = this.rows[i].at(j).toString();\n                let padding = '';\n                for (let i = val.length; i < maxColumnLens[j]; i++) {\n                    padding += ' ';\n                }\n                result += val + ', ' + padding;\n            }\n            if (i === 0) {\n                result += ' ⎤';\n            }\n            else if (i === 1) {\n                result += ' ⎥';\n            }\n            else {\n                result += ' ⎦';\n            }\n            result += '\\n';\n        }\n        return result.trimEnd();\n    }\n    /**\n     * ```\n     * result[0] = top left element\n     * result[1] = element at row zero, column 1\n     * ...\n     * ```\n     *\n     * Example:\n     * ```ts,runnable,console\n     * import { Mat33 } from '@js-draw/math';\n     * console.log(\n     *   new Mat33(\n     *     1, 2, 3,\n     *     4, 5, 6,\n     *     7, 8, 9,\n     *   )\n     * );\n     * ```\n     */\n    toArray() {\n        return [this.a1, this.a2, this.a3, this.b1, this.b2, this.b3, this.c1, this.c2, this.c3];\n    }\n    /**\n     * Returns a new `Mat33` where each entry is the output of the function\n     * `mapping`.\n     *\n     * @example\n     * ```\n     * new Mat33(\n     *  1, 2, 3,\n     *  4, 5, 6,\n     *  7, 8, 9,\n     * ).mapEntries(component => component - 1);\n     * // → ⎡ 0, 1, 2 ⎤\n     * //   ⎢ 3, 4, 5 ⎥\n     * //   ⎣ 6, 7, 8 ⎦\n     * ```\n     */\n    mapEntries(mapping) {\n        return new Mat33(mapping(this.a1, [0, 0]), mapping(this.a2, [0, 1]), mapping(this.a3, [0, 2]), mapping(this.b1, [1, 0]), mapping(this.b2, [1, 1]), mapping(this.b3, [1, 2]), mapping(this.c1, [2, 0]), mapping(this.c2, [2, 1]), mapping(this.c3, [2, 2]));\n    }\n    /** Estimate the scale factor of this matrix (based on the first row). */\n    getScaleFactor() {\n        return Math.hypot(this.a1, this.a2);\n    }\n    /** Returns the `idx`-th column (`idx` is 0-indexed). */\n    getColumn(idx) {\n        return Vec3_1.default.of(this.rows[0].at(idx), this.rows[1].at(idx), this.rows[2].at(idx));\n    }\n    /** Returns the magnitude of the entry with the largest entry */\n    maximumEntryMagnitude() {\n        let greatestSoFar = Math.abs(this.a1);\n        for (const entry of this.toArray()) {\n            greatestSoFar = Math.max(greatestSoFar, Math.abs(entry));\n        }\n        return greatestSoFar;\n    }\n    /**\n     * Constructs a 3x3 translation matrix (for translating `Vec2`s) using\n     * **transformVec2**.\n     *\n     * Creates a matrix in the form\n     * $$\n     * \t\\begin{pmatrix}\n     * \t\t1 & 0 & {\\tt amount.x}\\\\\n     * \t\t0 & 1 & {\\tt amount.y}\\\\\n     * \t\t0 & 0 & 1\n     * \t\\end{pmatrix}\n     * $$\n     */\n    static translation(amount) {\n        // When transforming Vec2s by a 3x3 matrix, we give the input\n        // Vec2s z = 1. As such,\n        //   outVec2.x = inVec2.x * 1 + inVec2.y * 0 + 1 * amount.x\n        //   ...\n        return new Mat33(1, 0, amount.x, 0, 1, amount.y, 0, 0, 1);\n    }\n    /**\n     * Creates a matrix for rotating `Vec2`s about `center` by some number of `radians`.\n     *\n     * For this function, {@link Vec2}s are considered to be points in 2D space.\n     *\n     * For example,\n     * ```ts,runnable,console\n     * import { Mat33, Vec2 } from '@js-draw/math';\n     *\n     * const halfCircle = Math.PI; // PI radians = 180 degrees = 1/2 circle\n     * const center = Vec2.of(1, 1); // The point (1,1)\n     * const rotationMatrix = Mat33.zRotation(halfCircle, center);\n     *\n     * console.log(\n     *   'Rotating (0,0) 180deg about', center, 'results in',\n     *   // Rotates (0,0)\n     *   rotationMatrix.transformVec2(Vec2.zero),\n     * );\n     * ```\n     */\n    static zRotation(radians, center = Vec2_1.Vec2.zero) {\n        if (radians === 0) {\n            return Mat33.identity;\n        }\n        const cos = Math.cos(radians);\n        const sin = Math.sin(radians);\n        // Translate everything so that rotation is about the origin\n        let result = Mat33.translation(center);\n        result = result.rightMul(new Mat33(cos, -sin, 0, sin, cos, 0, 0, 0, 1));\n        return result.rightMul(Mat33.translation(center.times(-1)));\n    }\n    static scaling2D(amount, center = Vec2_1.Vec2.zero) {\n        let result = Mat33.translation(center);\n        let xAmount, yAmount;\n        if (typeof amount === 'number') {\n            xAmount = amount;\n            yAmount = amount;\n        }\n        else {\n            xAmount = amount.x;\n            yAmount = amount.y;\n        }\n        result = result.rightMul(new Mat33(xAmount, 0, 0, 0, yAmount, 0, 0, 0, 1));\n        // Translate such that [center] goes to (0, 0)\n        return result.rightMul(Mat33.translation(center.times(-1)));\n    }\n    /**\n     * **Note**: Assumes `this.c1 = this.c2 = 0` and `this.c3 = 1`.\n     *\n     * @see {@link fromCSSMatrix}\n     */\n    toCSSMatrix() {\n        return `matrix(${this.a1},${this.b1},${this.a2},${this.b2},${this.a3},${this.b3})`;\n    }\n    /**\n     * Converts a CSS-form `matrix(a, b, c, d, e, f)` to a Mat33.\n     *\n     * Note that such a matrix has the form,\n     * ```\n     * ⎡ a c e ⎤\n     * ⎢ b d f ⎥\n     * ⎣ 0 0 1 ⎦\n     * ```\n     */\n    static fromCSSMatrix(cssString) {\n        if (cssString === '' || cssString === 'none') {\n            return Mat33.identity;\n        }\n        // Normalize spacing\n        cssString = cssString.trim().replace(/\\s+/g, ' ');\n        const parseArguments = (argumentString) => {\n            const parsed = argumentString.split(/[, \\t\\n]+/g).map((argString) => {\n                // Handle trailing spaces/commands\n                if (argString.trim() === '') {\n                    return null;\n                }\n                let isPercentage = false;\n                if (argString.endsWith('%')) {\n                    isPercentage = true;\n                    argString = argString.substring(0, argString.length - 1);\n                }\n                // Remove trailing px units.\n                argString = argString.replace(/px$/gi, '');\n                const numberExp = /^[-]?\\d*(?:\\.\\d*)?(?:[eE][-+]?\\d+)?$/i;\n                if (!numberExp.exec(argString)) {\n                    throw new Error(`All arguments to transform functions must be numeric (state: ${JSON.stringify({\n                        currentArgument: argString,\n                        allArguments: argumentString,\n                    })})`);\n                }\n                let argNumber = parseFloat(argString);\n                if (isPercentage) {\n                    argNumber /= 100;\n                }\n                return argNumber;\n            });\n            return parsed.filter((n) => n !== null);\n        };\n        const keywordToAction = {\n            matrix: (matrixData) => {\n                if (matrixData.length !== 6) {\n                    throw new Error(`Invalid matrix argument: ${matrixData}. Must have length 6`);\n                }\n                const a = matrixData[0];\n                const b = matrixData[1];\n                const c = matrixData[2];\n                const d = matrixData[3];\n                const e = matrixData[4];\n                const f = matrixData[5];\n                const transform = new Mat33(a, c, e, b, d, f, 0, 0, 1);\n                return transform;\n            },\n            scale: (scaleArgs) => {\n                let scaleX, scaleY;\n                if (scaleArgs.length === 1) {\n                    scaleX = scaleArgs[0];\n                    scaleY = scaleArgs[0];\n                }\n                else if (scaleArgs.length === 2) {\n                    scaleX = scaleArgs[0];\n                    scaleY = scaleArgs[1];\n                }\n                else {\n                    throw new Error(`The scale() function only supports two arguments. Given: ${scaleArgs}`);\n                }\n                return Mat33.scaling2D(Vec2_1.Vec2.of(scaleX, scaleY));\n            },\n            translate: (translateArgs) => {\n                let translateX = 0;\n                let translateY = 0;\n                if (translateArgs.length === 1) {\n                    // If no y translation is given, assume 0.\n                    translateX = translateArgs[0];\n                }\n                else if (translateArgs.length === 2) {\n                    translateX = translateArgs[0];\n                    translateY = translateArgs[1];\n                }\n                else {\n                    throw new Error(`The translate() function requires either 1 or 2 arguments. Given ${translateArgs}`);\n                }\n                return Mat33.translation(Vec2_1.Vec2.of(translateX, translateY));\n            },\n        };\n        // A command (\\w+)\n        // followed by a set of arguments ([^)]*)\n        const partRegex = /(?:^|\\W)(\\w+)\\s?\\(([^)]*)\\)/gi;\n        let match;\n        let matrix = null;\n        while ((match = partRegex.exec(cssString)) !== null) {\n            const action = match[1].toLowerCase();\n            if (!(action in keywordToAction)) {\n                throw new Error(`Unsupported CSS transform action: ${action}`);\n            }\n            const args = parseArguments(match[2]);\n            const currentMatrix = keywordToAction[action](args);\n            if (!matrix) {\n                matrix = currentMatrix;\n            }\n            else {\n                matrix = matrix.rightMul(currentMatrix);\n            }\n        }\n        return matrix ?? Mat33.identity;\n    }\n}\nexports.Mat33 = Mat33;\n/** The 3x3 [identity matrix](https://en.wikipedia.org/wiki/Identity_matrix). */\nMat33.identity = new Mat33(1, 0, 0, 0, 1, 0, 0, 0, 1);\nexports[\"default\"] = Mat33;\n\n\n//# sourceURL=webpack://default/./node_modules/@js-draw/math/dist/cjs/Mat33.js?");

/***/ }),

/***/ "./node_modules/@js-draw/math/dist/cjs/Vec2.js":
/*!*****************************************************!*\
  !*** ./node_modules/@js-draw/math/dist/cjs/Vec2.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Vec2 = exports.Vec3 = void 0;\n// Internally, we define Vec2 as a namespace within Vec3 --\n// this allows referencing Vec2s from Vec3 constructors without\n// cyclic references.\nconst Vec3_1 = __webpack_require__(/*! ./Vec3 */ \"./node_modules/@js-draw/math/dist/cjs/Vec3.js\");\nObject.defineProperty(exports, \"Vec3\", ({ enumerable: true, get: function () { return Vec3_1.Vec3; } }));\nObject.defineProperty(exports, \"Vec2\", ({ enumerable: true, get: function () { return Vec3_1.Vec2; } }));\nexports[\"default\"] = Vec3_1.Vec2;\n\n\n//# sourceURL=webpack://default/./node_modules/@js-draw/math/dist/cjs/Vec2.js?");

/***/ }),

/***/ "./node_modules/@js-draw/math/dist/cjs/Vec3.js":
/*!*****************************************************!*\
  !*** ./node_modules/@js-draw/math/dist/cjs/Vec3.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Vec3 = exports.Vec2 = void 0;\nconst defaultEqlTolerance = 1e-10;\nclass Vec3Impl {\n    constructor(x, y, z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n    get xy() {\n        // Useful for APIs that behave differently if .z is present.\n        return {\n            x: this.x,\n            y: this.y,\n        };\n    }\n    /** Returns this' `idx`th component. For example, `Vec3.of(1, 2, 3).at(1) → 2`. */\n    at(idx) {\n        if (idx === 0)\n            return this.x;\n        if (idx === 1)\n            return this.y;\n        if (idx === 2)\n            return this.z;\n        throw new Error(`${idx} out of bounds!`);\n    }\n    length() {\n        return this.magnitude();\n    }\n    magnitude() {\n        return Math.sqrt(this.magnitudeSquared());\n    }\n    magnitudeSquared() {\n        return this.x * this.x + this.y * this.y + this.z * this.z;\n    }\n    squareDistanceTo(p) {\n        const dx = this.x - p.x;\n        const dy = this.y - p.y;\n        const dz = this.z - p.z;\n        return dx * dx + dy * dy + dz * dz;\n    }\n    distanceTo(p) {\n        return Math.sqrt(this.squareDistanceTo(p));\n    }\n    maximumEntryMagnitude() {\n        return Math.max(Math.abs(this.x), Math.max(Math.abs(this.y), Math.abs(this.z)));\n    }\n    angle() {\n        return Math.atan2(this.y, this.x);\n    }\n    normalized() {\n        const norm = this.magnitude();\n        return Vec3.of(this.x / norm, this.y / norm, this.z / norm);\n    }\n    normalizedOrZero() {\n        if (this.eq(Vec3.zero)) {\n            return Vec3.zero;\n        }\n        return this.normalized();\n    }\n    times(c) {\n        return Vec3.of(this.x * c, this.y * c, this.z * c);\n    }\n    plus(v) {\n        return Vec3.of(this.x + v.x, this.y + v.y, this.z + v.z);\n    }\n    minus(v) {\n        return Vec3.of(this.x - v.x, this.y - v.y, this.z - v.z);\n    }\n    dot(other) {\n        return this.x * other.x + this.y * other.y + this.z * other.z;\n    }\n    cross(other) {\n        // | i  j  k |\n        // | x1 y1 z1| = (i)(y1z2 - y2z1) - (j)(x1z2 - x2z1) + (k)(x1y2 - x2y1)\n        // | x2 y2 z2|\n        return Vec3.of(this.y * other.z - other.y * this.z, other.x * this.z - this.x * other.z, this.x * other.y - other.x * this.y);\n    }\n    scale(other) {\n        if (typeof other === 'number') {\n            return this.times(other);\n        }\n        return Vec3.of(this.x * other.x, this.y * other.y, this.z * other.z);\n    }\n    orthog() {\n        // If parallel to the z-axis\n        if (this.dot(Vec3.unitX) === 0 && this.dot(Vec3.unitY) === 0) {\n            return this.dot(Vec3.unitX) === 0 ? Vec3.unitX : this.cross(Vec3.unitX).normalized();\n        }\n        return this.cross(Vec3.unitZ.times(-1)).normalized();\n    }\n    extend(distance, direction) {\n        return this.plus(direction.normalized().times(distance));\n    }\n    lerp(target, fractionTo) {\n        return this.times(1 - fractionTo).plus(target.times(fractionTo));\n    }\n    zip(other, zip) {\n        return Vec3.of(zip(other.x, this.x), zip(other.y, this.y), zip(other.z, this.z));\n    }\n    map(fn) {\n        return Vec3.of(fn(this.x, 0), fn(this.y, 1), fn(this.z, 2));\n    }\n    asArray() {\n        return [this.x, this.y, this.z];\n    }\n    eq(other, fuzz = defaultEqlTolerance) {\n        return (Math.abs(other.x - this.x) <= fuzz &&\n            Math.abs(other.y - this.y) <= fuzz &&\n            Math.abs(other.z - this.z) <= fuzz);\n    }\n    toString() {\n        return `Vec(${this.x}, ${this.y}, ${this.z})`;\n    }\n}\nclass Vec2Impl {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    get z() {\n        return 0;\n    }\n    get xy() {\n        // Useful for APIs that behave differently if .z is present.\n        return {\n            x: this.x,\n            y: this.y,\n        };\n    }\n    at(idx) {\n        if (idx === 0)\n            return this.x;\n        if (idx === 1)\n            return this.y;\n        if (idx === 2)\n            return 0;\n        throw new Error(`${idx} out of bounds!`);\n    }\n    length() {\n        return this.magnitude();\n    }\n    magnitude() {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n    }\n    magnitudeSquared() {\n        return this.x * this.x + this.y * this.y;\n    }\n    squareDistanceTo(p) {\n        const dx = this.x - p.x;\n        const dy = this.y - p.y;\n        return dx * dx + dy * dy + p.z * p.z;\n    }\n    distanceTo(p) {\n        return Math.sqrt(this.squareDistanceTo(p));\n    }\n    maximumEntryMagnitude() {\n        return Math.max(Math.abs(this.x), Math.abs(this.y));\n    }\n    angle() {\n        return Math.atan2(this.y, this.x);\n    }\n    normalized() {\n        const norm = this.magnitude();\n        return Vec2.of(this.x / norm, this.y / norm);\n    }\n    normalizedOrZero() {\n        if (this.eq(Vec3.zero)) {\n            return Vec3.zero;\n        }\n        return this.normalized();\n    }\n    times(c) {\n        return Vec2.of(this.x * c, this.y * c);\n    }\n    plus(v) {\n        return Vec3.of(this.x + v.x, this.y + v.y, v.z);\n    }\n    minus(v) {\n        return Vec3.of(this.x - v.x, this.y - v.y, -v.z);\n    }\n    dot(other) {\n        return this.x * other.x + this.y * other.y;\n    }\n    cross(other) {\n        // | i  j  k |\n        // | x1 y1 z1| = (i)(y1z2 - y2z1) - (j)(x1z2 - x2z1) + (k)(x1y2 - x2y1)\n        // | x2 y2 z2|\n        return Vec3.of(this.y * other.z, -this.x * other.z, this.x * other.y - other.x * this.y);\n    }\n    scale(other) {\n        if (typeof other === 'number') {\n            return this.times(other);\n        }\n        return Vec2.of(this.x * other.x, this.y * other.y);\n    }\n    orthog() {\n        // If parallel to the z-axis\n        if (this.dot(Vec3.unitX) === 0 && this.dot(Vec3.unitY) === 0) {\n            return this.dot(Vec3.unitX) === 0 ? Vec3.unitX : this.cross(Vec3.unitX).normalized();\n        }\n        return this.cross(Vec3.unitZ.times(-1)).normalized();\n    }\n    extend(distance, direction) {\n        return this.plus(direction.normalized().times(distance));\n    }\n    lerp(target, fractionTo) {\n        return this.times(1 - fractionTo).plus(target.times(fractionTo));\n    }\n    zip(other, zip) {\n        return Vec3.of(zip(other.x, this.x), zip(other.y, this.y), zip(other.z, 0));\n    }\n    map(fn) {\n        return Vec3.of(fn(this.x, 0), fn(this.y, 1), fn(0, 2));\n    }\n    asArray() {\n        return [this.x, this.y, 0];\n    }\n    eq(other, fuzz = defaultEqlTolerance) {\n        return (Math.abs(other.x - this.x) <= fuzz &&\n            Math.abs(other.y - this.y) <= fuzz &&\n            Math.abs(other.z) <= fuzz);\n    }\n    toString() {\n        return `Vec(${this.x}, ${this.y})`;\n    }\n}\n/**\n * A `Vec2` is a {@link Vec3} optimized for working in a plane. `Vec2`s have an\n * always-zero `z` component.\n *\n * ```ts,runnable,console\n * import { Vec2 } from '@js-draw/math';\n *\n * const v = Vec2.of(1, 2);\n * console.log('a Vec2:', v);\n * console.log('x component:', v.x);\n * console.log('z component:', v.z);\n * ```\n */\nvar Vec2;\n(function (Vec2) {\n    /**\n     * Creates a `Vec2` from an x and y coordinate.\n     *\n     * @example\n     * ```ts,runnable,console\n     * import { Vec2 } from '@js-draw/math';\n     * const v = Vec2.of(3, 4); // x=3, y=4.\n     * ```\n     */\n    Vec2.of = (x, y) => {\n        return new Vec2Impl(x, y);\n    };\n    /**\n     * Creates a `Vec2` from an object containing `x` and `y` coordinates.\n     *\n     * @example\n     * ```ts,runnable,console\n     * import { Vec2 } from '@js-draw/math';\n     * const v1 = Vec2.ofXY({ x: 3, y: 4.5 });\n     * const v2 = Vec2.ofXY({ x: -123.4, y: 1 });\n     * ```\n     */\n    Vec2.ofXY = ({ x, y }) => {\n        return Vec2.of(x, y);\n    };\n    /** A vector of length 1 in the X direction (→). */\n    Vec2.unitX = Vec2.of(1, 0);\n    /** A vector of length 1 in the Y direction (↑). */\n    Vec2.unitY = Vec2.of(0, 1);\n    /** The zero vector: A vector with x=0, y=0. */\n    Vec2.zero = Vec2.of(0, 0);\n})(Vec2 || (exports.Vec2 = Vec2 = {}));\n/** Contains static methods for constructing a {@link Vec3}. */\nvar Vec3;\n(function (Vec3) {\n    /**\n     * Construct a vector from three components.\n     *\n     * @example\n     * ```ts,runnable,console\n     * import { Vec3 } from '@js-draw/math';\n     * const v1 = Vec3.of(1, 2, 3);\n     * console.log(v1.plus(Vec3.of(0, 100, 0)));\n     * ```\n     */\n    Vec3.of = (x, y, z) => {\n        if (z === 0) {\n            return Vec2.of(x, y);\n        }\n        else {\n            return new Vec3Impl(x, y, z);\n        }\n    };\n    /** A unit vector in the x direction (`[1, 0, 0]`). */\n    Vec3.unitX = Vec2.unitX;\n    /** A unit vector in the y direction (`[0, 1, 0]`). */\n    Vec3.unitY = Vec2.unitY;\n    /** The zero vector (`[0, 0, 0]`). */\n    Vec3.zero = Vec2.zero;\n    /** A vector of length 1 in the z direction. */\n    Vec3.unitZ = Vec3.of(0, 0, 1);\n})(Vec3 || (exports.Vec3 = Vec3 = {}));\nexports[\"default\"] = Vec3;\n\n\n//# sourceURL=webpack://default/./node_modules/@js-draw/math/dist/cjs/Vec3.js?");

/***/ }),

/***/ "./node_modules/@js-draw/math/dist/cjs/lib.js":
/*!****************************************************!*\
  !*** ./node_modules/@js-draw/math/dist/cjs/lib.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * This package contains general math utilities used by `js-draw`.\n * These include 2D and 3D vectors, 2D paths, and 3x3 matrices.\n *\n * ```ts,runnable,console\n * import { Vec2, Mat33, Rect2 } from '@js-draw/math';\n *\n * // Example: Rotate a vector 90 degrees about the z-axis\n * const rotate90Degrees = Mat33.zRotation(Math.PI/2); // π/2 radians = 90 deg\n * const moveUp = Mat33.translation(Vec2.of(1, 0));\n * const moveUpThenRotate = rotate90Degrees.rightMul(moveUp);\n * console.log(moveUpThenRotate.transformVec2(Vec2.of(1, 2)));\n *\n * // Example: Bounding box of some points\n * console.log(Rect2.bboxOf([\n *   Vec2.of(1, 2), Vec2.of(3, 4), Vec2.of(-100, 1000),\n * ]));\n * ```\n *\n * @packageDocumentation\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Color4 = exports.Vec3 = exports.Vec2 = exports.Mat33 = exports.Abstract2DShape = exports.QuadraticBezier = exports.Parameterized2DShape = exports.Rect2 = exports.PathCommandType = exports.comparePathIndices = exports.stepPathIndexBy = exports.Path = exports.LineSegment2 = void 0;\nvar LineSegment2_1 = __webpack_require__(/*! ./shapes/LineSegment2 */ \"./node_modules/@js-draw/math/dist/cjs/shapes/LineSegment2.js\");\nObject.defineProperty(exports, \"LineSegment2\", ({ enumerable: true, get: function () { return LineSegment2_1.LineSegment2; } }));\nvar Path_1 = __webpack_require__(/*! ./shapes/Path */ \"./node_modules/@js-draw/math/dist/cjs/shapes/Path.js\");\nObject.defineProperty(exports, \"Path\", ({ enumerable: true, get: function () { return Path_1.Path; } }));\nObject.defineProperty(exports, \"stepPathIndexBy\", ({ enumerable: true, get: function () { return Path_1.stepCurveIndexBy; } }));\nObject.defineProperty(exports, \"comparePathIndices\", ({ enumerable: true, get: function () { return Path_1.compareCurveIndices; } }));\nObject.defineProperty(exports, \"PathCommandType\", ({ enumerable: true, get: function () { return Path_1.PathCommandType; } }));\nvar Rect2_1 = __webpack_require__(/*! ./shapes/Rect2 */ \"./node_modules/@js-draw/math/dist/cjs/shapes/Rect2.js\");\nObject.defineProperty(exports, \"Rect2\", ({ enumerable: true, get: function () { return Rect2_1.Rect2; } }));\nvar Parameterized2DShape_1 = __webpack_require__(/*! ./shapes/Parameterized2DShape */ \"./node_modules/@js-draw/math/dist/cjs/shapes/Parameterized2DShape.js\");\nObject.defineProperty(exports, \"Parameterized2DShape\", ({ enumerable: true, get: function () { return Parameterized2DShape_1.Parameterized2DShape; } }));\nvar QuadraticBezier_1 = __webpack_require__(/*! ./shapes/QuadraticBezier */ \"./node_modules/@js-draw/math/dist/cjs/shapes/QuadraticBezier.js\");\nObject.defineProperty(exports, \"QuadraticBezier\", ({ enumerable: true, get: function () { return QuadraticBezier_1.QuadraticBezier; } }));\nvar Abstract2DShape_1 = __webpack_require__(/*! ./shapes/Abstract2DShape */ \"./node_modules/@js-draw/math/dist/cjs/shapes/Abstract2DShape.js\");\nObject.defineProperty(exports, \"Abstract2DShape\", ({ enumerable: true, get: function () { return Abstract2DShape_1.Abstract2DShape; } }));\nvar Mat33_1 = __webpack_require__(/*! ./Mat33 */ \"./node_modules/@js-draw/math/dist/cjs/Mat33.js\");\nObject.defineProperty(exports, \"Mat33\", ({ enumerable: true, get: function () { return Mat33_1.Mat33; } }));\nvar Vec2_1 = __webpack_require__(/*! ./Vec2 */ \"./node_modules/@js-draw/math/dist/cjs/Vec2.js\");\nObject.defineProperty(exports, \"Vec2\", ({ enumerable: true, get: function () { return Vec2_1.Vec2; } }));\nvar Vec3_1 = __webpack_require__(/*! ./Vec3 */ \"./node_modules/@js-draw/math/dist/cjs/Vec3.js\");\nObject.defineProperty(exports, \"Vec3\", ({ enumerable: true, get: function () { return Vec3_1.Vec3; } }));\nvar Color4_1 = __webpack_require__(/*! ./Color4 */ \"./node_modules/@js-draw/math/dist/cjs/Color4.js\");\nObject.defineProperty(exports, \"Color4\", ({ enumerable: true, get: function () { return Color4_1.Color4; } }));\n__exportStar(__webpack_require__(/*! ./rounding/lib */ \"./node_modules/@js-draw/math/dist/cjs/rounding/lib.js\"), exports);\n// Note: All above exports cannot use `export { default as ... } from \"...\"` because this\n// breaks TypeDoc -- TypeDoc otherwise labels any imports of these classes as `default`.\n\n\n//# sourceURL=webpack://default/./node_modules/@js-draw/math/dist/cjs/lib.js?");

/***/ }),

/***/ "./node_modules/@js-draw/math/dist/cjs/polynomial/solveQuadratic.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@js-draw/math/dist/cjs/polynomial/solveQuadratic.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * Solves an equation of the form ax² + bx + c = 0.\n * The larger solution is returned first.\n *\n * If there are no solutions, returns `[NaN, NaN]`. If there is one solution,\n * repeats the solution twice in the result.\n */\nconst solveQuadratic = (a, b, c) => {\n    // See also https://en.wikipedia.org/wiki/Quadratic_formula\n    if (a === 0) {\n        let solution;\n        if (b === 0) {\n            solution = c === 0 ? 0 : NaN;\n        }\n        else {\n            // Then we have bx + c = 0\n            // which implies bx = -c.\n            // Thus, x = -c/b\n            solution = -c / b;\n        }\n        return [solution, solution];\n    }\n    const discriminant = b * b - 4 * a * c;\n    if (discriminant < 0) {\n        return [NaN, NaN];\n    }\n    const rootDiscriminant = Math.sqrt(discriminant);\n    const solution1 = (-b + rootDiscriminant) / (2 * a);\n    const solution2 = (-b - rootDiscriminant) / (2 * a);\n    if (solution1 > solution2) {\n        return [solution1, solution2];\n    }\n    else {\n        return [solution2, solution1];\n    }\n};\nexports[\"default\"] = solveQuadratic;\n\n\n//# sourceURL=webpack://default/./node_modules/@js-draw/math/dist/cjs/polynomial/solveQuadratic.js?");

/***/ }),

/***/ "./node_modules/@js-draw/math/dist/cjs/rounding/cleanUpNumber.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@js-draw/math/dist/cjs/rounding/cleanUpNumber.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.cleanUpNumber = void 0;\n/** Cleans up stringified numbers */\nconst cleanUpNumber = (text) => {\n    // Regular expression substitions can be somewhat expensive. Only do them\n    // if necessary.\n    if (text.indexOf('e') > 0) {\n        // Round to zero.\n        if (text.match(/[eE][-]\\d{2,}$/)) {\n            return '0';\n        }\n    }\n    const lastChar = text.charAt(text.length - 1);\n    if (lastChar === '0' || lastChar === '.') {\n        // Remove trailing zeroes\n        text = text.replace(/([.]\\d*[^0])0+$/, '$1');\n        text = text.replace(/[.]0+$/, '.');\n        // Remove trailing period\n        text = text.replace(/[.]$/, '');\n    }\n    const firstChar = text.charAt(0);\n    if (firstChar === '0' || firstChar === '-') {\n        // Remove unnecessary leading zeroes.\n        text = text.replace(/^(0+)[.]/, '.');\n        text = text.replace(/^-(0+)[.]/, '-.');\n        text = text.replace(/^(-?)0+$/, '$10');\n    }\n    if (text === '-0') {\n        return '0';\n    }\n    return text;\n};\nexports.cleanUpNumber = cleanUpNumber;\nexports[\"default\"] = exports.cleanUpNumber;\n\n\n//# sourceURL=webpack://default/./node_modules/@js-draw/math/dist/cjs/rounding/cleanUpNumber.js?");

/***/ }),

/***/ "./node_modules/@js-draw/math/dist/cjs/rounding/constants.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@js-draw/math/dist/cjs/rounding/constants.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.numberRegex = void 0;\nexports.numberRegex = /^([-]?)(\\d*)[.](\\d+)$/;\n\n\n//# sourceURL=webpack://default/./node_modules/@js-draw/math/dist/cjs/rounding/constants.js?");

/***/ }),

/***/ "./node_modules/@js-draw/math/dist/cjs/rounding/getLenAfterDecimal.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@js-draw/math/dist/cjs/rounding/getLenAfterDecimal.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getLenAfterDecimal = void 0;\nconst constants_1 = __webpack_require__(/*! ./constants */ \"./node_modules/@js-draw/math/dist/cjs/rounding/constants.js\");\n/**\n * Returns the length of `numberAsString` after a decimal point.\n *\n * For example,\n * ```ts\n * getLenAfterDecimal('1.001') // -> 3\n * ```\n */\nconst getLenAfterDecimal = (numberAsString) => {\n    const numberMatch = constants_1.numberRegex.exec(numberAsString);\n    if (!numberMatch) {\n        // If not a match, either the number is exponential notation (or is something\n        // like NaN or Infinity)\n        if (numberAsString.search(/[eE]/) !== -1 || /^[a-zA-Z]+$/.exec(numberAsString)) {\n            return -1;\n            // Or it has no decimal point\n        }\n        else {\n            return 0;\n        }\n    }\n    const afterDecimalLen = numberMatch[3].length;\n    return afterDecimalLen;\n};\nexports.getLenAfterDecimal = getLenAfterDecimal;\nexports[\"default\"] = exports.getLenAfterDecimal;\n\n\n//# sourceURL=webpack://default/./node_modules/@js-draw/math/dist/cjs/rounding/getLenAfterDecimal.js?");

/***/ }),

/***/ "./node_modules/@js-draw/math/dist/cjs/rounding/lib.js":
/*!*************************************************************!*\
  !*** ./node_modules/@js-draw/math/dist/cjs/rounding/lib.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.toRoundedString = void 0;\nvar toRoundedString_1 = __webpack_require__(/*! ./toRoundedString */ \"./node_modules/@js-draw/math/dist/cjs/rounding/toRoundedString.js\");\nObject.defineProperty(exports, \"toRoundedString\", ({ enumerable: true, get: function () { return toRoundedString_1.toRoundedString; } }));\n\n\n//# sourceURL=webpack://default/./node_modules/@js-draw/math/dist/cjs/rounding/lib.js?");

/***/ }),

/***/ "./node_modules/@js-draw/math/dist/cjs/rounding/toRoundedString.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@js-draw/math/dist/cjs/rounding/toRoundedString.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.toRoundedString = void 0;\nconst cleanUpNumber_1 = __importDefault(__webpack_require__(/*! ./cleanUpNumber */ \"./node_modules/@js-draw/math/dist/cjs/rounding/cleanUpNumber.js\"));\n/**\n * Converts `num` to a string, removing trailing digits that were likely caused by\n * precision errors.\n *\n * @example\n * ```ts,runnable,console\n * import { toRoundedString } from '@js-draw/math';\n *\n * console.log('Rounded: ', toRoundedString(1.000000011));\n * ```\n */\nconst toRoundedString = (num) => {\n    // Try to remove rounding errors. If the number ends in at least three/four zeroes\n    // (or nines) just one or two digits, it's probably a rounding error.\n    const fixRoundingUpExp = /^([-]?\\d*\\.\\d{3,})0{4,}\\d{1,4}$/;\n    const hasRoundingDownExp = /^([-]?)(\\d*)\\.(\\d{3,}9{4,})\\d{1,4}$/;\n    let text = num.toString(10);\n    if (text.indexOf('.') === -1) {\n        return text;\n    }\n    const roundingDownMatch = hasRoundingDownExp.exec(text);\n    if (roundingDownMatch) {\n        const negativeSign = roundingDownMatch[1];\n        const postDecimalString = roundingDownMatch[3];\n        const lastDigit = parseInt(postDecimalString.charAt(postDecimalString.length - 1), 10);\n        const postDecimal = parseInt(postDecimalString, 10);\n        const preDecimal = parseInt(roundingDownMatch[2], 10);\n        const origPostDecimalString = roundingDownMatch[3];\n        let newPostDecimal = (postDecimal + 10 - lastDigit).toString();\n        let carry = 0;\n        if (newPostDecimal.length > postDecimal.toString().length) {\n            // Left-shift\n            newPostDecimal = newPostDecimal.substring(1);\n            carry = 1;\n        }\n        // parseInt(...).toString() removes leading zeroes. Add them back.\n        while (newPostDecimal.length < origPostDecimalString.length) {\n            newPostDecimal = carry.toString(10) + newPostDecimal;\n            carry = 0;\n        }\n        text = `${negativeSign + (preDecimal + carry).toString()}.${newPostDecimal}`;\n    }\n    text = text.replace(fixRoundingUpExp, '$1');\n    return (0, cleanUpNumber_1.default)(text);\n};\nexports.toRoundedString = toRoundedString;\nexports[\"default\"] = exports.toRoundedString;\n\n\n//# sourceURL=webpack://default/./node_modules/@js-draw/math/dist/cjs/rounding/toRoundedString.js?");

/***/ }),

/***/ "./node_modules/@js-draw/math/dist/cjs/rounding/toStringOfSamePrecision.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@js-draw/math/dist/cjs/rounding/toStringOfSamePrecision.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.toStringOfSamePrecision = void 0;\nconst cleanUpNumber_1 = __importDefault(__webpack_require__(/*! ./cleanUpNumber */ \"./node_modules/@js-draw/math/dist/cjs/rounding/cleanUpNumber.js\"));\nconst constants_1 = __webpack_require__(/*! ./constants */ \"./node_modules/@js-draw/math/dist/cjs/rounding/constants.js\");\nconst getLenAfterDecimal_1 = __importDefault(__webpack_require__(/*! ./getLenAfterDecimal */ \"./node_modules/@js-draw/math/dist/cjs/rounding/getLenAfterDecimal.js\"));\nconst toRoundedString_1 = __importDefault(__webpack_require__(/*! ./toRoundedString */ \"./node_modules/@js-draw/math/dist/cjs/rounding/toRoundedString.js\"));\n// [reference] should be a string representation of a base-10 number (no exponential (e.g. 10e10))\nconst toStringOfSamePrecision = (num, ...references) => {\n    const text = num.toString(10);\n    const textMatch = constants_1.numberRegex.exec(text);\n    if (!textMatch) {\n        return text;\n    }\n    let decimalPlaces = -1;\n    for (const reference of references) {\n        decimalPlaces = Math.max((0, getLenAfterDecimal_1.default)(reference), decimalPlaces);\n    }\n    if (decimalPlaces === -1) {\n        return (0, toRoundedString_1.default)(num);\n    }\n    // Make text's after decimal length match [afterDecimalLen].\n    let postDecimal = textMatch[3].substring(0, decimalPlaces);\n    let preDecimal = textMatch[2];\n    const nextDigit = textMatch[3].charAt(decimalPlaces);\n    if (nextDigit !== '') {\n        const asNumber = parseInt(nextDigit, 10);\n        if (asNumber >= 5) {\n            // Don't attempt to parseInt() an empty string.\n            if (postDecimal.length > 0) {\n                const leadingZeroMatch = /^(0+)(\\d*)$/.exec(postDecimal);\n                let leadingZeroes = '';\n                let postLeading = postDecimal;\n                if (leadingZeroMatch) {\n                    leadingZeroes = leadingZeroMatch[1];\n                    postLeading = leadingZeroMatch[2];\n                }\n                postDecimal = (parseInt(postDecimal) + 1).toString();\n                // If postDecimal got longer, remove leading zeroes if possible\n                if (postDecimal.length > postLeading.length && leadingZeroes.length > 0) {\n                    leadingZeroes = leadingZeroes.substring(1);\n                }\n                postDecimal = leadingZeroes + postDecimal;\n            }\n            if (postDecimal.length === 0 || postDecimal.length > decimalPlaces) {\n                preDecimal = (parseInt(preDecimal) + 1).toString();\n                postDecimal = postDecimal.substring(1);\n            }\n        }\n    }\n    const negativeSign = textMatch[1];\n    return (0, cleanUpNumber_1.default)(`${negativeSign}${preDecimal}.${postDecimal}`);\n};\nexports.toStringOfSamePrecision = toStringOfSamePrecision;\nexports[\"default\"] = exports.toStringOfSamePrecision;\n\n\n//# sourceURL=webpack://default/./node_modules/@js-draw/math/dist/cjs/rounding/toStringOfSamePrecision.js?");

/***/ }),

/***/ "./node_modules/@js-draw/math/dist/cjs/shapes/Abstract2DShape.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@js-draw/math/dist/cjs/shapes/Abstract2DShape.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Abstract2DShape = void 0;\n/**\n * An abstract base class for 2D shapes.\n */\nclass Abstract2DShape {\n    /**\n     * @returns the distance from `point` to this shape. If `point` is within this shape,\n     * this returns the distance from `point` to the edge of this shape.\n     *\n     * @see {@link signedDistance}\n     */\n    distance(point) {\n        return Math.abs(this.signedDistance(point));\n    }\n    /**\n     * Returns `true` if and only if the given `point` is contained within this shape.\n     *\n     * `epsilon` is a small number used to counteract floating point error. Thus, if\n     * `point` is within `epsilon` of the inside of this shape, `containsPoint` may also\n     * return `true`.\n     *\n     * The default implementation relies on `signedDistance`.\n     * Subclasses may override this method to provide a more efficient implementation.\n     */\n    containsPoint(point, epsilon = Abstract2DShape.smallValue) {\n        return this.signedDistance(point) < epsilon;\n    }\n    /**\n     * Returns a bounding box that **loosely** fits the content of this shape.\n     *\n     * The result of this call can be larger than the result of {@link getTightBoundingBox},\n     * **but should not be smaller**. Thus, a call to `getLooseBoundingBox` can be significantly\n     * faster than a call to {@link getTightBoundingBox} for some shapes.\n     */\n    getLooseBoundingBox() {\n        return this.getTightBoundingBox();\n    }\n}\nexports.Abstract2DShape = Abstract2DShape;\n// @internal\nAbstract2DShape.smallValue = 1e-12;\nexports[\"default\"] = Abstract2DShape;\n\n\n//# sourceURL=webpack://default/./node_modules/@js-draw/math/dist/cjs/shapes/Abstract2DShape.js?");

/***/ }),

/***/ "./node_modules/@js-draw/math/dist/cjs/shapes/BezierJSWrapper.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@js-draw/math/dist/cjs/shapes/BezierJSWrapper.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar _BezierJSWrapper_bezierJs;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BezierJSWrapper = void 0;\nconst bezier_js_1 = __webpack_require__(/*! bezier-js */ \"./node_modules/bezier-js/dist/bezier.cjs\");\nconst Vec2_1 = __webpack_require__(/*! ../Vec2 */ \"./node_modules/@js-draw/math/dist/cjs/Vec2.js\");\nconst LineSegment2_1 = __importDefault(__webpack_require__(/*! ./LineSegment2 */ \"./node_modules/@js-draw/math/dist/cjs/shapes/LineSegment2.js\"));\nconst Rect2_1 = __importDefault(__webpack_require__(/*! ./Rect2 */ \"./node_modules/@js-draw/math/dist/cjs/shapes/Rect2.js\"));\nconst Parameterized2DShape_1 = __importDefault(__webpack_require__(/*! ./Parameterized2DShape */ \"./node_modules/@js-draw/math/dist/cjs/shapes/Parameterized2DShape.js\"));\n/**\n * A lazy-initializing wrapper around Bezier-js.\n *\n * Subclasses may override `at`, `derivativeAt`, and `normal` with functions\n * that do not initialize a `bezier-js` `Bezier`.\n *\n * **Do not use this class directly.** It may be removed/replaced in a future release.\n * @internal\n */\nclass BezierJSWrapper extends Parameterized2DShape_1.default {\n    constructor(bezierJsBezier) {\n        super();\n        _BezierJSWrapper_bezierJs.set(this, null);\n        if (bezierJsBezier) {\n            __classPrivateFieldSet(this, _BezierJSWrapper_bezierJs, bezierJsBezier, \"f\");\n        }\n    }\n    getBezier() {\n        if (!__classPrivateFieldGet(this, _BezierJSWrapper_bezierJs, \"f\")) {\n            __classPrivateFieldSet(this, _BezierJSWrapper_bezierJs, new bezier_js_1.Bezier(this.getPoints().map((p) => p.xy)), \"f\");\n        }\n        return __classPrivateFieldGet(this, _BezierJSWrapper_bezierJs, \"f\");\n    }\n    signedDistance(point) {\n        // .d: Distance\n        return this.nearestPointTo(point).point.distanceTo(point);\n    }\n    /**\n     * @returns the (more) exact distance from `point` to this.\n     *\n     * @see {@link approximateDistance}\n     */\n    distance(point) {\n        // A Bézier curve has no interior, thus, signed distance is the same as distance.\n        return this.signedDistance(point);\n    }\n    /**\n     * @returns the curve evaluated at `t`.\n     */\n    at(t) {\n        return Vec2_1.Vec2.ofXY(this.getBezier().get(t));\n    }\n    /** @returns the curve's directional derivative at `t`. */\n    derivativeAt(t) {\n        return Vec2_1.Vec2.ofXY(this.getBezier().derivative(t));\n    }\n    secondDerivativeAt(t) {\n        return Vec2_1.Vec2.ofXY(this.getBezier().dderivative(t));\n    }\n    /** @returns the [normal vector](https://en.wikipedia.org/wiki/Normal_(geometry)) to this curve at `t`. */\n    normal(t) {\n        return Vec2_1.Vec2.ofXY(this.getBezier().normal(t));\n    }\n    normalAt(t) {\n        return this.normal(t);\n    }\n    tangentAt(t) {\n        return this.derivativeAt(t).normalized();\n    }\n    getTightBoundingBox() {\n        const bbox = this.getBezier().bbox();\n        const width = bbox.x.max - bbox.x.min;\n        const height = bbox.y.max - bbox.y.min;\n        return new Rect2_1.default(bbox.x.min, bbox.y.min, width, height);\n    }\n    argIntersectsLineSegment(line) {\n        // Bezier-js has a bug when all control points of a Bezier curve lie on\n        // a line. Our solution involves converting the Bezier into a line, then\n        // finding the parameter value that produced the intersection.\n        //\n        // TODO: This is unnecessarily slow. A better solution would be to fix\n        // the bug upstream.\n        const asLine = LineSegment2_1.default.ofSmallestContainingPoints(this.getPoints());\n        if (asLine) {\n            const intersection = asLine.intersectsLineSegment(line);\n            return intersection.map((p) => this.nearestPointTo(p).parameterValue);\n        }\n        const bezier = this.getBezier();\n        return bezier\n            .intersects(line)\n            .map((t) => {\n            // We're using the .intersects(line) function, which is documented\n            // to always return numbers. However, to satisfy the type checker (and\n            // possibly improperly-defined types),\n            if (typeof t === 'string') {\n                t = parseFloat(t);\n            }\n            const point = Vec2_1.Vec2.ofXY(this.at(t));\n            // Ensure that the intersection is on the line segment\n            if (point.distanceTo(line.p1) > line.length || point.distanceTo(line.p2) > line.length) {\n                return null;\n            }\n            return t;\n        })\n            .filter((entry) => entry !== null);\n    }\n    splitAt(t) {\n        if (t <= 0 || t >= 1) {\n            return [this];\n        }\n        const bezier = this.getBezier();\n        const split = bezier.split(t);\n        return [\n            new BezierJSWrapperImpl(split.left.points.map((point) => Vec2_1.Vec2.ofXY(point)), split.left),\n            new BezierJSWrapperImpl(split.right.points.map((point) => Vec2_1.Vec2.ofXY(point)), split.right),\n        ];\n    }\n    nearestPointTo(point) {\n        // One implementation could be similar to this:\n        //   const projection = this.getBezier().project(point);\n        //   return {\n        //    point: Vec2.ofXY(projection),\n        //    parameterValue: projection.t!,\n        //   };\n        // However, Bezier-js is rather impercise (and relies on a lookup table).\n        // Thus, we instead use Newton's Method:\n        // We want to find t such that f(t) = |B(t) - p|² is minimized.\n        // Expanding,\n        //   f(t)  = (Bₓ(t) - pₓ)² + (Bᵧ(t) - pᵧ)²\n        // ⇒ f'(t) = Dₜ(Bₓ(t) - pₓ)² + Dₜ(Bᵧ(t) - pᵧ)²\n        // ⇒ f'(t) = 2(Bₓ(t) - pₓ)(Bₓ'(t)) + 2(Bᵧ(t) - pᵧ)(Bᵧ'(t))\n        //         = 2Bₓ(t)Bₓ'(t) - 2pₓBₓ'(t) + 2Bᵧ(t)Bᵧ'(t) - 2pᵧBᵧ'(t)\n        // ⇒ f''(t)= 2Bₓ'(t)Bₓ'(t) + 2Bₓ(t)Bₓ''(t) - 2pₓBₓ''(t) + 2Bᵧ'(t)Bᵧ'(t)\n        //         + 2Bᵧ(t)Bᵧ''(t) - 2pᵧBᵧ''(t)\n        // Because f'(t) = 0 at relative extrema, we can use Newton's Method\n        // to improve on an initial guess.\n        const sqrDistAt = (t) => point.squareDistanceTo(this.at(t));\n        const yIntercept = sqrDistAt(0);\n        let t = 0;\n        let minSqrDist = yIntercept;\n        // Start by testing a few points:\n        const pointsToTest = 4;\n        for (let i = 0; i < pointsToTest; i++) {\n            const testT = i / (pointsToTest - 1);\n            const testMinSqrDist = sqrDistAt(testT);\n            if (testMinSqrDist < minSqrDist) {\n                t = testT;\n                minSqrDist = testMinSqrDist;\n            }\n        }\n        // To use Newton's Method, we need to evaluate the second derivative of the distance\n        // function:\n        const secondDerivativeAt = (t) => {\n            // f''(t) = 2Bₓ'(t)Bₓ'(t) + 2Bₓ(t)Bₓ''(t) - 2pₓBₓ''(t)\n            //        + 2Bᵧ'(t)Bᵧ'(t) + 2Bᵧ(t)Bᵧ''(t) - 2pᵧBᵧ''(t)\n            const b = this.at(t);\n            const bPrime = this.derivativeAt(t);\n            const bPrimePrime = this.secondDerivativeAt(t);\n            return (2 * bPrime.x * bPrime.x +\n                2 * b.x * bPrimePrime.x -\n                2 * point.x * bPrimePrime.x +\n                2 * bPrime.y * bPrime.y +\n                2 * b.y * bPrimePrime.y -\n                2 * point.y * bPrimePrime.y);\n        };\n        // Because we're zeroing f'(t), we also need to be able to compute it:\n        const derivativeAt = (t) => {\n            // f'(t) = 2Bₓ(t)Bₓ'(t) - 2pₓBₓ'(t) + 2Bᵧ(t)Bᵧ'(t) - 2pᵧBᵧ'(t)\n            const b = this.at(t);\n            const bPrime = this.derivativeAt(t);\n            return (2 * b.x * bPrime.x - 2 * point.x * bPrime.x + 2 * b.y * bPrime.y - 2 * point.y * bPrime.y);\n        };\n        const iterate = () => {\n            const slope = secondDerivativeAt(t);\n            if (slope === 0)\n                return;\n            // We intersect a line through the point on f'(t) at t with the x-axis:\n            //    y = m(x - x₀) + y₀\n            // ⇒  x - x₀ = (y - y₀) / m\n            // ⇒  x = (y - y₀) / m + x₀\n            //\n            // Thus, when zeroed,\n            //   tN = (0 - f'(t)) / m + t\n            const newT = (0 - derivativeAt(t)) / slope + t;\n            //const distDiff = sqrDistAt(newT) - sqrDistAt(t);\n            //console.assert(distDiff <= 0, `${-distDiff} >= 0`);\n            t = newT;\n            if (t > 1) {\n                t = 1;\n            }\n            else if (t < 0) {\n                t = 0;\n            }\n        };\n        for (let i = 0; i < 12; i++) {\n            iterate();\n        }\n        return { parameterValue: t, point: this.at(t) };\n    }\n    intersectsBezier(other) {\n        const intersections = this.getBezier().intersects(other.getBezier());\n        if (!intersections || intersections.length === 0) {\n            return [];\n        }\n        const result = [];\n        for (const intersection of intersections) {\n            // From http://pomax.github.io/bezierjs/#intersect-curve,\n            // .intersects returns an array of 't1/t2' pairs, where curve1.at(t1) gives the point.\n            const match = /^([-0-9.eE]+)\\/([-0-9.eE]+)$/.exec(intersection);\n            if (!match) {\n                throw new Error(`Incorrect format returned by .intersects: ${intersections} should be array of \"number/number\"!`);\n            }\n            const t = parseFloat(match[1]);\n            result.push({\n                parameterValue: t,\n                point: this.at(t),\n            });\n        }\n        return result;\n    }\n    toString() {\n        return `Bézier(${this.getPoints()\n            .map((point) => point.toString())\n            .join(', ')})`;\n    }\n}\nexports.BezierJSWrapper = BezierJSWrapper;\n_BezierJSWrapper_bezierJs = new WeakMap();\n/**\n * Private concrete implementation of `BezierJSWrapper`, used by methods above that need to return a wrapper\n * around a `Bezier`.\n */\nclass BezierJSWrapperImpl extends BezierJSWrapper {\n    constructor(controlPoints, curve) {\n        super(curve);\n        this.controlPoints = controlPoints;\n    }\n    getPoints() {\n        return this.controlPoints;\n    }\n}\nexports[\"default\"] = BezierJSWrapper;\n\n\n//# sourceURL=webpack://default/./node_modules/@js-draw/math/dist/cjs/shapes/BezierJSWrapper.js?");

/***/ }),

/***/ "./node_modules/@js-draw/math/dist/cjs/shapes/CubicBezier.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@js-draw/math/dist/cjs/shapes/CubicBezier.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst BezierJSWrapper_1 = __importDefault(__webpack_require__(/*! ./BezierJSWrapper */ \"./node_modules/@js-draw/math/dist/cjs/shapes/BezierJSWrapper.js\"));\nconst Rect2_1 = __importDefault(__webpack_require__(/*! ./Rect2 */ \"./node_modules/@js-draw/math/dist/cjs/shapes/Rect2.js\"));\n/**\n * A wrapper around [`bezier-js`](https://github.com/Pomax/bezierjs)'s cubic Bezier.\n */\nclass CubicBezier extends BezierJSWrapper_1.default {\n    constructor(\n    // Start point\n    p0, \n    // Control point 1\n    p1, \n    // Control point 2\n    p2, \n    // End point\n    p3) {\n        super();\n        this.p0 = p0;\n        this.p1 = p1;\n        this.p2 = p2;\n        this.p3 = p3;\n    }\n    getPoints() {\n        return [this.p0, this.p1, this.p2, this.p3];\n    }\n    /** Returns an overestimate of this shape's bounding box. */\n    getLooseBoundingBox() {\n        return Rect2_1.default.bboxOf([this.p0, this.p1, this.p2, this.p3]);\n    }\n}\nexports[\"default\"] = CubicBezier;\n\n\n//# sourceURL=webpack://default/./node_modules/@js-draw/math/dist/cjs/shapes/CubicBezier.js?");

/***/ }),

/***/ "./node_modules/@js-draw/math/dist/cjs/shapes/LineSegment2.js":
/*!********************************************************************!*\
  !*** ./node_modules/@js-draw/math/dist/cjs/shapes/LineSegment2.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LineSegment2 = void 0;\nconst Rect2_1 = __importDefault(__webpack_require__(/*! ./Rect2 */ \"./node_modules/@js-draw/math/dist/cjs/shapes/Rect2.js\"));\nconst Vec2_1 = __webpack_require__(/*! ../Vec2 */ \"./node_modules/@js-draw/math/dist/cjs/Vec2.js\");\nconst Parameterized2DShape_1 = __importDefault(__webpack_require__(/*! ./Parameterized2DShape */ \"./node_modules/@js-draw/math/dist/cjs/shapes/Parameterized2DShape.js\"));\n/**\n * Represents a line segment. A `LineSegment2` is immutable.\n *\n * @example\n * ```ts,runnable,console\n * import {LineSegment2, Vec2} from '@js-draw/math';\n * const l = new LineSegment2(Vec2.of(1, 1), Vec2.of(2, 2));\n * console.log('length: ', l.length);\n * console.log('direction: ', l.direction);\n * console.log('bounding box: ', l.bbox);\n * ```\n */\nclass LineSegment2 extends Parameterized2DShape_1.default {\n    /** Creates a new `LineSegment2` from its endpoints. */\n    constructor(point1, point2) {\n        super();\n        this.point1 = point1;\n        this.point2 = point2;\n        this.bbox = Rect2_1.default.bboxOf([point1, point2]);\n        this.direction = point2.minus(point1);\n        this.length = this.direction.magnitude();\n        // Normalize\n        if (this.length > 0) {\n            this.direction = this.direction.times(1 / this.length);\n        }\n    }\n    /**\n     * Returns the smallest line segment that contains all points in `points`, or `null`\n     * if no such line segment exists.\n     *\n     * @example\n     * ```ts,runnable,console\n     * import {LineSegment2, Vec2} from '@js-draw/math';\n     * console.log(LineSegment2.ofSmallestContainingPoints([Vec2.of(1, 0), Vec2.of(0, 1)]));\n     * ```\n     */\n    static ofSmallestContainingPoints(points) {\n        if (points.length <= 1)\n            return null;\n        const sorted = [...points].sort((a, b) => (a.x !== b.x ? a.x - b.x : a.y - b.y));\n        const line = new LineSegment2(sorted[0], sorted[sorted.length - 1]);\n        for (const point of sorted) {\n            if (!line.containsPoint(point)) {\n                return null;\n            }\n        }\n        return line;\n    }\n    // Accessors to make LineSegment2 compatible with bezier-js's\n    // interface\n    /** Alias for `point1`. */\n    get p1() {\n        return this.point1;\n    }\n    /** Alias for `point2`. */\n    get p2() {\n        return this.point2;\n    }\n    get center() {\n        return this.point1.lerp(this.point2, 0.5);\n    }\n    /**\n     * Gets a point a **distance** `t` along this line.\n     *\n     * @deprecated\n     */\n    get(t) {\n        return this.point1.plus(this.direction.times(t));\n    }\n    /**\n     * Returns a point a fraction, `t`, along this line segment.\n     * Thus, `segment.at(0)` returns `segment.p1` and `segment.at(1)` returns\n     * `segment.p2`.\n     *\n     * `t` should be in `[0, 1]`.\n     */\n    at(t) {\n        return this.get(t * this.length);\n    }\n    normalAt(_t) {\n        return this.direction.orthog();\n    }\n    tangentAt(_t) {\n        return this.direction;\n    }\n    splitAt(t) {\n        if (t <= 0 || t >= 1) {\n            return [this];\n        }\n        return [new LineSegment2(this.point1, this.at(t)), new LineSegment2(this.at(t), this.point2)];\n    }\n    /**\n     * Returns the intersection of this with another line segment.\n     *\n     * **WARNING**: The parameter value returned by this method does not range from 0 to 1 and\n     *              is currently a length.\n     *              This will change in a future release.\n     * @deprecated\n     */\n    intersection(other) {\n        // TODO(v2.0.0): Make this return a `t` value from `0` to `1`.\n        // We want x₁(t) = x₂(t) and y₁(t) = y₂(t)\n        // Observe that\n        // x = this.point1.x + this.direction.x · t₁\n        //   = other.point1.x + other.direction.x · t₂\n        // Thus,\n        //  t₁ = (x - this.point1.x) / this.direction.x\n        //     = (y - this.point1.y) / this.direction.y\n        // and\n        //  t₂ = (x - other.point1.x) / other.direction.x\n        // (and similarly for y)\n        //\n        // Letting o₁ₓ = this.point1.x, o₂ₓ = other.point1.x,\n        //         d₁ᵧ = this.direction.y, ...\n        //\n        // We can substitute these into the equations for y:\n        // y = o₁ᵧ + d₁ᵧ · (x - o₁ₓ) / d₁ₓ\n        //   = o₂ᵧ + d₂ᵧ · (x - o₂ₓ) / d₂ₓ\n        // ⇒ o₁ᵧ - o₂ᵧ = d₂ᵧ · (x - o₂ₓ) / d₂ₓ - d₁ᵧ · (x - o₁ₓ) / d₁ₓ\n        //            = (d₂ᵧ/d₂ₓ)(x) - (d₂ᵧ/d₂ₓ)(o₂ₓ) - (d₁ᵧ/d₁ₓ)(x) + (d₁ᵧ/d₁ₓ)(o₁ₓ)\n        //            = (x)(d₂ᵧ/d₂ₓ - d₁ᵧ/d₁ₓ) - (d₂ᵧ/d₂ₓ)(o₂ₓ) + (d₁ᵧ/d₁ₓ)(o₁ₓ)\n        // ⇒ (x)(d₂ᵧ/d₂ₓ - d₁ᵧ/d₁ₓ) = o₁ᵧ - o₂ᵧ + (d₂ᵧ/d₂ₓ)(o₂ₓ) - (d₁ᵧ/d₁ₓ)(o₁ₓ)\n        // ⇒ x = (o₁ᵧ - o₂ᵧ + (d₂ᵧ/d₂ₓ)(o₂ₓ) - (d₁ᵧ/d₁ₓ)(o₁ₓ))/(d₂ᵧ/d₂ₓ - d₁ᵧ/d₁ₓ)\n        //     = (d₁ₓd₂ₓ)(o₁ᵧ - o₂ᵧ + (d₂ᵧ/d₂ₓ)(o₂ₓ) - (d₁ᵧ/d₁ₓ)(o₁ₓ))/(d₂ᵧd₁ₓ - d₁ᵧd₂ₓ)\n        //     = ((o₁ᵧ - o₂ᵧ)((d₁ₓd₂ₓ)) + (d₂ᵧd₁ₓ)(o₂ₓ) - (d₁ᵧd₂ₓ)(o₁ₓ))/(d₂ᵧd₁ₓ - d₁ᵧd₂ₓ)\n        // ⇒ y = o₁ᵧ + d₁ᵧ · (x - o₁ₓ) / d₁ₓ = ...\n        let resultPoint, resultT;\n        // Consider very-near-vertical lines to be vertical --- not doing so can lead to\n        // precision error when dividing by this.direction.x.\n        const small = 4e-13;\n        if (Math.abs(this.direction.x) < small) {\n            // Vertical line: Where does the other have x = this.point1.x?\n            // x = o₁ₓ = o₂ₓ + d₂ₓ · (y - o₂ᵧ) / d₂ᵧ\n            // ⇒ (o₁ₓ - o₂ₓ)(d₂ᵧ/d₂ₓ) + o₂ᵧ = y\n            // Avoid division by zero\n            if (other.direction.x === 0 || this.direction.y === 0) {\n                return null;\n            }\n            const xIntersect = this.point1.x;\n            const yIntersect = ((this.point1.x - other.point1.x) * other.direction.y) / other.direction.x + other.point1.y;\n            resultPoint = Vec2_1.Vec2.of(xIntersect, yIntersect);\n            resultT = (yIntersect - this.point1.y) / this.direction.y;\n        }\n        else {\n            // From above,\n            // x = ((o₁ᵧ - o₂ᵧ)(d₁ₓd₂ₓ) + (d₂ᵧd₁ₓ)(o₂ₓ) - (d₁ᵧd₂ₓ)(o₁ₓ))/(d₂ᵧd₁ₓ - d₁ᵧd₂ₓ)\n            const numerator = (this.point1.y - other.point1.y) * this.direction.x * other.direction.x +\n                this.direction.x * other.direction.y * other.point1.x -\n                this.direction.y * other.direction.x * this.point1.x;\n            const denominator = other.direction.y * this.direction.x - this.direction.y * other.direction.x;\n            // Avoid dividing by zero. It means there is no intersection\n            if (denominator === 0) {\n                return null;\n            }\n            const xIntersect = numerator / denominator;\n            const t1 = (xIntersect - this.point1.x) / this.direction.x;\n            const yIntersect = this.point1.y + this.direction.y * t1;\n            resultPoint = Vec2_1.Vec2.of(xIntersect, yIntersect);\n            resultT = (xIntersect - this.point1.x) / this.direction.x;\n        }\n        // Ensure the result is in this/the other segment.\n        const resultToP1 = resultPoint.distanceTo(this.point1);\n        const resultToP2 = resultPoint.distanceTo(this.point2);\n        const resultToP3 = resultPoint.distanceTo(other.point1);\n        const resultToP4 = resultPoint.distanceTo(other.point2);\n        if (resultToP1 > this.length ||\n            resultToP2 > this.length ||\n            resultToP3 > other.length ||\n            resultToP4 > other.length) {\n            return null;\n        }\n        return {\n            point: resultPoint,\n            t: resultT,\n        };\n    }\n    intersects(other) {\n        return this.intersection(other) !== null;\n    }\n    argIntersectsLineSegment(lineSegment) {\n        const intersection = this.intersection(lineSegment);\n        if (intersection) {\n            return [intersection.t / this.length];\n        }\n        return [];\n    }\n    /**\n     * Returns the points at which this line segment intersects the\n     * given line segment.\n     *\n     * Note that {@link intersects} returns *whether* this line segment intersects another\n     * line segment. This method, by contrast, returns **the point** at which the intersection\n     * occurs, if such a point exists.\n     */\n    intersectsLineSegment(lineSegment) {\n        const intersection = this.intersection(lineSegment);\n        if (intersection) {\n            return [intersection.point];\n        }\n        return [];\n    }\n    // Returns the closest point on this to [target]\n    closestPointTo(target) {\n        return this.nearestPointTo(target).point;\n    }\n    nearestPointTo(target) {\n        // Distance from P1 along this' direction.\n        const projectedDistFromP1 = target.minus(this.p1).dot(this.direction);\n        const projectedDistFromP2 = this.length - projectedDistFromP1;\n        const projection = this.p1.plus(this.direction.times(projectedDistFromP1));\n        if (projectedDistFromP1 > 0 && projectedDistFromP1 < this.length) {\n            return { point: projection, parameterValue: projectedDistFromP1 / this.length };\n        }\n        if (Math.abs(projectedDistFromP2) < Math.abs(projectedDistFromP1)) {\n            return { point: this.p2, parameterValue: 1 };\n        }\n        else {\n            return { point: this.p1, parameterValue: 0 };\n        }\n    }\n    /**\n     * Returns the distance from this line segment to `target`.\n     *\n     * Because a line segment has no interior, this signed distance is equivalent to\n     * the full distance between `target` and this line segment.\n     */\n    signedDistance(target) {\n        return this.closestPointTo(target).minus(target).magnitude();\n    }\n    /** Returns a copy of this line segment transformed by the given `affineTransfm`. */\n    transformedBy(affineTransfm) {\n        return new LineSegment2(affineTransfm.transformVec2(this.p1), affineTransfm.transformVec2(this.p2));\n    }\n    /** @inheritdoc */\n    getTightBoundingBox() {\n        return this.bbox;\n    }\n    toString() {\n        return `LineSegment(${this.p1.toString()}, ${this.p2.toString()})`;\n    }\n    /**\n     * Returns `true` iff this is equivalent to `other`.\n     *\n     * **Options**:\n     * - `tolerance`: The maximum difference between endpoints. (Default: 0)\n     * - `ignoreDirection`: Allow matching a version of `this` with opposite direction. (Default: `true`)\n     */\n    eq(other, options) {\n        if (!(other instanceof LineSegment2)) {\n            return false;\n        }\n        const tolerance = options?.tolerance;\n        const ignoreDirection = options?.ignoreDirection ?? true;\n        return ((other.p1.eq(this.p1, tolerance) && other.p2.eq(this.p2, tolerance)) ||\n            (ignoreDirection && other.p1.eq(this.p2, tolerance) && other.p2.eq(this.p1, tolerance)));\n    }\n}\nexports.LineSegment2 = LineSegment2;\nexports[\"default\"] = LineSegment2;\n\n\n//# sourceURL=webpack://default/./node_modules/@js-draw/math/dist/cjs/shapes/LineSegment2.js?");

/***/ }),

/***/ "./node_modules/@js-draw/math/dist/cjs/shapes/Parameterized2DShape.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@js-draw/math/dist/cjs/shapes/Parameterized2DShape.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Parameterized2DShape = void 0;\nconst Abstract2DShape_1 = __importDefault(__webpack_require__(/*! ./Abstract2DShape */ \"./node_modules/@js-draw/math/dist/cjs/shapes/Abstract2DShape.js\"));\n/**\n * A 2-dimensional path with parameter interval $t \\in [0, 1]$.\n *\n * **Note:** Avoid extending this class outside of `js-draw` --- new abstract methods\n * may be added between minor versions.\n */\nclass Parameterized2DShape extends Abstract2DShape_1.default {\n    intersectsLineSegment(line) {\n        return this.argIntersectsLineSegment(line).map((t) => this.at(t));\n    }\n}\nexports.Parameterized2DShape = Parameterized2DShape;\nexports[\"default\"] = Parameterized2DShape;\n\n\n//# sourceURL=webpack://default/./node_modules/@js-draw/math/dist/cjs/shapes/Parameterized2DShape.js?");

/***/ }),

/***/ "./node_modules/@js-draw/math/dist/cjs/shapes/Path.js":
/*!************************************************************!*\
  !*** ./node_modules/@js-draw/math/dist/cjs/shapes/Path.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Path = exports.stepCurveIndexBy = exports.compareCurveIndices = exports.PathCommandType = void 0;\nconst LineSegment2_1 = __importDefault(__webpack_require__(/*! ./LineSegment2 */ \"./node_modules/@js-draw/math/dist/cjs/shapes/LineSegment2.js\"));\nconst Rect2_1 = __importDefault(__webpack_require__(/*! ./Rect2 */ \"./node_modules/@js-draw/math/dist/cjs/shapes/Rect2.js\"));\nconst Vec2_1 = __webpack_require__(/*! ../Vec2 */ \"./node_modules/@js-draw/math/dist/cjs/Vec2.js\");\nconst CubicBezier_1 = __importDefault(__webpack_require__(/*! ./CubicBezier */ \"./node_modules/@js-draw/math/dist/cjs/shapes/CubicBezier.js\"));\nconst QuadraticBezier_1 = __importDefault(__webpack_require__(/*! ./QuadraticBezier */ \"./node_modules/@js-draw/math/dist/cjs/shapes/QuadraticBezier.js\"));\nconst PointShape2D_1 = __importDefault(__webpack_require__(/*! ./PointShape2D */ \"./node_modules/@js-draw/math/dist/cjs/shapes/PointShape2D.js\"));\nconst toRoundedString_1 = __importDefault(__webpack_require__(/*! ../rounding/toRoundedString */ \"./node_modules/@js-draw/math/dist/cjs/rounding/toRoundedString.js\"));\nconst toStringOfSamePrecision_1 = __importDefault(__webpack_require__(/*! ../rounding/toStringOfSamePrecision */ \"./node_modules/@js-draw/math/dist/cjs/rounding/toStringOfSamePrecision.js\"));\nconst convexHull2Of_1 = __importDefault(__webpack_require__(/*! ../utils/convexHull2Of */ \"./node_modules/@js-draw/math/dist/cjs/utils/convexHull2Of.js\"));\n/** Identifiers for different path commands. These commands can make up a {@link Path}. */\nvar PathCommandType;\n(function (PathCommandType) {\n    PathCommandType[PathCommandType[\"LineTo\"] = 0] = \"LineTo\";\n    PathCommandType[PathCommandType[\"MoveTo\"] = 1] = \"MoveTo\";\n    PathCommandType[PathCommandType[\"CubicBezierTo\"] = 2] = \"CubicBezierTo\";\n    PathCommandType[PathCommandType[\"QuadraticBezierTo\"] = 3] = \"QuadraticBezierTo\";\n})(PathCommandType || (exports.PathCommandType = PathCommandType = {}));\n/** Returns a positive number if `a` comes after `b`, 0 if equal, and negative otherwise. */\nconst compareCurveIndices = (a, b) => {\n    const indexCompare = a.curveIndex - b.curveIndex;\n    if (indexCompare === 0) {\n        return a.parameterValue - b.parameterValue;\n    }\n    else {\n        return indexCompare;\n    }\n};\nexports.compareCurveIndices = compareCurveIndices;\n/**\n * Returns a version of `index` with its parameter value incremented by `stepBy`\n * (which can be either positive or negative).\n */\nconst stepCurveIndexBy = (index, stepBy) => {\n    if (index.parameterValue + stepBy > 1) {\n        return { curveIndex: index.curveIndex + 1, parameterValue: index.parameterValue + stepBy - 1 };\n    }\n    if (index.parameterValue + stepBy < 0) {\n        if (index.curveIndex === 0) {\n            return { curveIndex: 0, parameterValue: 0 };\n        }\n        return { curveIndex: index.curveIndex - 1, parameterValue: index.parameterValue + stepBy + 1 };\n    }\n    return { curveIndex: index.curveIndex, parameterValue: index.parameterValue + stepBy };\n};\nexports.stepCurveIndexBy = stepCurveIndexBy;\n/**\n * Represents a union of lines and curves.\n *\n * To create a path from a string, see {@link fromString}.\n *\n * @example\n * ```ts,runnable,console\n * import {Path, Mat33, Vec2, LineSegment2} from '@js-draw/math';\n *\n * // Creates a path from an SVG path string.\n * // In this case,\n * // 1. Move to (0,0)\n * // 2. Line to (100,0)\n * const path = Path.fromString('M0,0 L100,0');\n *\n * // Logs the distance from (10,0) to the curve 1 unit\n * // away from path. This curve forms a stroke with the path at\n * // its center.\n * const strokeRadius = 1;\n * console.log(path.signedDistance(Vec2.of(10,0), strokeRadius));\n *\n * // Log a version of the path that's scaled by a factor of 4.\n * console.log(path.transformedBy(Mat33.scaling2D(4)).toString());\n *\n * // Log all intersections of a stroked version of the path with\n * // a vertical line segment.\n * // (Try removing the `strokeRadius` parameter).\n * const segment = new LineSegment2(Vec2.of(5, -100), Vec2.of(5, 100));\n * console.log(path.intersection(segment, strokeRadius).map(i => i.point));\n * ```\n */\nclass Path {\n    /**\n     * Creates a new `Path` that starts at `startPoint` and is made up of the path commands,\n     * `parts`.\n     *\n     * See also {@link fromString}\n     */\n    constructor(startPoint, parts) {\n        this.startPoint = startPoint;\n        this.cachedGeometry = null;\n        this.cachedPolylineApproximation = null;\n        this.cachedStringVersion = null;\n        this.parts = parts;\n        // Initial bounding box contains one point: the start point.\n        this.bbox = Rect2_1.default.bboxOf([startPoint]);\n        // Convert into a representation of the geometry (cache for faster intersection\n        // calculation)\n        for (const part of this.parts) {\n            this.bbox = this.bbox.union(Path.computeBBoxForSegment(startPoint, part));\n        }\n    }\n    /**\n     * Computes and returns the full bounding box for this path.\n     *\n     * If a slight over-estimate of a path's bounding box is sufficient, use\n     * {@link bbox} instead.\n     */\n    getExactBBox() {\n        const bboxes = [];\n        for (const part of this.geometry) {\n            bboxes.push(part.getTightBoundingBox());\n        }\n        return Rect2_1.default.union(...bboxes);\n    }\n    // Lazy-loads and returns this path's geometry\n    get geometry() {\n        if (this.cachedGeometry) {\n            return this.cachedGeometry;\n        }\n        let startPoint = this.startPoint;\n        const geometry = [];\n        for (const part of this.parts) {\n            let exhaustivenessCheck;\n            switch (part.kind) {\n                case PathCommandType.CubicBezierTo:\n                    geometry.push(new CubicBezier_1.default(startPoint, part.controlPoint1, part.controlPoint2, part.endPoint));\n                    startPoint = part.endPoint;\n                    break;\n                case PathCommandType.QuadraticBezierTo:\n                    geometry.push(new QuadraticBezier_1.default(startPoint, part.controlPoint, part.endPoint));\n                    startPoint = part.endPoint;\n                    break;\n                case PathCommandType.LineTo:\n                    geometry.push(new LineSegment2_1.default(startPoint, part.point));\n                    startPoint = part.point;\n                    break;\n                case PathCommandType.MoveTo:\n                    geometry.push(new PointShape2D_1.default(part.point));\n                    startPoint = part.point;\n                    break;\n                default:\n                    exhaustivenessCheck = part;\n                    return exhaustivenessCheck;\n            }\n        }\n        this.cachedGeometry = geometry;\n        return this.cachedGeometry;\n    }\n    /**\n     * Iterates through the start/end points of each component in this path.\n     *\n     * If a start point is equivalent to the end point of the previous segment,\n     * the point is **not** emitted twice.\n     */\n    *startEndPoints() {\n        yield this.startPoint;\n        for (const part of this.parts) {\n            let exhaustivenessCheck;\n            switch (part.kind) {\n                case PathCommandType.CubicBezierTo:\n                    yield part.endPoint;\n                    break;\n                case PathCommandType.QuadraticBezierTo:\n                    yield part.endPoint;\n                    break;\n                case PathCommandType.LineTo:\n                    yield part.point;\n                    break;\n                case PathCommandType.MoveTo:\n                    yield part.point;\n                    break;\n                default:\n                    exhaustivenessCheck = part;\n                    return exhaustivenessCheck;\n            }\n        }\n    }\n    // Approximates this path with a group of line segments.\n    polylineApproximation() {\n        if (this.cachedPolylineApproximation) {\n            return this.cachedPolylineApproximation;\n        }\n        const points = [];\n        for (const part of this.parts) {\n            switch (part.kind) {\n                case PathCommandType.CubicBezierTo:\n                    points.push(part.controlPoint1, part.controlPoint2, part.endPoint);\n                    break;\n                case PathCommandType.QuadraticBezierTo:\n                    points.push(part.controlPoint, part.endPoint);\n                    break;\n                case PathCommandType.MoveTo:\n                case PathCommandType.LineTo:\n                    points.push(part.point);\n                    break;\n            }\n        }\n        const result = [];\n        let prevPoint = this.startPoint;\n        for (const point of points) {\n            result.push(new LineSegment2_1.default(prevPoint, point));\n            prevPoint = point;\n        }\n        return result;\n    }\n    static computeBBoxForSegment(startPoint, part) {\n        const points = [startPoint];\n        let exhaustivenessCheck;\n        switch (part.kind) {\n            case PathCommandType.MoveTo:\n            case PathCommandType.LineTo:\n                points.push(part.point);\n                break;\n            case PathCommandType.CubicBezierTo:\n                points.push(part.controlPoint1, part.controlPoint2, part.endPoint);\n                break;\n            case PathCommandType.QuadraticBezierTo:\n                points.push(part.controlPoint, part.endPoint);\n                break;\n            default:\n                exhaustivenessCheck = part;\n                return exhaustivenessCheck;\n        }\n        return Rect2_1.default.bboxOf(points);\n    }\n    /**\n     * Returns the signed distance between `point` and a curve `strokeRadius` units\n     * away from this path.\n     *\n     * This returns the **signed distance**, which means that points inside this shape\n     * have their distance negated. For example,\n     * ```ts,runnable,console\n     * import {Path, Vec2} from '@js-draw/math';\n     * console.log(Path.fromString('m0,0 L100,0').signedDistance(Vec2.zero, 1));\n     * ```\n     * would print `-1` because (0,0) is on `m0,0 L100,0` and thus one unit away from its boundary.\n     *\n     * **Note**: `strokeRadius = strokeWidth / 2`\n     */\n    signedDistance(point, strokeRadius) {\n        let minDist = Infinity;\n        for (const part of this.geometry) {\n            const currentDist = part.signedDistance(point) - strokeRadius;\n            if (currentDist < minDist) {\n                minDist = currentDist;\n            }\n        }\n        return minDist;\n    }\n    /**\n     * Let `S` be a closed path a distance `strokeRadius` from this path.\n     *\n     * @returns Approximate intersections of `line` with `S` using ray marching, starting from\n     * \t        both end points of `line` and each point in `additionalRaymarchStartPoints`.\n     */\n    raymarchIntersectionWith(line, strokeRadius, additionalRaymarchStartPoints = []) {\n        // No intersection between bounding boxes: No possible intersection\n        // of the interior.\n        if (!line.bbox.intersects(this.bbox.grownBy(strokeRadius))) {\n            return [];\n        }\n        const lineLength = line.length;\n        const partDistFunctionRecords = [];\n        // Determine distance functions for all parts that the given line could possibly intersect with\n        for (const part of this.geometry) {\n            const bbox = part.getTightBoundingBox().grownBy(strokeRadius);\n            if (!bbox.intersects(line.bbox)) {\n                continue;\n            }\n            // Signed distance function\n            const partDist = (point) => part.signedDistance(point);\n            // Part signed distance function (negative result implies `point` is\n            // inside the shape).\n            const partSdf = (point) => partDist(point) - strokeRadius;\n            // If the line can't possibly intersect the part,\n            if (partSdf(line.p1) > lineLength && partSdf(line.p2) > lineLength) {\n                continue;\n            }\n            partDistFunctionRecords.push({\n                part,\n                distFn: partDist,\n                bbox,\n            });\n        }\n        // If no distance functions, there are no intersections.\n        if (partDistFunctionRecords.length === 0) {\n            return [];\n        }\n        // Returns the minimum distance to a part in this stroke, where only parts that the given\n        // line could intersect are considered.\n        const sdf = (point) => {\n            let minDist = Infinity;\n            let minDistPart = null;\n            const uncheckedDistFunctions = [];\n            // First pass: only curves for which the current point is inside\n            // the bounding box.\n            for (const distFnRecord of partDistFunctionRecords) {\n                const { part, distFn, bbox } = distFnRecord;\n                // Check later if the current point isn't in the bounding box.\n                if (!bbox.containsPoint(point)) {\n                    uncheckedDistFunctions.push(distFnRecord);\n                    continue;\n                }\n                const currentDist = distFn(point);\n                if (currentDist <= minDist) {\n                    minDist = currentDist;\n                    minDistPart = part;\n                }\n            }\n            // Second pass: Everything else\n            for (const { part, distFn, bbox } of uncheckedDistFunctions) {\n                // Skip if impossible for the distance to the target to be lesser than\n                // the current minimum.\n                if (isFinite(minDist) && !bbox.grownBy(minDist).containsPoint(point)) {\n                    continue;\n                }\n                const currentDist = distFn(point);\n                if (currentDist <= minDist) {\n                    minDist = currentDist;\n                    minDistPart = part;\n                }\n            }\n            return [minDistPart, minDist - strokeRadius];\n        };\n        // Raymarch:\n        const maxRaymarchSteps = 8;\n        // Start raymarching from each of these points. This allows detection of multiple\n        // intersections.\n        const startPoints = [line.p1, ...additionalRaymarchStartPoints, line.p2];\n        // Converts a point ON THE LINE to a parameter\n        const pointToParameter = (point) => {\n            // Because line.direction is a unit vector, this computes the length\n            // of the projection of the vector(line.p1->point) onto line.direction.\n            //\n            // Note that this can be negative if the given point is outside of the given\n            // line segment.\n            return point.minus(line.p1).dot(line.direction);\n        };\n        // Sort start points by parameter on the line.\n        // This allows us to determine whether the current value of a parameter\n        // drops down to a value already tested.\n        startPoints.sort((a, b) => {\n            const t_a = pointToParameter(a);\n            const t_b = pointToParameter(b);\n            // Sort in increasing order\n            return t_a - t_b;\n        });\n        const result = [];\n        const stoppingThreshold = strokeRadius / 1000;\n        // Returns the maximum parameter value explored\n        const raymarchFrom = (startPoint, \n        // Direction to march in (multiplies line.direction)\n        directionMultiplier, \n        // Terminate if the current point corresponds to a parameter\n        // below this.\n        minimumLineParameter) => {\n            let currentPoint = startPoint;\n            let [lastPart, lastDist] = sdf(currentPoint);\n            let lastParameter = pointToParameter(currentPoint);\n            if (lastDist > lineLength) {\n                return lastParameter;\n            }\n            const direction = line.direction.times(directionMultiplier);\n            for (let i = 0; i < maxRaymarchSteps; i++) {\n                // Step in the direction of the edge of the shape.\n                const step = lastDist;\n                currentPoint = currentPoint.plus(direction.times(step));\n                lastParameter = pointToParameter(currentPoint);\n                // If we're below the minimum parameter, stop. We've already tried\n                // this.\n                if (lastParameter <= minimumLineParameter) {\n                    return lastParameter;\n                }\n                const [currentPart, signedDist] = sdf(currentPoint);\n                // Ensure we're stepping in the correct direction.\n                // Note that because we could start with a negative distance and work towards a\n                // positive distance, we need absolute values here.\n                if (Math.abs(signedDist) > Math.abs(lastDist)) {\n                    // If not, stop.\n                    return null;\n                }\n                lastDist = signedDist;\n                lastPart = currentPart;\n                // Is the distance close enough that we can stop early?\n                if (Math.abs(lastDist) < stoppingThreshold) {\n                    break;\n                }\n            }\n            // Ensure that the point we ended with is on the line.\n            const isOnLineSegment = lastParameter >= 0 && lastParameter <= lineLength;\n            if (lastPart && isOnLineSegment && Math.abs(lastDist) < stoppingThreshold) {\n                result.push({\n                    point: currentPoint,\n                    parameterValue: lastPart.nearestPointTo(currentPoint).parameterValue,\n                    curve: lastPart,\n                    curveIndex: this.geometry.indexOf(lastPart),\n                });\n                // Slightly increase the parameter value to prevent the same point from being\n                // added to the results twice.\n                const parameterIncrease = strokeRadius / 20 / line.length;\n                lastParameter += isFinite(parameterIncrease) ? parameterIncrease : 0;\n            }\n            return lastParameter;\n        };\n        // The maximum value of the line's parameter explored so far (0 corresponds to\n        // line.p1)\n        let maxLineT = 0;\n        // Raymarch for each start point.\n        //\n        // Use a for (i from 0 to length) loop because startPoints may be added\n        // during iteration.\n        for (let i = 0; i < startPoints.length; i++) {\n            const startPoint = startPoints[i];\n            // Try raymarching in both directions.\n            maxLineT = Math.max(maxLineT, raymarchFrom(startPoint, 1, maxLineT) ?? maxLineT);\n            maxLineT = Math.max(maxLineT, raymarchFrom(startPoint, -1, maxLineT) ?? maxLineT);\n        }\n        return result;\n    }\n    /**\n     * Returns a list of intersections with this path. If `strokeRadius` is given,\n     * intersections are approximated with the surface `strokeRadius` away from this.\n     *\n     * If `strokeRadius > 0`, the resultant `parameterValue` has no defined value.\n     *\n     * **Note**: `strokeRadius` is half of a stroke's width.\n     */\n    intersection(line, strokeRadius) {\n        let result = [];\n        // Is any intersection between shapes within the bounding boxes impossible?\n        if (!line.bbox.intersects(this.bbox.grownBy(strokeRadius ?? 0))) {\n            return [];\n        }\n        if (this.parts.length === 0) {\n            return new Path(this.startPoint, [\n                { kind: PathCommandType.MoveTo, point: this.startPoint },\n            ]).intersection(line, strokeRadius);\n        }\n        let index = 0;\n        for (const part of this.geometry) {\n            const intersections = part.argIntersectsLineSegment(line);\n            for (const intersection of intersections) {\n                result.push({\n                    curve: part,\n                    curveIndex: index,\n                    point: part.at(intersection),\n                    parameterValue: intersection,\n                });\n            }\n            index++;\n        }\n        // If given a non-zero strokeWidth, attempt to raymarch.\n        // Even if raymarching, we need to collect starting points.\n        // We use the above-calculated intersections for this.\n        const doRaymarching = strokeRadius && strokeRadius > 1e-8;\n        if (doRaymarching) {\n            // Starting points for raymarching (in addition to the end points of the line).\n            const startPoints = result.map((intersection) => intersection.point);\n            result = this.raymarchIntersectionWith(line, strokeRadius, startPoints);\n        }\n        return result;\n    }\n    /**\n     * @returns the nearest point on this path to the given `point`.\n     */\n    nearestPointTo(point) {\n        // Find the closest point on this\n        let closestSquareDist = Infinity;\n        let closestPartIndex = 0;\n        let closestParameterValue = 0;\n        let closestPoint = this.startPoint;\n        for (let i = 0; i < this.geometry.length; i++) {\n            const current = this.geometry[i];\n            const nearestPoint = current.nearestPointTo(point);\n            const sqareDist = nearestPoint.point.squareDistanceTo(point);\n            if (i === 0 || sqareDist < closestSquareDist) {\n                closestPartIndex = i;\n                closestSquareDist = sqareDist;\n                closestParameterValue = nearestPoint.parameterValue;\n                closestPoint = nearestPoint.point;\n            }\n        }\n        return {\n            curve: this.geometry[closestPartIndex],\n            curveIndex: closestPartIndex,\n            parameterValue: closestParameterValue,\n            point: closestPoint,\n        };\n    }\n    at(index) {\n        if (index.curveIndex === 0 && index.parameterValue === 0) {\n            return this.startPoint;\n        }\n        return this.geometry[index.curveIndex].at(index.parameterValue);\n    }\n    tangentAt(index) {\n        return this.geometry[index.curveIndex].tangentAt(index.parameterValue);\n    }\n    /** Splits this path in two near the given `point`. */\n    splitNear(point, options) {\n        const nearest = this.nearestPointTo(point);\n        return this.splitAt(nearest, options);\n    }\n    /**\n     * Returns a copy of this path with `deleteFrom` until `deleteUntil` replaced with `insert`.\n     *\n     * This method is analogous to {@link Array.toSpliced}.\n     */\n    spliced(deleteFrom, deleteTo, insert, options) {\n        const isBeforeOrEqual = (a, b) => {\n            return (a.curveIndex < b.curveIndex ||\n                (a.curveIndex === b.curveIndex && a.parameterValue <= b.parameterValue));\n        };\n        if (isBeforeOrEqual(deleteFrom, deleteTo)) {\n            //          deleteFrom        deleteTo\n            //      <---------|             |-------------->\n            //      x                                      x\n            //  startPoint                             endPoint\n            const firstSplit = this.splitAt(deleteFrom, options);\n            const secondSplit = this.splitAt(deleteTo, options);\n            const before = firstSplit[0];\n            const after = secondSplit[secondSplit.length - 1];\n            return insert ? before.union(insert).union(after) : before.union(after);\n        }\n        else {\n            // In this case, we need to handle wrapping at the start/end.\n            //          deleteTo        deleteFrom\n            //      <---------|    keep     |-------------->\n            //      x                                      x\n            //  startPoint                             endPoint\n            const splitAtFrom = this.splitAt([deleteFrom], options);\n            const beforeFrom = splitAtFrom[0];\n            // We need splitNear, rather than splitAt, because beforeFrom does not have\n            // the same indexing as this.\n            const splitAtTo = beforeFrom.splitNear(this.at(deleteTo), options);\n            const betweenBoth = splitAtTo[splitAtTo.length - 1];\n            return insert ? betweenBoth.union(insert) : betweenBoth;\n        }\n    }\n    // @internal\n    splitAt(splitAt, options) {\n        if (!Array.isArray(splitAt)) {\n            splitAt = [splitAt];\n        }\n        splitAt = [...splitAt];\n        splitAt.sort(exports.compareCurveIndices);\n        //\n        // Bounds checking & reversal.\n        //\n        while (splitAt.length > 0 &&\n            splitAt[splitAt.length - 1].curveIndex >= this.parts.length - 1 &&\n            splitAt[splitAt.length - 1].parameterValue >= 1) {\n            splitAt.pop();\n        }\n        splitAt.reverse(); // .reverse() <-- We're `.pop`ing from the end\n        while (splitAt.length > 0 &&\n            splitAt[splitAt.length - 1].curveIndex <= 0 &&\n            splitAt[splitAt.length - 1].parameterValue <= 0) {\n            splitAt.pop();\n        }\n        if (splitAt.length === 0 || this.parts.length === 0) {\n            return [this];\n        }\n        const expectedSplitCount = splitAt.length + 1;\n        const mapNewPoint = options?.mapNewPoint ?? ((p) => p);\n        const result = [];\n        let currentStartPoint = this.startPoint;\n        let currentPath = [];\n        //\n        // Splitting\n        //\n        let { curveIndex, parameterValue } = splitAt.pop();\n        for (let i = 0; i < this.parts.length; i++) {\n            if (i !== curveIndex) {\n                currentPath.push(this.parts[i]);\n            }\n            else {\n                let part = this.parts[i];\n                let geom = this.geometry[i];\n                while (i === curveIndex) {\n                    let newPathStart;\n                    const newPath = [];\n                    switch (part.kind) {\n                        case PathCommandType.MoveTo:\n                            currentPath.push({\n                                kind: part.kind,\n                                point: part.point,\n                            });\n                            newPathStart = part.point;\n                            break;\n                        case PathCommandType.LineTo:\n                            {\n                                const split = geom.splitAt(parameterValue);\n                                currentPath.push({\n                                    kind: part.kind,\n                                    point: mapNewPoint(split[0].p2),\n                                });\n                                newPathStart = split[0].p2;\n                                if (split.length > 1) {\n                                    console.assert(split.length === 2);\n                                    newPath.push({\n                                        kind: part.kind,\n                                        // Don't map: For lines, the end point of the split is\n                                        // the same as the end point of the original:\n                                        point: split[1].p2,\n                                    });\n                                    geom = split[1];\n                                }\n                            }\n                            break;\n                        case PathCommandType.QuadraticBezierTo:\n                        case PathCommandType.CubicBezierTo:\n                            {\n                                const split = geom.splitAt(parameterValue);\n                                let isFirstPart = split.length === 2;\n                                for (const segment of split) {\n                                    geom = segment;\n                                    const targetArray = isFirstPart ? currentPath : newPath;\n                                    const controlPoints = segment.getPoints();\n                                    if (part.kind === PathCommandType.CubicBezierTo) {\n                                        targetArray.push({\n                                            kind: part.kind,\n                                            controlPoint1: mapNewPoint(controlPoints[1]),\n                                            controlPoint2: mapNewPoint(controlPoints[2]),\n                                            endPoint: mapNewPoint(controlPoints[3]),\n                                        });\n                                    }\n                                    else {\n                                        targetArray.push({\n                                            kind: part.kind,\n                                            controlPoint: mapNewPoint(controlPoints[1]),\n                                            endPoint: mapNewPoint(controlPoints[2]),\n                                        });\n                                    }\n                                    // We want the start of the new path to match the start of the\n                                    // FIRST Bézier in the NEW path.\n                                    if (!isFirstPart) {\n                                        newPathStart = controlPoints[0];\n                                    }\n                                    isFirstPart = false;\n                                }\n                            }\n                            break;\n                        default: {\n                            const exhaustivenessCheck = part;\n                            return exhaustivenessCheck;\n                        }\n                    }\n                    result.push(new Path(currentStartPoint, [...currentPath]));\n                    currentStartPoint = mapNewPoint(newPathStart);\n                    console.assert(!!currentStartPoint, 'should have a start point');\n                    currentPath = newPath;\n                    part = newPath[newPath.length - 1] ?? part;\n                    const nextSplit = splitAt.pop();\n                    if (!nextSplit) {\n                        break;\n                    }\n                    else {\n                        curveIndex = nextSplit.curveIndex;\n                        if (i === curveIndex) {\n                            const originalPoint = this.at(nextSplit);\n                            parameterValue = geom.nearestPointTo(originalPoint).parameterValue;\n                            currentPath = [];\n                        }\n                        else {\n                            parameterValue = nextSplit.parameterValue;\n                        }\n                    }\n                }\n            }\n        }\n        result.push(new Path(currentStartPoint, currentPath));\n        console.assert(result.length === expectedSplitCount, `should split into splitAt.length + 1 splits (was ${result.length}, expected ${expectedSplitCount})`);\n        return result;\n    }\n    /**\n     * Replaces all `MoveTo` commands with `LineTo` commands and connects the end point of this\n     * path to the start point.\n     */\n    asClosed() {\n        const newParts = [];\n        let hasChanges = false;\n        for (const part of this.parts) {\n            if (part.kind === PathCommandType.MoveTo) {\n                newParts.push({\n                    kind: PathCommandType.LineTo,\n                    point: part.point,\n                });\n                hasChanges = true;\n            }\n            else {\n                newParts.push(part);\n            }\n        }\n        if (!this.getEndPoint().eq(this.startPoint)) {\n            newParts.push({\n                kind: PathCommandType.LineTo,\n                point: this.startPoint,\n            });\n            hasChanges = true;\n        }\n        if (!hasChanges) {\n            return this;\n        }\n        const result = new Path(this.startPoint, newParts);\n        console.assert(result.getEndPoint().eq(result.startPoint));\n        return result;\n    }\n    static mapPathCommand(part, mapping) {\n        switch (part.kind) {\n            case PathCommandType.MoveTo:\n            case PathCommandType.LineTo:\n                return {\n                    kind: part.kind,\n                    point: mapping(part.point),\n                };\n                break;\n            case PathCommandType.CubicBezierTo:\n                return {\n                    kind: part.kind,\n                    controlPoint1: mapping(part.controlPoint1),\n                    controlPoint2: mapping(part.controlPoint2),\n                    endPoint: mapping(part.endPoint),\n                };\n                break;\n            case PathCommandType.QuadraticBezierTo:\n                return {\n                    kind: part.kind,\n                    controlPoint: mapping(part.controlPoint),\n                    endPoint: mapping(part.endPoint),\n                };\n                break;\n        }\n        const exhaustivenessCheck = part;\n        return exhaustivenessCheck;\n    }\n    mapPoints(mapping) {\n        const startPoint = mapping(this.startPoint);\n        const newParts = [];\n        for (const part of this.parts) {\n            newParts.push(Path.mapPathCommand(part, mapping));\n        }\n        return new Path(startPoint, newParts);\n    }\n    transformedBy(affineTransfm) {\n        if (affineTransfm.isIdentity()) {\n            return this;\n        }\n        return this.mapPoints((point) => affineTransfm.transformVec2(point));\n    }\n    /**\n     * @internal\n     */\n    closedContainsPoint(point) {\n        const bbox = this.getExactBBox();\n        if (!bbox.containsPoint(point)) {\n            return false;\n        }\n        const pointOutside = point.plus(Vec2_1.Vec2.of(bbox.width, 0));\n        const asClosed = this.asClosed();\n        const lineToOutside = new LineSegment2_1.default(point, pointOutside);\n        return asClosed.intersection(lineToOutside).length % 2 === 1;\n    }\n    // Creates a new path by joining [other] to the end of this path\n    union(other, \n    // allowReverse: true iff reversing other or this is permitted if it means\n    //               no moveTo command is necessary when unioning the paths.\n    options = { allowReverse: true }) {\n        if (!other) {\n            return this;\n        }\n        if (Array.isArray(other)) {\n            return new Path(this.startPoint, [...this.parts, ...other]);\n        }\n        const thisEnd = this.getEndPoint();\n        let newParts = [];\n        if (thisEnd.eq(other.startPoint)) {\n            newParts = this.parts.concat(other.parts);\n        }\n        else if (options.allowReverse && this.startPoint.eq(other.getEndPoint())) {\n            return other.union(this, { allowReverse: false });\n        }\n        else if (options.allowReverse && this.startPoint.eq(other.startPoint)) {\n            return this.union(other.reversed(), { allowReverse: false });\n        }\n        else {\n            newParts = [\n                ...this.parts,\n                {\n                    kind: PathCommandType.MoveTo,\n                    point: other.startPoint,\n                },\n                ...other.parts,\n            ];\n        }\n        return new Path(this.startPoint, newParts);\n    }\n    /**\n     * @returns a version of this path with the direction reversed.\n     *\n     * Example:\n     * ```ts,runnable,console\n     * import {Path} from '@js-draw/math';\n     * console.log(Path.fromString('m0,0l1,1').reversed()); // -> M1,1 L0,0\n     * ```\n     */\n    reversed() {\n        const newStart = this.getEndPoint();\n        const newParts = [];\n        let lastPoint = this.startPoint;\n        for (const part of this.parts) {\n            switch (part.kind) {\n                case PathCommandType.LineTo:\n                case PathCommandType.MoveTo:\n                    newParts.push({\n                        kind: part.kind,\n                        point: lastPoint,\n                    });\n                    lastPoint = part.point;\n                    break;\n                case PathCommandType.CubicBezierTo:\n                    newParts.push({\n                        kind: part.kind,\n                        controlPoint1: part.controlPoint2,\n                        controlPoint2: part.controlPoint1,\n                        endPoint: lastPoint,\n                    });\n                    lastPoint = part.endPoint;\n                    break;\n                case PathCommandType.QuadraticBezierTo:\n                    newParts.push({\n                        kind: part.kind,\n                        controlPoint: part.controlPoint,\n                        endPoint: lastPoint,\n                    });\n                    lastPoint = part.endPoint;\n                    break;\n                default: {\n                    const exhaustivenessCheck = part;\n                    return exhaustivenessCheck;\n                }\n            }\n        }\n        newParts.reverse();\n        return new Path(newStart, newParts);\n    }\n    /** Computes and returns the end point of this path */\n    getEndPoint() {\n        if (this.parts.length === 0) {\n            return this.startPoint;\n        }\n        const lastPart = this.parts[this.parts.length - 1];\n        if (lastPart.kind === PathCommandType.QuadraticBezierTo ||\n            lastPart.kind === PathCommandType.CubicBezierTo) {\n            return lastPart.endPoint;\n        }\n        else {\n            return lastPart.point;\n        }\n    }\n    /**\n     * Like {@link closedRoughlyIntersects} except takes stroke width into account.\n     *\n     * This is intended to be a very fast and rough approximation. Use {@link intersection}\n     * and {@link signedDistance} for more accurate (but much slower) intersection calculations.\n     *\n     * **Note**: Unlike other methods, this accepts `strokeWidth` (and not `strokeRadius`).\n     *\n     * `strokeRadius` is half of `strokeWidth`.\n     */\n    roughlyIntersects(rect, strokeWidth = 0) {\n        if (this.parts.length === 0) {\n            return rect.containsPoint(this.startPoint);\n        }\n        const isClosed = this.startPoint.eq(this.getEndPoint());\n        if (isClosed && strokeWidth === 0) {\n            return this.closedRoughlyIntersects(rect);\n        }\n        if (rect.containsRect(this.bbox)) {\n            return true;\n        }\n        // Does the rectangle intersect the bounding boxes of any of this' parts?\n        let startPoint = this.startPoint;\n        for (const part of this.parts) {\n            const bbox = Path.computeBBoxForSegment(startPoint, part).grownBy(strokeWidth);\n            if (part.kind === PathCommandType.LineTo || part.kind === PathCommandType.MoveTo) {\n                startPoint = part.point;\n            }\n            else {\n                startPoint = part.endPoint;\n            }\n            if (rect.intersects(bbox)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Treats this as a closed path and returns true if part of `rect` is *roughly* within\n     * this path's interior.\n     *\n     * **Note**: Assumes that this is a closed, non-self-intersecting path.\n     */\n    closedRoughlyIntersects(rect) {\n        if (rect.containsRect(this.bbox)) {\n            return true;\n        }\n        // Choose a point outside of the path.\n        const startPt = this.bbox.topLeft.minus(Vec2_1.Vec2.of(1, 1));\n        const testPts = rect.corners;\n        const polygon = this.polylineApproximation();\n        for (const point of testPts) {\n            const testLine = new LineSegment2_1.default(point, startPt);\n            let intersectionCount = 0;\n            for (const line of polygon) {\n                if (line.intersects(testLine)) {\n                    intersectionCount++;\n                }\n            }\n            // Odd? The point is within the polygon!\n            if (intersectionCount % 2 === 1) {\n                return true;\n            }\n        }\n        // Grow the rectangle for possible additional precision.\n        const grownRect = rect.grownBy(Math.min(rect.size.x, rect.size.y));\n        const edges = [];\n        for (const subrect of grownRect.divideIntoGrid(4, 4)) {\n            edges.push(...subrect.getEdges());\n        }\n        for (const edge of edges) {\n            for (const line of polygon) {\n                if (edge.intersects(line)) {\n                    return true;\n                }\n            }\n        }\n        // Even? Probably no intersection.\n        return false;\n    }\n    /** @returns true if all points on this are equivalent to the points on `other` */\n    eq(other, tolerance) {\n        if (other.parts.length !== this.parts.length) {\n            return false;\n        }\n        for (let i = 0; i < this.parts.length; i++) {\n            const part1 = this.parts[i];\n            const part2 = other.parts[i];\n            switch (part1.kind) {\n                case PathCommandType.LineTo:\n                case PathCommandType.MoveTo:\n                    if (part1.kind !== part2.kind) {\n                        return false;\n                    }\n                    else if (!part1.point.eq(part2.point, tolerance)) {\n                        return false;\n                    }\n                    break;\n                case PathCommandType.CubicBezierTo:\n                    if (part1.kind !== part2.kind) {\n                        return false;\n                    }\n                    else if (!part1.controlPoint1.eq(part2.controlPoint1, tolerance) ||\n                        !part1.controlPoint2.eq(part2.controlPoint2, tolerance) ||\n                        !part1.endPoint.eq(part2.endPoint, tolerance)) {\n                        return false;\n                    }\n                    break;\n                case PathCommandType.QuadraticBezierTo:\n                    if (part1.kind !== part2.kind) {\n                        return false;\n                    }\n                    else if (!part1.controlPoint.eq(part2.controlPoint, tolerance) ||\n                        !part1.endPoint.eq(part2.endPoint, tolerance)) {\n                        return false;\n                    }\n                    break;\n                default: {\n                    const exhaustivenessCheck = part1;\n                    return exhaustivenessCheck;\n                }\n            }\n        }\n        return true;\n    }\n    /**\n     * Returns a path that outlines `rect`.\n     *\n     * If `lineWidth` is given, the resultant path traces a `lineWidth` thick\n     * border around `rect`. Otherwise, the resultant path is just the border\n     * of `rect`.\n     */\n    static fromRect(rect, lineWidth = null) {\n        const commands = [];\n        let corners;\n        let startPoint;\n        if (lineWidth !== null) {\n            // Vector from the top left corner or bottom right corner to the edge of the\n            // stroked region.\n            const cornerToEdge = Vec2_1.Vec2.of(lineWidth, lineWidth).times(0.5);\n            const innerRect = Rect2_1.default.fromCorners(rect.topLeft.plus(cornerToEdge), rect.bottomRight.minus(cornerToEdge));\n            const outerRect = Rect2_1.default.fromCorners(rect.topLeft.minus(cornerToEdge), rect.bottomRight.plus(cornerToEdge));\n            corners = [innerRect.corners[3], ...innerRect.corners, ...outerRect.corners.reverse()];\n            startPoint = outerRect.corners[3];\n        }\n        else {\n            corners = rect.corners.slice(1);\n            startPoint = rect.corners[0];\n        }\n        for (const corner of corners) {\n            commands.push({\n                kind: PathCommandType.LineTo,\n                point: corner,\n            });\n        }\n        // Close the shape\n        commands.push({\n            kind: PathCommandType.LineTo,\n            point: startPoint,\n        });\n        return new Path(startPoint, commands);\n    }\n    /**\n     * Convert to an [SVG path representation](https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths).\n     *\n     * If `useNonAbsCommands` is given, relative path commands (e.g. `l10,0`) are to be used instead of\n     * absolute commands (e.g. `L10,0`).\n     *\n     * See also {@link fromString}.\n     */\n    toString(useNonAbsCommands, ignoreCache = false) {\n        if (this.cachedStringVersion && !ignoreCache) {\n            return this.cachedStringVersion;\n        }\n        if (useNonAbsCommands === undefined) {\n            // Hueristic: Try to determine whether converting absolute to relative commands is worth it.\n            useNonAbsCommands = Math.abs(this.bbox.topLeft.x) > 10 && Math.abs(this.bbox.topLeft.y) > 10;\n        }\n        const result = Path.toString(this.startPoint, this.parts, !useNonAbsCommands);\n        this.cachedStringVersion = result;\n        return result;\n    }\n    serialize() {\n        return this.toString();\n    }\n    // @param onlyAbsCommands - True if we should avoid converting absolute coordinates to relative offsets -- such\n    //   conversions can lead to smaller output strings, but also take time.\n    static toString(startPoint, parts, onlyAbsCommands) {\n        const result = [];\n        let prevPoint;\n        const addCommand = (command, ...points) => {\n            const absoluteCommandParts = [];\n            const relativeCommandParts = [];\n            const makeAbsCommand = !prevPoint || onlyAbsCommands;\n            const roundedPrevX = prevPoint ? (0, toRoundedString_1.default)(prevPoint.x) : '';\n            const roundedPrevY = prevPoint ? (0, toRoundedString_1.default)(prevPoint.y) : '';\n            for (const point of points) {\n                const xComponent = (0, toRoundedString_1.default)(point.x);\n                const yComponent = (0, toRoundedString_1.default)(point.y);\n                // Relative commands are often shorter as strings than absolute commands.\n                if (!makeAbsCommand) {\n                    const xComponentRelative = (0, toStringOfSamePrecision_1.default)(point.x - prevPoint.x, xComponent, roundedPrevX, roundedPrevY);\n                    const yComponentRelative = (0, toStringOfSamePrecision_1.default)(point.y - prevPoint.y, yComponent, roundedPrevX, roundedPrevY);\n                    // No need for an additional separator if it starts with a '-'\n                    if (yComponentRelative.charAt(0) === '-') {\n                        relativeCommandParts.push(`${xComponentRelative}${yComponentRelative}`);\n                    }\n                    else {\n                        relativeCommandParts.push(`${xComponentRelative},${yComponentRelative}`);\n                    }\n                }\n                else {\n                    absoluteCommandParts.push(`${xComponent},${yComponent}`);\n                }\n            }\n            let commandString;\n            if (makeAbsCommand) {\n                commandString = `${command}${absoluteCommandParts.join(' ')}`;\n            }\n            else {\n                commandString = `${command.toLowerCase()}${relativeCommandParts.join(' ')}`;\n            }\n            // Don't add no-ops.\n            if (commandString === 'l0,0' || commandString === 'm0,0') {\n                return;\n            }\n            result.push(commandString);\n            if (points.length > 0) {\n                prevPoint = points[points.length - 1];\n            }\n        };\n        // Don't add two moveTos in a row (this can happen if\n        // the start point corresponds to a moveTo _and_ the first command is\n        // also a moveTo)\n        if (parts[0]?.kind !== PathCommandType.MoveTo) {\n            addCommand('M', startPoint);\n        }\n        let exhaustivenessCheck;\n        for (let i = 0; i < parts.length; i++) {\n            const part = parts[i];\n            switch (part.kind) {\n                case PathCommandType.MoveTo:\n                    addCommand('M', part.point);\n                    break;\n                case PathCommandType.LineTo:\n                    addCommand('L', part.point);\n                    break;\n                case PathCommandType.CubicBezierTo:\n                    addCommand('C', part.controlPoint1, part.controlPoint2, part.endPoint);\n                    break;\n                case PathCommandType.QuadraticBezierTo:\n                    addCommand('Q', part.controlPoint, part.endPoint);\n                    break;\n                default:\n                    exhaustivenessCheck = part;\n                    return exhaustivenessCheck;\n            }\n        }\n        return result.join('');\n    }\n    /**\n     * Create a `Path` from a subset of the SVG path specification.\n     *\n     * Currently, this does not support elliptical arcs or `s` and `t` command\n     * shorthands. See https://github.com/personalizedrefrigerator/js-draw/pull/19.\n     *\n     * @example\n     * ```ts,runnable,console\n     * import { Path } from '@js-draw/math';\n     *\n     * const path = Path.fromString('m0,0l100,100');\n     * console.log(path.toString(true)); // true: Prefer relative to absolute path commands\n     * ```\n     */\n    static fromString(pathString) {\n        // TODO: Support elliptical arcs, and the `s`, `t` command shorthands.\n        //\n        // See the MDN reference:\n        // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d\n        // and\n        // https://www.w3.org/TR/SVG2/paths.html\n        // Remove linebreaks\n        pathString = pathString.split('\\n').join(' ');\n        let lastPos = Vec2_1.Vec2.zero;\n        let firstPos = null;\n        let startPos = null;\n        let isFirstCommand = true;\n        const commands = [];\n        const moveTo = (point) => {\n            // The first moveTo/lineTo is already handled by the [startPoint] parameter of the Path constructor.\n            if (isFirstCommand) {\n                isFirstCommand = false;\n                return;\n            }\n            commands.push({\n                kind: PathCommandType.MoveTo,\n                point,\n            });\n        };\n        const lineTo = (point) => {\n            if (isFirstCommand) {\n                isFirstCommand = false;\n                return;\n            }\n            commands.push({\n                kind: PathCommandType.LineTo,\n                point,\n            });\n        };\n        const cubicBezierTo = (cp1, cp2, end) => {\n            commands.push({\n                kind: PathCommandType.CubicBezierTo,\n                controlPoint1: cp1,\n                controlPoint2: cp2,\n                endPoint: end,\n            });\n        };\n        const quadraticBeierTo = (controlPoint, endPoint) => {\n            commands.push({\n                kind: PathCommandType.QuadraticBezierTo,\n                controlPoint,\n                endPoint,\n            });\n        };\n        const commandArgCounts = {\n            m: 1,\n            l: 1,\n            c: 3,\n            q: 2,\n            z: 0,\n            h: 1,\n            v: 1,\n        };\n        // Each command: Command character followed by anything that isn't a command character\n        const commandExp = /([MZLHVCSQTA])\\s*([^MZLHVCSQTA]*)/gi;\n        let current;\n        while ((current = commandExp.exec(pathString)) !== null) {\n            const argParts = current[2]\n                .trim()\n                .split(/[^0-9Ee.-]/)\n                .filter((part) => part.length > 0)\n                .reduce((accumualtor, current) => {\n                // As of 09/2022, iOS Safari doesn't support support lookbehind in regular\n                // expressions. As such, we need an alternative.\n                // Because '-' can be used as a path separator, unless preceeded by an 'e' (as in 1e-5),\n                // we need special cases:\n                current = current.replace(/([^eE])[-]/g, '$1 -');\n                const parts = current.split(' -');\n                if (parts[0] !== '') {\n                    accumualtor.push(parts[0]);\n                }\n                accumualtor.push(...parts.slice(1).map((part) => `-${part}`));\n                return accumualtor;\n            }, []);\n            let numericArgs = argParts.map((arg) => parseFloat(arg));\n            let commandChar = current[1].toLowerCase();\n            let uppercaseCommand = current[1] !== commandChar;\n            // Convert commands that don't take points into commands that do.\n            if (commandChar === 'v' || commandChar === 'h') {\n                numericArgs = numericArgs.reduce((accumulator, current) => {\n                    if (commandChar === 'v') {\n                        return accumulator.concat(uppercaseCommand ? lastPos.x : 0, current);\n                    }\n                    else {\n                        return accumulator.concat(current, uppercaseCommand ? lastPos.y : 0);\n                    }\n                }, []);\n                commandChar = 'l';\n            }\n            else if (commandChar === 'z') {\n                if (firstPos) {\n                    numericArgs = [firstPos.x, firstPos.y];\n                    firstPos = lastPos;\n                }\n                else {\n                    continue;\n                }\n                // 'z' always acts like an uppercase lineTo(startPos)\n                uppercaseCommand = true;\n                commandChar = 'l';\n            }\n            const commandArgCount = commandArgCounts[commandChar] ?? 0;\n            const allArgs = numericArgs\n                .reduce((accumulator, current, index, parts) => {\n                if (index % 2 !== 0) {\n                    const currentAsFloat = current;\n                    const prevAsFloat = parts[index - 1];\n                    return accumulator.concat(Vec2_1.Vec2.of(prevAsFloat, currentAsFloat));\n                }\n                else {\n                    return accumulator;\n                }\n            }, [])\n                .map((coordinate, index) => {\n                // Lowercase commands are relative, uppercase commands use absolute\n                // positioning\n                let newPos;\n                if (uppercaseCommand) {\n                    newPos = coordinate;\n                }\n                else {\n                    newPos = lastPos.plus(coordinate);\n                }\n                if ((index + 1) % commandArgCount === 0) {\n                    lastPos = newPos;\n                }\n                return newPos;\n            });\n            if (allArgs.length % commandArgCount !== 0) {\n                throw new Error([\n                    `Incorrect number of arguments: got ${JSON.stringify(allArgs)} with a length of ${allArgs.length} ≠ ${commandArgCount}k, k ∈ ℤ.`,\n                    `The number of arguments to ${commandChar} must be a multiple of ${commandArgCount}!`,\n                    `Command: ${current[0]}`,\n                ].join('\\n'));\n            }\n            for (let argPos = 0; argPos < allArgs.length; argPos += commandArgCount) {\n                const args = allArgs.slice(argPos, argPos + commandArgCount);\n                switch (commandChar.toLowerCase()) {\n                    case 'm':\n                        if (argPos === 0) {\n                            moveTo(args[0]);\n                        }\n                        else {\n                            lineTo(args[0]);\n                        }\n                        break;\n                    case 'l':\n                        lineTo(args[0]);\n                        break;\n                    case 'c':\n                        cubicBezierTo(args[0], args[1], args[2]);\n                        break;\n                    case 'q':\n                        quadraticBeierTo(args[0], args[1]);\n                        break;\n                    default:\n                        throw new Error(`Unknown path command ${commandChar}`);\n                }\n                isFirstCommand = false;\n            }\n            if (allArgs.length > 0) {\n                firstPos ??= allArgs[0];\n                startPos ??= firstPos;\n                lastPos = allArgs[allArgs.length - 1];\n            }\n        }\n        const result = new Path(startPos ?? Vec2_1.Vec2.zero, commands);\n        result.cachedStringVersion = pathString;\n        return result;\n    }\n    static fromConvexHullOf(points) {\n        if (points.length === 0) {\n            return Path.empty;\n        }\n        const hull = (0, convexHull2Of_1.default)(points);\n        const commands = hull.slice(1).map((p) => ({\n            kind: PathCommandType.LineTo,\n            point: p,\n        }));\n        // Close -- connect back to the start\n        commands.push({\n            kind: PathCommandType.LineTo,\n            point: hull[0],\n        });\n        return new Path(hull[0], commands);\n    }\n}\nexports.Path = Path;\n// @internal TODO: At present, this isn't really an empty path.\nPath.empty = new Path(Vec2_1.Vec2.zero, []);\nexports[\"default\"] = Path;\n\n\n//# sourceURL=webpack://default/./node_modules/@js-draw/math/dist/cjs/shapes/Path.js?");

/***/ }),

/***/ "./node_modules/@js-draw/math/dist/cjs/shapes/PointShape2D.js":
/*!********************************************************************!*\
  !*** ./node_modules/@js-draw/math/dist/cjs/shapes/PointShape2D.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Vec2_1 = __webpack_require__(/*! ../Vec2 */ \"./node_modules/@js-draw/math/dist/cjs/Vec2.js\");\nconst Parameterized2DShape_1 = __importDefault(__webpack_require__(/*! ./Parameterized2DShape */ \"./node_modules/@js-draw/math/dist/cjs/shapes/Parameterized2DShape.js\"));\nconst Rect2_1 = __importDefault(__webpack_require__(/*! ./Rect2 */ \"./node_modules/@js-draw/math/dist/cjs/shapes/Rect2.js\"));\n/**\n * Like a {@link Point2}, but with additional functionality (e.g. SDF).\n *\n * Access the internal `Point2` using the `p` property.\n */\nclass PointShape2D extends Parameterized2DShape_1.default {\n    constructor(p) {\n        super();\n        this.p = p;\n    }\n    signedDistance(point) {\n        return this.p.distanceTo(point);\n    }\n    argIntersectsLineSegment(lineSegment, epsilon) {\n        if (lineSegment.containsPoint(this.p, epsilon)) {\n            return [0];\n        }\n        return [];\n    }\n    getTightBoundingBox() {\n        return new Rect2_1.default(this.p.x, this.p.y, 0, 0);\n    }\n    at(_t) {\n        return this.p;\n    }\n    /**\n     * Returns an arbitrary unit-length vector.\n     */\n    normalAt(_t) {\n        // Return a vector that makes sense.\n        return Vec2_1.Vec2.unitY;\n    }\n    tangentAt(_t) {\n        return Vec2_1.Vec2.unitX;\n    }\n    splitAt(_t) {\n        return [this];\n    }\n    nearestPointTo(_point) {\n        return {\n            point: this.p,\n            parameterValue: 0,\n        };\n    }\n}\nexports[\"default\"] = PointShape2D;\n\n\n//# sourceURL=webpack://default/./node_modules/@js-draw/math/dist/cjs/shapes/PointShape2D.js?");

/***/ }),

/***/ "./node_modules/@js-draw/math/dist/cjs/shapes/QuadraticBezier.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@js-draw/math/dist/cjs/shapes/QuadraticBezier.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.QuadraticBezier = void 0;\nconst Vec2_1 = __webpack_require__(/*! ../Vec2 */ \"./node_modules/@js-draw/math/dist/cjs/Vec2.js\");\nconst solveQuadratic_1 = __importDefault(__webpack_require__(/*! ../polynomial/solveQuadratic */ \"./node_modules/@js-draw/math/dist/cjs/polynomial/solveQuadratic.js\"));\nconst BezierJSWrapper_1 = __importDefault(__webpack_require__(/*! ./BezierJSWrapper */ \"./node_modules/@js-draw/math/dist/cjs/shapes/BezierJSWrapper.js\"));\nconst Rect2_1 = __importDefault(__webpack_require__(/*! ./Rect2 */ \"./node_modules/@js-draw/math/dist/cjs/shapes/Rect2.js\"));\n/**\n * Represents a 2D [Bézier curve](https://en.wikipedia.org/wiki/B%C3%A9zier_curve).\n *\n * Example:\n * ```ts,runnable,console\n * import { QuadraticBezier, Vec2 } from '@js-draw/math';\n *\n * const startPoint = Vec2.of(4, 3);\n * const controlPoint = Vec2.of(1, 1);\n * const endPoint = Vec2.of(1, 3);\n *\n * const curve = new QuadraticBezier(\n *   startPoint,\n *   controlPoint,\n *   endPoint,\n * );\n *\n * console.log('Curve:', curve);\n * ```\n *\n * **Note**: Some Bézier operations internally use the `bezier-js` library.\n */\nclass QuadraticBezier extends BezierJSWrapper_1.default {\n    constructor(\n    // Start point\n    p0, \n    // Control point\n    p1, \n    // End point\n    p2) {\n        super();\n        this.p0 = p0;\n        this.p1 = p1;\n        this.p2 = p2;\n    }\n    /**\n     * Returns a component of a quadratic Bézier curve at t, where p0,p1,p2 are either all x or\n     * all y components of the target curve.\n     */\n    static componentAt(t, p0, p1, p2) {\n        return p0 + t * (-2 * p0 + 2 * p1) + t * t * (p0 - 2 * p1 + p2);\n    }\n    static derivativeComponentAt(t, p0, p1, p2) {\n        return -2 * p0 + 2 * p1 + 2 * t * (p0 - 2 * p1 + p2);\n    }\n    static secondDerivativeComponentAt(t, p0, p1, p2) {\n        return 2 * (p0 - 2 * p1 + p2);\n    }\n    /**\n     * @returns the curve evaluated at `t`.\n     *\n     * `t` should be a number in `[0, 1]`.\n     */\n    at(t) {\n        if (t === 0)\n            return this.p0;\n        if (t === 1)\n            return this.p2;\n        const p0 = this.p0;\n        const p1 = this.p1;\n        const p2 = this.p2;\n        return Vec2_1.Vec2.of(QuadraticBezier.componentAt(t, p0.x, p1.x, p2.x), QuadraticBezier.componentAt(t, p0.y, p1.y, p2.y));\n    }\n    derivativeAt(t) {\n        const p0 = this.p0;\n        const p1 = this.p1;\n        const p2 = this.p2;\n        return Vec2_1.Vec2.of(QuadraticBezier.derivativeComponentAt(t, p0.x, p1.x, p2.x), QuadraticBezier.derivativeComponentAt(t, p0.y, p1.y, p2.y));\n    }\n    secondDerivativeAt(t) {\n        const p0 = this.p0;\n        const p1 = this.p1;\n        const p2 = this.p2;\n        return Vec2_1.Vec2.of(QuadraticBezier.secondDerivativeComponentAt(t, p0.x, p1.x, p2.x), QuadraticBezier.secondDerivativeComponentAt(t, p0.y, p1.y, p2.y));\n    }\n    normal(t) {\n        const tangent = this.derivativeAt(t);\n        return tangent.orthog().normalized();\n    }\n    /** @returns an overestimate of this shape's bounding box. */\n    getLooseBoundingBox() {\n        return Rect2_1.default.bboxOf([this.p0, this.p1, this.p2]);\n    }\n    /**\n     * @returns the *approximate* distance from `point` to this curve.\n     */\n    approximateDistance(point) {\n        // We want to minimize f(t) = |B(t) - p|².\n        // Expanding,\n        //   f(t)  = (Bₓ(t) - pₓ)² + (Bᵧ(t) - pᵧ)²\n        // ⇒ f'(t) = Dₜ(Bₓ(t) - pₓ)² + Dₜ(Bᵧ(t) - pᵧ)²\n        //\n        // Considering just one component,\n        //  Dₜ(Bₓ(t) - pₓ)² = 2(Bₓ(t) - pₓ)(DₜBₓ(t))\n        //                  = 2(Bₓ(t)DₜBₓ(t) - pₓBₓ(t))\n        //   = 2(p0ₓ + (t)(-2p0ₓ + 2p1ₓ) + (t²)(p0ₓ - 2p1ₓ + p2ₓ) - pₓ)((-2p0ₓ + 2p1ₓ) + 2(t)(p0ₓ - 2p1ₓ + p2ₓ))\n        //     - (pₓ)((-2p0ₓ + 2p1ₓ) + (t)(p0ₓ - 2p1ₓ + p2ₓ))\n        const A = this.p0.x - point.x;\n        const B = -2 * this.p0.x + 2 * this.p1.x;\n        const C = this.p0.x - 2 * this.p1.x + this.p2.x;\n        // Let A = p0ₓ - pₓ, B = -2p0ₓ + 2p1ₓ, C = p0ₓ - 2p1ₓ + p2ₓ. We then have,\n        //  Dₜ(Bₓ(t) - pₓ)²\n        //    = 2(A + tB + t²C)(B + 2tC) - (pₓ)(B + 2tC)\n        //    = 2(AB + tB² + t²BC + 2tCA + 2tCtB + 2tCt²C) - pₓB - pₓ2tC\n        //    = 2(AB + tB² + 2tCA + t²BC + 2t²CB + 2C²t³) - pₓB - pₓ2tC\n        //    = 2AB + 2t(B² + 2CA) + 2t²(BC + 2CB) + 4C²t³ - pₓB - pₓ2tC\n        //    = 2AB + 2t(B² + 2CA - pₓC) + 2t²(BC + 2CB) + 4C²t³ - pₓB\n        //\n        const D = this.p0.y - point.y;\n        const E = -2 * this.p0.y + 2 * this.p1.y;\n        const F = this.p0.y - 2 * this.p1.y + this.p2.y;\n        // Using D = p0ᵧ - pᵧ, E = -2p0ᵧ + 2p1ᵧ, F = p0ᵧ - 2p1ᵧ + p2ᵧ, we thus have,\n        //  f'(t) = 2AB + 2t(B² + 2CA - pₓC) + 2t²(BC + 2CB) + 4C²t³ - pₓB\n        //        + 2DE + 2t(E² + 2FD - pᵧF) + 2t²(EF + 2FE) + 4F²t³ - pᵧE\n        const a = 2 * A * B + 2 * D * E - point.x * B - point.y * E;\n        const b = 2 * B * B + 2 * E * E + 2 * C * A + 2 * F * D - point.x * C - point.y * F;\n        const c = 2 * E * F + 2 * B * C + 2 * C * B + 2 * F * E;\n        //const d = 4 * C * C + 4 * F * F;\n        // Thus,\n        // f'(t) = a + bt + ct² + dt³\n        const fDerivAtZero = a;\n        const f2ndDerivAtZero = b;\n        const f3rdDerivAtZero = 2 * c;\n        // Using the first few terms of a Maclaurin series to approximate f'(t),\n        // f'(t) ≈ f'(0) + t f''(0) + t² f'''(0) / 2\n        let [min1, min2] = (0, solveQuadratic_1.default)(f3rdDerivAtZero / 2, f2ndDerivAtZero, fDerivAtZero);\n        // If the quadratic has no solutions, approximate.\n        if (isNaN(min1)) {\n            min1 = 0.25;\n        }\n        if (isNaN(min2)) {\n            min2 = 0.75;\n        }\n        const at1 = this.at(min1);\n        const at2 = this.at(min2);\n        const sqrDist1 = at1.squareDistanceTo(point);\n        const sqrDist2 = at2.squareDistanceTo(point);\n        const sqrDist3 = this.at(0).squareDistanceTo(point);\n        const sqrDist4 = this.at(1).squareDistanceTo(point);\n        return Math.sqrt(Math.min(sqrDist1, sqrDist2, sqrDist3, sqrDist4));\n    }\n    getPoints() {\n        return [this.p0, this.p1, this.p2];\n    }\n}\nexports.QuadraticBezier = QuadraticBezier;\nexports[\"default\"] = QuadraticBezier;\n\n\n//# sourceURL=webpack://default/./node_modules/@js-draw/math/dist/cjs/shapes/QuadraticBezier.js?");

/***/ }),

/***/ "./node_modules/@js-draw/math/dist/cjs/shapes/Rect2.js":
/*!*************************************************************!*\
  !*** ./node_modules/@js-draw/math/dist/cjs/shapes/Rect2.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Rect2 = void 0;\nconst LineSegment2_1 = __importDefault(__webpack_require__(/*! ./LineSegment2 */ \"./node_modules/@js-draw/math/dist/cjs/shapes/LineSegment2.js\"));\nconst Mat33_1 = __importDefault(__webpack_require__(/*! ../Mat33 */ \"./node_modules/@js-draw/math/dist/cjs/Mat33.js\"));\nconst Vec2_1 = __webpack_require__(/*! ../Vec2 */ \"./node_modules/@js-draw/math/dist/cjs/Vec2.js\");\nconst Abstract2DShape_1 = __importDefault(__webpack_require__(/*! ./Abstract2DShape */ \"./node_modules/@js-draw/math/dist/cjs/shapes/Abstract2DShape.js\"));\n/**\n * Represents a rectangle in 2D space, parallel to the XY axes.\n *\n * **Example**:\n * ```ts,runnable,console\n * import { Rect2, Vec2 } from '@js-draw/math';\n *\n * const rect = Rect2.fromCorners(\n *   Vec2.of(0, 0),\n *   Vec2.of(10, 10),\n * );\n * console.log('area', rect.area);\n * console.log('topLeft', rect.topLeft);\n * ```\n *\n * `invariant: w ≥ 0, h ≥ 0, immutable`\n */\nclass Rect2 extends Abstract2DShape_1.default {\n    constructor(\n    // Top left x coordinate\n    x, \n    // Top left y coordinate\n    y, \n    // Width\n    w, \n    // Height\n    h) {\n        super();\n        this.x = x;\n        this.y = y;\n        this.w = w;\n        this.h = h;\n        if (w < 0) {\n            this.x += w;\n            this.w = Math.abs(w);\n        }\n        if (h < 0) {\n            this.y += h;\n            this.h = Math.abs(h);\n        }\n        // Precompute/store vector forms.\n        this.topLeft = Vec2_1.Vec2.of(this.x, this.y);\n        this.size = Vec2_1.Vec2.of(this.w, this.h);\n        this.area = this.w * this.h;\n    }\n    translatedBy(vec) {\n        return new Rect2(vec.x + this.x, vec.y + this.y, this.w, this.h);\n    }\n    // Returns a copy of this with the given size (but same top-left).\n    resizedTo(size) {\n        return new Rect2(this.x, this.y, size.x, size.y);\n    }\n    containsPoint(other) {\n        return (this.x <= other.x &&\n            this.y <= other.y &&\n            this.x + this.w >= other.x &&\n            this.y + this.h >= other.y);\n    }\n    /** @returns true iff `other` is completely within this `Rect2`. */\n    containsRect(other) {\n        return (this.x <= other.x &&\n            this.y <= other.y &&\n            this.x + this.w >= other.x + other.w &&\n            this.y + this.h >= other.y + other.h);\n    }\n    /**\n     * @returns true iff this and `other` overlap\n     */\n    intersects(other) {\n        // Project along x/y axes.\n        const thisMinX = this.x;\n        const thisMaxX = thisMinX + this.w;\n        const otherMinX = other.x;\n        const otherMaxX = other.x + other.w;\n        if (thisMaxX < otherMinX || thisMinX > otherMaxX) {\n            return false;\n        }\n        const thisMinY = this.y;\n        const thisMaxY = thisMinY + this.h;\n        const otherMinY = other.y;\n        const otherMaxY = other.y + other.h;\n        if (thisMaxY < otherMinY || thisMinY > otherMaxY) {\n            return false;\n        }\n        return true;\n    }\n    // Returns the overlap of this and [other], or null, if no such\n    //          overlap exists\n    intersection(other) {\n        if (!this.intersects(other)) {\n            return null;\n        }\n        const topLeft = this.topLeft.zip(other.topLeft, Math.max);\n        const bottomRight = this.bottomRight.zip(other.bottomRight, Math.min);\n        return Rect2.fromCorners(topLeft, bottomRight);\n    }\n    // Returns a new rectangle containing both [this] and [other].\n    union(other) {\n        return Rect2.union(this, other);\n    }\n    // Returns a the subdivision of this into [columns] columns\n    // and [rows] rows. For example,\n    //\t Rect2.unitSquare.divideIntoGrid(2, 2)\n    //\t\t-> [ Rect2(0, 0, 0.5, 0.5), Rect2(0.5, 0, 0.5, 0.5), Rect2(0, 0.5, 0.5, 0.5), Rect2(0.5, 0.5, 0.5, 0.5) ]\n    // The rectangles are ordered in row-major order.\n    divideIntoGrid(columns, rows) {\n        const result = [];\n        if (columns <= 0 || rows <= 0) {\n            return result;\n        }\n        const eachRectWidth = this.w / columns;\n        const eachRectHeight = this.h / rows;\n        if (eachRectWidth === 0) {\n            columns = 1;\n        }\n        if (eachRectHeight === 0) {\n            rows = 1;\n        }\n        for (let j = 0; j < rows; j++) {\n            for (let i = 0; i < columns; i++) {\n                const x = eachRectWidth * i + this.x;\n                const y = eachRectHeight * j + this.y;\n                result.push(new Rect2(x, y, eachRectWidth, eachRectHeight));\n            }\n        }\n        return result;\n    }\n    // Returns a rectangle containing this and [point].\n    // [margin] is the minimum distance between the new point and the edge\n    // of the resultant rectangle.\n    grownToPoint(point, margin = 0) {\n        const otherRect = new Rect2(point.x - margin, point.y - margin, margin * 2, margin * 2);\n        return this.union(otherRect);\n    }\n    // Returns this grown by [margin] in both the x and y directions.\n    grownBy(margin) {\n        if (margin === 0) {\n            return this;\n        }\n        // Prevent width/height from being negative\n        if (margin < 0) {\n            const xMargin = -Math.min(-margin, this.w / 2);\n            const yMargin = -Math.min(-margin, this.h / 2);\n            return new Rect2(this.x - xMargin, this.y - yMargin, this.w + xMargin * 2, this.h + yMargin * 2);\n        }\n        return new Rect2(this.x - margin, this.y - margin, this.w + margin * 2, this.h + margin * 2);\n    }\n    /**\n     * If this rectangle is smaller than `minSize`, returns a copy of this\n     * with a larger width/height.\n     *\n     * If smaller than `minSize`, padding is applied on both sides.\n     */\n    grownToSize(minSize) {\n        if (this.width >= minSize.x && this.height >= minSize.y) {\n            return this;\n        }\n        const deltaWidth = Math.max(0, minSize.x - this.width);\n        const deltaHeight = Math.max(0, minSize.y - this.height);\n        return new Rect2(this.x - deltaWidth / 2, this.y - deltaHeight / 2, this.width + deltaWidth, this.height + deltaHeight);\n    }\n    getClosestPointOnBoundaryTo(target) {\n        const closestEdgePoints = this.getEdges().map((edge) => {\n            return edge.closestPointTo(target);\n        });\n        let closest = null;\n        let closestDist = null;\n        for (const point of closestEdgePoints) {\n            const dist = point.distanceTo(target);\n            if (closestDist === null || dist < closestDist) {\n                closest = point;\n                closestDist = dist;\n            }\n        }\n        return closest;\n    }\n    /**\n     * Returns `true` iff all points in this rectangle are within `distance` from `point`:\n     *\n     * If $R$ is the set of points in this rectangle, returns `true` iff\n     * $$\n     * \t\\forall {\\bf a} \\in R, \\|\\texttt{point} - {\\bf a}\\| < \\texttt{radius}\n     * $$\n     */\n    isWithinRadiusOf(radius, point) {\n        if (this.maxDimension > radius) {\n            return false;\n        }\n        const squareRadius = radius * radius;\n        return this.corners.every((corner) => corner.minus(point).magnitudeSquared() < squareRadius);\n    }\n    get corners() {\n        return [this.bottomRight, this.topRight, this.topLeft, this.bottomLeft];\n    }\n    get maxDimension() {\n        return Math.max(this.w, this.h);\n    }\n    get minDimension() {\n        return Math.min(this.w, this.h);\n    }\n    get bottomRight() {\n        return this.topLeft.plus(this.size);\n    }\n    get topRight() {\n        return this.bottomRight.plus(Vec2_1.Vec2.of(0, -this.h));\n    }\n    get bottomLeft() {\n        return this.topLeft.plus(Vec2_1.Vec2.of(0, this.h));\n    }\n    get width() {\n        return this.w;\n    }\n    get height() {\n        return this.h;\n    }\n    get center() {\n        return Vec2_1.Vec2.of(this.x + this.w / 2, this.y + this.h / 2);\n    }\n    // Returns edges in the order\n    // [ rightEdge, topEdge, leftEdge, bottomEdge ]\n    getEdges() {\n        const corners = this.corners;\n        return [\n            new LineSegment2_1.default(corners[0], corners[1]),\n            new LineSegment2_1.default(corners[1], corners[2]),\n            new LineSegment2_1.default(corners[2], corners[3]),\n            new LineSegment2_1.default(corners[3], corners[0]),\n        ];\n    }\n    intersectsLineSegment(lineSegment) {\n        const result = [];\n        for (const edge of this.getEdges()) {\n            const intersection = edge.intersectsLineSegment(lineSegment);\n            intersection.forEach((point) => result.push(point));\n        }\n        return result;\n    }\n    signedDistance(point) {\n        const closestBoundaryPoint = this.getClosestPointOnBoundaryTo(point);\n        const dist = point.minus(closestBoundaryPoint).magnitude();\n        if (this.containsPoint(point)) {\n            return -dist;\n        }\n        return dist;\n    }\n    getTightBoundingBox() {\n        return this;\n    }\n    // [affineTransform] is a transformation matrix that both scales and **translates**.\n    // the bounding box of this' four corners after transformed by the given affine transformation.\n    transformedBoundingBox(affineTransform) {\n        // Optimize transforming by the identity matrix (a common case).\n        if (affineTransform === Mat33_1.default.identity) {\n            return this;\n        }\n        return Rect2.bboxOf(this.corners.map((corner) => affineTransform.transformVec2(corner)));\n    }\n    /** @return true iff this is equal to `other ± tolerance` */\n    eq(other, tolerance = 0) {\n        return this.topLeft.eq(other.topLeft, tolerance) && this.size.eq(other.size, tolerance);\n    }\n    toString() {\n        return `Rect(point(${this.x}, ${this.y}), size(${this.w}, ${this.h}))`;\n    }\n    static fromCorners(corner1, corner2) {\n        return new Rect2(Math.min(corner1.x, corner2.x), Math.min(corner1.y, corner2.y), Math.abs(corner1.x - corner2.x), Math.abs(corner1.y - corner2.y));\n    }\n    // Returns a box that contains all points in [points] with at least [margin]\n    // between each point and the edge of the box.\n    static bboxOf(points, margin = 0) {\n        let minX = 0;\n        let minY = 0;\n        let maxX = 0;\n        let maxY = 0;\n        let isFirst = true;\n        for (const point of points) {\n            if (isFirst) {\n                minX = point.x;\n                minY = point.y;\n                maxX = point.x;\n                maxY = point.y;\n                isFirst = false;\n            }\n            minX = Math.min(minX, point.x);\n            minY = Math.min(minY, point.y);\n            maxX = Math.max(maxX, point.x);\n            maxY = Math.max(maxY, point.y);\n        }\n        return Rect2.fromCorners(Vec2_1.Vec2.of(minX - margin, minY - margin), Vec2_1.Vec2.of(maxX + margin, maxY + margin));\n    }\n    // @returns a rectangle that contains all of the given rectangles, the bounding box\n    //     of the given rectangles.\n    static union(...rects) {\n        if (rects.length === 0) {\n            return Rect2.empty;\n        }\n        const firstRect = rects[0];\n        let minX = firstRect.x;\n        let minY = firstRect.y;\n        let maxX = firstRect.x + firstRect.w;\n        let maxY = firstRect.y + firstRect.h;\n        for (let i = 1; i < rects.length; i++) {\n            const rect = rects[i];\n            minX = Math.min(minX, rect.x);\n            minY = Math.min(minY, rect.y);\n            maxX = Math.max(maxX, rect.x + rect.w);\n            maxY = Math.max(maxY, rect.y + rect.h);\n        }\n        return new Rect2(minX, minY, maxX - minX, maxY - minY);\n    }\n    static of(template) {\n        const width = template.width ?? template.w ?? 0;\n        const height = template.height ?? template.h ?? 0;\n        return new Rect2(template.x, template.y, width, height);\n    }\n}\nexports.Rect2 = Rect2;\nRect2.empty = new Rect2(0, 0, 0, 0);\nRect2.unitSquare = new Rect2(0, 0, 1, 1);\nexports[\"default\"] = Rect2;\n\n\n//# sourceURL=webpack://default/./node_modules/@js-draw/math/dist/cjs/shapes/Rect2.js?");

/***/ }),

/***/ "./node_modules/@js-draw/math/dist/cjs/utils/convexHull2Of.js":
/*!********************************************************************!*\
  !*** ./node_modules/@js-draw/math/dist/cjs/utils/convexHull2Of.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Vec2_1 = __webpack_require__(/*! ../Vec2 */ \"./node_modules/@js-draw/math/dist/cjs/Vec2.js\");\n/**\n * Implements Gift Wrapping, in $O(nh)$. This algorithm is not the most efficient in the worst case.\n *\n * See https://en.wikipedia.org/wiki/Gift_wrapping_algorithm\n * and https://www.cs.jhu.edu/~misha/Spring16/06.pdf\n */\nconst convexHull2Of = (points) => {\n    if (points.length === 0) {\n        return [];\n    }\n    // 1. Start with a vertex on the hull\n    const lowestPoint = points.reduce((lowest, current) => (current.y < lowest.y ? current : lowest), points[0]);\n    const vertices = [lowestPoint];\n    let toProcess = [...points.filter((p) => !p.eq(lowestPoint))];\n    let lastBaseDirection = Vec2_1.Vec2.of(-1, 0);\n    // 2. Find the point with greatest angle from the vertex:\n    //\n    //  . .     .\n    //   . .   /  <- Notice that **all** other points are to the\n    //       /       **left** of the vector from the current\n    //    ./         vertex to the new point.\n    while (toProcess.length > 0) {\n        const lastVertex = vertices[vertices.length - 1];\n        let smallestDotProductSoFar = lastBaseDirection.dot(lowestPoint.minus(lastVertex).normalizedOrZero());\n        let furthestPointSoFar = lowestPoint;\n        for (const point of toProcess) {\n            // Maximizing the angle is the same as minimizing the dot product:\n            //              point.minus(lastVertex)\n            //             ^\n            //            /\n            //           /\n            //        ϑ /\n            //   <-----. lastBaseDirection\n            const currentDotProduct = lastBaseDirection.dot(point.minus(lastVertex).normalizedOrZero());\n            if (currentDotProduct <= smallestDotProductSoFar) {\n                furthestPointSoFar = point;\n                smallestDotProductSoFar = currentDotProduct;\n            }\n        }\n        toProcess = toProcess.filter((p) => !p.eq(furthestPointSoFar));\n        const newBaseDirection = furthestPointSoFar.minus(lastVertex).normalized();\n        // If the last vertex is on the same edge as the current, there's no need to include\n        // the previous one.\n        if (Math.abs(newBaseDirection.dot(lastBaseDirection)) === 1 && vertices.length > 1) {\n            vertices.pop();\n        }\n        // Stoping condition: We've gone in a full circle.\n        if (furthestPointSoFar.eq(lowestPoint)) {\n            break;\n        }\n        else {\n            vertices.push(furthestPointSoFar);\n            lastBaseDirection = lastVertex.minus(furthestPointSoFar).normalized();\n        }\n    }\n    return vertices;\n};\nexports[\"default\"] = convexHull2Of;\n\n\n//# sourceURL=webpack://default/./node_modules/@js-draw/math/dist/cjs/utils/convexHull2Of.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/bundledStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/js-draw/dist/bundledStyles.js ***!
  \****************************************************/
/***/ (() => {

"use strict";
eval("var jsdrawStyles=(()=>{(()=>{if(typeof document<\"u\"&&typeof document.createElement==\"function\"){let o=document.createElement(\"style\");o.textContent='\\uFEFF:root .insert-image-widget-dropdown-content.insert-image-widget-dropdown-content.insert-image-widget-dropdown-content>div>div{padding:5px}:root .insert-image-widget-dropdown-content.insert-image-widget-dropdown-content.insert-image-widget-dropdown-content>div{min-height:0}:root .insert-image-widget-dropdown-content.insert-image-widget-dropdown-content.insert-image-widget-dropdown-content img{max-width:100%;max-height:100%;display:block;margin-left:auto;margin-right:auto}:root .insert-image-widget-dropdown-content.insert-image-widget-dropdown-content.insert-image-widget-dropdown-content .insert-image-image-status-view{display:flex;justify-content:space-between;padding-bottom:0}:root .insert-image-widget-dropdown-content.insert-image-widget-dropdown-content.insert-image-widget-dropdown-content .action-button-row{margin-top:4px;display:flex;flex-direction:row;justify-content:flex-end;padding-bottom:0;margin-bottom:0}:root .insert-image-widget-dropdown-content.insert-image-widget-dropdown-content.insert-image-widget-dropdown-content .action-button-row>button{flex-grow:1;text-align:end;max-width:50%;min-width:min(100%,40px)}.toolbar-overflow-widget-overflow-list{display:flex;flex-direction:column;flex-wrap:wrap;justify-content:center}.toolbar-overflow-widget-overflow-list>.toolbar-toolContainer>.toolbar-button{height:var(--toolbar-button-height)}.toolbar-overflow-widget.horizontal .toolbar-overflow-widget-overflow-list{flex-direction:row}.toolbar-overflow-widget.horizontal>.toolbar-dropdown{max-width:100%;left:15px;right:15px;margin-left:0 !important;translate:none !important;padding:4px}:root .toolbar--pen-tool-toggle-buttons.toolbar--pen-tool-toggle-buttons{display:flex;justify-content:stretch;padding-top:0;padding-bottom:5px;direction:ltr}:root .toolbar--pen-tool-toggle-buttons.toolbar--pen-tool-toggle-buttons>*{flex-grow:1;text-align:start;margin-inline-end:5px}:root .toolbar--pen-tool-toggle-buttons.toolbar--pen-tool-toggle-buttons>* .icon{margin:0;margin-inline-start:4px;margin-inline-end:10px}:root .toolbar--pen-tool-toggle-buttons.toolbar--pen-tool-toggle-buttons>:nth-child(1){direction:ltr}:root .toolbar--pen-tool-toggle-buttons.toolbar--pen-tool-toggle-buttons>:last-child{direction:rtl}.toolbar-zoomLevelEditor{display:flex;flex-direction:row;align-items:center}.toolbar-zoomLevelEditor .zoomDisplay{flex-grow:1}.toolbar-zoomLevelEditor button{min-width:48px}.selection-format-menu.disabled{opacity:.5}.toolbar-document-properties-widget button.about-button{width:100%;text-align:end}.toolbar-document-properties-widget>*{--align-items-to-x: 120px}.toolbar-document-properties-widget .js-draw-size-input-row.js-draw-size-input-row{display:flex}.toolbar-document-properties-widget .js-draw-size-input-row.js-draw-size-input-row.size-input-row--automatic-size{display:none}.toolbar-thicknessSliderContainer{display:flex;flex-direction:row}.toolbar-thicknessSliderContainer input{flex-grow:1}.toolbar-element .clr-field *{cursor:pointer}.toolbar-element .clr-field button{width:1.2em;height:1.2em;top:50%;left:0;border-radius:50%;margin-left:0;margin-right:0}.toolbar-element .clr-field input{opacity:0}.color-input-container{display:inline-flex;flex-direction:row}.color-input-container .coloris_input{height:calc(100% - 6px)}.color-input-container.picker-open .clr-field{pointer-events:none}:root .color-input-container>button.pipetteButton{width:30px;height:30px;padding:0;display:inline-flex}.color-input-container>.color-input-wrapper{display:flex;justify-content:stretch}.color-input-container .pipetteButton>svg{width:100%}.color-input-container .pipetteButton .pickColorInstructions{display:none;font-size:1em;position:absolute;margin-left:30px;background-color:var(--background-color-1);border-radius:30px;padding:4px;opacity:0;transition:.2s ease opacity}@media(prefers-reduced-motion: reduce){.color-input-container .pipetteButton .pickColorInstructions{transition:none}}.color-input-container .pipetteButton.active{background-color:var(--selection-background-color);--icon-color: var(--selection-foreground-color)}.color-input-container .pipetteButton.active .pickColorInstructions{display:block;opacity:.8}.tool-dropdown-separator{--border-color: rgba(100, 100, 100, 0.2);--border-color: color-mix(in srgb, var(--foreground-color-1), rgba(0, 0, 0, 0) 80%);border-top:1px solid var(--border-color);padding-left:2px;margin-top:10px;margin-bottom:10px}.toolbar-element .toolbar--file-input-container{display:flex}.toolbar-element .toolbar--file-input-container.-loading{opacity:.8}.toolbar-element .toolbar--file-input-container>input.file-input{opacity:0;width:0;min-width:0 !important;max-width:0;height:0;overflow:hidden;padding:0;margin:0}.toolbar-element .toolbar--file-input-container>label{display:block;flex-grow:1;padding:0 !important;padding-bottom:5px;--active-border-color: rgba(100, 100, 100, 0.5);--active-border-color: color-mix(in srgb, var(--foreground-color-1), transparent)}.toolbar-element .toolbar--file-input-container>label .cancel-button{padding-left:3px;padding-right:3px}.toolbar-element .toolbar--file-input-container>label>.toolbar--file-input-description{background-color:var(--background-color-3);color:var(--foreground-color-3);border:1px dashed var(--active-border-color);padding:10px;margin-top:10px;display:flex;flex-direction:column;align-items:center;text-align:center;--action-color: var(--primary-action-foreground-color);--icon-color: var(--action-color)}.toolbar-element .toolbar--file-input-container>label>.toolbar--file-input-description>span{white-space:pre-wrap}.toolbar-element .toolbar--file-input-container>label>.toolbar--file-input-description>span>b{color:var(--action-color);cursor:pointer}.toolbar-element .toolbar--file-input-container>label>.toolbar--file-input-description>.icon{width:min(50vw,42px);height:min(50vw,42px);margin-bottom:8px;display:block}.toolbar-element .toolbar--file-input-container>label:active,.toolbar-element .toolbar--file-input-container>label:hover,.toolbar-element .toolbar--file-input-container>label.drag-target{--active-border-color: var(--foreground-color-1)}.toolbar-element .toolbar--file-input-container>label.drag-target>.toolbar--file-input-description{border-width:2px}.toolbar-grid-selector{position:relative}.toolbar-grid-selector>div{display:flex;flex-direction:row;max-width:350px;flex-wrap:wrap;--button-size: 48px}.toolbar-grid-selector .choice-button{display:flex;flex-direction:column-reverse;box-sizing:border-box;cursor:pointer;flex-shrink:1;margin:2px}.toolbar-grid-selector .choice-button.focus-visible{outline:2px solid var(--foreground-color-1)}.toolbar-grid-selector .choice-button input{opacity:0;height:0}.toolbar-grid-selector .choice-button label{display:flex;flex-direction:column;box-sizing:border-box;width:var(--button-size);height:var(--button-size);font-size:.7rem;align-items:center;justify-content:center;padding:4px;user-select:none;-webkit-user-select:none}.toolbar-grid-selector .choice-button .icon{flex-grow:1;flex-shrink:1;width:100%}.toolbar-grid-selector .choice-button.checked{background-color:var(--selection-background-color);color:var(--selection-foreground-color);--icon-color: var(--selection-foreground-color)}:root .toolbar-snapped-scroll-list.toolbar-snapped-scroll-list.toolbar-snapped-scroll-list{height:min(200px,50vh);position:relative;display:flex;align-items:center}:root .toolbar-snapped-scroll-list.toolbar-snapped-scroll-list.toolbar-snapped-scroll-list>.scroller{display:flex;flex-direction:column;overflow-y:auto;scroll-snap-type:y mandatory;height:100%;width:100%;flex-grow:1}:root .toolbar-snapped-scroll-list.toolbar-snapped-scroll-list.toolbar-snapped-scroll-list>.scroller>.item{height:100%;width:100%;flex-shrink:0;display:flex;justify-content:center;align-items:center;scroll-snap-align:start;scroll-snap-stop:always;box-sizing:border-box}:root .toolbar-snapped-scroll-list.toolbar-snapped-scroll-list.toolbar-snapped-scroll-list.-empty{display:none}:root .toolbar-snapped-scroll-list.toolbar-snapped-scroll-list.toolbar-snapped-scroll-list>.page-markers{overflow:hidden;display:flex;flex-direction:column;align-items:center;max-height:100%;min-height:0}:root .toolbar-snapped-scroll-list.toolbar-snapped-scroll-list.toolbar-snapped-scroll-list>.page-markers.-one-element{visibility:hidden}:root .toolbar-snapped-scroll-list.toolbar-snapped-scroll-list.toolbar-snapped-scroll-list>.page-markers>.marker{padding:2px;opacity:.1;cursor:pointer;left:0;transition:left .2s ease}:root .toolbar-snapped-scroll-list.toolbar-snapped-scroll-list.toolbar-snapped-scroll-list>.page-markers>.marker>.content{background-color:var(--foreground-color-1);border-radius:2px;padding:2px}:root .toolbar-snapped-scroll-list.toolbar-snapped-scroll-list.toolbar-snapped-scroll-list>.page-markers>.marker.-active{position:relative;left:2px;opacity:.2}.toolbar-root{background-color:var(--background-color-1);--icon-color: var(--foreground-color-1);--toolbar-button-height: min(20vh, 60px);flex-wrap:wrap;box-sizing:border-box;width:100%;display:flex;flex-direction:row;justify-content:center}.toolbar-element{z-index:1;font-family:system-ui,-apple-system,sans-serif}.toolbar-element details>summary{cursor:pointer}.toolbar-element>.toolbar-toolContainer>.toolbar-button,.toolbar-element>.toolbar-toolContainer>*>button,.toolbar-element>.toolbar-buttonGroup>button,.toolbar-element>.toolbar-button{white-space:pre;height:var(--toolbar-button-height)}.toolbar-dropdown .toolbar-button>.toolbar-icon{max-width:50px;width:100%}.toolbar-button.disabled{filter:sepia(0.2);opacity:.45;cursor:unset}.toolbar-button,.toolbar-element button{cursor:pointer;text-align:center;border-radius:6px;border:none;box-shadow:0px 0px 2px var(--shadow-color);user-select:none;-webkit-user-select:none;transition:background-color .15s ease,box-shadow .25s ease,opacity .2s ease}.toolbar-button,.toolbar-buttonGroup>button,.toolbar-toolContainer>*>button,.toolbar-root>button{display:flex;flex-direction:column;align-items:center;justify-content:center;padding-left:3px;padding-right:3px;min-width:40px;max-width:105px;width:min-content;font-size:1em}.toolbar-button>label{cursor:inherit;user-select:none;-webkit-user-select:none}.toolbar-root>.toolbar-toolContainer>.toolbar-button>label.long-label{font-size:.75em}.toolbar-dropdown>.toolbar-toolContainer>button,.toolbar-dropdown>.toolbar-toolContainer>.toolbar-button{width:6em}.toolbar-button:not(.disabled):hover,.toolbar-root button:not(:disabled):hover{box-shadow:0px 2px 4px var(--shadow-color)}.toolbar-root button:disabled{cursor:inherit;opacity:.5}.toolbar-root .toolbar-icon{flex-shrink:1;user-select:none;width:100%;min-width:20px;min-height:20px}.toolbar-toolContainer.selected>.toolbar-button{background-color:var(--selection-background-color);color:var(--selection-foreground-color);--icon-color: var(--selection-foreground-color)}.toolbar-toolContainer:not(.selected):not(.dropdownShowable)>.toolbar-button>.toolbar-showHideDropdownIcon{display:none}.toolbar-toolContainer>.toolbar-button>.toolbar-showHideDropdownIcon{height:15px;transition:transform .25s ease}.toolbar-toolContainer.dropdownVisible>.toolbar-button>.toolbar-showHideDropdownIcon{transform:rotate(180deg)}.toolbar-dropdown.hidden,.toolbar-toolContainer:not(.selected):not(.dropdownShowable)>.toolbar-dropdown:not(.hiding){display:none}.toolbar-dropdown{position:absolute;padding:15px;padding-top:5px;display:flex;flex-wrap:wrap;flex-direction:column;max-height:80vh;max-width:fit-content;z-index:2;background-color:var(--background-color-1);box-shadow:0px 3px 3px var(--shadow-color)}@keyframes dropdown-transition-in{0%{opacity:0;transform:scale(1, 0)}100%{opacity:1;transform:scale(1, 1)}}@keyframes dropdown-transition-out{0%{opacity:1;transform:scale(1, 1)}100%{opacity:0;transform:scale(1, 0)}}.toolbar-dropdown{transform-origin:top left;--dropdown-show-animation: dropdown-transition-in;--dropdown-hide-animation: dropdown-transition-out}@media(prefers-reduced-motion: reduce){.toolbar-dropdown{--dropdown-show-animation: none;--dropdown-hide-animation: none}.toolbar-dropdown.hiding{display:none}.toolbar-toolContainer>.toolbar-button>.toolbar-showHideDropdownIcon{transition:none}:root .toolbar-button,.toolbar-root button{transition:none}}.toolbar-buttonGroup{display:flex;flex-direction:row;justify-content:center}.toolbar-element .toolbar--toggle-button{color:var(--foreground-color-1);font-weight:normal}.toolbar-element .toolbar--toggle-button[aria-checked=true]{background:var(--selection-background-color);color:var(--selection-foreground-color)}.toolbar-element .toolbar--toggle-button>.icon{width:25px;height:25px;margin:0 5px}.toolbar-element .toolbar--toggle-button>*{vertical-align:middle}.toolbar-closeColorPickerOverlay{display:none;position:fixed;top:0;left:0;bottom:0;right:0;touch-action:none;background-color:var(--background-color-1);opacity:.3;z-index:2}.toolbar-spacedList>*{padding-bottom:5px;padding-top:5px}.toolbar-indentedList{padding-left:10px}@media print{.toolbar-element{display:none}}@keyframes rehide-label{0%{opacity:.8}80%{opacity:.8}100%{opacity:.1}}@keyframes show-label-delayed{0%{opacity:0}80%{opacity:0}100%{opacity:.8}}@keyframes show-label-now{0%{opacity:0}5%{opacity:0}100%{opacity:.8}}@keyframes keep-label-hidden{0%{opacity:0}100%{opacity:0}}@keyframes toolbar--edgemenu-transition-in{from{transform:translate(0, 100%)}to{transform:translate(0, 0)}}@keyframes toolbar--edgemenu-transition-in-reduce-motion{from{opacity:0}to{opacity:1}}@keyframes toolbar--edgemenu-transition-out{to{transform:translate(0, 100%)}}@keyframes toolbar--edgemenu-transition-out-reduce-motion{from{opacity:1}to{opacity:0}}@keyframes toolbar--edgemenu-container-transition-in{from{overflow-y:hidden}to{overflow-y:hidden}}@keyframes toolbar--edgemenu-container-transition-out{from{overflow-y:hidden}to{overflow-y:hidden}}.toolbar-edge-toolbar{--toolbar-button-height: min(20vh, 48px);--toolbar-button-size: var(--toolbar-button-height);--label-hover-offset-size: calc(14px + var(--toolbar-button-height));box-sizing:border-box;flex-direction:row;justify-content:space-around;--button-label-hover-offset-y: var(--label-hover-offset-size);--button-label-hover-offset-x: 0}@media screen and (min-width: 540px){.toolbar-edge-toolbar{flex-wrap:nowrap}.toolbar-edge-toolbar>.toolbar-action-row{max-width:50vw;flex-grow:0;flex-shrink:0}}@media screen and (max-width: 700px){.toolbar-edge-toolbar.one-row>*>.toolbar-toolContainer.label-inline{font-size:.9em}.toolbar-edge-toolbar.one-row>*>.toolbar-toolContainer.label-inline>.toolbar-button{width:var(--toolbar-button-size)}.toolbar-edge-toolbar.one-row>*>.toolbar-toolContainer.label-inline>.toolbar-button label{opacity:0;animation:.2s linear hide-initially}@keyframes hide-initially{from{opacity:0}to{opacity:0}}.toolbar-edge-toolbar.one-row>*>.toolbar-toolContainer.label-inline>.toolbar-button:not(.no-long-press-or-hover):not(.has-long-press-or-hover):hover:not(:focus-visible)>label,.toolbar-edge-toolbar.one-row>*>.toolbar-toolContainer.label-inline>.toolbar-button:not(.no-long-press-or-hover):not(.has-long-press-or-hover):active>label{opacity:.8;animation:1s ease show-label-delayed}.toolbar-edge-toolbar.one-row>*>.toolbar-toolContainer.label-inline>.toolbar-button.has-long-press-or-hover>label{opacity:.8}.toolbar-edge-toolbar.one-row>*>.toolbar-toolContainer.label-inline>.toolbar-button:focus-visible>label,.toolbar-edge-toolbar.one-row>*>.toolbar-toolContainer.label-inline>.toolbar-button.focus-visible>label{animation:1.5s ease rehide-label;opacity:0}.toolbar-edge-toolbar.one-row>*>.toolbar-toolContainer.label-inline>.toolbar-button:has(:focus-visible)>label{animation:1.5s ease rehide-label;opacity:0}.toolbar-edge-toolbar.one-row>*>.toolbar-toolContainer.label-inline>.toolbar-button>label{opacity:0;position:absolute;margin-top:var(--button-label-hover-offset-y);margin-left:var(--button-label-hover-offset-x);z-index:1;pointer-events:none;background-color:var(--background-color-1);color:var(--foreground-color-1);border-radius:25px;padding:10px;transition:.3s ease opacity,.2s ease margin-top}}@media screen and (max-width: 700px)and (prefers-reduced-motion: reduce){.toolbar-edge-toolbar.one-row>*>.toolbar-toolContainer.label-inline>.toolbar-button>label{transition:none}}@media screen and (max-width: 700px){.toolbar-edge-toolbar.one-row>*>.toolbar-toolContainer.label-inline>.toolbar-button>.toolbar-icon.toolbar-icon{margin-left:0;margin-right:0}}.toolbar-edge-toolbar>div.toolbar-element{flex-direction:row;display:flex;flex-grow:1;justify-content:center;background-color:var(--background-color-2);color:var(--foreground-color-2);--icon-color: var(--foreground-color-2);--extra-left-right-padding: 0px}.toolbar-edge-toolbar>div.toolbar-element::-webkit-scrollbar{width:3px;height:3px}.toolbar-edge-toolbar>div.toolbar-element::-webkit-scrollbar-thumb{background-color:var(--shadow-color)}.toolbar-edge-toolbar>div.toolbar-element.toolbar-tool-row{overflow-x:auto;overflow-y:hidden;flex-grow:100}.toolbar-edge-toolbar>div.toolbar-element.toolbar-action-row{z-index:2;background-color:var(--background-color-3);color:var(--foreground-color-3);--icon-color: var(--foreground-color-3)}.toolbar-edge-toolbar>div.toolbar-element.has-scroll{justify-content:start;position:relative;--button-label-hover-offset-y: 0;--button-label-hover-offset-x: calc(0px - var(--label-hover-offset-size))}.toolbar-edge-toolbar>div.toolbar-element.has-scroll>:nth-child(1){--button-label-hover-offset-x: var(--label-hover-offset-size)}.toolbar-edge-toolbar .toolbar-toolContainer.selected>.toolbar-button{background-color:var(--selection-background-color);color:var(--selection-foreground-color);--icon-color: var(--selection-foreground-color)}.toolbar-edge-toolbar .toolbar-button{box-sizing:border-box;background-color:rgba(0,0,0,0)}.toolbar-edge-toolbar .toolbar-button .toolbar-showHideDropdownIcon{flex-shrink:.01;height:12px}.toolbar-edge-toolbar .toolbar-toolContainer{order:1}.toolbar-edge-toolbar .toolbar-toolContainer.label-inline{flex-grow:1;display:flex;--button-flex-direction: row}.toolbar-edge-toolbar .toolbar-toolContainer.label-inline.label-left{justify-content:end;--button-flex-direction: row-reverse;order:100}.toolbar-edge-toolbar .toolbar-toolContainer.label-inline.label-left>.toolbar-button>.toolbar-icon{margin-left:7px;margin-right:0}.toolbar-edge-toolbar .toolbar-toolContainer.label-inline.label-right{order:-1}.toolbar-edge-toolbar .toolbar-toolContainer.label-inline>.toolbar-button{width:auto;flex-direction:var(--button-flex-direction)}.toolbar-edge-toolbar .toolbar-toolContainer.label-inline>.toolbar-button>.toolbar-icon{height:100%;margin-right:7px;margin-left:0;width:22px}.toolbar-edge-toolbar .toolbar-toolContainer:not(.no-icon):not(.label-inline) .toolbar-button{width:calc(var(--toolbar-button-size) + var(--extra-left-right-padding));height:var(--toolbar-button-size)}.toolbar-edge-toolbar .toolbar-toolContainer:not(.no-icon):not(.label-inline) .toolbar-button:not(.no-long-press-or-hover):not(.has-long-press-or-hover):hover:not(:focus-visible)>label,.toolbar-edge-toolbar .toolbar-toolContainer:not(.no-icon):not(.label-inline) .toolbar-button:not(.no-long-press-or-hover):not(.has-long-press-or-hover):active>label{opacity:.8;animation:1s ease show-label-delayed}.toolbar-edge-toolbar .toolbar-toolContainer:not(.no-icon):not(.label-inline) .toolbar-button.has-long-press-or-hover>label{opacity:.8}.toolbar-edge-toolbar .toolbar-toolContainer:not(.no-icon):not(.label-inline) .toolbar-button:focus-visible>label,.toolbar-edge-toolbar .toolbar-toolContainer:not(.no-icon):not(.label-inline) .toolbar-button.focus-visible>label{animation:1.5s ease rehide-label;opacity:0}.toolbar-edge-toolbar .toolbar-toolContainer:not(.no-icon):not(.label-inline) .toolbar-button:has(:focus-visible)>label{animation:1.5s ease rehide-label;opacity:0}.toolbar-edge-toolbar .toolbar-toolContainer:not(.no-icon):not(.label-inline) .toolbar-button>label{opacity:0;position:absolute;margin-top:var(--button-label-hover-offset-y);margin-left:var(--button-label-hover-offset-x);z-index:1;pointer-events:none;background-color:var(--background-color-1);color:var(--foreground-color-1);border-radius:25px;padding:10px;transition:.3s ease opacity,.2s ease margin-top}@media(prefers-reduced-motion: reduce){.toolbar-edge-toolbar .toolbar-toolContainer:not(.no-icon):not(.label-inline) .toolbar-button>label{transition:none}}.toolbar-edge-toolbar .toolbar-toolContainer:not(.no-icon):not(.label-inline).dropdownVisible>.toolbar-button>label{opacity:.8;animation:1.5s ease rehide-label .3s,1s ease keep-label-hidden 1.8s infinite}.toolbar-edge-toolbar>div>.toolbar-toolContainer:not(.selected):not(.dropdownShowable)>.toolbar-button>.toolbar-showHideDropdownIcon{display:block;visibility:hidden}.toolbar-edge-toolbar .toolbar-toolContainer>.toolbar-button{margin:0;border-radius:0;padding:8px;box-shadow:none}.toolbar-edge-toolbar .toolbar-toolContainer>.toolbar-button.has-dropdown{padding-left:8px;padding-right:8px;padding-top:8px;padding-bottom:0px}.imageEditorContainer.pipette--color-selection-in-progress .toolbar-edgemenu-container{height:0;background-color:rgba(0,0,0,0);opacity:.9}.imageEditorContainer.pipette--color-selection-in-progress .toolbar-edgemenu-container .toolbar-edgemenu{position:absolute}.toolbar-edgemenu-container{background-color:var(--background-color-transparent);transition:.15s ease-in-out height,.15s ease-in-out background-color,.2s ease-in-out opacity;position:absolute;width:var(--editor-current-width-px);height:var(--editor-current-height-px);box-sizing:border-box;display:flex;flex-direction:column-reverse;align-items:center;z-index:2}@media(prefers-reduced-motion: reduce){.toolbar-edgemenu-container{transition:.15s ease-in-out background-color,.2s ease-in-out opacity}}.toolbar-edgemenu-container.dropdown-below-edge{overflow-y:hidden}.toolbar-edgemenu-container button{font-size:1.2em;box-shadow:none;border:none;padding:10px;transition:.2s ease box-shadow;font-weight:bold;color:var(--primary-action-foreground-color)}.toolbar-edgemenu-container button:not(:disabled):hover{box-shadow:0 1px 2px var(--shadow-color)}.toolbar-edgemenu-container button:disabled{opacity:.5;font-weight:unset;cursor:unset;color:var(--foreground-color-1)}.toolbar-edgemenu-container .toolbar-grid-selector .choice-button{--button-label-hover-offset-y: var(--button-size)}.toolbar-edgemenu-container .toolbar-grid-selector .choice-button:not(.no-long-press-or-hover):not(.has-long-press-or-hover):hover:not(:focus-visible)>label>.button-label-text,.toolbar-edgemenu-container .toolbar-grid-selector .choice-button:not(.no-long-press-or-hover):not(.has-long-press-or-hover):active>label>.button-label-text{opacity:.8;animation:1s ease show-label-delayed}.toolbar-edgemenu-container .toolbar-grid-selector .choice-button.has-long-press-or-hover>label>.button-label-text{opacity:.8}.toolbar-edgemenu-container .toolbar-grid-selector .choice-button:focus-visible>label>.button-label-text,.toolbar-edgemenu-container .toolbar-grid-selector .choice-button.focus-visible>label>.button-label-text{animation:1.5s ease rehide-label;opacity:0}.toolbar-edgemenu-container .toolbar-grid-selector .choice-button:has(:focus-visible)>label>.button-label-text{animation:1.5s ease rehide-label;opacity:0}.toolbar-edgemenu-container .toolbar-grid-selector .choice-button>label>.button-label-text{opacity:0;position:absolute;margin-top:var(--button-label-hover-offset-y);margin-left:var(--button-label-hover-offset-x);z-index:1;pointer-events:none;background-color:var(--background-color-1);color:var(--foreground-color-1);border-radius:25px;padding:10px;transition:.3s ease opacity,.2s ease margin-top}@media(prefers-reduced-motion: reduce){.toolbar-edgemenu-container .toolbar-grid-selector .choice-button>label>.button-label-text{transition:none}}.toolbar-edgemenu-container .toolbar-help-overlay-button{align-items:last baseline}.toolbar-edgemenu-container .toolbar-edgemenu{--toolbar-button-height: 48px;touch-action:none;user-select:none;-webkit-user-select:none;background-color:var(--background-color-2);color:var(--foreground-color-2);--icon-color: var(--foreground-color-2);box-shadow:0px 0px 1px var(--shadow-color);padding-left:10px;padding-right:10px;width:min(400px,100vw);box-sizing:border-box;border-top-left-radius:30px;border-top-right-radius:30px;transition:transform .1s ease,padding-bottom .1s ease}.toolbar-edgemenu-container .toolbar-edgemenu input,.toolbar-edgemenu-container .toolbar-edgemenu textarea{user-select:auto;-webkit-user-select:auto}.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-toolContainer{display:inline-block}.toolbar-edgemenu-container .toolbar-edgemenu button{background-color:rgba(0,0,0,0)}.toolbar-edgemenu-container .toolbar-edgemenu>button.drag-elem{height:40px;display:block;cursor:ns-resize;position:relative;margin-top:-15px;margin-bottom:10px;width:100%;border:none;box-shadow:none;background:rgba(0,0,0,0)}.toolbar-edgemenu-container .toolbar-edgemenu>button.drag-elem::before{content:\"\";background-color:var(--icon-color);opacity:.2;display:block;position:relative;top:10px;height:5px;border-radius:5px;width:min(80%,40px);margin-left:auto;margin-right:auto}.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-toolContainer{display:block}.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-toolContainer .toolbar-button{flex-direction:row;max-width:unset;width:100%;box-sizing:border-box;justify-content:flex-start;box-shadow:none;padding:2px}.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-toolContainer .toolbar-button>.toolbar-icon{width:25px;height:25px;padding:13px;margin-right:15px}.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-toolContainer .toolbar-button label,.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-toolContainer .toolbar-button>label.long-label{font-size:1em}.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-nonbutton-controls-main-list{padding-left:10px;padding-right:10px}.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-spacedList{box-sizing:border-box;--align-items-to-x: 105px}.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-spacedList>div{display:flex;align-items:center;margin-top:5px;min-height:35px}.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-spacedList>div:first-child{margin-top:0}.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-spacedList>div>label{padding-right:35px;min-width:var(--align-items-to-x);flex-shrink:1;box-sizing:border-box}.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-spacedList>div>input[type=checkbox]{width:20px;height:20px;margin-left:0}.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-spacedList>div>input:not([type=checkbox]){flex-grow:1;min-width:48px;flex-shrink:1}.toolbar-dropdown-toolbar button,.toolbar-dropdown-toolbar .toolbar-button{background-color:var(--background-color-2);color:var(--foreground-color-2);--icon-color: var(--foreground-color-2)}.toolbar-dropdown-toolbar,.toolbar-dropdown-toolbar .toolbar-dropdown{background-color:var(--background-color-3);color:var(--foreground-color-3)}.toolbar-dropdown-toolbar .toolbar-spacedList>div>label{padding-right:10px;min-width:50px}.toolbar-dropdown-toolbar .clr-field button{width:100%;height:100%;top:50%;left:0;border-radius:5px}.toolbar-dropdown-toolbar .toolbar-grid-selector>div{--button-size: 57px}.toolbar-dropdown-toolbar .toolbar-dropdown>div>.toolbar-toolContainer{display:inline-block}.toolbar-help-overlay{width:100%;height:100%;max-width:none;max-height:none;border:none;margin:0;padding:0;z-index:5;touch-action:none;overflow:hidden;color:#fff;--icon-color: white;background-color:rgba(0,0,0,0);display:flex;flex-direction:column;transition:.3s ease transform}.toolbar-help-overlay::backdrop{background-color:rgba(0,0,0,.8);backdrop-filter:blur(1px);-webkit-backdrop-filter:blur(1px)}.toolbar-help-overlay,.toolbar-help-overlay::backdrop{animation:.25s ease transition-in}@keyframes transition-in{0%{opacity:0}100%{opacity:1}}@keyframes transition-out{0%{opacity:1}100%{opacity:0}}.toolbar-help-overlay.-hiding,.toolbar-help-overlay.-hiding::backdrop{animation:.25s ease transition-out;opacity:0}.toolbar-help-overlay.-dragging{transition:none}@media(prefers-reduced-motion: reduce){.toolbar-help-overlay{transition:none}}@media screen and (min-width: 800px){.toolbar-help-overlay>.navigation-buttons{order:1;margin-top:auto}}.toolbar-help-overlay .with-text-shadow,.toolbar-help-overlay .help-page-container>.label,.toolbar-help-overlay button{text-shadow:0 0 3px rgba(20,20,20,.9);filter:drop-shadow(0px 0px 2px rgba(0, 0, 0, 0.5))}.toolbar-help-overlay button:not(:disabled){cursor:pointer}.toolbar-help-overlay button{background:rgba(0,0,0,0);border:none;color:var(--help-overlay-foreground);border-radius:15px}.toolbar-help-overlay .close-button{align-self:flex-start;width:48px;height:48px;z-index:1}.toolbar-help-overlay .close-button>svg{width:100%}.toolbar-help-overlay .navigation-content{flex-grow:1;display:flex}.toolbar-help-overlay .help-page-container{display:flex;align-items:center;flex-grow:1;touch-action:none}.toolbar-help-overlay .help-page-container>.label{flex-grow:1;text-align:center;font-size:18.5pt;margin-left:15px;margin-right:15px;margin-top:0px;z-index:1;transition:.5s ease margin-top}.toolbar-help-overlay .help-page-container>.label.-large-space-below{margin-top:0;margin-bottom:auto}.toolbar-help-overlay .help-page-container>.label.-small-space-above{margin-top:40px;margin-bottom:auto}.toolbar-help-overlay .help-page-container>.label.-large-space-above{margin-top:auto;margin-bottom:10px}@media(prefers-reduced-motion: reduce){.toolbar-help-overlay .help-page-container>.label{transition:none}}.toolbar-help-overlay .help-page-container>.cloned-element-container{position:absolute;z-index:0;user-select:none;-webkit-user-select:none;border-radius:10px;opacity:.01;background-color:rgba(100,100,100,.01);box-shadow:none;transition:.5s ease opacity,.5s ease background-color}.toolbar-help-overlay .help-page-container>.cloned-element-container *{pointer-events:none !important}.toolbar-help-overlay .help-page-container>.cloned-element-container>*{margin:0;opacity:.01 !important;transition:.3s ease opacity !important}.toolbar-help-overlay .help-page-container>.cloned-element-container:not(.-clickable) *{cursor:unset !important}.toolbar-help-overlay .help-page-container>.cloned-element-container.-clickable,.toolbar-help-overlay .help-page-container>.cloned-element-container.-background{z-index:1;touch-action:none}.toolbar-help-overlay .help-page-container>.cloned-element-container.-clickable{cursor:pointer;z-index:2}.toolbar-help-overlay .help-page-container>.cloned-element-container.-clickable.has-long-press-or-hover{opacity:.5 !important}.toolbar-help-overlay .help-page-container>.cloned-element-container.-clickable.has-long-press-or-hover,.toolbar-help-overlay .help-page-container>.cloned-element-container.-active{background-color:var(--background-color-1)}.toolbar-help-overlay .help-page-container>.cloned-element-container.-active{opacity:1;background-color:var(--background-color-1);box-shadow:0 0 3px rgba(100,100,100,.5)}.toolbar-help-overlay .help-page-container>.cloned-element-container.-active>*{opacity:1 !important}.toolbar-help-overlay .navigation-buttons{display:flex;flex-direction:row;justify-content:space-between;direction:ltr}.toolbar-help-overlay .navigation-buttons>button:disabled{opacity:.5}.toolbar-help-overlay .navigation-buttons>.next,.toolbar-help-overlay .navigation-buttons>.previous{font-size:1em;padding:10px;transition:.2s ease font-size;z-index:3}@media(prefers-reduced-motion: reduce){.toolbar-help-overlay .navigation-buttons>.next,.toolbar-help-overlay .navigation-buttons>.previous{transition:none}}.toolbar-help-overlay .navigation-buttons:not(.-has-previous)>.next:not(:disabled){animation:.5s ease highlight-button .5s}@keyframes highlight-button{0%{transform:scale(1)}50%{transform:scale(1.2)}55%{transform:scale(1.2) rotate(2deg)}65%{transform:scale(1.2) rotate(-2deg)}100%{transform:scale(1)}}@media(prefers-reduced-motion: reduce){.toolbar-help-overlay .navigation-buttons:not(.-has-previous)>.next:not(:disabled){animation:none}}.toolbar-help-overlay .navigation-buttons>.next::after{content:\"\\u276F\";margin-left:3px}.toolbar-help-overlay .navigation-buttons>.previous::before{content:\"\\u276E\";margin-right:3px}.toolbar-help-overlay .navigation-buttons.-has-next>.next{font-size:1.4em}.toolbar-help-overlay .navigation-buttons.-has-previous>.previous{font-size:1.4em}.toolbar-help-overlay .navigation-buttons.-highlight-next>.next,.toolbar-help-overlay .navigation-buttons.-highlight-previous>.previous{font-weight:bold;background-color:rgba(200,200,200,.1);font-size:1.4em}.toolbar-help-overlay .navigation-help{margin-top:1em;font-size:.7em}.toolbar-element .toolbar-help-overlay-button{height:0;position:relative;display:flex;justify-content:end}.toolbar-element .toolbar-help-overlay-button>.button{margin:0;padding:5px;padding-top:0;padding-bottom:0;box-shadow:none;text-align:center;opacity:.5}.toolbar-element .toolbar-help-overlay-button>.button>.icon{width:1.18em;height:1.18em;transition:.2s ease filter}.toolbar-element .toolbar-help-overlay-button>.button:focus-visible>.icon,.toolbar-element .toolbar-help-overlay-button>.button:hover>.icon{filter:drop-shadow(0px 0px 1px var(--shadow-color))}.ScrollbarTool-overlay{width:0;height:0;overflow:visible;opacity:.2;pointer-events:none;--fade-out-animation: 1s ease 0s fade-out;--scrollbar-size: 3px}@media(prefers-reduced-motion: reduce){.ScrollbarTool-overlay{--fade-out-animation: none !important}}@keyframes fade-out{from{opacity:.2}to{opacity:0}}.ScrollbarTool-overlay:not(.just-updated){animation:var(--fade-out-animation);opacity:0}.ScrollbarTool-overlay .vertical-scrollbar,.ScrollbarTool-overlay .horizontal-scrollbar{width:var(--scrollbar-size);height:var(--scrollbar-size);min-width:var(--scrollbar-size);min-height:var(--scrollbar-size);background-color:var(--foreground-color-1);border-radius:var(--scrollbar-size);position:absolute}.ScrollbarTool-overlay .vertical-scrollbar.represents-no-scroll,.ScrollbarTool-overlay .horizontal-scrollbar.represents-no-scroll{animation:var(--fade-out-animation);opacity:0}.ScrollbarTool-overlay:not(.scrollbar-left) .vertical-scrollbar{margin-left:calc(var(--editor-current-display-width-px) - var(--scrollbar-size))}.ScrollbarTool-overlay:not(.scrollbar-top) .horizontal-scrollbar{margin-top:calc(var(--editor-current-display-height-px) - var(--scrollbar-size))}.clipboard-error-dialog details>summary{cursor:pointer}.clipboard-error-dialog details[open]{margin-bottom:12px}.clipboard-error-dialog textarea{width:100%;box-sizing:border-box}.selection-tool-selection-background{background-color:var(--selection-background-color);opacity:.5;overflow:visible}.selection-tool-handle{position:absolute;box-sizing:border-box;display:flex;align-items:center;justify-content:center;--max-size: 17px}.selection-tool-handle .selection-tool-content{border:1px solid var(--foreground-color-1);background:var(--background-color-1);box-sizing:border-box;max-width:var(--max-size);max-height:var(--max-size);width:100%;height:100%;display:flex;justify-content:center;align-items:center;padding:3px}.selection-tool-handle .selection-tool-content .icon{width:100%;height:100%}.selection-tool-handle.selection-tool-circle .selection-tool-content{border-radius:100%}.selection-tool-handle.selection-tool-rotate{--max-size: 28px;cursor:grab}.selection-tool-handle.selection-tool-resize-x{cursor:ew-resize}.selection-tool-handle.selection-tool-resize-y{cursor:ns-resize}.selection-tool-handle.selection-tool-resize-xy{cursor:nwse-resize}.selection-tool-rotated-near-perpendicular .selection-tool-handle.selection-tool-resize-x{cursor:ns-resize}.selection-tool-rotated-near-perpendicular .selection-tool-handle.selection-tool-resize-y{cursor:ew-resize}.selection-tool-rotated-near-perpendicular .selection-tool-handle.selection-tool-resize-xy{cursor:nesw-resize}.selection-tool-selection-menu>button{max-height:var(--vertical-offset);background-color:var(--background-color-1);width:24px;height:24px;padding:6px;font-size:14px;user-select:none;-webkit-user-select:none;color:var(--foreground-color-1);border:.5px solid var(--foreground-color-1);border-radius:3px;opacity:.8;transition:.2s ease opacity}.selection-tool-selection-menu>button:hover,.selection-tool-selection-menu>button:focus-visible{background-color:var(--background-color-2);color:var(--foreground-color-2);cursor:pointer;opacity:1}.selection-tool-selection-menu>button>.icon{width:100%;height:100%}.overlay.handleOverlay{touch-action:none;direction:ltr}.overlay.handleOverlay,.overlay.handleOverlay .selection-tool-selection-outer-container{height:0;overflow:visible}.overlay.handleOverlay .selection-tool-selection-inner-container{width:var(--editor-current-display-width-px);height:var(--editor-current-display-height-px);overflow:hidden;pointer-events:none}.overlay.handleOverlay .selection-tool-selection-inner-container>*{pointer-events:all}.overlay.handleOverlay .selection-tool-selection-inner-container.-empty{opacity:0}.overlay.handleOverlay .selection-tool-selection-inner-container.-hide-handles .selection-tool-handle{display:none}@keyframes selection-duplicated-animation{0%{scale:1 1}50%{scale:1.02 1.02}100%{scale:1 1}}@media(prefers-reduced-motion: reduce){@keyframes selection-duplicated-animation{}}.find-tool-overlay{order:-1;position:absolute}.js-draw-sound-ui-toggle{width:0px;height:0px;overflow:hidden;user-select:none;-webkit-user-select:none}.js-draw-sound-ui-toggle button{margin-top:1px}.js-draw-sound-ui-toggle:focus-within,.js-draw-sound-ui-toggle.sound-ui-tool-enabled{overflow:visible;z-index:5}.js-draw-sound-ui-toggle:not(:focus-within):not(:hover).sound-ui-tool-enabled{opacity:.5}@keyframes show-popup-menu-animation{from{opacity:0}to{opacity:1}}.editor-popup-menu{width:100%;height:100%;background-color:rgba(0,0,0,0);border:none;animation:var(--hide-menu-animation-timeout) ease show-popup-menu-animation;opacity:1;transition:var(--hide-menu-animation-timeout) ease opacity;overflow:hidden}.editor-popup-menu.-hide{opacity:0}.editor-popup-menu>.content{position:absolute;left:var(--anchor-x);top:var(--anchor-y);display:flex;flex-direction:column;overflow:clip;border-radius:6px;box-shadow:0px 1px 2px var(--shadow-color);background-color:var(--background-color-1)}.editor-popup-menu::backdrop{background:rgba(0,0,0,0)}.editor-popup-menu-option{display:flex;justify-content:start;cursor:pointer;padding:5px;padding-top:6px;padding-bottom:6px;background-color:rgba(0,0,0,0);color:var(--foreground-color-1);--icon-color: currentColor;border:none;font-size:1em}.editor-popup-menu-option:hover,.editor-popup-menu-option:focus-visible{background-color:var(--background-color-2);color:var(--foreground-color-2)}.editor-popup-menu-option>:first-child{width:1em;height:1em;flex-shrink:0;margin-inline-start:0em;margin-inline-end:.25em}.about-dialog-content>.scroll{white-space:pre-wrap;font-family:monospace}.about-dialog-content>.scroll>details>summary{cursor:pointer}.about-dialog-content>.scroll>h2,.about-dialog-content>.scroll>details>summary{margin-top:15px;font-size:1.2em;font-weight:bold}.about-dialog-content>.scroll>h2 a,.about-dialog-content>.scroll>details>summary a{color:var(--foreground-color-1);text-decoration:underline}@keyframes fade-in{from{opacity:0}to{opacity:1}}.message-dialog-container dialog{display:flex}.message-dialog-container dialog.-closing{opacity:0}.message-dialog-container dialog.-closing::backdrop{opacity:0}.message-dialog-container dialog,.message-dialog-container dialog::backdrop{transition:opacity .2s ease;animation:fade-in .2s ease}.message-dialog-content{display:flex;flex-direction:column;flex-grow:1}.message-dialog-content>.close{display:block;margin-left:auto;margin-right:auto}.message-dialog-content>.scroll{flex-grow:1;flex-shrink:1;overflow-y:auto;margin-left:20px;margin-right:20px;padding-bottom:20px}.dialog-container>dialog{background-color:var(--background-color-1);color:var(--foreground-color-1);border:none;outline:none;box-shadow:0 0 2px var(--shadow-color);border-radius:8px;max-height:90vh;width:min(100%,500px);box-sizing:border-box}.dialog-container>dialog::backdrop{backdrop-filter:blur(5px);-webkit-backdrop-filter:blur(5px);background-color:var(--background-color-transparent)}#clr-picker{--clr-slider-size: 30px}#clr-picker #clr-color-area,#clr-picker .clr_hue{touch-action:none}#clr-picker .clr-alpha{margin-top:15px;margin-bottom:15px}#clr-picker.clr-picker input[type=range]::-moz-range-thumb{width:var(--clr-slider-size);height:var(--clr-slider-size)}#clr-picker.clr-picker input[type=range]::-webkit-slider-thumb{width:var(--clr-slider-size);height:var(--clr-slider-size)}#clr-picker.clr-picker input[type=range]::-webkit-slider-runnable-track{height:var(--clr-slider-size)}#clr-picker.clr-picker input[type=range]::-moz-range-track{height:var(--clr-slider-size)}.imageEditorContainer{--background-color-1: white;--foreground-color-1: black;--background-color-2: #f5f5f5;--foreground-color-2: #2c303a;--background-color-3: #e5e5e5;--foreground-color-3: #1c202a;--selection-background-color: #cbdaf1;--selection-foreground-color: #2c303a;--background-color-transparent: rgba(105, 100, 100, 0.5);--shadow-color: rgba(0, 0, 0, 0.5);--primary-action-foreground-color: #15b}@media(prefers-color-scheme: dark){.imageEditorContainer{--background-color-1: #151515;--foreground-color-1: white;--background-color-2: #222;--foreground-color-2: #efefef;--background-color-3: #272627;--foreground-color-3: #eee;--selection-background-color: #607;--selection-foreground-color: white;--shadow-color: rgba(250, 250, 250, 0.5);--background-color-transparent: rgba(50, 50, 50, 0.5);--primary-action-foreground-color: #7ae}}.imageEditorContainer{--icon-color: var(--foreground-color-1)}.imageEditorContainer{color:var(--foreground-color-1);font-family:system-ui,-apple-system,sans-serif;background-color:var(--background-color-1);width:100%;height:400px;min-height:220px;min-width:100px;writing-mode:horizontal-tb;box-sizing:border-box;display:flex;flex-direction:column-reverse}.imageEditorContainer input{accent-color:var(--primary-action-foreground-color)}.imageEditorContainer .imageEditorRenderArea{display:grid;grid-template-columns:1fr;flex-grow:2;flex-shrink:1;min-height:100px;min-width:0;width:100%;height:100%}.imageEditorContainer .imageEditorRenderArea canvas{grid-row:1/1;grid-column:1/1;touch-action:none;box-sizing:border-box;width:100%;height:100%;min-width:0;max-width:inherit;min-height:0px;max-height:inherit;user-select:none;-webkit-user-select:none;-webkit-user-drag:none}.imageEditorContainer .loadingMessage{position:fixed;text-align:center;font-size:2em;text-shadow:0px 0px 1px var(--background-color-1);bottom:0;left:0;right:0}.imageEditorContainer .accessibilityAnnouncement{opacity:0;width:0;height:0;overflow:hidden;pointer-events:none;user-select:none;-webkit-user-select:none}.imageEditorContainer .textRendererOutputContainer{width:.001px;height:.001px;overflow:hidden;-webkit-user-select:none;user-select:none}.imageEditorContainer .textRendererOutputContainer:focus-within{overflow:visible;z-index:5}.imageEditorContainer .anchored-element-overlay{overflow:visible;height:0}.imageEditorContainer .anchored-element-overlay>.content-wrapper{width:var(--editor-current-display-width-px);height:var(--editor-current-display-height-px);overflow:hidden;position:relative;pointer-events:none}.imageEditorContainer .anchored-element-overlay>.content-wrapper>.content{position:absolute;left:var(--position-x);top:var(--position-y);transform:scale(var(--scale)) rotate(var(--rotation));transform-origin:left top;margin:0;pointer-events:all}@media print{.imageEditorContainer .loadingMessage{display:none}.imageEditorContainer .imageEditorRenderArea canvas{width:100%;height:initial}}',document.head.appendChild(o)}})();(()=>{if(typeof document<\"u\"&&typeof document.createElement==\"function\"){let o=document.createElement(\"style\");o.textContent='.clr-picker{display:none;flex-wrap:wrap;position:absolute;width:200px;z-index:1000;border-radius:10px;background-color:#fff;justify-content:flex-end;direction:ltr;box-shadow:0 0 5px rgba(0, 0, 0, 0.05),0 5px 20px rgba(0, 0, 0, 0.1);-moz-user-select:none;-webkit-user-select:none;user-select:none}.clr-picker.clr-open,.clr-picker[data-inline=true]{display:flex}.clr-picker[data-inline=true]{position:relative}.clr-gradient{position:relative;width:100%;height:100px;margin-bottom:15px;border-radius:3px 3px 0 0;background-image:linear-gradient(rgba(0, 0, 0, 0), #000),linear-gradient(90deg, #fff, currentColor);cursor:pointer}.clr-marker{position:absolute;width:12px;height:12px;margin:-6px 0 0 -6px;border:1px solid #fff;border-radius:50%;background-color:currentColor;cursor:pointer}.clr-picker input[type=range]::-webkit-slider-runnable-track{width:100%;height:16px}.clr-picker input[type=range]::-webkit-slider-thumb{width:16px;height:16px;-webkit-appearance:none}.clr-picker input[type=range]::-moz-range-track{width:100%;height:16px;border:0}.clr-picker input[type=range]::-moz-range-thumb{width:16px;height:16px;border:0}.clr-hue{background-image:linear-gradient(to right, #f00 0%, #ff0 16.66%, #0f0 33.33%, #0ff 50%, #00f 66.66%, #f0f 83.33%, #f00 100%)}.clr-hue,.clr-alpha{position:relative;width:calc(100% - 40px);height:8px;margin:5px 20px;border-radius:4px}.clr-alpha span{display:block;height:100%;width:100%;border-radius:inherit;background-image:linear-gradient(90deg, rgba(0, 0, 0, 0), currentColor)}.clr-hue input,.clr-alpha input{position:absolute;width:calc(100% + 32px);height:16px;left:-16px;top:-4px;margin:0;background-color:transparent;opacity:0;cursor:pointer;appearance:none;-webkit-appearance:none}.clr-hue div,.clr-alpha div{position:absolute;width:16px;height:16px;left:0;top:50%;margin-left:-8px;transform:translateY(-50%);border:2px solid #fff;border-radius:50%;background-color:currentColor;box-shadow:0 0 1px #888;pointer-events:none}.clr-alpha div:before{content:\"\";position:absolute;height:100%;width:100%;left:0;top:0;border-radius:50%;background-color:currentColor}.clr-format{display:none;order:1;width:calc(100% - 40px);margin:0 20px 20px}.clr-segmented{display:flex;position:relative;width:100%;margin:0;padding:0;border:1px solid #ddd;border-radius:15px;box-sizing:border-box;color:#999;font-size:12px}.clr-segmented input,.clr-segmented legend{position:absolute;width:100%;height:100%;margin:0;padding:0;border:0;left:0;top:0;opacity:0;pointer-events:none}.clr-segmented label{flex-grow:1;margin:0;padding:4px 0;font-size:inherit;font-weight:normal;line-height:initial;text-align:center;cursor:pointer}.clr-segmented label:first-of-type{border-radius:10px 0 0 10px}.clr-segmented label:last-of-type{border-radius:0 10px 10px 0}.clr-segmented input:checked+label{color:#fff;background-color:#666}.clr-swatches{order:2;width:calc(100% - 32px);margin:0 16px}.clr-swatches div{display:flex;flex-wrap:wrap;padding-bottom:12px;justify-content:center}.clr-swatches button{position:relative;width:20px;height:20px;margin:0 4px 6px 4px;padding:0;border:0;border-radius:50%;color:inherit;text-indent:-1000px;white-space:nowrap;overflow:hidden;cursor:pointer}.clr-swatches button:after{content:\"\";display:block;position:absolute;width:100%;height:100%;left:0;top:0;border-radius:inherit;background-color:currentColor;box-shadow:inset 0 0 0 1px rgba(0, 0, 0, 0.1)}input.clr-color{order:1;width:calc(100% - 80px);height:32px;margin:15px 20px 20px auto;padding:0 10px;border:1px solid #ddd;border-radius:16px;color:#444;background-color:#fff;font-family:sans-serif;font-size:14px;text-align:center;box-shadow:none}input.clr-color:focus{outline:none;border:1px solid #1e90ff}.clr-close,.clr-clear{display:none;order:2;height:24px;margin:0 20px 20px;padding:0 20px;border:0;border-radius:12px;color:#fff;background-color:#666;font-family:inherit;font-size:12px;font-weight:400;cursor:pointer}.clr-close{display:block;margin:0 20px 20px auto}.clr-preview{position:relative;width:32px;height:32px;margin:15px 0 20px 20px;border-radius:50%;overflow:hidden}.clr-preview:before,.clr-preview:after{content:\"\";position:absolute;height:100%;width:100%;left:0;top:0;border:1px solid #fff;border-radius:50%}.clr-preview:after{border:0;background-color:currentColor;box-shadow:inset 0 0 0 1px rgba(0, 0, 0, 0.1)}.clr-preview button{position:absolute;width:100%;height:100%;z-index:1;margin:0;padding:0;border:0;border-radius:50%;outline-offset:-2px;background-color:transparent;text-indent:-9999px;cursor:pointer;overflow:hidden}.clr-marker,.clr-hue div,.clr-alpha div,.clr-color{box-sizing:border-box}.clr-field{display:inline-block;position:relative;color:transparent}.clr-field input{margin:0;direction:ltr}.clr-field.clr-rtl input{text-align:right}.clr-field button{position:absolute;width:30px;height:100%;right:0;top:50%;transform:translateY(-50%);margin:0;padding:0;border:0;color:inherit;text-indent:-1000px;white-space:nowrap;overflow:hidden;pointer-events:none}.clr-field.clr-rtl button{right:auto;left:0}.clr-field button:after{content:\"\";display:block;position:absolute;width:100%;height:100%;left:0;top:0;border-radius:inherit;background-color:currentColor;box-shadow:inset 0 0 1px rgba(0, 0, 0, 0.5)}.clr-alpha,.clr-alpha div,.clr-swatches button,.clr-preview:before,.clr-field button{background-image:repeating-linear-gradient(45deg, #aaa 25%, transparent 25%, transparent 75%, #aaa 75%, #aaa),repeating-linear-gradient(45deg, #aaa 25%, #fff 25%, #fff 75%, #aaa 75%, #aaa);background-position:0 0,4px 4px;background-size:8px 8px}.clr-marker:focus{outline:none}.clr-keyboard-nav .clr-marker:focus,.clr-keyboard-nav .clr-hue input:focus+div,.clr-keyboard-nav .clr-alpha input:focus+div,.clr-keyboard-nav .clr-segmented input:focus+label{outline:none;box-shadow:0 0 0 2px #1e90ff,0 0 2px 2px #fff}.clr-picker[data-alpha=false] .clr-alpha{display:none}.clr-picker[data-minimal=true]{padding-top:16px}.clr-picker[data-minimal=true] .clr-gradient,.clr-picker[data-minimal=true] .clr-hue,.clr-picker[data-minimal=true] .clr-alpha,.clr-picker[data-minimal=true] .clr-color,.clr-picker[data-minimal=true] .clr-preview{display:none}.clr-dark{background-color:#444}.clr-dark .clr-segmented{border-color:#777}.clr-dark .clr-swatches button:after{box-shadow:inset 0 0 0 1px rgba(255, 255, 255, 0.3)}.clr-dark input.clr-color{color:#fff;border-color:#777;background-color:#555}.clr-dark input.clr-color:focus{border-color:#1e90ff}.clr-dark .clr-preview:after{box-shadow:inset 0 0 0 1px rgba(255, 255, 255, 0.5)}.clr-dark .clr-alpha,.clr-dark .clr-alpha div,.clr-dark .clr-swatches button,.clr-dark .clr-preview:before{background-image:repeating-linear-gradient(45deg, #666 25%, transparent 25%, transparent 75%, #888 75%, #888),repeating-linear-gradient(45deg, #888 25%, #444 25%, #444 75%, #888 75%, #888)}.clr-picker.clr-polaroid{border-radius:6px;box-shadow:0 0 5px rgba(0, 0, 0, 0.1),0 5px 30px rgba(0, 0, 0, 0.2)}.clr-picker.clr-polaroid:before{content:\"\";display:block;position:absolute;width:16px;height:10px;left:20px;top:-10px;border:solid transparent;border-width:0 8px 10px 8px;border-bottom-color:currentColor;box-sizing:border-box;color:#fff;filter:drop-shadow(0 -4px 3px rgba(0, 0, 0, 0.1));pointer-events:none}.clr-picker.clr-polaroid.clr-dark:before{color:#444}.clr-picker.clr-polaroid.clr-left:before{left:auto;right:20px}.clr-picker.clr-polaroid.clr-top:before{top:auto;bottom:-10px;transform:rotateZ(180deg)}.clr-polaroid .clr-gradient{width:calc(100% - 20px);height:120px;margin:10px;border-radius:3px}.clr-polaroid .clr-hue,.clr-polaroid .clr-alpha{width:calc(100% - 30px);height:10px;margin:6px 15px;border-radius:5px}.clr-polaroid .clr-hue div,.clr-polaroid .clr-alpha div{box-shadow:0 0 5px rgba(0, 0, 0, 0.2)}.clr-polaroid .clr-format{width:calc(100% - 20px);margin:0 10px 15px}.clr-polaroid .clr-swatches{width:calc(100% - 12px);margin:0 6px}.clr-polaroid .clr-swatches div{padding-bottom:10px}.clr-polaroid .clr-swatches button{width:22px;height:22px}.clr-polaroid input.clr-color{width:calc(100% - 60px);margin:10px 10px 15px auto}.clr-polaroid .clr-clear{margin:0 10px 15px 10px}.clr-polaroid .clr-close{margin:0 10px 15px auto}.clr-polaroid .clr-preview{margin:10px 0 15px 10px}.clr-picker.clr-large{width:275px}.clr-large .clr-gradient{height:150px}.clr-large .clr-swatches button{width:22px;height:22px}.clr-picker.clr-pill{width:380px;padding-left:180px;box-sizing:border-box}.clr-pill .clr-gradient{position:absolute;width:180px;height:100%;left:0;top:0;margin-bottom:0;border-radius:3px 0 0 3px}.clr-pill .clr-hue{margin-top:20px}',document.head.appendChild(o)}})();})();\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/bundledStyles.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/Editor.js":
/*!*************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/Editor.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Editor = void 0;\nconst EditorImage_1 = __importDefault(__webpack_require__(/*! ./image/EditorImage */ \"./node_modules/js-draw/dist/cjs/image/EditorImage.js\"));\nconst ToolController_1 = __importDefault(__webpack_require__(/*! ./tools/ToolController */ \"./node_modules/js-draw/dist/cjs/tools/ToolController.js\"));\nconst types_1 = __webpack_require__(/*! ./types */ \"./node_modules/js-draw/dist/cjs/types.js\");\nconst inputEvents_1 = __webpack_require__(/*! ./inputEvents */ \"./node_modules/js-draw/dist/cjs/inputEvents.js\");\nconst UndoRedoHistory_1 = __importDefault(__webpack_require__(/*! ./UndoRedoHistory */ \"./node_modules/js-draw/dist/cjs/UndoRedoHistory.js\"));\nconst Viewport_1 = __importDefault(__webpack_require__(/*! ./Viewport */ \"./node_modules/js-draw/dist/cjs/Viewport.js\"));\nconst EventDispatcher_1 = __importDefault(__webpack_require__(/*! ./EventDispatcher */ \"./node_modules/js-draw/dist/cjs/EventDispatcher.js\"));\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\nconst Display_1 = __importStar(__webpack_require__(/*! ./rendering/Display */ \"./node_modules/js-draw/dist/cjs/rendering/Display.js\"));\nconst SVGLoader_1 = __importDefault(__webpack_require__(/*! ./SVGLoader/SVGLoader */ \"./node_modules/js-draw/dist/cjs/SVGLoader/SVGLoader.js\"));\nconst Pointer_1 = __importDefault(__webpack_require__(/*! ./Pointer */ \"./node_modules/js-draw/dist/cjs/Pointer.js\"));\nconst getLocalizationTable_1 = __importDefault(__webpack_require__(/*! ./localizations/getLocalizationTable */ \"./node_modules/js-draw/dist/cjs/localizations/getLocalizationTable.js\"));\nconst IconProvider_1 = __importDefault(__webpack_require__(/*! ./toolbar/IconProvider */ \"./node_modules/js-draw/dist/cjs/toolbar/IconProvider.js\"));\nconst CanvasRenderer_1 = __importDefault(__webpack_require__(/*! ./rendering/renderers/CanvasRenderer */ \"./node_modules/js-draw/dist/cjs/rendering/renderers/CanvasRenderer.js\"));\nconst untilNextAnimationFrame_1 = __importDefault(__webpack_require__(/*! ./util/untilNextAnimationFrame */ \"./node_modules/js-draw/dist/cjs/util/untilNextAnimationFrame.js\"));\nconst uniteCommands_1 = __importDefault(__webpack_require__(/*! ./commands/uniteCommands */ \"./node_modules/js-draw/dist/cjs/commands/uniteCommands.js\"));\nconst SelectionTool_1 = __importDefault(__webpack_require__(/*! ./tools/SelectionTool/SelectionTool */ \"./node_modules/js-draw/dist/cjs/tools/SelectionTool/SelectionTool.js\"));\nconst Erase_1 = __importDefault(__webpack_require__(/*! ./commands/Erase */ \"./node_modules/js-draw/dist/cjs/commands/Erase.js\"));\nconst BackgroundComponent_1 = __importStar(__webpack_require__(/*! ./components/BackgroundComponent */ \"./node_modules/js-draw/dist/cjs/components/BackgroundComponent.js\"));\nconst sendPenEvent_1 = __importDefault(__webpack_require__(/*! ./testing/sendPenEvent */ \"./node_modules/js-draw/dist/cjs/testing/sendPenEvent.js\"));\nconst KeyboardShortcutManager_1 = __importDefault(__webpack_require__(/*! ./shortcuts/KeyboardShortcutManager */ \"./node_modules/js-draw/dist/cjs/shortcuts/KeyboardShortcutManager.js\"));\nconst EdgeToolbar_1 = __importDefault(__webpack_require__(/*! ./toolbar/EdgeToolbar */ \"./node_modules/js-draw/dist/cjs/toolbar/EdgeToolbar.js\"));\nconst StrokeKeyboardControl_1 = __importDefault(__webpack_require__(/*! ./tools/InputFilter/StrokeKeyboardControl */ \"./node_modules/js-draw/dist/cjs/tools/InputFilter/StrokeKeyboardControl.js\"));\nconst guessKeyCodeFromKey_1 = __importDefault(__webpack_require__(/*! ./util/guessKeyCodeFromKey */ \"./node_modules/js-draw/dist/cjs/util/guessKeyCodeFromKey.js\"));\nconst makeAboutDialog_1 = __importDefault(__webpack_require__(/*! ./dialogs/makeAboutDialog */ \"./node_modules/js-draw/dist/cjs/dialogs/makeAboutDialog.js\"));\nconst version_1 = __importDefault(__webpack_require__(/*! ./version */ \"./node_modules/js-draw/dist/cjs/version.js\"));\nconst editorImageToSVG_1 = __webpack_require__(/*! ./image/export/editorImageToSVG */ \"./node_modules/js-draw/dist/cjs/image/export/editorImageToSVG.js\");\nconst ReactiveValue_1 = __importStar(__webpack_require__(/*! ./util/ReactiveValue */ \"./node_modules/js-draw/dist/cjs/util/ReactiveValue.js\"));\nconst listenForKeyboardEventsFrom_1 = __importDefault(__webpack_require__(/*! ./util/listenForKeyboardEventsFrom */ \"./node_modules/js-draw/dist/cjs/util/listenForKeyboardEventsFrom.js\"));\nconst mitLicenseAttribution_1 = __importDefault(__webpack_require__(/*! ./util/mitLicenseAttribution */ \"./node_modules/js-draw/dist/cjs/util/mitLicenseAttribution.js\"));\nconst ClipboardHandler_1 = __importDefault(__webpack_require__(/*! ./util/ClipboardHandler */ \"./node_modules/js-draw/dist/cjs/util/ClipboardHandler.js\"));\nconst ContextMenuRecognizer_1 = __importDefault(__webpack_require__(/*! ./tools/InputFilter/ContextMenuRecognizer */ \"./node_modules/js-draw/dist/cjs/tools/InputFilter/ContextMenuRecognizer.js\"));\n/**\n * The main entrypoint for the full editor.\n *\n * ## Example\n * To create an editor with a toolbar,\n * ```ts,runnable\n * import { Editor } from 'js-draw';\n *\n * const editor = new Editor(document.body);\n *\n * const toolbar = editor.addToolbar();\n * toolbar.addSaveButton(() => {\n *   const saveData = editor.toSVG().outerHTML;\n *   // Do something with saveData...\n * });\n * ```\n *\n * See also\n * * [`examples.md`](https://github.com/personalizedrefrigerator/js-draw/blob/main/docs/examples.md).\n */\nclass Editor {\n    /**\n     * @example\n     * ```ts,runnable\n     * import { Editor } from 'js-draw';\n     *\n     * const container = document.body;\n     *\n     * // Create an editor\n     * const editor = new Editor(container, {\n     *   // 2e-10 and 1e12 are the default values for minimum/maximum zoom.\n     *   minZoom: 2e-10,\n     *   maxZoom: 1e12,\n     * });\n     *\n     * // Add the default toolbar\n     * const toolbar = editor.addToolbar();\n     *\n     * const createCustomIcon = () => {\n     *   // Create/return an icon here.\n     * };\n     *\n     * // Add a custom button\n     * toolbar.addActionButton({\n     *   label: 'Custom Button'\n     *   icon: createCustomIcon(),\n     * }, () => {\n     *   // Do something here\n     * });\n     * ```\n     */\n    constructor(parent, settings = {}) {\n        this.eventListenerTargets = [];\n        this.previousAccessibilityAnnouncement = '';\n        this.pointers = {};\n        this.announceUndoCallback = (command) => {\n            this.announceForAccessibility(this.localization.undoAnnouncement(command.description(this, this.localization)));\n        };\n        this.announceRedoCallback = (command) => {\n            this.announceForAccessibility(this.localization.redoAnnouncement(command.description(this, this.localization)));\n        };\n        // Listeners to be called once at the end of the next re-render.\n        this.nextRerenderListeners = [];\n        this.rerenderQueued = false;\n        this.closeAboutDialog = null;\n        this.localization = {\n            ...(0, getLocalizationTable_1.default)(),\n            ...settings.localization,\n        };\n        // Fill default settings.\n        this.settings = {\n            wheelEventsEnabled: settings.wheelEventsEnabled ?? true,\n            renderingMode: settings.renderingMode ?? Display_1.RenderingMode.CanvasRenderer,\n            localization: this.localization,\n            minZoom: settings.minZoom ?? 2e-10,\n            maxZoom: settings.maxZoom ?? 1e12,\n            keyboardShortcutOverrides: settings.keyboardShortcutOverrides ?? {},\n            iconProvider: settings.iconProvider ?? new IconProvider_1.default(),\n            notices: settings.notices ?? [],\n            appInfo: settings.appInfo ? { ...settings.appInfo } : null,\n            pens: {\n                additionalPenTypes: settings.pens?.additionalPenTypes ?? [],\n                filterPenTypes: settings.pens?.filterPenTypes ?? (() => true),\n            },\n            text: {\n                fonts: settings.text?.fonts ?? ['sans-serif', 'serif', 'monospace'],\n            },\n            image: {\n                showImagePicker: settings.image?.showImagePicker ?? undefined,\n            },\n            clipboardApi: settings.clipboardApi ?? null,\n        };\n        // Validate settings\n        if (this.settings.minZoom > this.settings.maxZoom) {\n            throw new Error('Minimum zoom must be lesser than maximum zoom!');\n        }\n        this.readOnly = ReactiveValue_1.MutableReactiveValue.fromInitialValue(false);\n        this.icons = this.settings.iconProvider;\n        this.shortcuts = new KeyboardShortcutManager_1.default(this.settings.keyboardShortcutOverrides);\n        this.container = document.createElement('div');\n        this.renderingRegion = document.createElement('div');\n        this.container.appendChild(this.renderingRegion);\n        this.container.classList.add('imageEditorContainer', 'js-draw');\n        this.loadingWarning = document.createElement('div');\n        this.loadingWarning.classList.add('loadingMessage');\n        this.loadingWarning.ariaLive = 'polite';\n        this.container.appendChild(this.loadingWarning);\n        this.accessibilityControlArea = document.createElement('textarea');\n        this.accessibilityControlArea.setAttribute('placeholder', this.localization.accessibilityInputInstructions);\n        this.accessibilityControlArea.style.opacity = '0';\n        this.accessibilityControlArea.style.width = '0';\n        this.accessibilityControlArea.style.height = '0';\n        this.accessibilityControlArea.style.position = 'absolute';\n        this.accessibilityAnnounceArea = document.createElement('div');\n        this.accessibilityAnnounceArea.setAttribute('aria-live', 'assertive');\n        this.accessibilityAnnounceArea.className = 'accessibilityAnnouncement';\n        this.container.appendChild(this.accessibilityAnnounceArea);\n        this.renderingRegion.style.touchAction = 'none';\n        this.renderingRegion.className = 'imageEditorRenderArea';\n        this.renderingRegion.appendChild(this.accessibilityControlArea);\n        this.renderingRegion.setAttribute('tabIndex', '0');\n        this.renderingRegion.setAttribute('alt', '');\n        this.notifier = new EventDispatcher_1.default();\n        this.viewport = new Viewport_1.default((oldTransform, newTransform) => {\n            this.notifier.dispatch(types_1.EditorEventType.ViewportChanged, {\n                kind: types_1.EditorEventType.ViewportChanged,\n                newTransform,\n                oldTransform,\n            });\n        });\n        this.display = new Display_1.default(this, this.settings.renderingMode, this.renderingRegion);\n        this.image = new EditorImage_1.default();\n        this.history = new UndoRedoHistory_1.default(this, this.announceRedoCallback, this.announceUndoCallback);\n        this.toolController = new ToolController_1.default(this, this.localization);\n        // TODO: Make this pipeline configurable (e.g. allow users to add global input stabilization)\n        this.toolController.addInputMapper(StrokeKeyboardControl_1.default.fromEditor(this));\n        this.toolController.addInputMapper(new ContextMenuRecognizer_1.default());\n        parent.appendChild(this.container);\n        this.viewport.updateScreenSize(math_1.Vec2.of(this.display.width, this.display.height));\n        this.registerListeners();\n        this.queueRerender();\n        this.hideLoadingWarning();\n        // Enforce zoom limits.\n        this.notifier.on(types_1.EditorEventType.ViewportChanged, (evt) => {\n            if (evt.kind !== types_1.EditorEventType.ViewportChanged)\n                return;\n            const getZoom = (mat) => mat.transformVec3(math_1.Vec2.unitX).length();\n            const zoom = getZoom(evt.newTransform);\n            if (zoom > this.settings.maxZoom || zoom < this.settings.minZoom) {\n                const oldZoom = getZoom(evt.oldTransform);\n                let resetTransform = math_1.Mat33.identity;\n                if (oldZoom <= this.settings.maxZoom && oldZoom >= this.settings.minZoom) {\n                    resetTransform = evt.oldTransform;\n                }\n                else {\n                    // If 1x zoom isn't acceptable, try a zoom between the minimum and maximum.\n                    resetTransform = math_1.Mat33.scaling2D((this.settings.minZoom + this.settings.maxZoom) / 2);\n                }\n                this.viewport.resetTransform(resetTransform);\n            }\n            else if (!isFinite(zoom)) {\n                // Recover from possible division-by-zero\n                console.warn(`Non-finite zoom (${zoom}) detected. Resetting the viewport. This was likely caused by division by zero.`);\n                if (isFinite(getZoom(evt.oldTransform))) {\n                    this.viewport.resetTransform(evt.oldTransform);\n                }\n                else {\n                    this.viewport.resetTransform();\n                }\n            }\n        });\n    }\n    /**\n     * @returns a shallow copy of the current settings of the editor.\n     *\n     * Do not modify.\n     */\n    getCurrentSettings() {\n        return {\n            ...this.settings,\n        };\n    }\n    /**\n     * @returns a reference to the editor's container.\n     *\n     * @example\n     * ```\n     *   // Set the editor's height to 500px\n     *   editor.getRootElement().style.height = '500px';\n     * ```\n     */\n    getRootElement() {\n        return this.container;\n    }\n    /**\n     * @returns the bounding box of the main rendering region of the editor in the HTML viewport.\n     *\n     * @internal\n     */\n    getOutputBBoxInDOM() {\n        return math_1.Rect2.of(this.renderingRegion.getBoundingClientRect());\n    }\n    /**\n     * Shows a \"Loading...\" message.\n     * @param fractionLoaded - should be a number from 0 to 1, where 1 represents completely loaded.\n     */\n    showLoadingWarning(fractionLoaded) {\n        const loadingPercent = Math.round(fractionLoaded * 100);\n        this.loadingWarning.innerText = this.localization.loading(loadingPercent);\n        this.loadingWarning.style.display = 'block';\n    }\n    /** @see {@link showLoadingWarning} */\n    hideLoadingWarning() {\n        this.loadingWarning.style.display = 'none';\n        this.announceForAccessibility(this.localization.doneLoading);\n    }\n    /**\n     * Announce `message` for screen readers. If `message` is the same as the previous\n     * message, it is re-announced.\n     */\n    announceForAccessibility(message) {\n        // Force re-announcing an announcement if announced again.\n        if (message === this.previousAccessibilityAnnouncement) {\n            message = message + '. ';\n        }\n        this.accessibilityAnnounceArea.innerText = message;\n        this.previousAccessibilityAnnouncement = message;\n    }\n    /**\n     * Creates a toolbar. If `defaultLayout` is true, default buttons are used.\n     * @returns a reference to the toolbar.\n     */\n    addToolbar(defaultLayout = true) {\n        const toolbar = new EdgeToolbar_1.default(this, this.container, this.localization);\n        if (defaultLayout) {\n            toolbar.addDefaults();\n        }\n        return toolbar;\n    }\n    registerListeners() {\n        this.handlePointerEventsFrom(this.renderingRegion);\n        this.handleKeyEventsFrom(this.renderingRegion);\n        this.handlePointerEventsFrom(this.accessibilityAnnounceArea);\n        // Prevent selected text from control areas from being dragged.\n        // See https://github.com/personalizedrefrigerator/joplin-plugin-freehand-drawing/issues/8\n        const preventSelectionOf = [\n            this.renderingRegion,\n            this.accessibilityAnnounceArea,\n            this.accessibilityControlArea,\n            this.loadingWarning,\n        ];\n        for (const element of preventSelectionOf) {\n            element.addEventListener('drag', (event) => {\n                event.preventDefault();\n                return false;\n            });\n            element.addEventListener('dragstart', (event) => {\n                event.preventDefault();\n                return false;\n            });\n        }\n        this.container.addEventListener('wheel', (evt) => {\n            this.handleHTMLWheelEvent(evt);\n        });\n        const handleResize = () => {\n            this.viewport.updateScreenSize(math_1.Vec2.of(this.display.width, this.display.height));\n            this.rerender();\n            this.updateEditorSizeVariables();\n        };\n        if ('ResizeObserver' in window) {\n            const resizeObserver = new ResizeObserver(handleResize);\n            resizeObserver.observe(this.renderingRegion);\n            resizeObserver.observe(this.container);\n        }\n        else {\n            addEventListener('resize', handleResize);\n        }\n        this.accessibilityControlArea.addEventListener('input', () => {\n            this.accessibilityControlArea.value = '';\n        });\n        const copyHandler = new ClipboardHandler_1.default(this);\n        document.addEventListener('copy', async (evt) => {\n            if (!this.isEventSink(document.querySelector(':focus'))) {\n                return;\n            }\n            copyHandler.copy(evt);\n        });\n        document.addEventListener('paste', (evt) => {\n            this.handlePaste(evt);\n        });\n    }\n    updateEditorSizeVariables() {\n        // Add CSS variables so that absolutely-positioned children of the editor can\n        // still fill the screen.\n        this.container.style.setProperty('--editor-current-width-px', `${this.container.clientWidth}px`);\n        this.container.style.setProperty('--editor-current-height-px', `${this.container.clientHeight}px`);\n        this.container.style.setProperty('--editor-current-display-width-px', `${this.renderingRegion.clientWidth}px`);\n        this.container.style.setProperty('--editor-current-display-height-px', `${this.renderingRegion.clientHeight}px`);\n    }\n    /** @internal */\n    handleHTMLWheelEvent(event) {\n        let delta = math_1.Vec3.of(event.deltaX, event.deltaY, event.deltaZ);\n        // Process wheel events if the ctrl key is down, even if disabled -- we do want to handle\n        // pinch-zooming.\n        if (!event.ctrlKey && !event.metaKey) {\n            if (!this.settings.wheelEventsEnabled) {\n                return;\n            }\n            else if (this.settings.wheelEventsEnabled === 'only-if-focused') {\n                const focusedChild = this.container.querySelector(':focus');\n                if (!focusedChild) {\n                    return;\n                }\n            }\n        }\n        if (event.deltaMode === WheelEvent.DOM_DELTA_LINE) {\n            delta = delta.times(15);\n        }\n        else if (event.deltaMode === WheelEvent.DOM_DELTA_PAGE) {\n            delta = delta.times(100);\n        }\n        if (event.ctrlKey || event.metaKey) {\n            delta = math_1.Vec3.of(0, 0, event.deltaY);\n        }\n        // Ensure that `pos` is relative to `this.renderingRegion`\n        const bbox = this.getOutputBBoxInDOM();\n        const pos = math_1.Vec2.of(event.clientX, event.clientY).minus(bbox.topLeft);\n        if (this.toolController.dispatchInputEvent({\n            kind: inputEvents_1.InputEvtType.WheelEvt,\n            delta,\n            screenPos: pos,\n        })) {\n            event.preventDefault();\n            return true;\n        }\n        return false;\n    }\n    getPointerList() {\n        const nowTime = performance.now();\n        const res = [];\n        for (const id in this.pointers) {\n            const maxUnupdatedTime = 2000; // Maximum time without a pointer update (ms)\n            if (this.pointers[id] && nowTime - this.pointers[id].timeStamp < maxUnupdatedTime) {\n                res.push(this.pointers[id]);\n            }\n        }\n        return res;\n    }\n    /**\n     * A protected method that can override setPointerCapture in environments where it may fail\n     * (e.g. with synthetic events). @internal\n     */\n    setPointerCapture(target, pointerId) {\n        try {\n            target.setPointerCapture(pointerId);\n        }\n        catch (error) {\n            console.warn('Failed to setPointerCapture', error);\n        }\n    }\n    /** Can be overridden in a testing environment to handle synthetic events. @internal */\n    releasePointerCapture(target, pointerId) {\n        try {\n            target.releasePointerCapture(pointerId);\n        }\n        catch (error) {\n            console.warn('Failed to releasePointerCapture', error);\n        }\n    }\n    /**\n     * Dispatches a `PointerEvent` to the editor. The target element for `evt` must have the same top left\n     * as the content of the editor.\n     */\n    handleHTMLPointerEvent(eventType, evt) {\n        const eventsRelativeTo = this.renderingRegion;\n        const eventTarget = evt.target ?? this.renderingRegion;\n        if (eventType === 'pointerdown') {\n            const pointer = Pointer_1.default.ofEvent(evt, true, this.viewport, eventsRelativeTo);\n            this.pointers[pointer.id] = pointer;\n            this.setPointerCapture(eventTarget, pointer.id);\n            const event = {\n                kind: inputEvents_1.InputEvtType.PointerDownEvt,\n                current: pointer,\n                allPointers: this.getPointerList(),\n            };\n            this.toolController.dispatchInputEvent(event);\n            return true;\n        }\n        else if (eventType === 'pointermove') {\n            const pointer = Pointer_1.default.ofEvent(evt, this.pointers[evt.pointerId]?.down ?? false, this.viewport, eventsRelativeTo);\n            if (pointer.down) {\n                const prevData = this.pointers[pointer.id];\n                if (prevData) {\n                    const distanceMoved = pointer.screenPos.distanceTo(prevData.screenPos);\n                    // If the pointer moved less than two pixels, don't send a new event.\n                    if (distanceMoved < 2) {\n                        return false;\n                    }\n                }\n                this.pointers[pointer.id] = pointer;\n                if (this.toolController.dispatchInputEvent({\n                    kind: inputEvents_1.InputEvtType.PointerMoveEvt,\n                    current: pointer,\n                    allPointers: this.getPointerList(),\n                })) {\n                    evt.preventDefault();\n                }\n            }\n            return true;\n        }\n        else if (eventType === 'pointercancel' || eventType === 'pointerup') {\n            const pointer = Pointer_1.default.ofEvent(evt, false, this.viewport, eventsRelativeTo);\n            if (!this.pointers[pointer.id]) {\n                return false;\n            }\n            this.pointers[pointer.id] = pointer;\n            this.releasePointerCapture(eventTarget, pointer.id);\n            if (this.toolController.dispatchInputEvent({\n                kind: inputEvents_1.InputEvtType.PointerUpEvt,\n                current: pointer,\n                allPointers: this.getPointerList(),\n            })) {\n                evt.preventDefault();\n            }\n            delete this.pointers[pointer.id];\n            return true;\n        }\n        return eventType;\n    }\n    isEventSink(evtTarget) {\n        let currentElem = evtTarget;\n        while (currentElem !== null) {\n            for (const elem of this.eventListenerTargets) {\n                if (elem === currentElem) {\n                    return true;\n                }\n            }\n            currentElem = currentElem.parentElement;\n        }\n        return false;\n    }\n    /** @internal */\n    async handleDrop(evt) {\n        evt.preventDefault();\n        await this.handlePaste(evt);\n    }\n    /** @internal */\n    async handlePaste(evt) {\n        const target = document.querySelector(':focus') ?? evt.target;\n        if (!this.isEventSink(target)) {\n            return;\n        }\n        return await new ClipboardHandler_1.default(this).paste(evt);\n    }\n    /**\n     * Forward pointer events from `elem` to this editor. Such that right-click/right-click drag\n     * events are also forwarded, `elem`'s contextmenu is disabled.\n     *\n     * `filter` is called once per pointer event, before doing any other processing. If `filter` returns `true` the event is\n     * forwarded to the editor.\n     *\n     * **Note**: `otherEventsFilter` is like `filter`, but is called for other pointer-related\n     * events that could also be forwarded to the editor. To forward just pointer events,\n     * for example, `otherEventsFilter` could be given as `()=>false`.\n     *\n     * @example\n     * ```ts\n     * const overlay = document.createElement('div');\n     * editor.createHTMLOverlay(overlay);\n     *\n     * // Send all pointer events that don't have the control key pressed\n     * // to the editor.\n     * editor.handlePointerEventsFrom(overlay, (event) => {\n     *   if (event.ctrlKey) {\n     *     return false;\n     *   }\n     *   return true;\n     * });\n     * ```\n     */\n    handlePointerEventsFrom(elem, filter, otherEventsFilter) {\n        // May be required to prevent text selection on iOS/Safari:\n        // See https://stackoverflow.com/a/70992717/17055750\n        const touchstartListener = (evt) => {\n            if (otherEventsFilter && !otherEventsFilter('touchstart', evt)) {\n                return;\n            }\n            evt.preventDefault();\n        };\n        const contextmenuListener = (evt) => {\n            if (otherEventsFilter && !otherEventsFilter('contextmenu', evt)) {\n                return;\n            }\n            // Don't show a context menu\n            evt.preventDefault();\n        };\n        const listeners = {\n            touchstart: touchstartListener,\n            contextmenu: contextmenuListener,\n        };\n        const eventNames = [\n            'pointerdown',\n            'pointermove',\n            'pointerup',\n            'pointercancel',\n        ];\n        for (const eventName of eventNames) {\n            listeners[eventName] = (evt) => {\n                // This listener will only be called in the context of PointerEvents.\n                const event = evt;\n                if (filter && !filter(eventName, event)) {\n                    return undefined;\n                }\n                return this.handleHTMLPointerEvent(eventName, event);\n            };\n        }\n        // Add all listeners.\n        for (const eventName in listeners) {\n            elem.addEventListener(eventName, listeners[eventName]);\n        }\n        return {\n            /** Remove all event listeners registered by this function. */\n            remove: () => {\n                for (const eventName in listeners) {\n                    elem.removeEventListener(eventName, listeners[eventName]);\n                }\n            },\n        };\n    }\n    /**\n     * Like {@link handlePointerEventsFrom} except ignores short input gestures like clicks.\n     *\n     * `filter` is called once per event, before doing any other processing. If `filter` returns `true` the event is\n     * forwarded to the editor.\n     *\n     * `otherEventsFilter` is passed unmodified to `handlePointerEventsFrom`.\n     */\n    handlePointerEventsExceptClicksFrom(elem, filter, otherEventsFilter) {\n        // Maps pointer IDs to gesture start points\n        const gestureData = Object.create(null);\n        return this.handlePointerEventsFrom(elem, (eventName, event) => {\n            if (filter && !filter(eventName, event)) {\n                return false;\n            }\n            // Position of the current event.\n            // jsdom doesn't seem to support pageX/pageY -- use clientX/clientY if unavailable\n            const currentPos = math_1.Vec2.of(event.pageX ?? event.clientX, event.pageY ?? event.clientY);\n            const pointerId = event.pointerId ?? 0;\n            // Whether to send the current event to the editor\n            let sendToEditor = true;\n            if (eventName === 'pointerdown') {\n                // Buffer the event, but don't send it to the editor yet.\n                // We don't want to send single-click events, but we do want to send full strokes.\n                gestureData[pointerId] = {\n                    eventBuffer: [[eventName, event]],\n                    startPoint: currentPos,\n                    hasMovedSignificantly: false,\n                };\n                // Capture the pointer so we receive future events even if the overlay is hidden.\n                this.setPointerCapture(elem, event.pointerId);\n                // Don't send to the editor.\n                sendToEditor = false;\n            }\n            else if (eventName === 'pointermove' && gestureData[pointerId]) {\n                const gestureStartPos = gestureData[pointerId].startPoint;\n                const eventBuffer = gestureData[pointerId].eventBuffer;\n                // Skip if the pointer hasn't moved enough to not be a \"click\".\n                const strokeStartThreshold = 10;\n                const isWithinClickThreshold = gestureStartPos && currentPos.distanceTo(gestureStartPos) < strokeStartThreshold;\n                if (isWithinClickThreshold && !gestureData[pointerId].hasMovedSignificantly) {\n                    eventBuffer.push([eventName, event]);\n                    sendToEditor = false;\n                }\n                else {\n                    // Send all buffered events to the editor -- start the stroke.\n                    for (const [eventName, event] of eventBuffer) {\n                        this.handleHTMLPointerEvent(eventName, event);\n                    }\n                    gestureData[pointerId].eventBuffer = [];\n                    gestureData[pointerId].hasMovedSignificantly = true;\n                    sendToEditor = true;\n                }\n            }\n            // Pointers that aren't down -- send to the editor.\n            else if (eventName === 'pointermove') {\n                sendToEditor = true;\n            }\n            // Otherwise, if we received a pointerup/pointercancel without flushing all pointerevents from the\n            // buffer, the gesture wasn't recognised as a stroke. Thus, the editor isn't expecting a pointerup/\n            // pointercancel event.\n            else if ((eventName === 'pointerup' || eventName === 'pointercancel') &&\n                gestureData[pointerId] &&\n                gestureData[pointerId].eventBuffer.length > 0) {\n                this.releasePointerCapture(elem, event.pointerId);\n                // Don't send to the editor.\n                sendToEditor = false;\n                delete gestureData[pointerId];\n            }\n            // Forward all other events to the editor.\n            return sendToEditor;\n        }, otherEventsFilter);\n    }\n    /** @internal */\n    handleHTMLKeyDownEvent(htmlEvent) {\n        console.assert(htmlEvent.type === 'keydown', `handling a keydown event with type ${htmlEvent.type}`);\n        const event = (0, inputEvents_1.keyPressEventFromHTMLEvent)(htmlEvent);\n        if (this.toolController.dispatchInputEvent(event)) {\n            htmlEvent.preventDefault();\n            return true;\n        }\n        else if (event.key === 't' || event.key === 'T') {\n            htmlEvent.preventDefault();\n            this.display.rerenderAsText();\n            return true;\n        }\n        else if (event.key === 'Escape') {\n            this.renderingRegion.blur();\n            return true;\n        }\n        return false;\n    }\n    /** @internal */\n    handleHTMLKeyUpEvent(htmlEvent) {\n        console.assert(htmlEvent.type === 'keyup', `Handling a keyup event with type ${htmlEvent.type}`);\n        const event = (0, inputEvents_1.keyUpEventFromHTMLEvent)(htmlEvent);\n        if (this.toolController.dispatchInputEvent(event)) {\n            htmlEvent.preventDefault();\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Adds event listners for keypresses (and drop events) on `elem` and forwards those\n     * events to the editor.\n     *\n     * If the given `filter` returns `false` for an event, the event is ignored and not\n     * passed to the editor.\n     */\n    handleKeyEventsFrom(elem, filter = () => true) {\n        (0, listenForKeyboardEventsFrom_1.default)(elem, {\n            filter,\n            handleKeyDown: (htmlEvent) => {\n                this.handleHTMLKeyDownEvent(htmlEvent);\n            },\n            handleKeyUp: (htmlEvent) => {\n                this.handleHTMLKeyUpEvent(htmlEvent);\n            },\n            getHandlesKeyEventsFrom: (element) => {\n                return this.eventListenerTargets.includes(element);\n            },\n        });\n        // Allow drop.\n        elem.ondragover = (evt) => {\n            evt.preventDefault();\n        };\n        elem.ondrop = (evt) => {\n            this.handleDrop(evt);\n        };\n        this.eventListenerTargets.push(elem);\n    }\n    /**\n     * Attempts to prevent **user-triggered** events from modifying\n     * the content of the image.\n     */\n    setReadOnly(readOnly) {\n        if (readOnly !== this.readOnly.get()) {\n            this.readOnly.set(readOnly);\n            this.notifier.dispatch(types_1.EditorEventType.ReadOnlyModeToggled, {\n                kind: types_1.EditorEventType.ReadOnlyModeToggled,\n                editorIsReadOnly: readOnly,\n            });\n        }\n    }\n    // @internal\n    isReadOnlyReactiveValue() {\n        return this.readOnly;\n    }\n    isReadOnly() {\n        return this.readOnly;\n    }\n    /**\n     * `apply` a command. `command` will be announced for accessibility.\n     *\n     * **Example**:\n     * [[include:doc-pages/inline-examples/adding-a-stroke.md]]\n     */\n    dispatch(command, addToHistory = true) {\n        const dispatchResult = this.dispatchNoAnnounce(command, addToHistory);\n        const commandDescription = command.description(this, this.localization);\n        this.announceForAccessibility(commandDescription);\n        return dispatchResult;\n    }\n    /**\n     * Dispatches a command without announcing it. By default, does not add to history.\n     * Use this to show finalized commands that don't need to have `announceForAccessibility`\n     * called.\n     *\n     * If `addToHistory` is `false`, this is equivalent to `command.apply(editor)`.\n     *\n     * @example\n     * ```\n     * const addToHistory = false;\n     * editor.dispatchNoAnnounce(editor.viewport.zoomTo(someRectangle), addToHistory);\n     * ```\n     */\n    dispatchNoAnnounce(command, addToHistory = false) {\n        const result = command.apply(this);\n        if (addToHistory) {\n            const apply = false; // Don't double-apply\n            this.history.push(command, apply);\n        }\n        return result;\n    }\n    /**\n     * Apply a large transformation in chunks.\n     * If `apply` is `false`, the commands are unapplied.\n     * Triggers a re-render after each `updateChunkSize`-sized group of commands\n     * has been applied.\n     */\n    async asyncApplyOrUnapplyCommands(commands, apply, updateChunkSize) {\n        console.assert(updateChunkSize > 0);\n        this.display.setDraftMode(true);\n        for (let i = 0; i < commands.length; i += updateChunkSize) {\n            this.showLoadingWarning(i / commands.length);\n            for (let j = i; j < commands.length && j < i + updateChunkSize; j++) {\n                const cmd = commands[j];\n                if (apply) {\n                    cmd.apply(this);\n                }\n                else {\n                    cmd.unapply(this);\n                }\n            }\n            // Re-render to show progress, but only if we're not done.\n            if (i + updateChunkSize < commands.length) {\n                await new Promise((resolve) => {\n                    this.rerender();\n                    requestAnimationFrame(resolve);\n                });\n            }\n        }\n        this.display.setDraftMode(false);\n        this.hideLoadingWarning();\n    }\n    /** @see {@link asyncApplyOrUnapplyCommands } */\n    asyncApplyCommands(commands, chunkSize) {\n        return this.asyncApplyOrUnapplyCommands(commands, true, chunkSize);\n    }\n    /**\n     * @see {@link asyncApplyOrUnapplyCommands}\n     *\n     * If `unapplyInReverseOrder`, commands are reversed before unapplying.\n     */\n    asyncUnapplyCommands(commands, chunkSize, unapplyInReverseOrder = false) {\n        if (unapplyInReverseOrder) {\n            commands = [...commands]; // copy\n            commands.reverse();\n        }\n        return this.asyncApplyOrUnapplyCommands(commands, false, chunkSize);\n    }\n    /**\n     * Schedule a re-render for some time in the near future. Does not schedule an additional\n     * re-render if a re-render is already queued.\n     *\n     * @returns a promise that resolves when re-rendering has completed.\n     */\n    queueRerender() {\n        if (!this.rerenderQueued) {\n            this.rerenderQueued = true;\n            requestAnimationFrame(() => {\n                // If .rerender was called manually, we might not need to\n                // re-render.\n                if (this.rerenderQueued) {\n                    this.rerender();\n                    this.rerenderQueued = false;\n                }\n            });\n        }\n        return new Promise((resolve) => {\n            this.nextRerenderListeners.push(() => resolve());\n        });\n    }\n    // @internal\n    isRerenderQueued() {\n        return this.rerenderQueued;\n    }\n    /**\n     * Re-renders the entire image.\n     *\n     * @see {@link Editor.queueRerender}\n     */\n    rerender(showImageBounds = true) {\n        this.display.startRerender();\n        // Don't render if the display has zero size.\n        if (this.display.width === 0 || this.display.height === 0) {\n            return;\n        }\n        const renderer = this.display.getDryInkRenderer();\n        this.image.renderWithCache(renderer, this.display.getCache(), this.viewport);\n        // Draw a rectangle around the region that will be visible on save\n        if (showImageBounds && !this.image.getAutoresizeEnabled()) {\n            const exportRectFill = { fill: math_1.Color4.fromHex('#44444455') };\n            const exportRectStrokeWidth = 5 * this.viewport.getSizeOfPixelOnCanvas();\n            renderer.drawRect(this.getImportExportRect(), exportRectStrokeWidth, exportRectFill);\n        }\n        this.rerenderQueued = false;\n        this.nextRerenderListeners.forEach((listener) => listener());\n        this.nextRerenderListeners = [];\n    }\n    /**\n     * Draws the given path onto the wet ink renderer. The given path will\n     * be displayed on top of the main image.\n     *\n     * @see {@link Display.getWetInkRenderer} {@link Display.flatten}\n     */\n    drawWetInk(...path) {\n        for (const part of path) {\n            this.display.getWetInkRenderer().drawPath(part);\n        }\n    }\n    /**\n     * Clears the wet ink display.\n     *\n     * The wet ink display can be used by the currently active tool to display a preview\n     * of an in-progress action.\n     *\n     * @see {@link Display.getWetInkRenderer}\n     */\n    clearWetInk() {\n        this.display.getWetInkRenderer().clear();\n    }\n    /**\n     * Focuses the region used for text input/key commands.\n     */\n    focus() {\n        this.renderingRegion.focus();\n    }\n    /**\n     * Creates an element that will be positioned on top of the dry/wet ink\n     * renderers.\n     *\n     * So as not to change the position of other overlays, `overlay` should either\n     * be styled to have 0 height or have `position: absolute`.\n     *\n     * This is useful for displaying content on top of the rendered content\n     * (e.g. a selection box).\n     */\n    createHTMLOverlay(overlay) {\n        // TODO(v2): Fix conflict with toolbars that have been added to the editor.\n        overlay.classList.add('overlay', 'js-draw-editor-overlay');\n        this.container.appendChild(overlay);\n        return {\n            remove: () => overlay.remove(),\n        };\n    }\n    /**\n     * Anchors the given `element` to the canvas with a given position/transformation in canvas space.\n     */\n    anchorElementToCanvas(element, canvasTransform) {\n        if (canvasTransform instanceof math_1.Mat33) {\n            canvasTransform = ReactiveValue_1.default.fromImmutable(canvasTransform);\n        }\n        // The element hierarchy looks like this:\n        //   overlay > contentWrapper > content\n        //\n        // Both contentWrapper and overlay are present to:\n        // 1. overlay: Positions the content at the top left of the viewport. The overlay\n        //    has `height: 0` to allow other overlays to also be aligned with the viewport's\n        //    top left.\n        // 2. contentWrapper: Has the same width/height as the editor's visible region and\n        //    has `overflow: hidden`. This prevents the anchored element from being visible\n        //    when not in the visible region of the canvas.\n        const overlay = document.createElement('div');\n        overlay.classList.add('anchored-element-overlay');\n        const contentWrapper = document.createElement('div');\n        contentWrapper.classList.add('content-wrapper');\n        element.classList.add('content');\n        // Updates CSS variables that specify the position/rotation/scale of the content.\n        const updateElementPositioning = () => {\n            const transform = canvasTransform.get();\n            const canvasRotation = transform.transformVec3(math_1.Vec2.unitX).angle();\n            const screenRotation = canvasRotation + this.viewport.getRotationAngle();\n            const screenTransform = this.viewport.canvasToScreenTransform.rightMul(canvasTransform.get());\n            overlay.style.setProperty('--full-transform', screenTransform.toCSSMatrix());\n            const translation = screenTransform.transformVec2(math_1.Vec2.zero);\n            overlay.style.setProperty('--position-x', `${translation.x}px`);\n            overlay.style.setProperty('--position-y', `${translation.y}px`);\n            overlay.style.setProperty('--rotation', `${(screenRotation * 180) / Math.PI}deg`);\n            overlay.style.setProperty('--scale', `${screenTransform.getScaleFactor()}`);\n        };\n        updateElementPositioning();\n        // The anchored element needs to be updated both when the user moves the canvas\n        // and when the anchored element's transform changes.\n        const updateListener = canvasTransform.onUpdate(updateElementPositioning);\n        const viewportListener = this.notifier.on(types_1.EditorEventType.ViewportChanged, updateElementPositioning);\n        contentWrapper.appendChild(element);\n        overlay.appendChild(contentWrapper);\n        overlay.classList.add('overlay', 'js-draw-editor-overlay');\n        this.renderingRegion.insertAdjacentElement('afterend', overlay);\n        return {\n            remove: () => {\n                overlay.remove();\n                updateListener.remove();\n                viewportListener.remove();\n            },\n        };\n    }\n    /**\n     * Creates a CSS stylesheet with `content` and applies it to the document\n     * (and thus, to this editor).\n     */\n    addStyleSheet(content) {\n        const styleSheet = document.createElement('style');\n        styleSheet.innerText = content;\n        this.container.appendChild(styleSheet);\n        return styleSheet;\n    }\n    /**\n     * Dispatch a keyboard event to the currently selected tool.\n     * Intended for unit testing.\n     *\n     * If `shiftKey` is undefined, it is guessed from `key`.\n     *\n     * At present, the **key code** dispatched is guessed from the given key and,\n     * while this works for ASCII alphanumeric characters, this does not work for\n     * most non-alphanumeric keys.\n     *\n     * Because guessing the key code from `key` is problematic, **only use this for testing**.\n     */\n    sendKeyboardEvent(eventType, key, ctrlKey = false, altKey = false, shiftKey = undefined) {\n        shiftKey ??= key.toUpperCase() === key && key.toLowerCase() !== key;\n        this.toolController.dispatchInputEvent({\n            kind: eventType,\n            key,\n            code: (0, guessKeyCodeFromKey_1.default)(key),\n            ctrlKey,\n            altKey,\n            shiftKey,\n        });\n    }\n    /**\n     * Dispatch a pen event to the currently selected tool.\n     * Intended primarially for unit tests.\n     *\n     * @deprecated\n     * @see {@link sendPenEvent} {@link sendTouchEvent}\n     */\n    sendPenEvent(eventType, point, \n    // @deprecated\n    allPointers) {\n        (0, sendPenEvent_1.default)(this, eventType, point, allPointers);\n    }\n    /**\n     * Adds all components in `components` such that they are in the center of the screen.\n     * This is a convenience method that creates **and applies** a single command.\n     *\n     * If `selectComponents` is true (the default), the components are selected.\n     *\n     * `actionDescription`, if given, should be a screenreader-friendly description of the\n     * reason components were added (e.g. \"pasted\").\n     */\n    async addAndCenterComponents(components, selectComponents = true, actionDescription) {\n        let bbox = null;\n        for (const component of components) {\n            if (bbox) {\n                bbox = bbox.union(component.getBBox());\n            }\n            else {\n                bbox = component.getBBox();\n            }\n        }\n        if (!bbox) {\n            return;\n        }\n        // Find a transform that scales/moves bbox onto the screen.\n        const visibleRect = this.viewport.visibleRect;\n        const scaleRatioX = visibleRect.width / bbox.width;\n        const scaleRatioY = visibleRect.height / bbox.height;\n        let scaleRatio = scaleRatioX;\n        if (bbox.width * scaleRatio > visibleRect.width ||\n            bbox.height * scaleRatio > visibleRect.height) {\n            scaleRatio = scaleRatioY;\n        }\n        scaleRatio *= 2 / 3;\n        scaleRatio = Viewport_1.default.roundScaleRatio(scaleRatio);\n        const transfm = math_1.Mat33.translation(visibleRect.center.minus(bbox.center)).rightMul(math_1.Mat33.scaling2D(scaleRatio, bbox.center));\n        const commands = [];\n        for (const component of components) {\n            // To allow deserialization, we need to add first, then transform.\n            commands.push(EditorImage_1.default.addElement(component));\n            commands.push(component.transformBy(transfm));\n        }\n        const applyChunkSize = 100;\n        await this.dispatch((0, uniteCommands_1.default)(commands, { applyChunkSize, description: actionDescription }), true);\n        if (selectComponents) {\n            for (const selectionTool of this.toolController.getMatchingTools(SelectionTool_1.default)) {\n                selectionTool.setEnabled(true);\n                selectionTool.setSelection(components);\n            }\n        }\n    }\n    /**\n     * Get a data URL (e.g. as produced by `HTMLCanvasElement::toDataURL`).\n     * If `format` is not `image/png`, a PNG image URL may still be returned (as in the\n     * case of `HTMLCanvasElement::toDataURL`).\n     *\n     * The export resolution is the same as the size of the drawing canvas, unless `outputSize`\n     * is given.\n     *\n     * **Example**:\n     * [[include:doc-pages/inline-examples/adding-an-image-and-data-urls.md]]\n     */\n    toDataURL(format = 'image/png', outputSize) {\n        const { element: canvas, renderer } = CanvasRenderer_1.default.fromViewport(this.image.getImportExportViewport(), { canvasSize: outputSize });\n        this.image.renderAll(renderer);\n        const dataURL = canvas.toDataURL(format);\n        return dataURL;\n    }\n    /**\n     * Converts the editor's content into an SVG image.\n     *\n     * If the output SVG has width or height less than `options.minDimension`, its size\n     * will be increased.\n     *\n     * @see\n     * {@link SVGRenderer}\n     */\n    toSVG(options) {\n        return (0, editorImageToSVG_1.editorImageToSVGSync)(this.image, options ?? {});\n    }\n    /**\n     * Converts the editor's content into an SVG image in an asynchronous,\n     * but **potentially lossy** way.\n     *\n     * **Warning**: If the image is being edited during an async rendering, edited components\n     * may not be rendered.\n     *\n     * Like {@link toSVG}, but can be configured to briefly pause after processing every\n     * `pauseAfterCount` items. This can prevent the editor from becoming unresponsive\n     * when saving very large images.\n     */\n    async toSVGAsync(options = {}) {\n        const pauseAfterCount = options.pauseAfterCount ?? 100;\n        return await (0, editorImageToSVG_1.editorImageToSVGAsync)(this.image, async (_component, processedCount, totalComponents) => {\n            if (options.onProgress) {\n                const shouldContinue = await options.onProgress(processedCount, totalComponents);\n                if (shouldContinue === false) {\n                    return false;\n                }\n            }\n            if (processedCount % pauseAfterCount === 0) {\n                await (0, untilNextAnimationFrame_1.default)();\n            }\n            return true;\n        }, {\n            minDimension: options.minDimension,\n        });\n    }\n    /**\n     * Load editor data from an `ImageLoader` (e.g. an {@link SVGLoader}).\n     *\n     * @see loadFromSVG\n     */\n    async loadFrom(loader) {\n        this.showLoadingWarning(0);\n        this.display.setDraftMode(true);\n        const originalBackgrounds = this.image.getBackgroundComponents();\n        const eraseBackgroundCommand = new Erase_1.default(originalBackgrounds);\n        await loader.start(async (component) => {\n            await this.dispatchNoAnnounce(EditorImage_1.default.addElement(component));\n        }, (countProcessed, totalToProcess) => {\n            if (countProcessed % 500 === 0) {\n                this.showLoadingWarning(countProcessed / totalToProcess);\n                this.rerender();\n                return (0, untilNextAnimationFrame_1.default)();\n            }\n            return null;\n        }, (importExportRect, options) => {\n            this.dispatchNoAnnounce(this.setImportExportRect(importExportRect), false);\n            this.dispatchNoAnnounce(this.viewport.zoomTo(importExportRect), false);\n            if (options) {\n                this.dispatchNoAnnounce(this.image.setAutoresizeEnabled(options.autoresize), false);\n            }\n        });\n        // Ensure that we don't have multiple overlapping BackgroundComponents. Remove\n        // old BackgroundComponents.\n        // Overlapping BackgroundComponents may cause changing the background color to\n        // not work properly.\n        if (this.image.getBackgroundComponents().length !== originalBackgrounds.length) {\n            await this.dispatchNoAnnounce(eraseBackgroundCommand);\n        }\n        this.hideLoadingWarning();\n        this.display.setDraftMode(false);\n        this.queueRerender();\n    }\n    getTopmostBackgroundComponent() {\n        let background = null;\n        // Find a background component, if one exists.\n        // Use the last (topmost) background component if there are multiple.\n        for (const component of this.image.getBackgroundComponents()) {\n            if (component instanceof BackgroundComponent_1.default) {\n                background = component;\n            }\n        }\n        return background;\n    }\n    /**\n     * This is a convenience method for adding or updating the {@link BackgroundComponent}\n     * and {@link EditorImage.setAutoresizeEnabled} for the current image.\n     *\n     * If there are multiple {@link BackgroundComponent}s in the image, this only modifies\n     * the topmost such element.\n     *\n     * **Example**:\n     * ```ts,runnable\n     * import { Editor, Color4, BackgroundComponentBackgroundType } from 'js-draw';\n     * const editor = new Editor(document.body);\n     * editor.dispatch(editor.setBackgroundStyle({\n     *     color: Color4.orange,\n     *     type: BackgroundComponentBackgroundType.Grid,\n     *     autoresize: true,\n     * }));\n     * ```\n     *\n     * To change the background size, see {@link EditorImage.setImportExportRect}.\n     */\n    setBackgroundStyle(style) {\n        const originalBackground = this.getTopmostBackgroundComponent();\n        const commands = [];\n        if (originalBackground) {\n            commands.push(new Erase_1.default([originalBackground]));\n        }\n        const originalType = originalBackground?.getBackgroundType?.() ?? BackgroundComponent_1.BackgroundType.None;\n        const originalColor = originalBackground?.getStyle?.().color ?? math_1.Color4.transparent;\n        const originalFillsScreen = this.image.getAutoresizeEnabled();\n        const defaultType = style.color && originalType === BackgroundComponent_1.BackgroundType.None\n            ? BackgroundComponent_1.BackgroundType.SolidColor\n            : originalType;\n        const backgroundType = style.type ?? defaultType;\n        const backgroundColor = style.color ?? originalColor;\n        const fillsScreen = style.autoresize ?? originalFillsScreen;\n        if (backgroundType !== BackgroundComponent_1.BackgroundType.None) {\n            const newBackground = new BackgroundComponent_1.default(backgroundType, backgroundColor);\n            commands.push(EditorImage_1.default.addElement(newBackground));\n        }\n        if (fillsScreen !== originalFillsScreen) {\n            commands.push(this.image.setAutoresizeEnabled(fillsScreen));\n            // Avoid 0x0 backgrounds\n            if (!fillsScreen && this.image.getImportExportRect().maxDimension === 0) {\n                commands.push(this.image.setImportExportRect(this.image.getImportExportRect().resizedTo(math_1.Vec2.of(500, 500))));\n            }\n        }\n        return (0, uniteCommands_1.default)(commands);\n    }\n    /**\n     * Set the background color of the image.\n     *\n     * This is a convenience method for adding or updating the {@link BackgroundComponent}\n     * for the current image.\n     *\n     * @see {@link setBackgroundStyle}\n     */\n    setBackgroundColor(color) {\n        let background = this.getTopmostBackgroundComponent();\n        if (!background) {\n            const backgroundType = color.eq(math_1.Color4.transparent)\n                ? BackgroundComponent_1.BackgroundType.None\n                : BackgroundComponent_1.BackgroundType.SolidColor;\n            background = new BackgroundComponent_1.default(backgroundType, color);\n            return this.image.addElement(background);\n        }\n        else {\n            return background.updateStyle({ color });\n        }\n    }\n    /**\n     * @returns the average of the colors of all background components. Use this to get the current background\n     * color.\n     */\n    estimateBackgroundColor() {\n        const backgroundColors = [];\n        for (const component of this.image.getBackgroundComponents()) {\n            if (component instanceof BackgroundComponent_1.default) {\n                backgroundColors.push(component.getStyle().color ?? math_1.Color4.transparent);\n            }\n        }\n        return math_1.Color4.average(backgroundColors);\n    }\n    // Returns the size of the visible region of the output SVG\n    getImportExportRect() {\n        return this.image.getImportExportViewport().visibleRect;\n    }\n    // Resize the output SVG to match `imageRect`.\n    setImportExportRect(imageRect) {\n        return this.image.setImportExportRect(imageRect);\n    }\n    /**\n     * Alias for `loadFrom(SVGLoader.fromString)`.\n     *\n     * @example\n     * ```ts,runnable\n     * import {Editor} from 'js-draw';\n     * const editor = new Editor(document.body);\n     *\n     * ---visible---\n     * await editor.loadFromSVG(`\n     *   <svg viewBox=\"5 23 52 30\" width=\"52\" height=\"16\" version=\"1.1\" baseProfile=\"full\" xmlns=\"http://www.w3.org/2000/svg\">\n     *     <text style=\"\n     *       transform: matrix(0.181846, 0.1, 0, 0.181846, 11.4, 33.2);\n     *       font-family: serif;\n     *       font-size: 32px;\n     *       fill: rgb(100, 140, 61);\n     *     \">An SVG image!</text>\n     *   </svg>\n     * `);\n     * ```\n     */\n    async loadFromSVG(svgData, sanitize = false) {\n        const loader = SVGLoader_1.default.fromString(svgData, sanitize);\n        await this.loadFrom(loader);\n    }\n    /**\n     * Shows an information dialog with legal notices.\n     */\n    showAboutDialog() {\n        const iconLicenseText = this.icons.licenseInfo();\n        const notices = [];\n        if (this.settings.appInfo) {\n            const descriptionLines = [];\n            if (this.settings.appInfo.version) {\n                descriptionLines.push(`v${this.settings.appInfo.version}`, '');\n            }\n            if (this.settings.appInfo.description) {\n                descriptionLines.push(this.settings.appInfo.description + '\\n');\n            }\n            else {\n                descriptionLines.push(`js-draw v${version_1.default.number}`);\n            }\n            notices.push({\n                heading: `${this.settings.appInfo.name}`,\n                text: descriptionLines.join('\\n'),\n            });\n        }\n        else {\n            notices.push({\n                heading: 'js-draw',\n                text: `v${version_1.default.number}`,\n            });\n        }\n        const screenSize = this.viewport.getScreenRectSize();\n        notices.push({\n            heading: this.localization.developerInformation,\n            text: [\n                'Image debug information (from when this dialog was opened):',\n                `    ${this.viewport.getScaleFactor()}x zoom, ${(180 / Math.PI) * this.viewport.getRotationAngle()}° rotation`,\n                `    ${this.image.estimateNumElements()} components`,\n                `    auto-resize: ${this.image.getAutoresizeEnabled() ? 'enabled' : 'disabled'}`,\n                `    image size: ${this.getImportExportRect().w}x${this.getImportExportRect().h}`,\n                `    screen size: ${screenSize.x}x${screenSize.y}`,\n                `    device pixel ratio: ${this.display.getDevicePixelRatio()}`,\n                '    cache:',\n                `        ${this.display\n                    .getCache()\n                    .getDebugInfo()\n                    // Indent\n                    .replace(/([\\n])/g, '\\n        ')}`,\n            ].join('\\n'),\n            minimized: true,\n        });\n        notices.push({\n            heading: this.localization.softwareLibraries,\n            text: [\n                `This image editor is powered by js-draw v${version_1.default.number}.`,\n                '',\n                'At runtime, js-draw uses',\n                ' - The Coloris color picker: https://github.com/mdbassit/Coloris',\n                ' - The bezier.js Bézier curve library: https://github.com/Pomax/bezierjs',\n                '',\n                'Both are licensed under the MIT license:',\n                '',\n                '',\n                '== Coloris ==',\n                (0, mitLicenseAttribution_1.default)('2021 Mohammed Bassit'),\n                '',\n                '',\n                '== Bezier.js ==',\n                (0, mitLicenseAttribution_1.default)('2023 Mike \"Pomax\" Kamermans'),\n                '',\n                '',\n                '== js-draw ==',\n                (0, mitLicenseAttribution_1.default)('2023-2025 Henry Heino'),\n                '',\n            ].join('\\n'),\n            minimized: true,\n        });\n        if (iconLicenseText) {\n            notices.push({\n                heading: 'Icon Pack',\n                text: iconLicenseText,\n                minimized: true,\n            });\n        }\n        notices.push(...this.settings.notices);\n        this.closeAboutDialog?.();\n        this.closeAboutDialog = (0, makeAboutDialog_1.default)(this, notices).close;\n    }\n    /**\n     * Removes and **destroys** the editor. The editor cannot be added to a parent\n     * again after calling this method.\n     */\n    remove() {\n        this.container.remove();\n        // TODO: Is additional cleanup necessary here?\n        this.toolController.onEditorDestroyed();\n    }\n}\nexports.Editor = Editor;\nexports[\"default\"] = Editor;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/Editor.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/EventDispatcher.js":
/*!**********************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/EventDispatcher.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n// Code shared with Joplin (from when it was MIT licensed)\n// (js-draw was originally intended to be part of Joplin).\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * Handles notifying listeners of events.\n *\n * `EventKeyType` is used to distinguish events (e.g. a `ClickEvent` vs a `TouchEvent`)\n * while `EventMessageType` is the type of the data sent with an event (can be `void`).\n *\n * @example\n * ```\n * const dispatcher = new EventDispatcher<'event1'|'event2'|'event3', void>();\n * dispatcher.on('event1', () => {\n *   console.log('Event 1 triggered.');\n * });\n * dispatcher.dispatch('event1');\n * ```\n *\n */\nclass EventDispatcher {\n    constructor() {\n        this.listeners = {};\n    }\n    dispatch(eventName, event) {\n        const listenerList = this.listeners[eventName];\n        if (listenerList) {\n            for (let i = 0; i < listenerList.length; i++) {\n                listenerList[i](event);\n            }\n        }\n    }\n    on(eventName, callback) {\n        if (!this.listeners[eventName])\n            this.listeners[eventName] = [];\n        this.listeners[eventName].push(callback);\n        return {\n            // Retuns false if the listener has already been removed, true otherwise.\n            remove: () => {\n                const originalListeners = this.listeners[eventName];\n                this.off(eventName, callback);\n                return originalListeners.length !== this.listeners[eventName].length;\n            },\n        };\n    }\n    /** Removes an event listener. This is equivalent to calling `.remove()` on the object returned by `.on`. */\n    off(eventName, callback) {\n        const listeners = this.listeners[eventName];\n        if (!listeners)\n            return;\n        // Replace the current list of listeners with a new, shortened list.\n        // This allows any iterators over this.listeners to continue iterating\n        // without skipping elements.\n        this.listeners[eventName] = listeners.filter((otherCallback) => otherCallback !== callback);\n    }\n}\nexports[\"default\"] = EventDispatcher;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/EventDispatcher.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/Pointer.js":
/*!**************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/Pointer.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PointerDevice = void 0;\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\nvar PointerDevice;\n(function (PointerDevice) {\n    PointerDevice[PointerDevice[\"Pen\"] = 0] = \"Pen\";\n    PointerDevice[PointerDevice[\"Eraser\"] = 1] = \"Eraser\";\n    PointerDevice[PointerDevice[\"Touch\"] = 2] = \"Touch\";\n    PointerDevice[PointerDevice[\"PrimaryButtonMouse\"] = 3] = \"PrimaryButtonMouse\";\n    PointerDevice[PointerDevice[\"RightButtonMouse\"] = 4] = \"RightButtonMouse\";\n    PointerDevice[PointerDevice[\"Other\"] = 5] = \"Other\";\n})(PointerDevice || (exports.PointerDevice = PointerDevice = {}));\n// Provides a snapshot containing information about a pointer. A Pointer\n// object is immutable — it will not be updated when the pointer's information changes.\nclass Pointer {\n    constructor(\n    // The (x, y) position of the pointer relative to the top-left corner\n    // of the visible canvas.\n    screenPos, \n    // Position of the pointer relative to the top left corner of the drawing\n    // surface.\n    canvasPos, pressure, isPrimary, down, device, \n    // Unique ID for the pointer\n    id, \n    // Numeric timestamp (milliseconds, as from `performance.now()`).\n    timeStamp) {\n        this.screenPos = screenPos;\n        this.canvasPos = canvasPos;\n        this.pressure = pressure;\n        this.isPrimary = isPrimary;\n        this.down = down;\n        this.device = device;\n        this.id = id;\n        this.timeStamp = timeStamp;\n    }\n    /**\n     * Snaps this pointer to the nearest grid point (rounds the coordinates of this\n     * pointer based on the current zoom). Returns a new Pointer and does not modify\n     * this.\n     */\n    snappedToGrid(viewport) {\n        const snappedCanvasPos = viewport.snapToGrid(this.canvasPos);\n        return this.withCanvasPosition(snappedCanvasPos, viewport);\n    }\n    // Snap this pointer to the X or Y axis (whichever is closer), where (0,0)\n    // is considered to be at `originPointScreen`.\n    // @internal\n    lockedToXYAxesScreen(originPointScreen, viewport) {\n        const current = this.screenPos;\n        const currentFromStart = current.minus(originPointScreen);\n        // Determine whether the last point was closer to being on the\n        // x- or y- axis.\n        const projOntoXAxis = math_1.Vec2.unitX.times(currentFromStart.x);\n        const projOntoYAxis = math_1.Vec2.unitY.times(currentFromStart.y);\n        let pos;\n        if (currentFromStart.dot(projOntoXAxis) > currentFromStart.dot(projOntoYAxis)) {\n            pos = projOntoXAxis;\n        }\n        else {\n            pos = projOntoYAxis;\n        }\n        pos = pos.plus(originPointScreen);\n        return this.withScreenPosition(pos, viewport);\n    }\n    /** @see {@link withCanvasPosition} */\n    withScreenPosition(screenPos, viewport) {\n        const canvasPos = viewport.screenToCanvas(screenPos);\n        return this.withCanvasPosition(canvasPos, viewport);\n    }\n    /** Returns a copy of this pointer with a changed timestamp. */\n    withTimestamp(timeStamp) {\n        return new Pointer(this.screenPos, this.canvasPos, this.pressure, this.isPrimary, this.down, this.device, this.id, timeStamp);\n    }\n    /**\n     * Returns a copy of this pointer with a new position. The screen position is determined\n     * by the given `canvasPos`.\n     */\n    withCanvasPosition(canvasPos, viewport) {\n        const screenPos = viewport.canvasToScreen(canvasPos);\n        return new Pointer(screenPos, canvasPos, this.pressure, this.isPrimary, this.down, this.device, this.id, this.timeStamp);\n    }\n    // Creates a Pointer from a DOM event. If `relativeTo` is given, (0, 0) in screen coordinates is\n    // considered the top left of `relativeTo`.\n    static ofEvent(evt, isDown, viewport, relativeTo) {\n        let screenPos = math_1.Vec2.of(evt.clientX, evt.clientY);\n        if (relativeTo) {\n            const bbox = relativeTo.getBoundingClientRect();\n            screenPos = screenPos.minus(math_1.Vec2.of(bbox.left, bbox.top));\n        }\n        const pointerTypeToDevice = {\n            mouse: PointerDevice.PrimaryButtonMouse,\n            pen: PointerDevice.Pen,\n            touch: PointerDevice.Touch,\n        };\n        let device = pointerTypeToDevice[evt.pointerType] ?? PointerDevice.Other;\n        const eraserButtonMask = 0x20;\n        if (device === PointerDevice.Pen && (evt.buttons & eraserButtonMask) !== 0) {\n            device = PointerDevice.Eraser;\n        }\n        const timeStamp = evt.timeStamp;\n        const canvasPos = viewport.roundPoint(viewport.screenToCanvas(screenPos));\n        if (device === PointerDevice.PrimaryButtonMouse) {\n            if (evt.buttons & 0x2) {\n                device = PointerDevice.RightButtonMouse;\n            }\n            // Commented out: Mouse up events seem to not satisfy this condition on mouse up.\n            // else if (!(evt.buttons & 0x1)) {\n            //\tdevice = PointerDevice.Other;\n            //}\n        }\n        return new Pointer(screenPos, canvasPos, evt.pressure ?? null, evt.isPrimary, isDown, device, evt.pointerId, timeStamp);\n    }\n    // Create a new Pointer from a point on the canvas.\n    // Intended for unit tests.\n    static ofCanvasPoint(canvasPos, isDown, viewport, id = 0, device = PointerDevice.Pen, isPrimary = true, pressure = null, timeStamp = null) {\n        const screenPos = viewport.canvasToScreen(canvasPos);\n        timeStamp ??= performance.now();\n        return new Pointer(screenPos, canvasPos, pressure, isPrimary, isDown, device, id, timeStamp);\n    }\n    // Create a new Pointer from a point on the screen.\n    // Intended for unit tests.\n    static ofScreenPoint(screenPos, isDown, viewport, id = 0, device = PointerDevice.Pen, isPrimary = true, pressure = null, timeStamp = null) {\n        const canvasPos = viewport.screenToCanvas(screenPos);\n        timeStamp ??= performance.now();\n        return new Pointer(screenPos, canvasPos, pressure, isPrimary, isDown, device, id, timeStamp);\n    }\n}\nexports[\"default\"] = Pointer;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/Pointer.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/SVGLoader/SVGLoader.js":
/*!**************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/SVGLoader/SVGLoader.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SVGLoaderLoadMethod = exports.svgLoaderAutoresizeClassName = exports.svgLoaderAttributeContainerID = exports.svgStyleAttributesDataKey = exports.svgAttributesDataKey = exports.defaultSVGViewRect = void 0;\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\nconst BackgroundComponent_1 = __importStar(__webpack_require__(/*! ../components/BackgroundComponent */ \"./node_modules/js-draw/dist/cjs/components/BackgroundComponent.js\"));\nconst ImageComponent_1 = __importDefault(__webpack_require__(/*! ../components/ImageComponent */ \"./node_modules/js-draw/dist/cjs/components/ImageComponent.js\"));\nconst Stroke_1 = __importDefault(__webpack_require__(/*! ../components/Stroke */ \"./node_modules/js-draw/dist/cjs/components/Stroke.js\"));\nconst SVGGlobalAttributesObject_1 = __importDefault(__webpack_require__(/*! ../components/SVGGlobalAttributesObject */ \"./node_modules/js-draw/dist/cjs/components/SVGGlobalAttributesObject.js\"));\nconst TextComponent_1 = __importStar(__webpack_require__(/*! ../components/TextComponent */ \"./node_modules/js-draw/dist/cjs/components/TextComponent.js\"));\nconst UnknownSVGObject_1 = __importDefault(__webpack_require__(/*! ../components/UnknownSVGObject */ \"./node_modules/js-draw/dist/cjs/components/UnknownSVGObject.js\"));\nconst RenderablePathSpec_1 = __webpack_require__(/*! ../rendering/RenderablePathSpec */ \"./node_modules/js-draw/dist/cjs/rendering/RenderablePathSpec.js\");\nconst SVGRenderer_1 = __webpack_require__(/*! ../rendering/renderers/SVGRenderer */ \"./node_modules/js-draw/dist/cjs/rendering/renderers/SVGRenderer.js\");\nconst determineFontSize_1 = __importDefault(__webpack_require__(/*! ./utils/determineFontSize */ \"./node_modules/js-draw/dist/cjs/SVGLoader/utils/determineFontSize.js\"));\n// Size of a loaded image if no size is specified.\nexports.defaultSVGViewRect = new math_1.Rect2(0, 0, 500, 500);\n// Key to retrieve unrecognised attributes from an AbstractComponent\nexports.svgAttributesDataKey = 'svgAttrs';\n// Like {@link svgAttributesDataKey}, but for styles\nexports.svgStyleAttributesDataKey = 'svgStyleAttrs';\n// Key that specifies the ID of an SVG element that contained a given node when the image\n// was first loaded.\nexports.svgLoaderAttributeContainerID = 'svgContainerID';\n// If present in the exported SVG's class list, the image will be\n// autoresized when components are added/removed.\nexports.svgLoaderAutoresizeClassName = 'js-draw--autoresize';\n// @internal\nvar SVGLoaderLoadMethod;\n(function (SVGLoaderLoadMethod) {\n    SVGLoaderLoadMethod[\"IFrame\"] = \"iframe\";\n    SVGLoaderLoadMethod[\"DOMParser\"] = \"domparser\";\n})(SVGLoaderLoadMethod || (exports.SVGLoaderLoadMethod = SVGLoaderLoadMethod = {}));\nconst supportedStrokeFillStyleAttrs = ['stroke', 'fill', 'stroke-width'];\n// Handles loading images from SVG.\nclass SVGLoader {\n    constructor(source, onFinish, options) {\n        this.source = source;\n        this.onFinish = onFinish;\n        this.onAddComponent = null;\n        this.onProgress = null;\n        this.onDetermineExportRect = null;\n        this.processedCount = 0;\n        this.totalToProcess = 0;\n        this.containerGroupIDs = [];\n        this.encounteredIDs = [];\n        this.storeUnknown = !(options.sanitize ?? false);\n        this.disableUnknownObjectWarnings = !!options.disableUnknownObjectWarnings;\n    }\n    // If [computedStyles] is given, it is preferred to directly accessing node's style object.\n    getStyle(node, computedStyles) {\n        let fill = math_1.Color4.transparent;\n        let stroke;\n        // If possible, use computedStyles (allows property inheritance).\n        // Chromium, however, sets .fill to a falsy, but not undefined value in some cases where\n        // styles are available. As such, use || instead of ??.\n        const fillAttribute = node.getAttribute('fill') ?? (computedStyles?.fill || node.style?.fill);\n        if (fillAttribute) {\n            try {\n                fill = math_1.Color4.fromString(fillAttribute);\n            }\n            catch {\n                console.error('Unknown fill color,', fillAttribute);\n            }\n        }\n        const strokeAttribute = node.getAttribute('stroke') ?? computedStyles?.stroke ?? node.style?.stroke ?? '';\n        const strokeWidthAttr = node.getAttribute('stroke-width') ??\n            computedStyles?.strokeWidth ??\n            node.style?.strokeWidth ??\n            '';\n        if (strokeAttribute && strokeWidthAttr) {\n            try {\n                let width = parseFloat(strokeWidthAttr ?? '1');\n                if (!isFinite(width)) {\n                    width = 0;\n                }\n                const strokeColor = math_1.Color4.fromString(strokeAttribute);\n                if (strokeColor.a > 0) {\n                    stroke = {\n                        width,\n                        color: strokeColor,\n                    };\n                }\n            }\n            catch (e) {\n                console.error('Error parsing stroke data:', e);\n            }\n        }\n        const style = {\n            fill,\n            stroke,\n        };\n        return style;\n    }\n    strokeDataFromElem(node) {\n        const result = [];\n        const pathData = node.getAttribute('d') ?? '';\n        const style = this.getStyle(node);\n        // Break the path into chunks at each moveTo ('M') command:\n        const parts = pathData.split('M');\n        let isFirst = true;\n        for (const part of parts) {\n            // Skip effective no-ops -- moveTos without additional commands.\n            const isNoOpMoveTo = /^[0-9., \\t\\n]+$/.exec(part);\n            if (part !== '' && !isNoOpMoveTo) {\n                // We split the path by moveTo commands, so add the 'M' back in\n                // if it was present.\n                const current = !isFirst ? `M${part}` : part;\n                const path = math_1.Path.fromString(current);\n                const spec = (0, RenderablePathSpec_1.pathToRenderable)(path, style);\n                result.push(spec);\n            }\n            isFirst = false;\n        }\n        return result;\n    }\n    attachUnrecognisedAttrs(elem, node, supportedAttrs, supportedStyleAttrs) {\n        if (!this.storeUnknown) {\n            return;\n        }\n        for (const attr of node.getAttributeNames()) {\n            if (supportedAttrs.has(attr) || (attr === 'style' && supportedStyleAttrs)) {\n                continue;\n            }\n            elem.attachLoadSaveData(exports.svgAttributesDataKey, [\n                attr,\n                node.getAttribute(attr),\n            ]);\n        }\n        if (supportedStyleAttrs && node.style) {\n            // Use a for loop instead of an iterator: js-dom seems to not\n            // support using node.style as an iterator.\n            for (let i = 0; i < node.style.length; i++) {\n                const attr = node.style[i];\n                if (attr === '' || !attr) {\n                    continue;\n                }\n                if (supportedStyleAttrs.has(attr)) {\n                    continue;\n                }\n                // TODO: Do we need special logic for !important properties?\n                elem.attachLoadSaveData(exports.svgStyleAttributesDataKey, {\n                    key: attr,\n                    value: node.style.getPropertyValue(attr),\n                    priority: node.style.getPropertyPriority(attr),\n                });\n            }\n        }\n    }\n    // Adds a stroke with a single path\n    async addPath(node) {\n        let elem;\n        try {\n            const strokeData = this.strokeDataFromElem(node);\n            elem = new Stroke_1.default(strokeData);\n            this.attachUnrecognisedAttrs(elem, node, new Set([...supportedStrokeFillStyleAttrs, 'd']), new Set(supportedStrokeFillStyleAttrs));\n        }\n        catch (e) {\n            console.error('Invalid path in node', node, '\\nError:', e, '\\nAdding as an unknown object.');\n            if (this.storeUnknown) {\n                elem = new UnknownSVGObject_1.default(node);\n            }\n            else {\n                return;\n            }\n        }\n        await this.addComponent(elem);\n    }\n    async addBackground(node) {\n        // If a grid background,\n        if (node.classList.contains(BackgroundComponent_1.backgroundTypeToClassNameMap[BackgroundComponent_1.BackgroundType.Grid])) {\n            let foregroundStr;\n            let backgroundStr;\n            let gridStrokeWidthStr;\n            // If a group,\n            if (node.tagName.toLowerCase() === 'g') {\n                // We expect exactly two children. One of these is the solid\n                // background of the grid\n                if (node.children.length !== 2) {\n                    await this.addUnknownNode(node);\n                    return;\n                }\n                const background = node.children[0];\n                const grid = node.children[1];\n                backgroundStr = background.getAttribute('fill');\n                foregroundStr = grid.getAttribute('stroke');\n                gridStrokeWidthStr = grid.getAttribute('stroke-width');\n            }\n            else {\n                backgroundStr = node.getAttribute('fill');\n                foregroundStr = node.getAttribute('stroke');\n                gridStrokeWidthStr = node.getAttribute('stroke-width');\n            }\n            // Default to a transparent background.\n            backgroundStr ??= math_1.Color4.transparent.toHexString();\n            // A grid must have a foreground color specified.\n            if (!foregroundStr) {\n                await this.addUnknownNode(node);\n                return;\n            }\n            // Extract the grid size from the class name\n            let gridSize = undefined;\n            for (const className of node.classList) {\n                if (className.startsWith(BackgroundComponent_1.imageBackgroundGridSizeCSSPrefix)) {\n                    const sizeStr = className.substring(BackgroundComponent_1.imageBackgroundGridSizeCSSPrefix.length);\n                    gridSize = parseFloat(sizeStr.replace(/p/g, '.'));\n                }\n            }\n            let gridStrokeWidth = undefined;\n            if (gridStrokeWidthStr) {\n                gridStrokeWidth = parseFloat(gridStrokeWidthStr);\n            }\n            const backgroundColor = math_1.Color4.fromString(backgroundStr);\n            let foregroundColor = math_1.Color4.fromString(foregroundStr);\n            // Should the foreground color be determined automatically?\n            if (!node.classList.contains(BackgroundComponent_1.imageBackgroundNonAutomaticSecondaryColorCSSClassName)) {\n                foregroundColor = undefined;\n            }\n            const elem = BackgroundComponent_1.default.ofGrid(backgroundColor, gridSize, foregroundColor, gridStrokeWidth);\n            await this.addComponent(elem);\n        }\n        // Otherwise, if just a <path/>, it's a solid color background.\n        else if (node.tagName.toLowerCase() === 'path') {\n            const fill = math_1.Color4.fromString(node.getAttribute('fill') ?? node.style.fill ?? 'black');\n            const elem = new BackgroundComponent_1.default(BackgroundComponent_1.BackgroundType.SolidColor, fill);\n            await this.addComponent(elem);\n        }\n        else {\n            await this.addUnknownNode(node);\n        }\n    }\n    getComputedStyle(element) {\n        try {\n            // getComputedStyle may fail in jsdom when using a DOMParser.\n            return window.getComputedStyle(element);\n        }\n        catch (error) {\n            console.warn('Error computing style', error);\n            return undefined;\n        }\n    }\n    // If given, 'supportedAttrs' will have x, y, etc. attributes that were used in computing the transform added to it,\n    // to prevent storing duplicate transform information when saving the component.\n    getTransform(elem, supportedAttrs, computedStyles) {\n        // If possible, load the js-draw specific transform attribute\n        const highpTransformAttribute = 'data-highp-transform';\n        const rawTransformData = elem.getAttribute(highpTransformAttribute);\n        let transform;\n        if (rawTransformData) {\n            try {\n                transform = math_1.Mat33.fromCSSMatrix(rawTransformData);\n                supportedAttrs?.push(highpTransformAttribute);\n            }\n            catch (e) {\n                console.warn(`Unable to parse raw transform data, ${rawTransformData}. Falling back to CSS data. Error:`, e);\n            }\n        }\n        if (!transform) {\n            computedStyles ??= this.getComputedStyle(elem);\n            let transformProperty = computedStyles?.transform;\n            if (!transformProperty || transformProperty === 'none') {\n                transformProperty = elem.style?.transform || 'none';\n            }\n            // Prefer the actual .style.transform\n            // to the computed stylesheet -- in some browsers, the computedStyles version\n            // can have lower precision.\n            try {\n                transform = math_1.Mat33.fromCSSMatrix(elem.style.transform);\n            }\n            catch (_e) {\n                console.warn('matrix parse error', _e);\n                transform = math_1.Mat33.fromCSSMatrix(transformProperty);\n            }\n            const elemX = elem.getAttribute('x');\n            const elemY = elem.getAttribute('y');\n            if (elemX || elemY) {\n                const x = parseFloat(elemX ?? '0');\n                const y = parseFloat(elemY ?? '0');\n                if (!isNaN(x) && !isNaN(y)) {\n                    supportedAttrs?.push('x', 'y');\n                    transform = transform.rightMul(math_1.Mat33.translation(math_1.Vec2.of(x, y)));\n                }\n            }\n        }\n        return transform;\n    }\n    makeText(elem) {\n        const contentList = [];\n        for (const child of elem.childNodes) {\n            if (child.nodeType === Node.TEXT_NODE) {\n                contentList.push(child.nodeValue ?? '');\n            }\n            else if (child.nodeType === Node.ELEMENT_NODE) {\n                const subElem = child;\n                if (subElem.tagName.toLowerCase() === 'tspan') {\n                    // FIXME: tspan's (x, y) components are absolute, not relative to the parent.\n                    contentList.push(this.makeText(subElem));\n                }\n                else {\n                    throw new Error(`Unrecognized text child element: ${subElem}`);\n                }\n            }\n            else {\n                throw new Error(`Unrecognized text child node: ${child}.`);\n            }\n        }\n        // If no content, the content is an empty string.\n        if (contentList.length === 0) {\n            contentList.push('');\n        }\n        // Compute styles.\n        const computedStyles = this.getComputedStyle(elem);\n        const supportedStyleAttrs = new Set([\n            'fontFamily',\n            'transform',\n            ...supportedStrokeFillStyleAttrs,\n        ]);\n        const style = {\n            size: (0, determineFontSize_1.default)(elem, computedStyles, supportedStyleAttrs),\n            fontFamily: computedStyles?.fontFamily || elem.style?.fontFamily || 'sans-serif',\n            fontWeight: computedStyles?.fontWeight || elem.style?.fontWeight || undefined,\n            fontStyle: computedStyles?.fontStyle || elem.style?.fontStyle || undefined,\n            renderingStyle: this.getStyle(elem, computedStyles),\n        };\n        const supportedAttrs = [];\n        let transform = this.getTransform(elem, supportedAttrs, computedStyles);\n        let transformMode = TextComponent_1.TextTransformMode.ABSOLUTE_XY;\n        const elemDX = elem.getAttribute('dx');\n        if (elemDX) {\n            transformMode = TextComponent_1.TextTransformMode.RELATIVE_X_ABSOLUTE_Y;\n            transform = transform.rightMul(math_1.Mat33.translation(math_1.Vec2.of(parseFloat(elemDX), 0)));\n            supportedAttrs.push('dx');\n        }\n        const elemDY = elem.getAttribute('dy');\n        if (elemDY) {\n            if (transformMode === TextComponent_1.TextTransformMode.RELATIVE_X_ABSOLUTE_Y) {\n                transformMode = TextComponent_1.TextTransformMode.RELATIVE_XY;\n            }\n            else {\n                transformMode = TextComponent_1.TextTransformMode.RELATIVE_Y_ABSOLUTE_X;\n            }\n            transform = transform.rightMul(math_1.Mat33.translation(math_1.Vec2.of(0, parseFloat(elemDY))));\n            supportedAttrs.push('dy');\n        }\n        const result = new TextComponent_1.default(contentList, transform, style, transformMode);\n        this.attachUnrecognisedAttrs(result, elem, new Set(supportedAttrs), new Set(supportedStyleAttrs));\n        return result;\n    }\n    async addText(elem) {\n        try {\n            const textElem = this.makeText(elem);\n            await this.addComponent(textElem);\n        }\n        catch (e) {\n            console.error('Invalid text object in node', elem, '. Continuing.... Error:', e);\n            this.addUnknownNode(elem);\n        }\n    }\n    async addImage(elem) {\n        const image = new Image();\n        image.src = elem.getAttribute('xlink:href') ?? elem.href.baseVal;\n        image.setAttribute('alt', elem.getAttribute('aria-label') ?? '');\n        try {\n            const supportedAttrs = [];\n            const transform = this.getTransform(elem, supportedAttrs);\n            const imageElem = await ImageComponent_1.default.fromImage(image, transform);\n            this.attachUnrecognisedAttrs(imageElem, elem, new Set(supportedAttrs), new Set(['transform']));\n            await this.addComponent(imageElem);\n        }\n        catch (e) {\n            console.error('Error loading image:', e, '. Element: ', elem, '. Continuing...');\n            await this.addUnknownNode(elem);\n        }\n    }\n    async addUnknownNode(node) {\n        if (this.storeUnknown) {\n            const component = new UnknownSVGObject_1.default(node);\n            await this.addComponent(component);\n        }\n    }\n    async startGroup(node) {\n        node = node.cloneNode(false);\n        // Select a unique ID based on the node's ID property (if it exists).\n        // Use `||` and not `??` so that empty string IDs are also replaced.\n        let id = node.id || `id-${this.encounteredIDs.length}`;\n        // Make id unique.\n        let idSuffixCounter = 0;\n        let suffix = '';\n        while (this.encounteredIDs.includes(id + suffix)) {\n            idSuffixCounter++;\n            suffix = '--' + idSuffixCounter;\n        }\n        id += suffix;\n        // Remove all children from the node -- children will be handled separately\n        // (not removing children here could cause duplicates in the result, when rendered).\n        node.replaceChildren();\n        node.id = id;\n        const component = new UnknownSVGObject_1.default(node);\n        this.addComponent(component);\n        // Add to IDs after -- we don't want the <g> element to be marked\n        // as its own container.\n        this.containerGroupIDs.push(node.id);\n        this.encounteredIDs.push(node.id);\n    }\n    // Ends the most recent group started by .startGroup\n    async endGroup() {\n        this.containerGroupIDs.pop();\n    }\n    async addComponent(component) {\n        // Attach the stack of container IDs\n        if (this.containerGroupIDs.length > 0) {\n            component.attachLoadSaveData(exports.svgLoaderAttributeContainerID, [...this.containerGroupIDs]);\n        }\n        await this.onAddComponent?.(component);\n    }\n    updateViewBox(node) {\n        const viewBoxAttr = node.getAttribute('viewBox');\n        if (this.rootViewBox || !viewBoxAttr) {\n            return;\n        }\n        const components = viewBoxAttr.split(/[ \\t\\n,]+/);\n        const x = parseFloat(components[0]);\n        const y = parseFloat(components[1]);\n        const width = parseFloat(components[2]);\n        const height = parseFloat(components[3]);\n        if (isNaN(x) || isNaN(y) || isNaN(width) || isNaN(height)) {\n            console.warn(`node ${node} has an unparsable viewbox. Viewbox: ${viewBoxAttr}. Match: ${components}.`);\n            return;\n        }\n        const autoresize = node.classList.contains(exports.svgLoaderAutoresizeClassName);\n        this.rootViewBox = new math_1.Rect2(x, y, width, height);\n        this.onDetermineExportRect?.(this.rootViewBox, { autoresize });\n    }\n    async updateSVGAttrs(node) {\n        if (this.storeUnknown) {\n            await this.onAddComponent?.(new SVGGlobalAttributesObject_1.default(this.getSourceAttrs(node)));\n        }\n    }\n    async visit(node) {\n        this.totalToProcess += node.childElementCount;\n        let visitChildren = true;\n        switch (node.tagName.toLowerCase()) {\n            case 'g':\n                if (node.classList.contains(BackgroundComponent_1.imageBackgroundCSSClassName)) {\n                    await this.addBackground(node);\n                    visitChildren = false;\n                }\n                else {\n                    await this.startGroup(node);\n                }\n                // Otherwise, continue -- visit the node's children.\n                break;\n            case 'path':\n                if (node.classList.contains(BackgroundComponent_1.imageBackgroundCSSClassName)) {\n                    await this.addBackground(node);\n                }\n                else {\n                    await this.addPath(node);\n                }\n                break;\n            case 'text':\n                await this.addText(node);\n                visitChildren = false;\n                break;\n            case 'image':\n                await this.addImage(node);\n                // Images should not have children.\n                visitChildren = false;\n                break;\n            case 'svg':\n                this.updateViewBox(node);\n                this.updateSVGAttrs(node);\n                break;\n            case 'style':\n                // Keeping unnecessary style sheets can cause the browser to keep all\n                // SVG elements *referenced* by the style sheet in some browsers.\n                //\n                // Only keep the style sheet if it won't be discarded on save.\n                if (node.getAttribute('id') !== SVGRenderer_1.renderedStylesheetId) {\n                    await this.addUnknownNode(node);\n                }\n                break;\n            default:\n                if (!this.disableUnknownObjectWarnings) {\n                    console.warn('Unknown SVG element,', node, node.tagName);\n                    if (!(node instanceof SVGElement)) {\n                        console.warn('Element', node, 'is not an SVGElement!', this.storeUnknown ? 'Continuing anyway.' : 'Skipping.');\n                    }\n                }\n                await this.addUnknownNode(node);\n                return;\n        }\n        if (visitChildren) {\n            for (const child of node.children) {\n                await this.visit(child);\n            }\n            if (node.tagName.toLowerCase() === 'g') {\n                await this.endGroup();\n            }\n        }\n        this.processedCount++;\n        await this.onProgress?.(this.processedCount, this.totalToProcess);\n    }\n    // Get SVG element attributes (e.g. xlink=...)\n    getSourceAttrs(node) {\n        return node.getAttributeNames().map((attr) => {\n            return [attr, node.getAttribute(attr)];\n        });\n    }\n    async start(onAddComponent, onProgress, onDetermineExportRect = null) {\n        this.onAddComponent = onAddComponent;\n        this.onProgress = onProgress;\n        this.onDetermineExportRect = onDetermineExportRect;\n        // Estimate the number of tags to process.\n        this.totalToProcess = this.source.childElementCount;\n        this.processedCount = 0;\n        this.rootViewBox = null;\n        await this.visit(this.source);\n        const viewBox = this.rootViewBox;\n        if (!viewBox) {\n            this.onDetermineExportRect?.(exports.defaultSVGViewRect);\n        }\n        this.onFinish?.();\n        this.onFinish = null;\n    }\n    /**\n     * Create an `SVGLoader` from the content of an SVG image. SVGs are loaded within a sandboxed\n     * iframe with `sandbox=\"allow-same-origin\"`\n     * [thereby disabling JavaScript](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#sandbox).\n     *\n     * @see {@link Editor.loadFrom}\n     * @param text - Textual representation of the SVG (e.g. `<svg viewbox='...'>...</svg>`).\n     * @param options - if `true` or `false`, treated as the `sanitize` option -- don't store unknown attributes.\n     */\n    static fromString(text, options = false) {\n        const domParserLoad = typeof options !== 'boolean' && options?.loadMethod === SVGLoaderLoadMethod.DOMParser;\n        const { svgElem, cleanUp } = (() => {\n            // If the user requested an iframe load (the default) try to load with an iframe.\n            // There are some cases (e.g. in a sandboxed iframe) where this doesn't work.\n            // TODO(v2): Use domParserLoad by default.\n            if (!domParserLoad) {\n                try {\n                    const sandbox = document.createElement('iframe');\n                    sandbox.src = 'about:blank';\n                    // allow-same-origin is necessary for how we interact with the sandbox. As such,\n                    // DO NOT ENABLE ALLOW-SCRIPTS.\n                    sandbox.setAttribute('sandbox', 'allow-same-origin');\n                    sandbox.setAttribute('csp', \"default-src 'about:blank'\");\n                    sandbox.style.display = 'none';\n                    // Required to access the frame's DOM. See https://stackoverflow.com/a/17777943/17055750\n                    document.body.appendChild(sandbox);\n                    if (!sandbox.hasAttribute('sandbox')) {\n                        sandbox.remove();\n                        throw new Error('SVG loading iframe is not sandboxed.');\n                    }\n                    const sandboxDoc = sandbox.contentWindow?.document ?? sandbox.contentDocument;\n                    if (sandboxDoc == null)\n                        throw new Error('Unable to open a sandboxed iframe!');\n                    sandboxDoc.open();\n                    sandboxDoc.write(`\n\t\t\t\t\t\t<!DOCTYPE html>\n\t\t\t\t\t\t<html>\n\t\t\t\t\t\t\t<head>\n\t\t\t\t\t\t\t\t<title>SVG Loading Sandbox</title>\n\t\t\t\t\t\t\t\t<meta name='viewport' conent='width=device-width,initial-scale=1.0'/>\n\t\t\t\t\t\t\t\t<meta charset='utf-8'/>\n\t\t\t\t\t\t\t</head>\n\t\t\t\t\t\t\t<body style='font-size: 12px;'>\n\t\t\t\t\t\t\t\t<script>\n\t\t\t\t\t\t\t\t\tconsole.error('JavaScript should not be able to run here!');\n\t\t\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t\t\t'The SVG sandbox is broken! Please double-check the sandboxing setting.'\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t</script>\n\t\t\t\t\t\t\t</body>\n\t\t\t\t\t\t</html>\n\t\t\t\t\t`);\n                    sandboxDoc.close();\n                    const svgElem = sandboxDoc.createElementNS('http://www.w3.org/2000/svg', 'svg');\n                    // eslint-disable-next-line no-unsanitized/property -- setting innerHTML in a sandboxed document.\n                    svgElem.innerHTML = text;\n                    sandboxDoc.body.appendChild(svgElem);\n                    const cleanUp = () => {\n                        svgElem.remove();\n                        sandbox.remove();\n                        sandbox.src = '';\n                    };\n                    return { svgElem, cleanUp };\n                }\n                catch (error) {\n                    console.warn('Failed loading SVG via a sandboxed iframe. Some styles may not be loaded correctly. Error: ', error);\n                }\n            }\n            // Fall back to creating a DOMParser\n            const parser = new DOMParser();\n            const doc = parser.parseFromString(`<svg xmlns=\"http://www.w3.org/2000/svg\">${text}</svg>`, 'text/html');\n            const svgElem = doc.querySelector('svg');\n            // Handle error messages reported while parsing. See\n            // https://developer.mozilla.org/en-US/docs/Web/Guide/Parsing_and_serializing_XML\n            const errorReportNode = doc.querySelector('parsererror');\n            if (errorReportNode) {\n                throw new Error('Parse error: ' + errorReportNode.textContent);\n            }\n            const cleanUp = () => { };\n            return { svgElem, cleanUp };\n        })();\n        // Handle options\n        let sanitize;\n        let disableUnknownObjectWarnings;\n        if (typeof options === 'boolean') {\n            sanitize = options;\n            disableUnknownObjectWarnings = false;\n        }\n        else {\n            sanitize = options.sanitize ?? false;\n            disableUnknownObjectWarnings = options.disableUnknownObjectWarnings ?? false;\n        }\n        return new SVGLoader(svgElem, cleanUp, {\n            sanitize,\n            disableUnknownObjectWarnings,\n        });\n    }\n}\nexports[\"default\"] = SVGLoader;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/SVGLoader/SVGLoader.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/SVGLoader/utils/determineFontSize.js":
/*!****************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/SVGLoader/utils/determineFontSize.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/** Computes the font size of a text element, based on style information. */\nconst determineFontSize = (elem, computedStyles, \n// output: Written to to update supported style attributes\nsupportedStyleAttrs) => {\n    const fontSizeExp = /^([-0-9.e]+)px/i;\n    // In some environments, computedStyles.fontSize can be increased by the system.\n    // Thus, to prevent text from growing on load/save, prefer .style.fontSize.\n    let fontSizeMatch = fontSizeExp.exec(elem.style?.fontSize ?? '');\n    if (!fontSizeMatch && elem.tagName.toLowerCase() === 'tspan' && elem.parentElement) {\n        // Try to inherit the font size of the parent text element.\n        fontSizeMatch = fontSizeExp.exec(elem.parentElement.style?.fontSize ?? '');\n    }\n    // If we still couldn't find a font size, try to use computedStyles (which can be\n    // wrong).\n    if (!fontSizeMatch && computedStyles) {\n        fontSizeMatch = fontSizeExp.exec(computedStyles.fontSize);\n    }\n    let fontSize = 12;\n    if (fontSizeMatch) {\n        supportedStyleAttrs.add('fontSize');\n        fontSize = parseFloat(fontSizeMatch[1]);\n    }\n    return fontSize;\n};\nexports[\"default\"] = determineFontSize;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/SVGLoader/utils/determineFontSize.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/UndoRedoHistory.js":
/*!**********************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/UndoRedoHistory.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _UndoRedoHistory_undoStack, _UndoRedoHistory_redoStack;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst types_1 = __webpack_require__(/*! ./types */ \"./node_modules/js-draw/dist/cjs/types.js\");\nclass UndoRedoHistory {\n    // @internal\n    constructor(editor, announceRedoCallback, announceUndoCallback) {\n        this.editor = editor;\n        this.announceRedoCallback = announceRedoCallback;\n        this.announceUndoCallback = announceUndoCallback;\n        _UndoRedoHistory_undoStack.set(this, void 0);\n        _UndoRedoHistory_redoStack.set(this, void 0);\n        this.maxUndoRedoStackSize = 700;\n        __classPrivateFieldSet(this, _UndoRedoHistory_undoStack, [], \"f\");\n        __classPrivateFieldSet(this, _UndoRedoHistory_redoStack, [], \"f\");\n    }\n    fireUpdateEvent(stackUpdateType, triggeringCommand) {\n        this.editor.notifier.dispatch(types_1.EditorEventType.UndoRedoStackUpdated, {\n            kind: types_1.EditorEventType.UndoRedoStackUpdated,\n            undoStackSize: __classPrivateFieldGet(this, _UndoRedoHistory_undoStack, \"f\").length,\n            redoStackSize: __classPrivateFieldGet(this, _UndoRedoHistory_redoStack, \"f\").length,\n            command: triggeringCommand,\n            stackUpdateType,\n        });\n    }\n    // Adds the given command to this and applies it to the editor.\n    push(command, apply = true) {\n        if (apply) {\n            command.apply(this.editor);\n        }\n        __classPrivateFieldGet(this, _UndoRedoHistory_undoStack, \"f\").push(command);\n        for (const elem of __classPrivateFieldGet(this, _UndoRedoHistory_redoStack, \"f\")) {\n            elem.onDrop(this.editor);\n        }\n        __classPrivateFieldSet(this, _UndoRedoHistory_redoStack, [], \"f\");\n        if (__classPrivateFieldGet(this, _UndoRedoHistory_undoStack, \"f\").length > this.maxUndoRedoStackSize) {\n            const removeAtOnceCount = Math.ceil(this.maxUndoRedoStackSize / 100);\n            const removedElements = __classPrivateFieldGet(this, _UndoRedoHistory_undoStack, \"f\").splice(0, removeAtOnceCount);\n            removedElements.forEach((elem) => elem.onDrop(this.editor));\n        }\n        this.fireUpdateEvent(types_1.UndoEventType.CommandDone, command);\n        this.editor.notifier.dispatch(types_1.EditorEventType.CommandDone, {\n            kind: types_1.EditorEventType.CommandDone,\n            command,\n        });\n    }\n    // Remove the last command from this' undo stack and apply it.\n    undo() {\n        const command = __classPrivateFieldGet(this, _UndoRedoHistory_undoStack, \"f\").pop();\n        if (command) {\n            __classPrivateFieldGet(this, _UndoRedoHistory_redoStack, \"f\").push(command);\n            const result = command.unapply(this.editor);\n            this.announceUndoCallback(command);\n            this.fireUpdateEvent(types_1.UndoEventType.CommandUndone, command);\n            this.editor.notifier.dispatch(types_1.EditorEventType.CommandUndone, {\n                kind: types_1.EditorEventType.CommandUndone,\n                command,\n            });\n            return result;\n        }\n    }\n    redo() {\n        const command = __classPrivateFieldGet(this, _UndoRedoHistory_redoStack, \"f\").pop();\n        if (command) {\n            __classPrivateFieldGet(this, _UndoRedoHistory_undoStack, \"f\").push(command);\n            const result = command.apply(this.editor);\n            this.announceRedoCallback(command);\n            this.fireUpdateEvent(types_1.UndoEventType.CommandRedone, command);\n            this.editor.notifier.dispatch(types_1.EditorEventType.CommandDone, {\n                kind: types_1.EditorEventType.CommandDone,\n                command,\n            });\n            return result;\n        }\n    }\n    get undoStackSize() {\n        return __classPrivateFieldGet(this, _UndoRedoHistory_undoStack, \"f\").length;\n    }\n    get redoStackSize() {\n        return __classPrivateFieldGet(this, _UndoRedoHistory_redoStack, \"f\").length;\n    }\n}\n_UndoRedoHistory_undoStack = new WeakMap(), _UndoRedoHistory_redoStack = new WeakMap();\nexports[\"default\"] = UndoRedoHistory;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/UndoRedoHistory.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/Viewport.js":
/*!***************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/Viewport.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar _inverseTransform, _a;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Viewport = exports.ViewportTransform = void 0;\nconst Command_1 = __importDefault(__webpack_require__(/*! ./commands/Command */ \"./node_modules/js-draw/dist/cjs/commands/Command.js\"));\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\nclass ViewportTransform extends Command_1.default {\n}\nexports.ViewportTransform = ViewportTransform;\nclass Viewport {\n    // @internal\n    constructor(onTransformChangeCallback) {\n        this.onTransformChangeCallback = onTransformChangeCallback;\n        this.resetTransform(math_1.Mat33.identity);\n        this.screenRect = math_1.Rect2.empty;\n    }\n    /**\n     * @returns a temporary copy of `this` that does not notify when modified. This is\n     * useful when rendering with a temporarily different viewport.\n     */\n    getTemporaryClone() {\n        const result = new Viewport(() => { });\n        result.transform = this.transform;\n        result.inverseTransform = this.inverseTransform;\n        result.screenRect = this.screenRect;\n        return result;\n    }\n    /** Resizes the screen rect to the given size. @internal */\n    updateScreenSize(screenSize) {\n        this.screenRect = this.screenRect.resizedTo(screenSize);\n    }\n    /** Get the screen's visible region transformed into canvas space. */\n    get visibleRect() {\n        return this.screenRect.transformedBoundingBox(this.inverseTransform);\n    }\n    /** @returns the given point, but in canvas coordinates */\n    screenToCanvas(screenPoint) {\n        return this.inverseTransform.transformVec2(screenPoint);\n    }\n    /** @returns the given point transformed into screen coordinates. */\n    canvasToScreen(canvasPoint) {\n        return this.transform.transformVec2(canvasPoint);\n    }\n    /** @returns a command that transforms the canvas by `transform`. */\n    static transformBy(transform) {\n        return new Viewport.ViewportTransform(transform);\n    }\n    /**\n     * Updates the transformation directly. Using `transformBy` is preferred.\n     * @param newTransform - should map from canvas coordinates to screen coordinates.\n     */\n    resetTransform(newTransform = math_1.Mat33.identity) {\n        const oldTransform = this.transform;\n        this.transform = newTransform;\n        this.inverseTransform = newTransform.inverse();\n        this.onTransformChangeCallback?.(oldTransform, newTransform);\n    }\n    get screenToCanvasTransform() {\n        return this.inverseTransform;\n    }\n    get canvasToScreenTransform() {\n        return this.transform;\n    }\n    /** @returns the size of the visible region in pixels (screen units). */\n    getScreenRectSize() {\n        return this.screenRect.size;\n    }\n    /** Alias for `getScreenRectSize`. @deprecated */\n    getResolution() {\n        return this.getScreenRectSize();\n    }\n    /** @returns the amount a vector on the canvas is scaled to become a vector on the screen. */\n    getScaleFactor() {\n        // Use transformVec3 to avoid translating the vector\n        return this.transform.transformVec3(math_1.Vec3.unitX).magnitude();\n    }\n    /**\n     * @returns `getScaleFactor()` rounded to the nearest power of 10.\n     * For example, if `getScaleFactor()` returns 101, `getScaleFactorToNearestPowerOfTen()`\n     * should return `100` because `100` is the nearest power of 10 to 101.\n     */\n    getScaleFactorToNearestPowerOfTen() {\n        return this.getScaleFactorToNearestPowerOf(10);\n    }\n    getScaleFactorToNearestPowerOf(powerOf) {\n        const scaleFactor = this.getScaleFactor();\n        return Math.pow(powerOf, Math.round(Math.log(scaleFactor) / Math.log(powerOf)));\n    }\n    /** Returns the size of a grid cell (in canvas units) as used by {@link snapToGrid}. */\n    static getGridSize(scaleFactor) {\n        return 50 / scaleFactor;\n    }\n    /**\n     * Snaps `canvasPos` to the nearest grid cell corner.\n     *\n     * @see {@link getGridSize}.\n     */\n    snapToGrid(canvasPos) {\n        const scaleFactor = this.getScaleFactorToNearestPowerOf(2);\n        const snapCoordinate = (coordinate) => {\n            const roundFactor = 1 / Viewport.getGridSize(scaleFactor);\n            const snapped = Math.round(coordinate * roundFactor) / roundFactor;\n            return snapped;\n        };\n        const snappedCanvasPos = math_1.Vec2.of(snapCoordinate(canvasPos.x), snapCoordinate(canvasPos.y));\n        return snappedCanvasPos;\n    }\n    /** Returns the size of one screen pixel in canvas units. */\n    getSizeOfPixelOnCanvas() {\n        return 1 / this.getScaleFactor();\n    }\n    /**\n     * @returns the angle of the canvas in radians.\n     * This is the angle by which the canvas is rotated relative to the screen.\n     *\n     * Returns an angle in the range $[-\\pi, \\pi]$ (the same range as {@link Vec3.angle}).\n     */\n    getRotationAngle() {\n        return this.transform.transformVec3(math_1.Vec3.unitX).angle();\n    }\n    // The separate function type definition seems necessary here.\n    // See https://stackoverflow.com/a/58163623/17055750.\n    static roundPoint(point, tolerance) {\n        const scaleFactor = 10 ** Math.floor(Math.log10(tolerance));\n        const roundComponent = (component) => {\n            return Math.round(component / scaleFactor) * scaleFactor;\n        };\n        if (typeof point === 'number') {\n            return roundComponent(point);\n        }\n        return point.map(roundComponent);\n    }\n    /** Round a point with a tolerance of ±1 screen unit. */\n    roundPoint(point) {\n        return Viewport.roundPoint(point, 1 / this.getScaleFactor());\n    }\n    // `roundAmount`: An integer >= 0, larger numbers cause less rounding. Smaller numbers cause more\n    // (as such `roundAmount = 0` does the most rounding).\n    static roundScaleRatio(scaleRatio, roundAmount = 1) {\n        if (Math.abs(scaleRatio) <= 1e-12) {\n            return 0;\n        }\n        // Represent as k 10ⁿ for some n, k ∈ ℤ.\n        const decimalComponent = 10 ** Math.floor(Math.log10(Math.abs(scaleRatio)));\n        const roundAmountFactor = 2 ** roundAmount;\n        scaleRatio =\n            (Math.round((scaleRatio / decimalComponent) * roundAmountFactor) / roundAmountFactor) *\n                decimalComponent;\n        return scaleRatio;\n    }\n    // Computes and returns an affine transformation that makes `toMakeVisible` visible and roughly centered on the screen.\n    computeZoomToTransform(toMakeVisible, allowZoomIn = true, allowZoomOut = true) {\n        let transform = math_1.Mat33.identity;\n        // Invalid size? (Would divide by zero)\n        if (toMakeVisible.w === 0 || toMakeVisible.h === 0) {\n            // Create a new rectangle with a valid size\n            let newSize = Math.max(toMakeVisible.w, toMakeVisible.h);\n            // Choose a reasonable default size, but don't zoom.\n            if (newSize === 0) {\n                newSize = 50;\n                allowZoomIn = false;\n                allowZoomOut = false;\n            }\n            toMakeVisible = new math_1.Rect2(toMakeVisible.x, toMakeVisible.y, newSize, newSize);\n        }\n        if (isNaN(toMakeVisible.size.magnitude())) {\n            throw new Error(`${toMakeVisible.toString()} rectangle has NaN size! Cannot zoom to!`);\n        }\n        // Try to move the selection within the center 4/5ths of the viewport.\n        const recomputeTargetRect = () => {\n            // transform transforms objects on the canvas. As such, we need to invert it\n            // to transform the viewport.\n            const visibleRect = this.visibleRect.transformedBoundingBox(transform.inverse());\n            return visibleRect.transformedBoundingBox(math_1.Mat33.scaling2D(4 / 5, visibleRect.center));\n        };\n        let targetRect = recomputeTargetRect();\n        const largerThanTarget = targetRect.w < toMakeVisible.w || targetRect.h < toMakeVisible.h;\n        // Ensure that toMakeVisible is at least 1/3rd of the visible region.\n        const muchSmallerThanTarget = toMakeVisible.maxDimension / targetRect.maxDimension < 1 / 3;\n        if ((largerThanTarget && allowZoomOut) || (muchSmallerThanTarget && allowZoomIn)) {\n            const multiplier = Math.max(toMakeVisible.w / targetRect.w, toMakeVisible.h / targetRect.h);\n            const visibleRectTransform = math_1.Mat33.scaling2D(multiplier, targetRect.topLeft);\n            const viewportContentTransform = visibleRectTransform.inverse();\n            transform = transform.rightMul(viewportContentTransform);\n        }\n        targetRect = recomputeTargetRect();\n        // Ensure that the center of the region is visible\n        if (!targetRect.containsRect(toMakeVisible)) {\n            // target position - current position\n            const translation = toMakeVisible.center.minus(targetRect.center);\n            const visibleRectTransform = math_1.Mat33.translation(translation);\n            const viewportContentTransform = visibleRectTransform.inverse();\n            transform = transform.rightMul(viewportContentTransform);\n        }\n        if (!transform.invertable()) {\n            console.warn('Unable to zoom to ', toMakeVisible, '! Computed transform', transform, 'is singular.');\n            transform = math_1.Mat33.identity;\n        }\n        return transform;\n    }\n    // Returns a Command that transforms the view such that [rect] is visible, and perhaps\n    // centered in the viewport.\n    // Returns null if no transformation is necessary\n    //\n    // @see {@link computeZoomToTransform}\n    zoomTo(toMakeVisible, allowZoomIn = true, allowZoomOut = true) {\n        const transform = this.computeZoomToTransform(toMakeVisible, allowZoomIn, allowZoomOut);\n        return new Viewport.ViewportTransform(transform);\n    }\n}\nexports.Viewport = Viewport;\n// Command that translates/scales the viewport.\nViewport.ViewportTransform = (_a = class extends ViewportTransform {\n        constructor(transform) {\n            super();\n            this.transform = transform;\n            _inverseTransform.set(this, void 0);\n            __classPrivateFieldSet(this, _inverseTransform, transform.inverse(), \"f\");\n        }\n        apply(editor) {\n            const viewport = editor.viewport;\n            viewport.resetTransform(viewport.transform.rightMul(this.transform));\n            editor.queueRerender();\n        }\n        unapply(editor) {\n            const viewport = editor.viewport;\n            viewport.resetTransform(viewport.transform.rightMul(__classPrivateFieldGet(this, _inverseTransform, \"f\")));\n            editor.queueRerender();\n        }\n        description(editor, localizationTable) {\n            const result = [];\n            // Describe the transformation's affect on the viewport (note that transformation transforms\n            // the **elements** within the viewport). Assumes the transformation only does rotation/scale/translation.\n            const origVec = editor.viewport.visibleRect.center;\n            const linearTransformedVec = this.transform.transformVec3(math_1.Vec2.unitX);\n            const affineTransformedVec = this.transform.transformVec2(origVec);\n            const scale = linearTransformedVec.magnitude();\n            const rotation = (180 / Math.PI) * linearTransformedVec.angle();\n            const translation = affineTransformedVec.minus(origVec);\n            if (scale > 1.2) {\n                result.push(localizationTable.zoomedIn);\n            }\n            else if (scale < 0.8) {\n                result.push(localizationTable.zoomedOut);\n            }\n            if (Math.floor(Math.abs(rotation)) > 0) {\n                result.push(localizationTable.rotatedBy(Math.round(rotation)));\n            }\n            const minTranslation = 1e-4;\n            if (translation.x > minTranslation) {\n                result.push(localizationTable.movedLeft);\n            }\n            else if (translation.x < -minTranslation) {\n                result.push(localizationTable.movedRight);\n            }\n            if (translation.y < -minTranslation) {\n                result.push(localizationTable.movedDown);\n            }\n            else if (translation.y > minTranslation) {\n                result.push(localizationTable.movedUp);\n            }\n            return result.join('; ');\n        }\n    },\n    _inverseTransform = new WeakMap(),\n    _a);\nexports[\"default\"] = Viewport;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/Viewport.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/commands/Command.js":
/*!***********************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/commands/Command.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Command = void 0;\n/**\n * A `Command` is an action that can be done, redone, and undone. It's used to enable undo/redo.\n *\n * See {@link Editor.dispatch}.\n */\nclass Command {\n    // Called when the command is being deleted\n    onDrop(_editor) { }\n    /** @deprecated Use {@link uniteCommands} */\n    static union(a, b) {\n        return new (class extends Command {\n            apply(editor) {\n                a.apply(editor);\n                b.apply(editor);\n            }\n            unapply(editor) {\n                b.unapply(editor);\n                a.unapply(editor);\n            }\n            description(editor, localizationTable) {\n                const aDescription = a.description(editor, localizationTable);\n                const bDescription = b.description(editor, localizationTable);\n                if (aDescription === bDescription) {\n                    return aDescription;\n                }\n                return `${aDescription}, ${bDescription}`;\n            }\n        })();\n    }\n}\nexports.Command = Command;\nCommand.empty = new (class extends Command {\n    description(_editor, _localizationTable) {\n        return '';\n    }\n    apply(_editor) { }\n    unapply(_editor) { }\n})();\nexports[\"default\"] = Command;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/commands/Command.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/commands/Duplicate.js":
/*!*************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/commands/Duplicate.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst describeComponentList_1 = __importDefault(__webpack_require__(/*! ../components/util/describeComponentList */ \"./node_modules/js-draw/dist/cjs/components/util/describeComponentList.js\"));\nconst Erase_1 = __importDefault(__webpack_require__(/*! ./Erase */ \"./node_modules/js-draw/dist/cjs/commands/Erase.js\"));\nconst SerializableCommand_1 = __importDefault(__webpack_require__(/*! ./SerializableCommand */ \"./node_modules/js-draw/dist/cjs/commands/SerializableCommand.js\"));\n/**\n * A command that duplicates the {@link AbstractComponent}s it's given. This command\n * is the reverse of an {@link Erase} command.\n *\n * @example\n * ```ts\n * // Given some editor...\n *\n * // Find all elements intersecting the rectangle with top left (0,0) and\n * // (width,height)=(100,100).\n * const elems = editor.image.getElementsIntersectingRegion(\n * \tnew Rect2(0, 0, 100, 100)\n * );\n *\n * // Create a command that, when applied, will duplicate the elements.\n * const duplicateElems = new Duplicate(elems);\n *\n * // Apply the command (and make it undoable)\n * editor.dispatch(duplicateElems);\n * ```\n *\n * @see {@link Editor.dispatch} {@link EditorImage.getElementsIntersectingRegion}\n */\nclass Duplicate extends SerializableCommand_1.default {\n    constructor(toDuplicate) {\n        super('duplicate');\n        this.toDuplicate = toDuplicate;\n        this.duplicates = toDuplicate.map((elem) => elem.clone());\n        this.reverse = new Erase_1.default(this.duplicates);\n    }\n    apply(editor) {\n        this.reverse.unapply(editor);\n    }\n    unapply(editor) {\n        this.reverse.apply(editor);\n    }\n    onDrop(editor) {\n        this.reverse.onDrop(editor);\n    }\n    description(_editor, localizationTable) {\n        if (this.duplicates.length === 0) {\n            return localizationTable.duplicatedNoElements;\n        }\n        return localizationTable.duplicateAction((0, describeComponentList_1.default)(localizationTable, this.duplicates) ?? localizationTable.elements, this.duplicates.length);\n    }\n    serializeToJSON() {\n        return this.toDuplicate.map((elem) => elem.getId());\n    }\n}\n(() => {\n    SerializableCommand_1.default.register('duplicate', (json, editor) => {\n        const elems = json.map((id) => editor.image.lookupElement(id));\n        return new Duplicate(elems);\n    });\n})();\nexports[\"default\"] = Duplicate;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/commands/Duplicate.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/commands/Erase.js":
/*!*********************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/commands/Erase.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst AbstractComponent_1 = __importDefault(__webpack_require__(/*! ../components/AbstractComponent */ \"./node_modules/js-draw/dist/cjs/components/AbstractComponent.js\"));\nconst describeComponentList_1 = __importDefault(__webpack_require__(/*! ../components/util/describeComponentList */ \"./node_modules/js-draw/dist/cjs/components/util/describeComponentList.js\"));\nconst EditorImage_1 = __importDefault(__webpack_require__(/*! ../image/EditorImage */ \"./node_modules/js-draw/dist/cjs/image/EditorImage.js\"));\nconst SerializableCommand_1 = __importDefault(__webpack_require__(/*! ./SerializableCommand */ \"./node_modules/js-draw/dist/cjs/commands/SerializableCommand.js\"));\n/**\n * Removes the given {@link AbstractComponent}s from the image.\n *\n * **Example**:\n * ```ts,runnable\n * import { Editor, Erase, uniteCommands, Color4, Path, Stroke, Rect2, pathToRenderable } from 'js-draw';\n *\n * const editor = new Editor(document.body);\n * editor.addToolbar();\n *\n * // Add a large number of strokes\n * const commands = [];\n * for (let x = -20; x < 20; x++) {\n *   for (let y = 0; y < 60; y++) {\n *     const stroke = new Stroke([\n *       pathToRenderable(\n *         Path.fromString(`m${x * 5},${y * 5}l1,1`),\n *         { fill: Color4.transparent, stroke: {width: 2, color: Color4.ofRGB(x / 10, y / 10, 0.5)}} )\n *       ]);\n *     commands.push(editor.image.addElement(stroke));\n *   }\n * }\n * await editor.dispatch(uniteCommands(commands, 100));\n *\n * ---visible---\n * // Given some editor...\n *\n * // Find all elements intersecting the rectangle with top left (-10,-30) and\n * // (width,height)=(50,100).\n * const elems = editor.image.getElementsIntersectingRegion(\n * \tnew Rect2(-10, -30, 50, 100)\n * );\n *\n * // Create a command that erases [elems] when applied\n * const eraseElemsCmd = new Erase(elems);\n *\n * // Apply the command (and make it undoable)\n * editor.dispatch(eraseElemsCmd);\n * ```\n */\nclass Erase extends SerializableCommand_1.default {\n    constructor(toRemove) {\n        super('erase');\n        // Clone the list\n        this.toRemove = toRemove.map((elem) => elem);\n        this.applied = false;\n    }\n    apply(editor) {\n        for (const part of this.toRemove) {\n            const parent = editor.image.findParent(part);\n            if (parent) {\n                parent.remove();\n                editor.image.onDestroyElement(part);\n            }\n        }\n        this.applied = true;\n        editor.queueRerender();\n    }\n    unapply(editor) {\n        for (const part of this.toRemove) {\n            if (!editor.image.findParent(part)) {\n                EditorImage_1.default.addElement(part).apply(editor);\n            }\n        }\n        this.applied = false;\n        editor.queueRerender();\n    }\n    onDrop(editor) {\n        if (this.applied) {\n            for (const part of this.toRemove) {\n                editor.image.onDestroyElement(part);\n            }\n        }\n    }\n    description(_editor, localizationTable) {\n        if (this.toRemove.length === 0) {\n            return localizationTable.erasedNoElements;\n        }\n        const description = (0, describeComponentList_1.default)(localizationTable, this.toRemove) ?? localizationTable.elements;\n        return localizationTable.eraseAction(description, this.toRemove.length);\n    }\n    serializeToJSON() {\n        // If applied, the elements can't be fetched from the image because they're\n        // erased. Serialize and return the elements themselves.\n        const elems = this.toRemove.map((elem) => elem.serialize());\n        return elems;\n    }\n}\n(() => {\n    SerializableCommand_1.default.register('erase', (json, editor) => {\n        if (!Array.isArray(json)) {\n            throw new Error('seralized erase data must be an array');\n        }\n        const elems = json.map((elemData) => {\n            const componentId = typeof elemData === 'string' ? elemData : `${elemData.id}`;\n            const component = editor.image.lookupElement(componentId) ?? AbstractComponent_1.default.deserialize(elemData);\n            return component;\n        });\n        return new Erase(elems);\n    });\n})();\nexports[\"default\"] = Erase;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/commands/Erase.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/commands/SerializableCommand.js":
/*!***********************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/commands/SerializableCommand.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar _SerializableCommand_commandTypeId;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Command_1 = __importDefault(__webpack_require__(/*! ./Command */ \"./node_modules/js-draw/dist/cjs/commands/Command.js\"));\n/**\n * A command that can be serialized to or deserialized from JSON. To allow a command to be deserialized, {@link SerializableCommand.register}\n * must be called for each {@link SerializableCommand}.\n *\n * This is used to [allow collaborative editing](https://github.com/personalizedrefrigerator/js-draw/tree/main/docs/examples/example-collaborative).\n */\nclass SerializableCommand extends Command_1.default {\n    /** @param commandTypeId - A unique identifier for this command. */\n    constructor(commandTypeId) {\n        super();\n        _SerializableCommand_commandTypeId.set(this, void 0);\n        if (!(commandTypeId in SerializableCommand.deserializationCallbacks)) {\n            throw new Error(`Command ${commandTypeId} must have a registered deserialization callback. To do this, call SerializableCommand.register.`);\n        }\n        __classPrivateFieldSet(this, _SerializableCommand_commandTypeId, commandTypeId, \"f\");\n    }\n    // Convert this command to an object that can be passed to `JSON.stringify`.\n    //\n    // Do not rely on the stability of the optupt of this function — it can change\n    // form without a major version increase.\n    serialize() {\n        return {\n            data: this.serializeToJSON(),\n            commandType: __classPrivateFieldGet(this, _SerializableCommand_commandTypeId, \"f\"),\n        };\n    }\n    // Convert a `string` containing JSON data (or the output of `JSON.parse`) into a\n    // `Command`.\n    //\n    // Implementations should assume that `data` is untrusted.\n    static deserialize(data, editor) {\n        const json = typeof data === 'string' ? JSON.parse(data) : data;\n        const commandType = json.commandType;\n        if (!(commandType in SerializableCommand.deserializationCallbacks)) {\n            throw new Error(`Unrecognised command type ${commandType}!`);\n        }\n        return SerializableCommand.deserializationCallbacks[commandType](json.data, editor);\n    }\n    // Register a deserialization callback. This must be called at least once for every subclass of\n    // `SerializableCommand`.\n    static register(commandTypeId, deserialize) {\n        SerializableCommand.deserializationCallbacks[commandTypeId] = deserialize;\n    }\n}\n_SerializableCommand_commandTypeId = new WeakMap();\nSerializableCommand.deserializationCallbacks = {};\nexports[\"default\"] = SerializableCommand;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/commands/SerializableCommand.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/commands/UnresolvedCommand.js":
/*!*********************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/commands/UnresolvedCommand.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst SerializableCommand_1 = __importDefault(__webpack_require__(/*! ./SerializableCommand */ \"./node_modules/js-draw/dist/cjs/commands/SerializableCommand.js\"));\n/**\n * A command that requires a component that may or may not be present in the editor when\n * the command is created.\n */\nclass UnresolvedSerializableCommand extends SerializableCommand_1.default {\n    constructor(commandId, componentID, component) {\n        super(commandId);\n        this.component = component ?? null;\n        this.componentID = componentID;\n    }\n    resolveComponent(image) {\n        if (this.component) {\n            return;\n        }\n        const component = image.lookupElement(this.componentID);\n        if (!component) {\n            throw new Error(`Unable to resolve component with ID ${this.componentID}`);\n        }\n        this.component = component;\n    }\n}\nexports[\"default\"] = UnresolvedSerializableCommand;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/commands/UnresolvedCommand.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/commands/invertCommand.js":
/*!*****************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/commands/invertCommand.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Command_1 = __importDefault(__webpack_require__(/*! ./Command */ \"./node_modules/js-draw/dist/cjs/commands/Command.js\"));\nconst SerializableCommand_1 = __importDefault(__webpack_require__(/*! ./SerializableCommand */ \"./node_modules/js-draw/dist/cjs/commands/SerializableCommand.js\"));\n// Returns a command that does the opposite of the given command --- `result.apply()` calls\n// `command.unapply()` and `result.unapply()` calls `command.apply()`.\nconst invertCommand = (command) => {\n    if (command instanceof SerializableCommand_1.default) {\n        // SerializableCommand that does the inverse of [command]\n        return new (class extends SerializableCommand_1.default {\n            constructor() {\n                super(...arguments);\n                // For debugging\n                this._command = command;\n            }\n            serializeToJSON() {\n                return command.serialize();\n            }\n            apply(editor) {\n                command.unapply(editor);\n            }\n            unapply(editor) {\n                command.apply(editor);\n            }\n            onDrop(editor) {\n                command.onDrop(editor);\n            }\n            description(editor, localizationTable) {\n                return localizationTable.inverseOf(command.description(editor, localizationTable));\n            }\n        })('inverse');\n    }\n    else {\n        // Command that does the inverse of [command].\n        const result = new (class extends Command_1.default {\n            apply(editor) {\n                command.unapply(editor);\n            }\n            unapply(editor) {\n                command.apply(editor);\n            }\n            onDrop(editor) {\n                command.onDrop(editor);\n            }\n            description(editor, localizationTable) {\n                return localizationTable.inverseOf(command.description(editor, localizationTable));\n            }\n        })();\n        // We know that T does not extend SerializableCommand, and thus returning a Command\n        // is appropriate.\n        return result;\n    }\n};\nSerializableCommand_1.default.register('inverse', (data, editor) => {\n    return invertCommand(SerializableCommand_1.default.deserialize(data, editor));\n});\nexports[\"default\"] = invertCommand;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/commands/invertCommand.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/commands/lib.js":
/*!*******************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/commands/lib.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.uniteCommands = exports.invertCommand = exports.SerializableCommand = exports.Erase = exports.Duplicate = exports.Command = void 0;\nconst Command_1 = __importDefault(__webpack_require__(/*! ./Command */ \"./node_modules/js-draw/dist/cjs/commands/Command.js\"));\nexports.Command = Command_1.default;\nconst Duplicate_1 = __importDefault(__webpack_require__(/*! ./Duplicate */ \"./node_modules/js-draw/dist/cjs/commands/Duplicate.js\"));\nexports.Duplicate = Duplicate_1.default;\nconst Erase_1 = __importDefault(__webpack_require__(/*! ./Erase */ \"./node_modules/js-draw/dist/cjs/commands/Erase.js\"));\nexports.Erase = Erase_1.default;\nconst invertCommand_1 = __importDefault(__webpack_require__(/*! ./invertCommand */ \"./node_modules/js-draw/dist/cjs/commands/invertCommand.js\"));\nexports.invertCommand = invertCommand_1.default;\nconst SerializableCommand_1 = __importDefault(__webpack_require__(/*! ./SerializableCommand */ \"./node_modules/js-draw/dist/cjs/commands/SerializableCommand.js\"));\nexports.SerializableCommand = SerializableCommand_1.default;\nconst uniteCommands_1 = __importDefault(__webpack_require__(/*! ./uniteCommands */ \"./node_modules/js-draw/dist/cjs/commands/uniteCommands.js\"));\nexports.uniteCommands = uniteCommands_1.default;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/commands/lib.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/commands/localization.js":
/*!****************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/commands/localization.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.defaultCommandLocalization = void 0;\nexports.defaultCommandLocalization = {\n    updatedViewport: 'Transformed Viewport',\n    transformedElements: (elemCount) => `Transformed ${elemCount} element${elemCount === 1 ? '' : 's'}`,\n    resizeOutputCommand: (newSize) => `Resized image to ${newSize.w}x${newSize.h}`,\n    enabledAutoresizeOutputCommand: 'Enabled output autoresize',\n    disabledAutoresizeOutputCommand: 'Disabled output autoresize',\n    addElementAction: (componentDescription) => `Added ${componentDescription}`,\n    eraseAction: (componentDescription, numElems) => `Erased ${numElems} ${componentDescription}`,\n    duplicateAction: (componentDescription, numElems) => `Duplicated ${numElems} ${componentDescription}`,\n    unionOf: (actionDescription, actionCount) => `Union: ${actionCount} ${actionDescription}`,\n    inverseOf: (actionDescription) => `Inverse of ${actionDescription}`,\n    elements: 'Elements',\n    erasedNoElements: 'Erased nothing',\n    duplicatedNoElements: 'Duplicated nothing',\n    rotatedBy: (degrees) => `Rotated by ${Math.abs(degrees)} degrees ${degrees < 0 ? 'clockwise' : 'counter-clockwise'}`,\n    movedLeft: 'Moved left',\n    movedUp: 'Moved up',\n    movedDown: 'Moved down',\n    movedRight: 'Moved right',\n    zoomedOut: 'Zoomed out',\n    zoomedIn: 'Zoomed in',\n    andNMoreCommands: (count) => `And ${count} more commands.`,\n    selectedElements: (count) => `Selected ${count} element${count === 1 ? '' : 's'}`,\n};\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/commands/localization.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/commands/uniteCommands.js":
/*!*****************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/commands/uniteCommands.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst waitForAll_1 = __importDefault(__webpack_require__(/*! ../util/waitForAll */ \"./node_modules/js-draw/dist/cjs/util/waitForAll.js\"));\nconst Command_1 = __importDefault(__webpack_require__(/*! ./Command */ \"./node_modules/js-draw/dist/cjs/commands/Command.js\"));\nconst SerializableCommand_1 = __importDefault(__webpack_require__(/*! ./SerializableCommand */ \"./node_modules/js-draw/dist/cjs/commands/SerializableCommand.js\"));\nclass NonSerializableUnion extends Command_1.default {\n    constructor(commands, applyChunkSize, descriptionOverride) {\n        super();\n        this.commands = commands;\n        this.applyChunkSize = applyChunkSize;\n        this.descriptionOverride = descriptionOverride;\n    }\n    apply(editor) {\n        if (this.applyChunkSize === undefined) {\n            const results = this.commands.map((cmd) => cmd.apply(editor));\n            return (0, waitForAll_1.default)(results);\n        }\n        else {\n            return editor.asyncApplyCommands(this.commands, this.applyChunkSize);\n        }\n    }\n    unapply(editor) {\n        const commands = [...this.commands];\n        commands.reverse();\n        if (this.applyChunkSize === undefined) {\n            const results = commands.map((cmd) => cmd.unapply(editor));\n            return (0, waitForAll_1.default)(results);\n        }\n        else {\n            return editor.asyncUnapplyCommands(commands, this.applyChunkSize, false);\n        }\n    }\n    onDrop(editor) {\n        this.commands.forEach((command) => command.onDrop(editor));\n    }\n    description(editor, localizationTable) {\n        if (this.descriptionOverride) {\n            return this.descriptionOverride;\n        }\n        const descriptions = [];\n        let lastDescription = null;\n        let duplicateDescriptionCount = 0;\n        let handledCommandCount = 0;\n        for (const part of this.commands) {\n            const description = part.description(editor, localizationTable);\n            if (description !== lastDescription && lastDescription !== null) {\n                descriptions.push(localizationTable.unionOf(lastDescription, duplicateDescriptionCount));\n                lastDescription = null;\n                duplicateDescriptionCount = 0;\n            }\n            duplicateDescriptionCount++;\n            handledCommandCount++;\n            lastDescription ??= description;\n            // Long descriptions aren't very useful to the user.\n            const maxDescriptionLength = 12;\n            if (descriptions.length > maxDescriptionLength) {\n                break;\n            }\n        }\n        if (duplicateDescriptionCount > 1) {\n            descriptions.push(localizationTable.unionOf(lastDescription, duplicateDescriptionCount));\n        }\n        else if (duplicateDescriptionCount === 1) {\n            descriptions.push(lastDescription);\n        }\n        if (handledCommandCount < this.commands.length) {\n            descriptions.push(localizationTable.andNMoreCommands(this.commands.length - handledCommandCount));\n        }\n        return descriptions.join(', ');\n    }\n}\nclass SerializableUnion extends SerializableCommand_1.default {\n    constructor(commands, applyChunkSize, descriptionOverride) {\n        super('union');\n        this.commands = commands;\n        this.applyChunkSize = applyChunkSize;\n        this.descriptionOverride = descriptionOverride;\n        this.nonserializableCommand = new NonSerializableUnion(commands, applyChunkSize, descriptionOverride);\n    }\n    serializeToJSON() {\n        if (this.serializedData) {\n            return this.serializedData;\n        }\n        return {\n            applyChunkSize: this.applyChunkSize,\n            data: this.commands.map((command) => command.serialize()),\n            description: this.descriptionOverride,\n        };\n    }\n    apply(editor) {\n        // Cache this' serialized form -- applying this may change how commands serialize.\n        this.serializedData = this.serializeToJSON();\n        return this.nonserializableCommand.apply(editor);\n    }\n    unapply(editor) {\n        return this.nonserializableCommand.unapply(editor);\n    }\n    onDrop(editor) {\n        this.nonserializableCommand.onDrop(editor);\n    }\n    description(editor, localizationTable) {\n        return this.nonserializableCommand.description(editor, localizationTable);\n    }\n}\n/**\n * Creates a single command from `commands`. This is useful when undoing should undo *all* commands\n * in `commands` at once, rather than one at a time.\n *\n * @example\n *\n * ```ts,runnable\n * import { Editor, pathToRenderable, Stroke, uniteCommands } from 'js-draw';\n * import { Path, Color4 } from '@js-draw/math';\n *\n * const editor = new Editor(document.body);\n * editor.addToolbar();\n *\n * // Create strokes!\n * const strokes = [];\n * for (let i = 0; i < 10; i++) {\n *   const renderablePath = pathToRenderable(\n *     Path.fromString(`M0,${i * 10} L100,100 L300,30 z`),\n *     { fill: Color4.transparent, stroke: { color: Color4.red, width: 1, } }\n *   );\n *   strokes.push(new Stroke([ renderablePath ]));\n * }\n *\n * // Convert to commands\n * const addStrokesCommands = strokes.map(stroke => editor.image.addElement(stroke));\n *\n * // Apply all as a single undoable command (try applying each in a loop instead!)\n * await editor.dispatch(uniteCommands(addStrokesCommands));\n *\n * // The second parameter to uniteCommands is for very large numbers of commands, when\n * // applying them shouldn't be done all at once (which would block the UI).\n *\n * // The second parameter to uniteCommands is for very large numbers of commands, when\n * // applying them shouldn't be done all at once (which would block the UI).\n * ```\n */\nconst uniteCommands = (commands, options) => {\n    let allSerializable = true;\n    for (const command of commands) {\n        if (!(command instanceof SerializableCommand_1.default)) {\n            allSerializable = false;\n            break;\n        }\n    }\n    let applyChunkSize;\n    let description;\n    if (typeof options === 'number') {\n        applyChunkSize = options;\n    }\n    else {\n        applyChunkSize = options?.applyChunkSize;\n        description = options?.description;\n    }\n    if (!allSerializable) {\n        return new NonSerializableUnion(commands, applyChunkSize, description);\n    }\n    else {\n        const castedCommands = commands;\n        return new SerializableUnion(castedCommands, applyChunkSize, description);\n    }\n};\nSerializableCommand_1.default.register('union', (data, editor) => {\n    if (typeof data.data.length !== 'number') {\n        throw new Error('Unions of commands must serialize to lists of serialization data.');\n    }\n    const applyChunkSize = data.applyChunkSize;\n    if (typeof applyChunkSize !== 'number' && applyChunkSize !== undefined) {\n        throw new Error('serialized applyChunkSize is neither undefined nor a number.');\n    }\n    const description = typeof data.description === 'string' ? data.description : undefined;\n    const commands = [];\n    for (const part of data.data) {\n        commands.push(SerializableCommand_1.default.deserialize(part, editor));\n    }\n    return uniteCommands(commands, { applyChunkSize, description });\n});\nexports[\"default\"] = uniteCommands;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/commands/uniteCommands.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/components/AbstractComponent.js":
/*!***********************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/components/AbstractComponent.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __setFunctionName = (this && this.__setFunctionName) || function (f, name, prefix) {\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n    return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar _a;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ComponentSizingMode = void 0;\nconst SerializableCommand_1 = __importDefault(__webpack_require__(/*! ../commands/SerializableCommand */ \"./node_modules/js-draw/dist/cjs/commands/SerializableCommand.js\"));\nconst EditorImage_1 = __importDefault(__webpack_require__(/*! ../image/EditorImage */ \"./node_modules/js-draw/dist/cjs/image/EditorImage.js\"));\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\nconst UnresolvedCommand_1 = __importDefault(__webpack_require__(/*! ../commands/UnresolvedCommand */ \"./node_modules/js-draw/dist/cjs/commands/UnresolvedCommand.js\"));\nvar ComponentSizingMode;\n(function (ComponentSizingMode) {\n    /** The default. The compnent gets its size from its bounding box. */\n    ComponentSizingMode[ComponentSizingMode[\"BoundingBox\"] = 0] = \"BoundingBox\";\n    /** Causes the component to fill the entire visible region of the screen */\n    ComponentSizingMode[ComponentSizingMode[\"FillScreen\"] = 1] = \"FillScreen\";\n    /**\n     * Displays the component anywhere (arbitrary location) on the\n     * canvas. (Ignoring the bounding box).\n     *\n     * These components may be ignored unless a full render is done.\n     *\n     * Intended for compnents that need to be rendered on a full export,\n     * but won't be visible to the user.\n     *\n     * For example, a metadata component.\n     */\n    ComponentSizingMode[ComponentSizingMode[\"Anywhere\"] = 2] = \"Anywhere\";\n})(ComponentSizingMode || (exports.ComponentSizingMode = ComponentSizingMode = {}));\n/**\n * A base class for everything that can be added to an {@link EditorImage}.\n */\nclass AbstractComponent {\n    constructor(\n    // A unique identifier for the type of component\n    componentKind, initialZIndex) {\n        this.componentKind = componentKind;\n        // Stores data attached by a loader.\n        this.loadSaveData = {};\n        this.lastChangedTime = new Date().getTime();\n        if (initialZIndex !== undefined) {\n            this.zIndex = initialZIndex;\n        }\n        else {\n            this.zIndex = AbstractComponent.zIndexCounter++;\n        }\n        // Create a unique ID.\n        this.id = `${new Date().getTime()}-${Math.random()}`;\n        if (AbstractComponent.deserializationCallbacks[componentKind] === undefined) {\n            throw new Error(`Component ${componentKind} has not been registered using AbstractComponent.registerComponent`);\n        }\n    }\n    // Returns a unique ID for this element.\n    // @see { @link EditorImage.lookupElement }\n    getId() {\n        return this.id;\n    }\n    // Store the deserialization callback (or lack of it) for [componentKind].\n    // If components are registered multiple times (as may be done in automated tests),\n    // the most recent deserialization callback is used.\n    static registerComponent(componentKind, deserialize) {\n        this.deserializationCallbacks[componentKind] = deserialize ?? null;\n    }\n    /**\n     * Attach data that can be used while exporting the component (e.g. to SVG).\n     *\n     * This is intended for use by an {@link ImageLoader}.\n     */\n    attachLoadSaveData(key, data) {\n        if (!this.loadSaveData[key]) {\n            this.loadSaveData[key] = [];\n        }\n        this.loadSaveData[key].push(data);\n    }\n    /** See {@link attachLoadSaveData} */\n    getLoadSaveData() {\n        return this.loadSaveData;\n    }\n    getZIndex() {\n        return this.zIndex;\n    }\n    /**\n     * @returns the bounding box of this. This can be a slight overestimate if doing so\n     * \t\t\tsignificantly improves performance.\n     */\n    getBBox() {\n        return this.contentBBox;\n    }\n    /**\n     * @returns the bounding box of this. Unlike `getBBox`, this should **not** be a rough estimate.\n     */\n    getExactBBox() {\n        return this.getBBox();\n    }\n    /**\n     * Returns information about how this component should be displayed\n     * (e.g. fill the screen or get its size from {@link getBBox}).\n     *\n     * {@link EditorImage.queueRerenderOf} must be called to apply changes to\n     * the output of this method if this component has already been added to an\n     * {@link EditorImage}.\n     */\n    getSizingMode() {\n        return ComponentSizingMode.BoundingBox;\n    }\n    /**\n     * **Optimization**\n     *\n     * Should return `true` if this component covers the entire `visibleRect`\n     * and would prevent anything below this component from being visible.\n     *\n     * Should return `false` otherwise.\n     */\n    occludesEverythingBelowWhenRenderedInRect(_visibleRect) {\n        return false;\n    }\n    /** Called when this component is added to the given image. */\n    onAddToImage(_image) { }\n    onRemoveFromImage() { }\n    /**\n     * @returns true if this component intersects `rect` -- it is entirely contained\n     *  within the rectangle or one of the rectangle's edges intersects this component.\n     *\n     * The default implementation assumes that `this.getExactBBox()` returns a tight bounding box\n     * -- that any horiziontal/vertical line that intersects this' boounding box also\n     * intersects a point in this component. If this is not the case, components must override\n     * this function.\n     */\n    intersectsRect(rect) {\n        // If this component intersects the given rectangle,\n        // it is either contained entirely within rect or intersects one of rect's edges.\n        // If contained within,\n        if (rect.containsRect(this.getExactBBox())) {\n            return true;\n        }\n        // Otherwise check if it intersects one of the rectangle's edges.\n        const testLines = rect.getEdges();\n        return testLines.some((edge) => this.intersects(edge));\n    }\n    // @returns true iff this component can be selected (e.g. by the selection tool.)\n    isSelectable() {\n        return true;\n    }\n    // @returns true iff this component should be added to the background, rather than the\n    // foreground of the image.\n    isBackground() {\n        return false;\n    }\n    // @returns an approximation of the proportional time it takes to render this component.\n    // This is intended to be a rough estimate, but, for example, a stroke with two points sould have\n    // a renderingWeight approximately twice that of a stroke with one point.\n    getProportionalRenderingTime() {\n        return 1;\n    }\n    /**\n     * Returns a command that, when applied, transforms this by [affineTransfm] and\n     * updates the editor.\n     *\n     * The transformed component is also moved to the top (use\n     * {@link AbstractComponent#setZIndexAndTransformBy} to avoid this behavior).\n     */\n    transformBy(affineTransfm) {\n        return new AbstractComponent.TransformElementCommand(affineTransfm, this.getId(), this);\n    }\n    // Returns a command that updates this component's z-index.\n    setZIndex(newZIndex) {\n        return new AbstractComponent.TransformElementCommand(math_1.Mat33.identity, this.getId(), this, newZIndex);\n    }\n    /**\n     * Combines {@link transformBy} and {@link setZIndex} into a single command.\n     *\n     * @param newZIndex - The z-index this component should have after applying this command.\n     * @param originalZIndex - @internal The z-index the component should revert to after unapplying\n     *                         this command.\n     */\n    setZIndexAndTransformBy(affineTransfm, newZIndex, originalZIndex) {\n        return new AbstractComponent.TransformElementCommand(affineTransfm, this.getId(), this, newZIndex, originalZIndex);\n    }\n    // Returns a copy of this component.\n    clone() {\n        const clone = this.createClone();\n        for (const attachmentKey in this.loadSaveData) {\n            for (const val of this.loadSaveData[attachmentKey]) {\n                clone.attachLoadSaveData(attachmentKey, val);\n            }\n        }\n        return clone;\n    }\n    // Convert the component to an object that can be passed to\n    // `JSON.stringify`.\n    //\n    // Do not rely on the output of this function to take a particular form —\n    // this function's output can change form without a major version increase.\n    serialize() {\n        const data = this.serializeToJSON();\n        if (data === null) {\n            throw new Error(`${this} cannot be serialized.`);\n        }\n        return {\n            name: this.componentKind,\n            zIndex: this.zIndex,\n            id: this.id,\n            loadSaveData: this.loadSaveData,\n            data,\n        };\n    }\n    // Returns true if `data` is not deserializable. May return false even if [data]\n    // is not deserializable.\n    static isNotDeserializable(json) {\n        if (typeof json === 'string') {\n            json = JSON.parse(json);\n        }\n        if (typeof json !== 'object') {\n            return true;\n        }\n        if (!this.deserializationCallbacks[json?.name]) {\n            return true;\n        }\n        if (!json.data) {\n            return true;\n        }\n        return false;\n    }\n    // Convert a string or an object produced by `JSON.parse` into an `AbstractComponent`.\n    static deserialize(json) {\n        if (typeof json === 'string') {\n            json = JSON.parse(json);\n        }\n        if (AbstractComponent.isNotDeserializable(json)) {\n            throw new Error(`Element with data ${json} cannot be deserialized.`);\n        }\n        const instance = this.deserializationCallbacks[json.name](json.data);\n        instance.id = json.id;\n        if (isFinite(json.zIndex)) {\n            instance.zIndex = json.zIndex;\n            // Ensure that new components will be added on top.\n            AbstractComponent.zIndexCounter = Math.max(AbstractComponent.zIndexCounter, instance.zIndex + 1);\n        }\n        // TODO: What should we do with json.loadSaveData?\n        //       If we attach it to [instance], we create a potential security risk — loadSaveData\n        //       is often used to store unrecognised attributes so they can be preserved on output.\n        //       ...but what if we're deserializing data sent across the network?\n        return instance;\n    }\n}\n// Topmost z-index\n// TODO: Should be a property of the EditorImage.\nAbstractComponent.zIndexCounter = 0;\nAbstractComponent.deserializationCallbacks = {};\nAbstractComponent.transformElementCommandId = 'transform-element';\nAbstractComponent.TransformElementCommand = (_a = class extends UnresolvedCommand_1.default {\n        // Construct a new TransformElementCommand. `component`, while optional, should\n        // be provided if available. If not provided, it will be fetched from the editor's\n        // document when the command is applied.\n        constructor(affineTransfm, componentID, component, targetZIndex, origZIndex) {\n            super(AbstractComponent.transformElementCommandId, componentID, component);\n            this.affineTransfm = affineTransfm;\n            this.origZIndex = origZIndex;\n            this.targetZIndex = targetZIndex ?? AbstractComponent.zIndexCounter++;\n            // Ensure that we keep drawing on top even after changing the z-index.\n            if (this.targetZIndex >= AbstractComponent.zIndexCounter) {\n                AbstractComponent.zIndexCounter = this.targetZIndex + 1;\n            }\n            if (component && origZIndex === undefined) {\n                this.origZIndex = component.getZIndex();\n            }\n        }\n        resolveComponent(image) {\n            if (this.component) {\n                return;\n            }\n            super.resolveComponent(image);\n            this.origZIndex ??= this.component.getZIndex();\n        }\n        updateTransform(editor, newTransfm, targetZIndex) {\n            if (!this.component) {\n                throw new Error('this.component is undefined or null!');\n            }\n            // Any parent should have only one direct child.\n            const parent = editor.image.findParent(this.component);\n            let hadParent = false;\n            if (parent) {\n                parent.remove();\n                hadParent = true;\n            }\n            this.component.applyTransformation(newTransfm);\n            this.component.zIndex = targetZIndex;\n            this.component.lastChangedTime = new Date().getTime();\n            // Ensure that new components are automatically drawn above the current component.\n            if (targetZIndex >= AbstractComponent.zIndexCounter) {\n                AbstractComponent.zIndexCounter = targetZIndex + 1;\n            }\n            // Add the element back to the document.\n            if (hadParent) {\n                EditorImage_1.default.addElement(this.component).apply(editor);\n            }\n        }\n        apply(editor) {\n            this.resolveComponent(editor.image);\n            this.updateTransform(editor, this.affineTransfm, this.targetZIndex);\n            editor.queueRerender();\n        }\n        unapply(editor) {\n            this.resolveComponent(editor.image);\n            this.updateTransform(editor, this.affineTransfm.inverse(), this.origZIndex);\n            editor.queueRerender();\n        }\n        description(_editor, localizationTable) {\n            return localizationTable.transformedElements(1);\n        }\n        serializeToJSON() {\n            return {\n                id: this.componentID,\n                transfm: this.affineTransfm.toArray(),\n                targetZIndex: this.targetZIndex,\n                origZIndex: this.origZIndex,\n            };\n        }\n    },\n    __setFunctionName(_a, \"TransformElementCommand\"),\n    (() => {\n        SerializableCommand_1.default.register(AbstractComponent.transformElementCommandId, (json, editor) => {\n            const elem = editor.image.lookupElement(json.id) ?? undefined;\n            const transform = new math_1.Mat33(...json.transfm);\n            const targetZIndex = json.targetZIndex;\n            const origZIndex = json.origZIndex ?? undefined;\n            return new AbstractComponent.TransformElementCommand(transform, json.id, elem, targetZIndex, origZIndex);\n        });\n    })(),\n    _a);\nexports[\"default\"] = AbstractComponent;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/components/AbstractComponent.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/components/BackgroundComponent.js":
/*!*************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/components/BackgroundComponent.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.backgroundTypeToClassNameMap = exports.imageBackgroundNonAutomaticSecondaryColorCSSClassName = exports.imageBackgroundGridSizeCSSPrefix = exports.imageBackgroundCSSClassName = exports.BackgroundType = void 0;\nconst EditorImage_1 = __webpack_require__(/*! ../image/EditorImage */ \"./node_modules/js-draw/dist/cjs/image/EditorImage.js\");\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\nconst AbstractComponent_1 = __importStar(__webpack_require__(/*! ./AbstractComponent */ \"./node_modules/js-draw/dist/cjs/components/AbstractComponent.js\"));\nconst RestylableComponent_1 = __webpack_require__(/*! ./RestylableComponent */ \"./node_modules/js-draw/dist/cjs/components/RestylableComponent.js\");\nconst Viewport_1 = __importDefault(__webpack_require__(/*! ../Viewport */ \"./node_modules/js-draw/dist/cjs/Viewport.js\"));\nconst RenderablePathSpec_1 = __webpack_require__(/*! ../rendering/RenderablePathSpec */ \"./node_modules/js-draw/dist/cjs/rendering/RenderablePathSpec.js\");\nvar BackgroundType;\n(function (BackgroundType) {\n    BackgroundType[BackgroundType[\"SolidColor\"] = 0] = \"SolidColor\";\n    BackgroundType[BackgroundType[\"Grid\"] = 1] = \"Grid\";\n    BackgroundType[BackgroundType[\"None\"] = 2] = \"None\";\n})(BackgroundType || (exports.BackgroundType = BackgroundType = {}));\nexports.imageBackgroundCSSClassName = 'js-draw-image-background';\n// Class name prefix indicating the size of the background's grid cells (if present).\nexports.imageBackgroundGridSizeCSSPrefix = 'js-draw-image-background-grid-';\n// Flag included in rendered SVGs (etc) that indicates that the secondary color of the\n// background has been manually set.\nexports.imageBackgroundNonAutomaticSecondaryColorCSSClassName = 'js-draw-image-background-non-automatic-secondary-color';\nexports.backgroundTypeToClassNameMap = {\n    [BackgroundType.Grid]: 'js-draw-image-background-grid',\n    [BackgroundType.SolidColor]: exports.imageBackgroundCSSClassName,\n    [BackgroundType.None]: '',\n};\n// Represents the background of the editor's canvas.\nclass BackgroundComponent extends AbstractComponent_1.default {\n    constructor(backgroundType, mainColor) {\n        super('image-background', 0);\n        this.backgroundType = backgroundType;\n        this.mainColor = mainColor;\n        this.viewportSizeChangeListener = null;\n        this.autoresizeChangedListener = null;\n        // Whether the background should grow/shrink to match the screen size,\n        // rather than being clipped to the image boundaries.\n        this.fillsScreen = false;\n        this.gridSize = Viewport_1.default.getGridSize(2);\n        this.gridStrokeWidth = 0.7;\n        this.secondaryColor = null;\n        // eslint-disable-next-line @typescript-eslint/prefer-as-const\n        this.isRestylableComponent = true;\n        this.contentBBox = math_1.Rect2.empty;\n    }\n    static ofGrid(backgroundColor, gridSize, gridColor, gridStrokeWidth) {\n        const background = new BackgroundComponent(BackgroundType.Grid, backgroundColor);\n        if (gridSize !== undefined) {\n            background.gridSize = gridSize;\n        }\n        if (gridColor !== undefined) {\n            background.secondaryColor = gridColor;\n        }\n        if (gridStrokeWidth !== undefined) {\n            background.gridStrokeWidth = gridStrokeWidth;\n        }\n        return background;\n    }\n    getBackgroundType() {\n        return this.backgroundType;\n    }\n    // @internal\n    getMainColor() {\n        return this.mainColor;\n    }\n    // @internal\n    getSecondaryColor() {\n        return this.secondaryColor;\n    }\n    // @internal\n    getGridSize() {\n        return this.gridSize;\n    }\n    getStyle() {\n        let color = this.mainColor;\n        if (this.backgroundType === BackgroundType.None) {\n            color = undefined;\n        }\n        return {\n            color,\n        };\n    }\n    updateStyle(style) {\n        return (0, RestylableComponent_1.createRestyleComponentCommand)(this.getStyle(), style, this);\n    }\n    // @internal\n    forceStyle(style, editor) {\n        const fill = style.color;\n        if (!fill) {\n            return;\n        }\n        this.mainColor = fill;\n        // A solid background and transparent fill is equivalent to no background.\n        if (fill.eq(math_1.Color4.transparent) && this.backgroundType === BackgroundType.SolidColor) {\n            this.backgroundType = BackgroundType.None;\n        }\n        else if (this.backgroundType === BackgroundType.None) {\n            this.backgroundType = BackgroundType.SolidColor;\n        }\n        if (editor) {\n            editor.image.queueRerenderOf(this);\n            editor.queueRerender();\n        }\n    }\n    onAddToImage(image) {\n        if (this.viewportSizeChangeListener) {\n            console.warn('onAddToImage called when background is already in an image');\n            this.onRemoveFromImage();\n        }\n        this.viewportSizeChangeListener = image.notifier.on(EditorImage_1.EditorImageEventType.ExportViewportChanged, () => {\n            this.recomputeBBox(image);\n        });\n        this.autoresizeChangedListener = image.notifier.on(EditorImage_1.EditorImageEventType.AutoresizeModeChanged, () => {\n            this.recomputeBBox(image);\n        });\n        this.recomputeBBox(image);\n    }\n    onRemoveFromImage() {\n        this.viewportSizeChangeListener?.remove();\n        this.autoresizeChangedListener?.remove();\n        this.viewportSizeChangeListener = null;\n        this.autoresizeChangedListener = null;\n    }\n    recomputeBBox(image) {\n        const importExportRect = image.getImportExportViewport().visibleRect;\n        let needsRerender = false;\n        if (!this.contentBBox.eq(importExportRect)) {\n            this.contentBBox = importExportRect;\n            // If the box already fills the screen, rerendering it will have\n            // no visual effect.\n            //\n            // TODO: This decision should be made by queueRerenderOf and not here.\n            //\n            needsRerender ||= !this.fillsScreen;\n        }\n        const imageAutoresizes = image.getAutoresizeEnabled();\n        if (imageAutoresizes !== this.fillsScreen) {\n            this.fillsScreen = imageAutoresizes;\n            needsRerender = true;\n        }\n        if (needsRerender) {\n            // Re-renders this if already added to the EditorImage.\n            image.queueRerenderOf(this);\n        }\n    }\n    generateGridPath(visibleRect) {\n        const contentBBox = this.getFullBoundingBox(visibleRect);\n        // .grownBy acts on all sides, so we need only grow by strokeWidth / 2 (1 * the stroke radius)\n        const targetRect = (visibleRect?.intersection(contentBBox) ?? contentBBox).grownBy(this.gridStrokeWidth / 2);\n        const roundDownToGrid = (coord) => Math.floor(coord / this.gridSize) * this.gridSize;\n        const roundUpToGrid = (coord) => Math.ceil(coord / this.gridSize) * this.gridSize;\n        const startY = roundUpToGrid(targetRect.y);\n        const endY = roundDownToGrid(targetRect.y + targetRect.h);\n        const startX = roundUpToGrid(targetRect.x);\n        const endX = roundDownToGrid(targetRect.x + targetRect.w);\n        const result = [];\n        // Don't generate grids with a huge number of rows/columns -- such grids\n        // take a long time to render and are likely invisible due to the number of\n        // cells.\n        const rowCount = (endY - startY) / this.gridSize;\n        const colCount = (endX - startX) / this.gridSize;\n        const maxGridCols = 1000;\n        const maxGridRows = 1000;\n        if (rowCount > maxGridRows || colCount > maxGridCols) {\n            return math_1.Path.empty;\n        }\n        const startPoint = math_1.Vec2.of(targetRect.x, startY);\n        for (let y = startY; y <= endY; y += this.gridSize) {\n            result.push({\n                kind: math_1.PathCommandType.MoveTo,\n                point: math_1.Vec2.of(targetRect.x, y),\n            });\n            result.push({\n                kind: math_1.PathCommandType.LineTo,\n                point: math_1.Vec2.of(targetRect.x + targetRect.w, y),\n            });\n        }\n        for (let x = startX; x <= endX; x += this.gridSize) {\n            result.push({\n                kind: math_1.PathCommandType.MoveTo,\n                point: math_1.Vec2.of(x, targetRect.y),\n            });\n            result.push({\n                kind: math_1.PathCommandType.LineTo,\n                point: math_1.Vec2.of(x, targetRect.y + targetRect.h),\n            });\n        }\n        return new math_1.Path(startPoint, result);\n    }\n    /**\n     * @returns this background's bounding box if the screen size is taken into\n     * account (which may be necessary if this component is configured to fill the\n     * entire screen).\n     */\n    getFullBoundingBox(visibleRect) {\n        return (this.fillsScreen ? visibleRect : this.contentBBox) ?? this.contentBBox;\n    }\n    render(canvas, visibleRect) {\n        if (this.backgroundType === BackgroundType.None) {\n            return;\n        }\n        // If visibleRect is null, components should render everything.\n        // In that case, a full render is being done.\n        const mustRender = !visibleRect;\n        // If this.fillsScreen, the visibleRect needs to be known.\n        // Use the screen rect.\n        if (this.fillsScreen) {\n            visibleRect ??= canvas.getVisibleRect();\n        }\n        const clip = this.backgroundType === BackgroundType.Grid;\n        const contentBBox = this.getFullBoundingBox(visibleRect);\n        canvas.startObject(contentBBox, clip);\n        if (this.backgroundType === BackgroundType.SolidColor ||\n            this.backgroundType === BackgroundType.Grid) {\n            // If the rectangle for this region contains the visible rect,\n            // we can fill the entire visible rectangle (which may be more efficient than\n            // filling the entire region for this.)\n            const intersection = visibleRect?.intersection(contentBBox);\n            if (intersection) {\n                canvas.fillRect(intersection, this.mainColor);\n            }\n            else if (mustRender) {\n                canvas.fillRect(contentBBox, this.mainColor);\n            }\n        }\n        if (this.backgroundType === BackgroundType.Grid) {\n            let gridColor = this.secondaryColor;\n            gridColor ??= math_1.Color4.ofRGBA(1 - this.mainColor.r, 1 - this.mainColor.g, 1 - this.mainColor.b, 0.2);\n            // If the background fill is completely transparent, ensure visibility on otherwise light\n            // and dark backgrounds.\n            if (this.mainColor.a === 0) {\n                gridColor = math_1.Color4.ofRGBA(0.5, 0.5, 0.5, 0.2);\n            }\n            const style = {\n                fill: math_1.Color4.transparent,\n                stroke: { width: this.gridStrokeWidth, color: gridColor },\n            };\n            canvas.drawPath((0, RenderablePathSpec_1.pathToRenderable)(this.generateGridPath(visibleRect), style));\n        }\n        const backgroundTypeCSSClass = exports.backgroundTypeToClassNameMap[this.backgroundType];\n        const classNames = [exports.imageBackgroundCSSClassName];\n        if (backgroundTypeCSSClass !== exports.imageBackgroundCSSClassName) {\n            classNames.push(backgroundTypeCSSClass);\n            const gridSizeStr = (0, math_1.toRoundedString)(this.gridSize).replace(/[.]/g, 'p');\n            classNames.push(exports.imageBackgroundGridSizeCSSPrefix + gridSizeStr);\n        }\n        if (this.secondaryColor !== null) {\n            classNames.push(exports.imageBackgroundNonAutomaticSecondaryColorCSSClassName);\n        }\n        canvas.endObject(this.getLoadSaveData(), classNames);\n    }\n    intersects(lineSegment) {\n        return this.contentBBox.getEdges().some((edge) => edge.intersects(lineSegment));\n    }\n    isSelectable() {\n        return false;\n    }\n    isBackground() {\n        return true;\n    }\n    getSizingMode() {\n        return this.fillsScreen ? AbstractComponent_1.ComponentSizingMode.FillScreen : AbstractComponent_1.ComponentSizingMode.BoundingBox;\n    }\n    serializeToJSON() {\n        return {\n            mainColor: this.mainColor.toHexString(),\n            secondaryColor: this.secondaryColor?.toHexString(),\n            backgroundType: this.backgroundType,\n            gridSize: this.gridSize,\n            gridStrokeWidth: this.gridStrokeWidth,\n        };\n    }\n    applyTransformation(_affineTransfm) {\n        // Do nothing — it doesn't make sense to transform the background.\n    }\n    description(localizationTable) {\n        if (this.backgroundType === BackgroundType.SolidColor) {\n            return localizationTable.filledBackgroundWithColor(this.mainColor.toString());\n        }\n        else if (this.backgroundType === BackgroundType.None) {\n            return localizationTable.emptyBackground;\n        }\n        else if (this.backgroundType === BackgroundType.Grid) {\n            return localizationTable.gridBackground;\n        }\n        else {\n            const exhaustivenessCheck = this.backgroundType;\n            return exhaustivenessCheck;\n        }\n    }\n    createClone() {\n        return new BackgroundComponent(this.backgroundType, this.mainColor);\n    }\n    // @internal\n    static deserializeFromJSON(json) {\n        if (typeof json === 'string') {\n            json = JSON.parse(json);\n        }\n        if (typeof json.mainColor !== 'string') {\n            throw new Error('Error deserializing — mainColor must be of type string.');\n        }\n        let backgroundType;\n        const jsonBackgroundType = json.backgroundType;\n        if (jsonBackgroundType === BackgroundType.None ||\n            jsonBackgroundType === BackgroundType.Grid ||\n            jsonBackgroundType === BackgroundType.SolidColor) {\n            backgroundType = jsonBackgroundType;\n        }\n        else {\n            const exhaustivenessCheck = jsonBackgroundType;\n            return exhaustivenessCheck;\n        }\n        const mainColor = math_1.Color4.fromHex(json.mainColor);\n        const secondaryColor = json.secondaryColor ? math_1.Color4.fromHex(json.secondaryColor) : null;\n        const gridSize = json.gridSize ?? undefined;\n        const gridStrokeWidth = json.gridStrokeWidth ?? undefined;\n        const result = new BackgroundComponent(backgroundType, mainColor);\n        result.secondaryColor = secondaryColor;\n        if (gridSize) {\n            result.gridSize = gridSize;\n        }\n        if (gridStrokeWidth) {\n            result.gridStrokeWidth = gridStrokeWidth;\n        }\n        return result;\n    }\n}\nexports[\"default\"] = BackgroundComponent;\nAbstractComponent_1.default.registerComponent('image-background', BackgroundComponent.deserializeFromJSON);\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/components/BackgroundComponent.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/components/ImageComponent.js":
/*!********************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/components/ImageComponent.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\nconst assertions_1 = __webpack_require__(/*! ../util/assertions */ \"./node_modules/js-draw/dist/cjs/util/assertions.js\");\nconst AbstractComponent_1 = __importDefault(__webpack_require__(/*! ./AbstractComponent */ \"./node_modules/js-draw/dist/cjs/components/AbstractComponent.js\"));\nconst waitForImageLoaded_1 = __importDefault(__webpack_require__(/*! ../util/waitForImageLoaded */ \"./node_modules/js-draw/dist/cjs/util/waitForImageLoaded.js\"));\n/**\n * Represents a raster image.\n *\n * **Example: Adding images**:\n * [[include:doc-pages/inline-examples/adding-an-image-and-data-urls.md]]\n */\nclass ImageComponent extends AbstractComponent_1.default {\n    constructor(image) {\n        super('image-component');\n        this.image = {\n            ...image,\n            label: image.label ??\n                image.image.getAttribute('alt') ??\n                image.image.getAttribute('aria-label') ??\n                undefined,\n        };\n        const isHTMLImageElem = (elem) => {\n            return elem.getAttribute('src') !== undefined;\n        };\n        if (isHTMLImageElem(image.image) && !image.image.complete) {\n            image.image.onload = () => this.recomputeBBox();\n        }\n        this.recomputeBBox();\n    }\n    getImageRect() {\n        return new math_1.Rect2(0, 0, this.image.image.width, this.image.image.height);\n    }\n    recomputeBBox() {\n        this.contentBBox = this.getImageRect();\n        this.contentBBox = this.contentBBox.transformedBoundingBox(this.image.transform);\n    }\n    /**\n     * Load from an image. Waits for the image to load if incomplete.\n     *\n     * The image, `elem`, must not [taint](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image#security_and_tainted_canvases)\n     * an HTMLCanvasElement when rendered.\n     */\n    static async fromImage(elem, transform) {\n        await (0, waitForImageLoaded_1.default)(elem);\n        let width, height;\n        if (typeof elem.width === 'number' &&\n            typeof elem.height === 'number' &&\n            elem.width !== 0 &&\n            elem.height !== 0) {\n            width = elem.width;\n            height = elem.height;\n        }\n        else {\n            width = elem.clientWidth;\n            height = elem.clientHeight;\n        }\n        let image;\n        let url = elem.src ?? '';\n        if (!url.startsWith('data:image/')) {\n            // Convert to a data URL:\n            const canvas = document.createElement('canvas');\n            canvas.width = width;\n            canvas.height = height;\n            const ctx = canvas.getContext('2d');\n            ctx.drawImage(elem, 0, 0, canvas.width, canvas.height);\n            url = canvas.toDataURL();\n            image = canvas;\n        }\n        else {\n            image = new Image();\n            image.src = url;\n            image.width = width;\n            image.height = height;\n        }\n        image.setAttribute('alt', elem.getAttribute('alt') ?? '');\n        image.setAttribute('aria-label', elem.getAttribute('aria-label') ?? '');\n        return new ImageComponent({\n            image,\n            base64Url: url,\n            transform: transform,\n        });\n    }\n    render(canvas, _visibleRect) {\n        canvas.startObject(this.contentBBox);\n        canvas.drawImage(this.image);\n        canvas.endObject(this.getLoadSaveData());\n    }\n    // A *very* rough estimate of how long it takes to render this component\n    getProportionalRenderingTime() {\n        // Estimate: Equivalent to a stroke with 10 segments.\n        return 10;\n    }\n    intersects(lineSegment) {\n        const rect = this.getImageRect();\n        const edges = rect.getEdges().map((edge) => edge.transformedBy(this.image.transform));\n        for (const edge of edges) {\n            if (edge.intersects(lineSegment)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    applyTransformation(affineTransfm) {\n        this.image.transform = affineTransfm.rightMul(this.image.transform);\n        this.recomputeBBox();\n    }\n    description(localizationTable) {\n        return this.image.label\n            ? localizationTable.imageNode(this.image.label)\n            : localizationTable.unlabeledImageNode;\n    }\n    getAltText() {\n        return this.image.label;\n    }\n    // The base64 image URL of this image.\n    getURL() {\n        return this.image.base64Url;\n    }\n    getTransformation() {\n        return this.image.transform;\n    }\n    createClone() {\n        return new ImageComponent({\n            ...this.image,\n        });\n    }\n    serializeToJSON() {\n        return {\n            src: this.image.base64Url,\n            label: this.image.label,\n            // Store the width and height for bounding box computations while the image is loading.\n            width: this.image.image.width,\n            height: this.image.image.height,\n            transform: this.image.transform.toArray(),\n        };\n    }\n    static deserializeFromJSON(data) {\n        if (!(typeof data.src === 'string')) {\n            throw new Error(`${data} has invalid format! Expected src property.`);\n        }\n        (0, assertions_1.assertIsNumberArray)(data.transform);\n        (0, assertions_1.assertIsNumber)(data.width);\n        (0, assertions_1.assertIsNumber)(data.height);\n        const image = new Image();\n        image.src = data.src;\n        image.width = data.width;\n        image.height = data.height;\n        const transform = new math_1.Mat33(...data.transform);\n        return new ImageComponent({\n            image: image,\n            base64Url: data.src,\n            label: data.label,\n            transform,\n        });\n    }\n}\nexports[\"default\"] = ImageComponent;\nAbstractComponent_1.default.registerComponent('image-component', ImageComponent.deserializeFromJSON);\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/components/ImageComponent.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/components/RestylableComponent.js":
/*!*************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/components/RestylableComponent.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isRestylableComponent = exports.createRestyleComponentCommand = void 0;\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\nconst SerializableCommand_1 = __importDefault(__webpack_require__(/*! ../commands/SerializableCommand */ \"./node_modules/js-draw/dist/cjs/commands/SerializableCommand.js\"));\nconst UnresolvedCommand_1 = __importDefault(__webpack_require__(/*! ../commands/UnresolvedCommand */ \"./node_modules/js-draw/dist/cjs/commands/UnresolvedCommand.js\"));\nconst TextRenderingStyle_1 = __webpack_require__(/*! ../rendering/TextRenderingStyle */ \"./node_modules/js-draw/dist/cjs/rendering/TextRenderingStyle.js\");\nconst serializeComponentStyle = (style) => {\n    const result = {};\n    if (style.color) {\n        result.color = style.color.toHexString();\n    }\n    if (style.textStyle) {\n        result.textStyle = (0, TextRenderingStyle_1.textStyleToJSON)(style.textStyle);\n    }\n    return result;\n};\nconst deserializeComponentStyle = (json) => {\n    const color = json.color ? math_1.Color4.fromHex(json.color) : undefined;\n    const textStyle = json.textStyle ? (0, TextRenderingStyle_1.textStyleFromJSON)(json.textStyle) : undefined;\n    return {\n        color,\n        textStyle,\n    };\n};\n// For internal use by Components implementing `updateStyle`:\nconst createRestyleComponentCommand = (initialStyle, newStyle, component) => {\n    return new DefaultRestyleComponentCommand(initialStyle, newStyle, component.getId(), component);\n};\nexports.createRestyleComponentCommand = createRestyleComponentCommand;\n// Returns true if `component` is a `RestylableComponent`.\nconst isRestylableComponent = (component) => {\n    const hasMethods = 'getStyle' in component && 'updateStyle' in component && 'forceStyle' in component;\n    if (!hasMethods) {\n        return false;\n    }\n    if (!('isRestylableComponent' in component) || !component['isRestylableComponent']) {\n        return false;\n    }\n    return true;\n};\nexports.isRestylableComponent = isRestylableComponent;\nconst defaultRestyleComponentCommandId = 'default-restyle-element';\nclass DefaultRestyleComponentCommand extends UnresolvedCommand_1.default {\n    constructor(originalStyle, newStyle, componentID, component) {\n        super(defaultRestyleComponentCommandId, componentID, component);\n        this.originalStyle = originalStyle;\n        this.newStyle = newStyle;\n    }\n    getComponent(editor) {\n        this.resolveComponent(editor.image);\n        const component = this.component;\n        if (!component || !component['forceStyle'] || !component['updateStyle']) {\n            throw new Error('this.component is missing forceStyle and/or updateStyle methods!');\n        }\n        return component;\n    }\n    apply(editor) {\n        this.getComponent(editor).forceStyle(this.newStyle, editor);\n    }\n    unapply(editor) {\n        this.getComponent(editor).forceStyle(this.originalStyle, editor);\n    }\n    description(editor, localizationTable) {\n        return localizationTable.restyledElement(this.getComponent(editor).description(localizationTable));\n    }\n    serializeToJSON() {\n        return {\n            id: this.componentID,\n            originalStyle: serializeComponentStyle(this.originalStyle),\n            newStyle: serializeComponentStyle(this.newStyle),\n        };\n    }\n}\n(() => {\n    SerializableCommand_1.default.register(defaultRestyleComponentCommandId, (json, _editor) => {\n        const origStyle = deserializeComponentStyle(json.originalStyle);\n        const newStyle = deserializeComponentStyle(json.newStyle);\n        const id = json.id;\n        if (typeof json.id !== 'string') {\n            throw new Error(`json.id is of type ${typeof json.id}, not string.`);\n        }\n        return new DefaultRestyleComponentCommand(origStyle, newStyle, id);\n    });\n})();\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/components/RestylableComponent.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/components/SVGGlobalAttributesObject.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/components/SVGGlobalAttributesObject.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n//\n// Used by `SVGLoader`s to store unrecognised global attributes\n// (e.g. unrecognised XML namespace declarations).\n// @internal\n// @packageDocumentation\n//\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\nconst SVGRenderer_1 = __importDefault(__webpack_require__(/*! ../rendering/renderers/SVGRenderer */ \"./node_modules/js-draw/dist/cjs/rendering/renderers/SVGRenderer.js\"));\nconst AbstractComponent_1 = __importStar(__webpack_require__(/*! ./AbstractComponent */ \"./node_modules/js-draw/dist/cjs/components/AbstractComponent.js\"));\nconst componentKind = 'svg-global-attributes';\n// Stores global SVG attributes (e.g. namespace identifiers.)\nclass SVGGlobalAttributesObject extends AbstractComponent_1.default {\n    // Does not modify `attrs`\n    constructor(attrs) {\n        super(componentKind);\n        this.contentBBox = math_1.Rect2.empty;\n        // Already stored/managed in `editor.image`.\n        const attrsManagedByRenderer = ['viewBox', 'width', 'height'];\n        // Only store attributes that aren't managed by other parts of the app.\n        this.attrs = attrs.filter(([attr, _value]) => {\n            return !attrsManagedByRenderer.includes(attr);\n        });\n    }\n    render(canvas, _visibleRect) {\n        if (!(canvas instanceof SVGRenderer_1.default)) {\n            // Don't draw unrenderable objects if we can't\n            return;\n        }\n        for (const [attr, value] of this.attrs) {\n            canvas.setRootSVGAttribute(attr, value);\n        }\n    }\n    intersects(_lineSegment) {\n        return false;\n    }\n    applyTransformation(_affineTransfm) { }\n    isSelectable() {\n        return false;\n    }\n    getSizingMode() {\n        // This component can be shown anywhere (it won't be\n        // visible to the user, it just needs to be saved with\n        // the image).\n        return AbstractComponent_1.ComponentSizingMode.Anywhere;\n    }\n    createClone() {\n        return new SVGGlobalAttributesObject(this.attrs);\n    }\n    description(localization) {\n        return localization.svgObject;\n    }\n    serializeToJSON() {\n        return JSON.stringify(this.attrs);\n    }\n    static deserializeFromString(_data) {\n        // To be safe, don't deserialize any attributes\n        return new SVGGlobalAttributesObject([]);\n    }\n}\nexports[\"default\"] = SVGGlobalAttributesObject;\nAbstractComponent_1.default.registerComponent(componentKind, SVGGlobalAttributesObject.deserializeFromString);\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/components/SVGGlobalAttributesObject.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/components/Stroke.js":
/*!************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/components/Stroke.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\nconst RenderingStyle_1 = __webpack_require__(/*! ../rendering/RenderingStyle */ \"./node_modules/js-draw/dist/cjs/rendering/RenderingStyle.js\");\nconst AbstractComponent_1 = __importDefault(__webpack_require__(/*! ./AbstractComponent */ \"./node_modules/js-draw/dist/cjs/components/AbstractComponent.js\"));\nconst RestylableComponent_1 = __webpack_require__(/*! ./RestylableComponent */ \"./node_modules/js-draw/dist/cjs/components/RestylableComponent.js\");\nconst RenderablePathSpec_1 = __webpack_require__(/*! ../rendering/RenderablePathSpec */ \"./node_modules/js-draw/dist/cjs/rendering/RenderablePathSpec.js\");\n/**\n * Represents an {@link AbstractComponent} made up of one or more {@link Path}s.\n *\n * @example\n * For some {@link Editor} editor and `Stroke` stroke,\n *\n * **Restyling**:\n * ```ts\n * editor.dispatch(stroke.updateStyle({ color: Color4.red }));\n * ```\n *\n * **Transforming**:\n * ```ts\n * editor.dispatch(stroke.transformBy(Mat33.translation(Vec2.of(10, 0))));\n * ```\n *\n * **Adding**:\n * [[include:doc-pages/inline-examples/adding-a-stroke.md]]\n */\nclass Stroke extends AbstractComponent_1.default {\n    /**\n     * Creates a `Stroke` from the given `parts`. All parts should have the\n     * same color.\n     *\n     * @example\n     * ```ts\n     * // A path that starts at (1,1), moves to the right by (2, 0),\n     * // then moves down and right by (3, 3)\n     * const path = Path.fromString('m1,1 2,0 3,3');\n     *\n     * const stroke = new Stroke([\n     *     // Fill with red\n     *     pathToRenderable(path, { fill: Color4.red })\n     * ]);\n     * ```\n     */\n    constructor(parts, initialZIndex) {\n        super('stroke', initialZIndex);\n        // @internal\n        // eslint-disable-next-line @typescript-eslint/prefer-as-const\n        this.isRestylableComponent = true;\n        // A simplification of the path for a given visibleRect. Intended\n        // to help check for occlusion.\n        this.simplifiedPath = null;\n        this.approximateRenderingTime = 0;\n        this.parts = [];\n        for (const section of parts) {\n            const path = (0, RenderablePathSpec_1.pathFromRenderable)(section);\n            const pathBBox = this.bboxForPart(path.bbox, section.style);\n            if (!this.contentBBox) {\n                this.contentBBox = pathBBox;\n            }\n            else {\n                this.contentBBox = this.contentBBox.union(pathBBox);\n            }\n            this.parts.push({\n                path,\n                // To implement RenderablePathSpec\n                startPoint: path.startPoint,\n                style: section.style,\n                commands: path.parts,\n            });\n            this.approximateRenderingTime += path.parts.length;\n        }\n        this.contentBBox ??= math_1.Rect2.empty;\n    }\n    getStyle() {\n        if (this.parts.length === 0) {\n            return {};\n        }\n        const firstPart = this.parts[0];\n        if (firstPart.style.stroke === undefined || firstPart.style.stroke.width === 0) {\n            return {\n                color: firstPart.style.fill,\n            };\n        }\n        return {\n            color: firstPart.style.stroke.color,\n        };\n    }\n    updateStyle(style) {\n        return (0, RestylableComponent_1.createRestyleComponentCommand)(this.getStyle(), style, this);\n    }\n    forceStyle(style, editor) {\n        if (!style.color) {\n            return;\n        }\n        this.parts = this.parts.map((part) => {\n            const newStyle = {\n                ...part.style,\n                stroke: part.style.stroke\n                    ? {\n                        ...part.style.stroke,\n                    }\n                    : undefined,\n            };\n            // Change the stroke color if a stroked shape. Else,\n            // change the fill.\n            if (newStyle.stroke && newStyle.stroke.width > 0) {\n                newStyle.stroke.color = style.color;\n            }\n            else {\n                newStyle.fill = style.color;\n            }\n            return {\n                path: part.path,\n                startPoint: part.startPoint,\n                commands: part.commands,\n                style: newStyle,\n            };\n        });\n        if (editor) {\n            editor.image.queueRerenderOf(this);\n            editor.queueRerender();\n        }\n    }\n    /** @beta -- May fail for concave `path`s */\n    withRegionErased(eraserPath, viewport) {\n        const polyline = eraserPath.polylineApproximation();\n        const isPointInsideEraser = (point) => {\n            return eraserPath.closedContainsPoint(point);\n        };\n        const newStrokes = [];\n        let failedAssertions = false;\n        for (const part of this.parts) {\n            const path = part.path;\n            const makeStroke = (path) => {\n                if (part.style.fill.a > 0) {\n                    // Remove visually empty paths.\n                    if (path.parts.length < 1 ||\n                        (path.parts.length === 1 && path.parts[0].kind === math_1.PathCommandType.LineTo)) {\n                        // TODO: If this isn't present, a very large number of strokes are created while erasing.\n                        return null;\n                    }\n                    else {\n                        // Filled paths must be closed (allows for optimizations elsewhere)\n                        path = path.asClosed();\n                    }\n                }\n                if (isNaN(path.getExactBBox().area)) {\n                    console.warn('Prevented creating a stroke with NaN area');\n                    failedAssertions = true;\n                    return null;\n                }\n                return new Stroke([(0, RenderablePathSpec_1.pathToRenderable)(path, part.style)], this.getZIndex());\n            };\n            const intersectionPoints = [];\n            // If stroked, finds intersections with the middle of the stroke.\n            // If filled, finds intersections with the edge of the stroke.\n            for (const segment of polyline) {\n                intersectionPoints.push(...path.intersection(segment));\n            }\n            // When stroked, if the stroke width is significantly larger than the eraser,\n            // it can't intersect both the edge of the stroke and its middle at the same time\n            // (generally, erasing is triggered by the eraser touching the edge of this stroke).\n            //\n            // As such, we also look for intersections along the edge of this, if none with the\n            // center were found, but only within a certain range of sizes because:\n            // 1. Intersection testing with stroked paths is generally much slower than with\n            //    non-stroked paths.\n            // 2. If zoomed in significantly, it's unlikely that the user wants to erase a large\n            //    part of the stroke.\n            let isErasingFromEdge = false;\n            if (intersectionPoints.length === 0 &&\n                part.style.stroke &&\n                part.style.stroke.width > eraserPath.bbox.minDimension * 0.3 &&\n                part.style.stroke.width < eraserPath.bbox.maxDimension * 30) {\n                for (const segment of polyline) {\n                    intersectionPoints.push(...path.intersection(segment, part.style.stroke.width / 2));\n                }\n                isErasingFromEdge = true;\n            }\n            // Sort first by curve index, then by parameter value\n            intersectionPoints.sort(math_1.comparePathIndices);\n            const isInsideJustBeforeFirst = (() => {\n                if (intersectionPoints.length === 0) {\n                    return false;\n                }\n                // The eraser may not be near the center of the curve -- approximate.\n                if (isErasingFromEdge) {\n                    return (intersectionPoints[0].curveIndex === 0 && intersectionPoints[0].parameterValue <= 0);\n                }\n                const justBeforeFirstIntersection = (0, math_1.stepPathIndexBy)(intersectionPoints[0], -1e-10);\n                return isPointInsideEraser(path.at(justBeforeFirstIntersection));\n            })();\n            let intersectionCount = isInsideJustBeforeFirst ? 1 : 0;\n            const addNewPath = (path, knownToBeInside) => {\n                const component = makeStroke(path);\n                let isInside = intersectionCount % 2 === 1;\n                intersectionCount++;\n                if (knownToBeInside !== undefined) {\n                    isInside = knownToBeInside;\n                }\n                // Here, we work around bugs in the underlying Bezier curve library\n                // (including https://github.com/Pomax/bezierjs/issues/179).\n                // Even if not all intersections are returned correctly, we still want\n                // isInside to be roughly correct.\n                if (knownToBeInside === undefined &&\n                    !isInside &&\n                    eraserPath.closedContainsPoint(path.getExactBBox().center)) {\n                    isInside = !isInside;\n                }\n                if (!component) {\n                    return;\n                }\n                // Assertion: Avoid deleting sections that are much larger than the eraser.\n                failedAssertions ||=\n                    isInside && path.getExactBBox().maxDimension > eraserPath.getExactBBox().maxDimension * 2;\n                if (!isInside) {\n                    newStrokes.push(component);\n                }\n            };\n            if (part.style.fill.a === 0) {\n                // Not filled?\n                // An additional case where we erase completely -- without the padding of the stroke,\n                // the path is smaller than the eraser (allows us to erase dots completely).\n                const shouldEraseCompletely = eraserPath.getExactBBox().maxDimension / 10 > path.getExactBBox().maxDimension;\n                if (!shouldEraseCompletely) {\n                    const split = path.splitAt(intersectionPoints, {\n                        mapNewPoint: (p) => viewport.roundPoint(p),\n                    });\n                    for (const splitPart of split) {\n                        addNewPath(splitPart);\n                    }\n                }\n            }\n            else if (intersectionPoints.length >= 2 && intersectionPoints.length % 2 === 0) {\n                // TODO: Support subtractive erasing on small scales -- see https://github.com/personalizedrefrigerator/js-draw/pull/63/commits/568686e2384219ad0bb07617ea4efff1540aed00\n                //       for a broken implementation.\n                //\n                // We currently assume that a 4-point intersection means that the intersection\n                // looks similar to this:\n                //   -----------\n                //  |   STROKE  |\n                //  |           |\n                //%%x-----------x%%%%%%%\n                //%                    %\n                //%      ERASER        %\n                //%                    %\n                //%%x-----------x%%%%%%%\n                //  |   STROKE  |\n                //   -----------\n                //\n                // Our goal is to separate STROKE into the contiguous parts outside\n                // of the eraser (as shown above).\n                //\n                // To do this, we split STROKE at each intersection:\n                //   3 3 3 3 3 3\n                //  3   STROKE  3\n                //  3           3\n                //  x           x\n                //  2           4\n                //  2   STROKE  4\n                //  2           4\n                //  x           x\n                //  1   STROKE  5\n                //   . 5 5 5 5 5\n                //   ^\n                // Start\n                //\n                // The difficulty here is correctly pairing edges to create the the output\n                // strokes, particularly because we don't know the order of intersection points.\n                const parts = path.splitAt(intersectionPoints, {\n                    mapNewPoint: (p) => viewport.roundPoint(p),\n                });\n                for (let i = 0; i < Math.floor(parts.length / 2); i++) {\n                    addNewPath(parts[i].union(parts[parts.length - i - 1]).asClosed());\n                }\n                if (parts.length % 2 !== 0) {\n                    addNewPath(parts[Math.floor(parts.length / 2)].asClosed());\n                }\n            }\n            else {\n                addNewPath(path, false);\n            }\n        }\n        if (failedAssertions) {\n            return [this];\n        }\n        return newStrokes;\n    }\n    intersects(line) {\n        for (const part of this.parts) {\n            const strokeWidth = part.style.stroke?.width;\n            const strokeRadius = strokeWidth ? strokeWidth / 2 : undefined;\n            if (part.path.intersection(line, strokeRadius).length > 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n    intersectsRect(rect) {\n        // AbstractComponent::intersectsRect can be inexact for strokes with non-zero\n        // stroke radius (has many false negatives). As such, additional checks are\n        // done here, before passing to the superclass.\n        if (!rect.intersects(this.getBBox())) {\n            return false;\n        }\n        // The following check only checks for the positive case:\n        // Sample a set of points that are known to be within each part of this\n        // stroke. For example, the points marked with an \"x\" below:\n        //   ___________________\n        //  /                   \\\n        //  | x              x  |\n        //  \\_____________      |\n        //                |  x  |\n        //                \\_____/\n        //\n        // Because we don't want the following case to result in selection,\n        //   __________________\n        //  /.___.             \\\n        //  || x |          x  |    <-  /* The\n        //  |·---·             |            .___.\n        //  \\____________      |            |   |\n        //               |  x  |            ·---·\n        //               \\_____/           denotes the input rectangle */\n        //\n        // we need to ensure that the rectangle intersects each point **and** the\n        // edge of the rectangle.\n        for (const part of this.parts) {\n            // As such, we need to shrink the input rectangle to verify that the original,\n            // unshrunken rectangle would have intersected the edge of the stroke if it\n            // intersects a point within the stroke.\n            const interiorRect = rect.grownBy(-(part.style.stroke?.width ?? 0));\n            if (interiorRect.area === 0) {\n                continue;\n            }\n            for (const point of part.path.startEndPoints()) {\n                if (interiorRect.containsPoint(point)) {\n                    return true;\n                }\n            }\n        }\n        return super.intersectsRect(rect);\n    }\n    computeSimplifiedPathFor(visibleRect) {\n        const simplifiedParts = [];\n        let occludes = false;\n        let skipSimplification = false;\n        for (const part of this.parts) {\n            if (skipSimplification ||\n                // Simplification currently only works for stroked paths\n                !part.style.stroke ||\n                // One of the main purposes of this is to check for occlusion.\n                // We can't occlude things if the stroke is partially transparent.\n                part.style.stroke.color.a < 0.99) {\n                simplifiedParts.push(part);\n                continue;\n            }\n            const mapping = (0, RenderablePathSpec_1.simplifyPathToFullScreenOrEmpty)(part, visibleRect);\n            if (mapping) {\n                simplifiedParts.push(mapping.path);\n                if (mapping.fullScreen) {\n                    occludes = true;\n                    skipSimplification = true;\n                }\n            }\n            else {\n                simplifiedParts.push(part);\n            }\n        }\n        return {\n            forVisibleRect: visibleRect,\n            parts: simplifiedParts,\n            occludes,\n        };\n    }\n    occludesEverythingBelowWhenRenderedInRect(rect) {\n        // Can't occlude if doesn't contain.\n        if (!this.getBBox().containsRect(rect)) {\n            return false;\n        }\n        if (!this.simplifiedPath || !this.simplifiedPath.forVisibleRect.eq(rect)) {\n            this.simplifiedPath = this.computeSimplifiedPathFor(rect);\n        }\n        return this.simplifiedPath.occludes;\n    }\n    render(canvas, visibleRect) {\n        canvas.startObject(this.getBBox());\n        // Can we use a cached simplified path for faster rendering?\n        let parts = this.parts;\n        if (visibleRect && this.simplifiedPath?.forVisibleRect?.containsRect(visibleRect)) {\n            parts = this.simplifiedPath.parts;\n        }\n        else {\n            // Save memory\n            this.simplifiedPath = null;\n        }\n        for (const part of parts) {\n            const bbox = this.bboxForPart(part.path.bbox, part.style);\n            if (visibleRect) {\n                if (!bbox.intersects(visibleRect)) {\n                    continue;\n                }\n                const muchBiggerThanVisible = bbox.size.x > visibleRect.size.x * 3 || bbox.size.y > visibleRect.size.y * 3;\n                if (muchBiggerThanVisible &&\n                    !part.path.roughlyIntersects(visibleRect, part.style.stroke?.width ?? 0)) {\n                    continue;\n                }\n            }\n            canvas.drawPath(part);\n        }\n        canvas.endObject(this.getLoadSaveData());\n    }\n    getProportionalRenderingTime() {\n        return this.approximateRenderingTime;\n    }\n    // Grows the bounding box for a given stroke part based on that part's style.\n    bboxForPart(origBBox, style) {\n        if (!style.stroke) {\n            return origBBox;\n        }\n        return origBBox.grownBy(style.stroke.width / 2);\n    }\n    getExactBBox() {\n        let bbox = null;\n        for (const { path, style } of this.parts) {\n            // Paths' default .bbox can be\n            const partBBox = this.bboxForPart(path.getExactBBox(), style);\n            bbox ??= partBBox;\n            bbox = bbox.union(partBBox);\n        }\n        return bbox ?? math_1.Rect2.empty;\n    }\n    applyTransformation(affineTransfm) {\n        this.contentBBox = math_1.Rect2.empty;\n        let isFirstPart = true;\n        // Update each part\n        this.parts = this.parts.map((part) => {\n            const newPath = part.path.transformedBy(affineTransfm);\n            const newStyle = {\n                ...part.style,\n                stroke: part.style.stroke\n                    ? {\n                        ...part.style.stroke,\n                    }\n                    : undefined,\n            };\n            // Approximate the scale factor.\n            if (newStyle.stroke) {\n                const scaleFactor = affineTransfm.getScaleFactor();\n                newStyle.stroke.width *= scaleFactor;\n            }\n            const newBBox = this.bboxForPart(newPath.bbox, newStyle);\n            if (isFirstPart) {\n                this.contentBBox = newBBox;\n                isFirstPart = false;\n            }\n            else {\n                this.contentBBox = this.contentBBox.union(newBBox);\n            }\n            return {\n                path: newPath,\n                startPoint: newPath.startPoint,\n                commands: newPath.parts,\n                style: newStyle,\n            };\n        });\n    }\n    /**\n     * @returns A list of the parts that make up this path. Many paths only have one part.\n     *\n     * Each part (a {@link RenderablePathSpec}) contains information about the style and geometry\n     * of that part of the stroke. Use the `.path` property to do collision detection and other\n     * operations involving the stroke's geometry.\n     *\n     * Note that many of {@link Path}'s methods (e.g. {@link Path.intersection}) take a\n     * `strokeWidth` parameter that can be gotten from {@link RenderablePathSpec.style} `.stroke.width`.\n     */\n    getParts() {\n        return [...this.parts];\n    }\n    /**\n     * @returns the {@link Path.union} of all paths that make up this stroke.\n     */\n    getPath() {\n        let result = null;\n        for (const part of this.parts) {\n            if (result) {\n                result = result.union(part.path);\n            }\n            else {\n                result ??= part.path;\n            }\n        }\n        return result ?? math_1.Path.empty;\n    }\n    description(localization) {\n        return localization.stroke;\n    }\n    createClone() {\n        return new Stroke(this.parts);\n    }\n    serializeToJSON() {\n        return this.parts.map((part) => {\n            return {\n                style: (0, RenderingStyle_1.styleToJSON)(part.style),\n                path: part.path.serialize(),\n            };\n        });\n    }\n    /** @internal */\n    static deserializeFromJSON(json) {\n        if (typeof json === 'string') {\n            json = JSON.parse(json);\n        }\n        if (typeof json !== 'object' || typeof json.length !== 'number') {\n            throw new Error(`${json} is missing required field, parts, or parts is of the wrong type.`);\n        }\n        const pathSpec = json.map((part) => {\n            const style = (0, RenderingStyle_1.styleFromJSON)(part.style);\n            return (0, RenderablePathSpec_1.pathToRenderable)(math_1.Path.fromString(part.path), style);\n        });\n        return new Stroke(pathSpec);\n    }\n}\nexports[\"default\"] = Stroke;\nAbstractComponent_1.default.registerComponent('stroke', Stroke.deserializeFromJSON);\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/components/Stroke.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/components/TextComponent.js":
/*!*******************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/components/TextComponent.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TextTransformMode = void 0;\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\nconst TextRenderingStyle_1 = __webpack_require__(/*! ../rendering/TextRenderingStyle */ \"./node_modules/js-draw/dist/cjs/rendering/TextRenderingStyle.js\");\nconst AbstractComponent_1 = __importDefault(__webpack_require__(/*! ./AbstractComponent */ \"./node_modules/js-draw/dist/cjs/components/AbstractComponent.js\"));\nconst RestylableComponent_1 = __webpack_require__(/*! ./RestylableComponent */ \"./node_modules/js-draw/dist/cjs/components/RestylableComponent.js\");\nconst componentTypeId = 'text';\nvar TextTransformMode;\n(function (TextTransformMode) {\n    /** Absolutely positioned in both the X and Y dimensions. */\n    TextTransformMode[TextTransformMode[\"ABSOLUTE_XY\"] = 0] = \"ABSOLUTE_XY\";\n    /** Relatively positioned in both the X and Y dimensions. */\n    TextTransformMode[TextTransformMode[\"RELATIVE_XY\"] = 1] = \"RELATIVE_XY\";\n    /**Relatively positioned in the X direction, absolutely positioned in the Y direction. */\n    TextTransformMode[TextTransformMode[\"RELATIVE_X_ABSOLUTE_Y\"] = 2] = \"RELATIVE_X_ABSOLUTE_Y\";\n    /**Relatively positioned in the Y direction, absolutely positioned in the X direction. */\n    TextTransformMode[TextTransformMode[\"RELATIVE_Y_ABSOLUTE_X\"] = 3] = \"RELATIVE_Y_ABSOLUTE_X\";\n})(TextTransformMode || (exports.TextTransformMode = TextTransformMode = {}));\nconst defaultTextStyle = {\n    fontFamily: 'sans',\n    size: 12,\n    renderingStyle: { fill: math_1.Color4.purple },\n};\n/**\n * Displays text.\n *\n * A `TextComponent` is a collection of `TextElement`s (`string`s or {@link TextComponent}s).\n *\n * **Example**:\n *\n * ```ts,runnable\n * import { Editor, TextComponent, Mat33, Vec2, Color4, TextRenderingStyle } from 'js-draw';\n * const editor = new Editor(document.body);\n * editor.dispatch(editor.setBackgroundStyle({ color: Color4.black, autoresize: true ));\n * ---visible---\n * /// Adding a simple TextComponent\n * ///------------------------------\n *\n * const positioning1 = Mat33.translation(Vec2.of(10, 10));\n * const style: TextRenderingStyle = {\n *     fontFamily: 'sans', size: 12, renderingStyle: { fill: Color4.green },\n * };\n *\n * editor.dispatch(\n *     editor.image.addElement(new TextComponent(['Hello, world'], positioning1, style)),\n * );\n *\n *\n * /// Adding nested TextComponents\n * ///-----------------------------\n *\n * // Add another TextComponent that contains text and a TextComponent. Observe that '[Test]'\n * // is placed directly after 'Test'.\n * const positioning2 = Mat33.translation(Vec2.of(10, 50));\n * editor.dispatch(\n *     editor.image.addElement(\n *         new TextComponent([ new TextComponent(['Test'], positioning1, style), '[Test]' ], positioning2, style)\n *     ),\n * );\n * ```\n */\nclass TextComponent extends AbstractComponent_1.default {\n    /**\n     * Creates a new text object from a list of component text or child TextComponents.\n     *\n     * @see {@link fromLines}\n     */\n    constructor(textObjects, \n    // Transformation relative to this component's parent element.\n    transform, style = defaultTextStyle, \n    // @internal\n    transformMode = TextTransformMode.ABSOLUTE_XY) {\n        super(componentTypeId);\n        this.textObjects = textObjects;\n        this.transform = transform;\n        this.style = style;\n        this.transformMode = transformMode;\n        // eslint-disable-next-line @typescript-eslint/prefer-as-const\n        this.isRestylableComponent = true;\n        this.recomputeBBox();\n        // If this has no direct children, choose a style representative of this' content\n        // (useful for estimating the style of the TextComponent).\n        const hasDirectContent = textObjects.some((obj) => typeof obj === 'string');\n        if (!hasDirectContent && textObjects.length > 0) {\n            this.style = textObjects[0].getTextStyle();\n        }\n    }\n    static applyTextStyles(ctx, style) {\n        // Quote the font family if necessary.\n        const hasSpaces = style.fontFamily.match(/\\s/);\n        const isQuoted = style.fontFamily.match(/^\".*\"$/);\n        const fontFamily = hasSpaces && !isQuoted ? `\"${style.fontFamily.replace(/[\"]/g, '\\\\\"')}\"` : style.fontFamily;\n        ctx.font = [\n            style.fontStyle ?? '',\n            style.fontWeight ?? '',\n            (style.size ?? 12) + 'px',\n            `${fontFamily}`,\n        ].join(' ');\n        // TODO: Support RTL\n        ctx.textAlign = 'left';\n    }\n    // Roughly estimate the bounding box of `text`. Use if no CanvasRenderingContext2D is available.\n    static estimateTextDimens(text, style) {\n        const widthEst = text.length * style.size;\n        const heightEst = style.size;\n        // Text is drawn with (0, 0) as its baseline. As such, the majority of the text's height should\n        // be above (0, 0).\n        return new math_1.Rect2(0, (-heightEst * 2) / 3, widthEst, heightEst);\n    }\n    // Returns a set of TextMetrics for the given text, if a canvas is available.\n    static getTextMetrics(text, style) {\n        TextComponent.textMeasuringCtx ??= document.createElement('canvas').getContext('2d') ?? null;\n        if (!TextComponent.textMeasuringCtx) {\n            return null;\n        }\n        const ctx = TextComponent.textMeasuringCtx;\n        TextComponent.applyTextStyles(ctx, style);\n        return ctx.measureText(text);\n    }\n    // Returns the bounding box of `text`. This is approximate if no Canvas is available.\n    static getTextDimens(text, style) {\n        const metrics = this.getTextMetrics(text, style);\n        if (!metrics) {\n            return this.estimateTextDimens(text, style);\n        }\n        // Text is drawn with (0,0) at the bottom left of the baseline.\n        const textY = -metrics.actualBoundingBoxAscent;\n        const textHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;\n        return new math_1.Rect2(0, textY, metrics.width, textHeight);\n    }\n    static getFontHeight(style) {\n        return style.size;\n    }\n    computeUntransformedBBoxOfPart(part) {\n        if (typeof part === 'string') {\n            return TextComponent.getTextDimens(part, this.style);\n        }\n        else {\n            return part.contentBBox;\n        }\n    }\n    recomputeBBox() {\n        let bbox = null;\n        const cursor = new TextComponent.TextCursor(this.transform, this.style);\n        for (const textObject of this.textObjects) {\n            const transform = cursor.update(textObject).transform;\n            const currentBBox = this.computeUntransformedBBoxOfPart(textObject).transformedBoundingBox(transform);\n            bbox ??= currentBBox;\n            bbox = bbox.union(currentBBox);\n        }\n        this.contentBBox = bbox ?? math_1.Rect2.empty;\n    }\n    /**\n     * Renders a TextComponent or a TextComponent child onto a `canvas`.\n     *\n     * `visibleRect` can be provided as a performance optimization. If not the top-level\n     * text node, `baseTransform` (specifies the transformation of the parent text component\n     * in canvas space) should also be provided.\n     *\n     * Note that passing a `baseTransform` is preferable to transforming `visibleRect`. At high\n     * zoom levels, transforming `visibleRect` by the inverse of the parent transform can lead to\n     * inaccuracy due to precision loss.\n     */\n    renderInternal(canvas, visibleRect, baseTransform = math_1.Mat33.identity) {\n        const cursor = new TextComponent.TextCursor(this.transform, this.style);\n        for (const textObject of this.textObjects) {\n            const { transform, bbox } = cursor.update(textObject);\n            if (visibleRect && !visibleRect.intersects(bbox.transformedBoundingBox(baseTransform))) {\n                continue;\n            }\n            if (typeof textObject === 'string') {\n                canvas.drawText(textObject, transform, this.style);\n            }\n            else {\n                canvas.pushTransform(transform);\n                textObject.renderInternal(canvas, visibleRect, baseTransform.rightMul(transform));\n                canvas.popTransform();\n            }\n        }\n    }\n    render(canvas, visibleRect) {\n        canvas.startObject(this.contentBBox);\n        this.renderInternal(canvas, visibleRect);\n        canvas.endObject(this.getLoadSaveData());\n    }\n    getProportionalRenderingTime() {\n        return this.textObjects.length;\n    }\n    intersects(lineSegment) {\n        const cursor = new TextComponent.TextCursor(this.transform, this.style);\n        for (const subObject of this.textObjects) {\n            // Convert canvas space to internal space relative to the current object.\n            const invTransform = cursor.update(subObject).transform.inverse();\n            const transformedLine = lineSegment.transformedBy(invTransform);\n            if (typeof subObject === 'string') {\n                const textBBox = TextComponent.getTextDimens(subObject, this.style);\n                // TODO: Use a better intersection check. Perhaps draw the text onto a CanvasElement and\n                // use pixel-testing to check for intersection with its contour.\n                if (textBBox.getEdges().some((edge) => transformedLine.intersection(edge) !== null)) {\n                    return true;\n                }\n            }\n            else {\n                if (subObject.intersects(transformedLine)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    getStyle() {\n        return {\n            color: this.style.renderingStyle.fill,\n            // Make a copy\n            textStyle: {\n                ...this.style,\n                renderingStyle: {\n                    ...this.style.renderingStyle,\n                },\n            },\n        };\n    }\n    updateStyle(style) {\n        return (0, RestylableComponent_1.createRestyleComponentCommand)(this.getStyle(), style, this);\n    }\n    forceStyle(style, editor) {\n        if (style.textStyle) {\n            this.style = (0, TextRenderingStyle_1.cloneTextStyle)(style.textStyle);\n        }\n        else if (style.color) {\n            this.style = {\n                ...this.style,\n                renderingStyle: {\n                    ...this.style.renderingStyle,\n                    fill: style.color,\n                },\n            };\n        }\n        else {\n            return;\n        }\n        for (const child of this.textObjects) {\n            if (child instanceof TextComponent) {\n                child.forceStyle(style, editor);\n            }\n        }\n        if (editor) {\n            editor.image.queueRerenderOf(this);\n            editor.queueRerender();\n        }\n    }\n    // See {@link getStyle}\n    getTextStyle() {\n        return (0, TextRenderingStyle_1.cloneTextStyle)(this.style);\n    }\n    getBaselinePos() {\n        return this.transform.transformVec2(math_1.Vec2.zero);\n    }\n    getTransform() {\n        return this.transform;\n    }\n    applyTransformation(affineTransfm) {\n        this.transform = affineTransfm.rightMul(this.transform);\n        this.recomputeBBox();\n    }\n    createClone() {\n        const clonedTextObjects = this.textObjects.map((obj) => {\n            if (typeof obj === 'string') {\n                return obj;\n            }\n            else {\n                return obj.createClone();\n            }\n        });\n        return new TextComponent(clonedTextObjects, this.transform, this.style);\n    }\n    getText() {\n        const result = [];\n        for (const textObject of this.textObjects) {\n            if (typeof textObject === 'string') {\n                result.push(textObject);\n            }\n            else {\n                result.push(textObject.getText());\n            }\n        }\n        return result.join('\\n');\n    }\n    description(localizationTable) {\n        return localizationTable.text(this.getText());\n    }\n    // Do not rely on the output of `serializeToJSON` taking any particular format.\n    serializeToJSON() {\n        const serializableStyle = (0, TextRenderingStyle_1.textStyleToJSON)(this.style);\n        const serializedTextObjects = this.textObjects.map((text) => {\n            if (typeof text === 'string') {\n                return {\n                    text,\n                };\n            }\n            else {\n                return {\n                    json: text.serializeToJSON(),\n                };\n            }\n        });\n        return {\n            textObjects: serializedTextObjects,\n            transform: this.transform.toArray(),\n            style: serializableStyle,\n        };\n    }\n    // @internal\n    static deserializeFromString(json) {\n        if (typeof json === 'string') {\n            json = JSON.parse(json);\n        }\n        const style = (0, TextRenderingStyle_1.textStyleFromJSON)(json.style);\n        const textObjects = json.textObjects.map((data) => {\n            if ((data.text ?? null) !== null) {\n                return data.text;\n            }\n            return TextComponent.deserializeFromString(data.json);\n        });\n        json.transform = json.transform.filter((elem) => typeof elem === 'number');\n        if (json.transform.length !== 9) {\n            throw new Error(`Unable to deserialize transform, ${json.transform}.`);\n        }\n        const transformData = json.transform;\n        const transform = new math_1.Mat33(...transformData);\n        return new TextComponent(textObjects, transform, style);\n    }\n    /**\n     * Creates a `TextComponent` from `lines`.\n     *\n     * @example\n     * ```ts\n     * const textStyle = {\n     *   size: 12,\n     *   fontFamily: 'serif',\n     *   renderingStyle: { fill: Color4.black },\n     * };\n     *\n     * const text = TextComponent.fromLines('foo\\nbar'.split('\\n'), Mat33.identity, textStyle);\n     * ```\n     */\n    static fromLines(lines, transform, style) {\n        let lastComponent = null;\n        const components = [];\n        const lineMargin = Math.round(this.getFontHeight(style));\n        let position = math_1.Vec2.zero;\n        for (const line of lines) {\n            if (lastComponent) {\n                position = position.plus(math_1.Vec2.unitY.times(lineMargin));\n            }\n            const component = new TextComponent([line], math_1.Mat33.translation(position), style);\n            components.push(component);\n            lastComponent = component;\n        }\n        return new TextComponent(components, transform, style);\n    }\n}\nTextComponent.textMeasuringCtx = null;\nTextComponent.TextCursor = class {\n    constructor(parentTransform = math_1.Mat33.identity, parentStyle) {\n        this.parentTransform = parentTransform;\n        this.parentStyle = parentStyle;\n        this.transform = math_1.Mat33.identity;\n    }\n    /**\n     * Based on previous calls to `update`, returns the transformation and bounding box (relative\n     * to the parent element, or if none, the canvas) of the given `element`. Note that\n     * this is computed in part using the `parentTransform` provivded to this cursor's constructor.\n     *\n     * Warning: There may be edge cases here that are not taken into account.\n     */\n    update(elem) {\n        let elementTransform = math_1.Mat33.identity;\n        let elemInternalTransform = math_1.Mat33.identity;\n        let textSize;\n        if (typeof elem === 'string') {\n            textSize = TextComponent.getTextDimens(elem, this.parentStyle);\n        }\n        else {\n            // TODO: Double-check whether we need to take elem.transform into account here.\n            // elementTransform = elem.transform;\n            elemInternalTransform = elem.transform;\n            textSize = elem.getBBox();\n        }\n        const positioning = typeof elem === 'string' ? TextTransformMode.RELATIVE_XY : elem.transformMode;\n        if (positioning === TextTransformMode.RELATIVE_XY) {\n            // Position relative to the previous element's transform.\n            elementTransform = this.transform.rightMul(elementTransform);\n        }\n        else if (positioning === TextTransformMode.RELATIVE_X_ABSOLUTE_Y ||\n            positioning === TextTransformMode.RELATIVE_Y_ABSOLUTE_X) {\n            // Zero the absolute component of this.transform's translation\n            const transform = this.transform.mapEntries((component, [row, col]) => {\n                if (positioning === TextTransformMode.RELATIVE_X_ABSOLUTE_Y) {\n                    // Zero the y component of this.transform's translation\n                    return row === 1 && col === 2 ? 0 : component;\n                }\n                else if (positioning === TextTransformMode.RELATIVE_Y_ABSOLUTE_X) {\n                    // Zero the x component of this.transform's translation\n                    return row === 0 && col === 2 ? 0 : component;\n                }\n                throw new Error('Unreachable');\n                return 0;\n            });\n            elementTransform = transform.rightMul(elementTransform);\n        }\n        // Update this.transform so that future calls to update return correct values.\n        const endShiftTransform = math_1.Mat33.translation(math_1.Vec2.of(textSize.width, 0));\n        this.transform = elementTransform.rightMul(elemInternalTransform).rightMul(endShiftTransform);\n        const transform = this.parentTransform.rightMul(elementTransform);\n        return {\n            transform,\n            bbox: textSize.transformedBoundingBox(transform),\n        };\n    }\n};\nexports[\"default\"] = TextComponent;\nAbstractComponent_1.default.registerComponent(componentTypeId, (data) => TextComponent.deserializeFromString(data));\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/components/TextComponent.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/components/UnknownSVGObject.js":
/*!**********************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/components/UnknownSVGObject.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n//\n// Stores objects loaded from an SVG that aren't recognised by the editor.\n// @internal\n// @packageDocumentation\n//\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\nconst SVGRenderer_1 = __importDefault(__webpack_require__(/*! ../rendering/renderers/SVGRenderer */ \"./node_modules/js-draw/dist/cjs/rendering/renderers/SVGRenderer.js\"));\nconst AbstractComponent_1 = __importStar(__webpack_require__(/*! ./AbstractComponent */ \"./node_modules/js-draw/dist/cjs/components/AbstractComponent.js\"));\nconst componentId = 'unknown-svg-object';\nclass UnknownSVGObject extends AbstractComponent_1.default {\n    constructor(svgObject) {\n        super(componentId);\n        this.svgObject = svgObject;\n        this.contentBBox = math_1.Rect2.of(svgObject.getBoundingClientRect());\n    }\n    render(canvas, _visibleRect) {\n        if (!(canvas instanceof SVGRenderer_1.default)) {\n            // Don't draw unrenderable objects if we can't\n            return;\n        }\n        canvas.startObject(this.contentBBox);\n        canvas.drawSVGElem(this.svgObject);\n        canvas.endObject(this.getLoadSaveData());\n    }\n    intersects(lineSegment) {\n        return this.contentBBox.getEdges().some((edge) => edge.intersection(lineSegment) !== null);\n    }\n    applyTransformation(_affineTransfm) { }\n    isSelectable() {\n        return false;\n    }\n    getSizingMode() {\n        // This component can be shown anywhere (it won't be\n        // visible to the user, it just needs to be saved with\n        // the image).\n        return AbstractComponent_1.ComponentSizingMode.Anywhere;\n    }\n    createClone() {\n        return new UnknownSVGObject(this.svgObject.cloneNode(true));\n    }\n    description(localization) {\n        return localization.svgObject;\n    }\n    serializeToJSON() {\n        return JSON.stringify({\n            html: this.svgObject.outerHTML,\n        });\n    }\n}\nexports[\"default\"] = UnknownSVGObject;\n// null: Do not deserialize UnknownSVGObjects.\nAbstractComponent_1.default.registerComponent(componentId, null);\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/components/UnknownSVGObject.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/components/builders/ArrowBuilder.js":
/*!***************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/components/builders/ArrowBuilder.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.makeArrowBuilder = void 0;\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\nconst Stroke_1 = __importDefault(__webpack_require__(/*! ../Stroke */ \"./node_modules/js-draw/dist/cjs/components/Stroke.js\"));\nconst makeSnapToGridAutocorrect_1 = __importDefault(__webpack_require__(/*! ./autocorrect/makeSnapToGridAutocorrect */ \"./node_modules/js-draw/dist/cjs/components/builders/autocorrect/makeSnapToGridAutocorrect.js\"));\n/**\n * Creates a stroke builder that generates arrows.\n *\n * Example:\n * [[include:doc-pages/inline-examples/changing-pen-types.md]]\n */\nexports.makeArrowBuilder = (0, makeSnapToGridAutocorrect_1.default)((initialPoint, viewport) => {\n    return new ArrowBuilder(initialPoint, viewport);\n});\nclass ArrowBuilder {\n    constructor(startPoint, viewport) {\n        this.startPoint = startPoint;\n        this.viewport = viewport;\n        this.endPoint = startPoint;\n    }\n    getLineWidth() {\n        return Math.max(this.endPoint.width, this.startPoint.width);\n    }\n    getBBox() {\n        const preview = this.buildPreview();\n        return preview.getBBox();\n    }\n    buildPreview() {\n        const lineStartPoint = this.startPoint.pos;\n        const endPoint = this.endPoint.pos;\n        const toEnd = endPoint.minus(lineStartPoint).normalized();\n        const arrowLength = endPoint.distanceTo(lineStartPoint);\n        // Ensure that the arrow tip is smaller than the arrow.\n        const arrowTipSize = Math.min(this.getLineWidth(), arrowLength / 2);\n        const startSize = this.startPoint.width / 2;\n        const endSize = this.endPoint.width / 2;\n        const arrowTipBase = endPoint.minus(toEnd.times(arrowTipSize));\n        // Scaled normal vectors.\n        const lineNormal = toEnd.orthog();\n        const scaledStartNormal = lineNormal.times(startSize);\n        const scaledBaseNormal = lineNormal.times(endSize);\n        const path = new math_1.Path(arrowTipBase.minus(scaledBaseNormal), [\n            // Stem\n            {\n                kind: math_1.PathCommandType.LineTo,\n                point: lineStartPoint.minus(scaledStartNormal),\n            },\n            {\n                kind: math_1.PathCommandType.LineTo,\n                point: lineStartPoint.plus(scaledStartNormal),\n            },\n            {\n                kind: math_1.PathCommandType.LineTo,\n                point: arrowTipBase.plus(scaledBaseNormal),\n            },\n            // Head\n            {\n                kind: math_1.PathCommandType.LineTo,\n                point: arrowTipBase.plus(lineNormal.times(arrowTipSize).plus(scaledBaseNormal)),\n            },\n            {\n                kind: math_1.PathCommandType.LineTo,\n                point: endPoint.plus(toEnd.times(endSize)),\n            },\n            {\n                kind: math_1.PathCommandType.LineTo,\n                point: arrowTipBase.plus(lineNormal.times(-arrowTipSize).minus(scaledBaseNormal)),\n            },\n            {\n                kind: math_1.PathCommandType.LineTo,\n                point: arrowTipBase.minus(scaledBaseNormal),\n            },\n            // Round all points in the arrow (to remove unnecessary decimal places)\n        ]).mapPoints((point) => this.viewport.roundPoint(point));\n        const preview = new Stroke_1.default([\n            {\n                startPoint: path.startPoint,\n                commands: path.parts,\n                style: {\n                    fill: this.startPoint.color,\n                },\n            },\n        ]);\n        return preview;\n    }\n    build() {\n        return this.buildPreview();\n    }\n    preview(renderer) {\n        this.buildPreview().render(renderer);\n    }\n    addPoint(point) {\n        this.endPoint = point;\n    }\n}\nexports[\"default\"] = ArrowBuilder;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/components/builders/ArrowBuilder.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/components/builders/CircleBuilder.js":
/*!****************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/components/builders/CircleBuilder.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.makeOutlinedCircleBuilder = void 0;\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\nconst RenderablePathSpec_1 = __webpack_require__(/*! ../../rendering/RenderablePathSpec */ \"./node_modules/js-draw/dist/cjs/rendering/RenderablePathSpec.js\");\nconst Viewport_1 = __importDefault(__webpack_require__(/*! ../../Viewport */ \"./node_modules/js-draw/dist/cjs/Viewport.js\"));\nconst Stroke_1 = __importDefault(__webpack_require__(/*! ../Stroke */ \"./node_modules/js-draw/dist/cjs/components/Stroke.js\"));\nconst makeSnapToGridAutocorrect_1 = __importDefault(__webpack_require__(/*! ./autocorrect/makeSnapToGridAutocorrect */ \"./node_modules/js-draw/dist/cjs/components/builders/autocorrect/makeSnapToGridAutocorrect.js\"));\n/**\n * Creates a stroke builder that generates outlined circles.\n *\n * Example:\n * [[include:doc-pages/inline-examples/changing-pen-types.md]]\n */\nexports.makeOutlinedCircleBuilder = (0, makeSnapToGridAutocorrect_1.default)((initialPoint, viewport) => {\n    return new CircleBuilder(initialPoint, viewport);\n});\nclass CircleBuilder {\n    constructor(startPoint, viewport) {\n        this.startPoint = startPoint;\n        this.viewport = viewport;\n        // Initially, the start and end points are the same.\n        this.endPoint = startPoint;\n    }\n    getBBox() {\n        const preview = this.buildPreview();\n        return preview.getBBox();\n    }\n    buildPreview() {\n        const pathCommands = [];\n        const numDivisions = 6;\n        const stepSize = (Math.PI * 2) / numDivisions;\n        // Round the stroke width so that when exported it doesn't have unnecessary trailing decimals.\n        const strokeWidth = Viewport_1.default.roundPoint(this.endPoint.width, 5 / this.viewport.getScaleFactor());\n        const center = this.startPoint.pos.lerp(this.endPoint.pos, 0.5);\n        const startEndDelta = this.endPoint.pos.minus(center);\n        const radius = startEndDelta.length() - strokeWidth / 2;\n        const startPoint = center.plus(math_1.Vec2.of(radius, 0));\n        for (let t = stepSize; t <= Math.PI * 2; t += stepSize) {\n            const endPoint = math_1.Vec2.of(radius * Math.cos(t), -radius * Math.sin(t)).plus(center);\n            // controlPointRadiusScale is selected to make the circles appear circular and\n            // **does** depend on stepSize.\n            const controlPointRadiusScale = 1.141;\n            const controlPoint = math_1.Vec2.of(Math.cos(t - stepSize / 2), -Math.sin(t - stepSize / 2))\n                .times(radius * controlPointRadiusScale)\n                .plus(center);\n            pathCommands.push({\n                kind: math_1.PathCommandType.QuadraticBezierTo,\n                controlPoint,\n                endPoint,\n            });\n        }\n        pathCommands.push({\n            kind: math_1.PathCommandType.LineTo,\n            point: startPoint,\n        });\n        const path = new math_1.Path(startPoint, pathCommands).mapPoints((point) => this.viewport.roundPoint(point));\n        const preview = new Stroke_1.default([\n            (0, RenderablePathSpec_1.pathToRenderable)(path, {\n                fill: math_1.Color4.transparent,\n                stroke: {\n                    width: strokeWidth,\n                    color: this.endPoint.color,\n                },\n            }),\n        ]);\n        return preview;\n    }\n    build() {\n        return this.buildPreview();\n    }\n    preview(renderer) {\n        this.buildPreview().render(renderer);\n    }\n    addPoint(point) {\n        this.endPoint = point;\n    }\n}\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/components/builders/CircleBuilder.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/components/builders/FreehandLineBuilder.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/components/builders/FreehandLineBuilder.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.makeFreehandLineBuilder = void 0;\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\nconst Stroke_1 = __importDefault(__webpack_require__(/*! ../Stroke */ \"./node_modules/js-draw/dist/cjs/components/Stroke.js\"));\nconst Viewport_1 = __importDefault(__webpack_require__(/*! ../../Viewport */ \"./node_modules/js-draw/dist/cjs/Viewport.js\"));\nconst StrokeSmoother_1 = __webpack_require__(/*! ../util/StrokeSmoother */ \"./node_modules/js-draw/dist/cjs/components/util/StrokeSmoother.js\");\nconst makeShapeFitAutocorrect_1 = __importDefault(__webpack_require__(/*! ./autocorrect/makeShapeFitAutocorrect */ \"./node_modules/js-draw/dist/cjs/components/builders/autocorrect/makeShapeFitAutocorrect.js\"));\n/**\n * Creates a stroke builder that draws freehand lines.\n *\n * Example:\n * [[include:doc-pages/inline-examples/changing-pen-types.md]]\n */\nexports.makeFreehandLineBuilder = (0, makeShapeFitAutocorrect_1.default)((initialPoint, viewport) => {\n    // Don't smooth if input is more than ± 3 pixels from the true curve, do smooth if\n    // less than ±1 px from the curve.\n    const maxSmoothingDist = viewport.getSizeOfPixelOnCanvas() * 3;\n    const minSmoothingDist = viewport.getSizeOfPixelOnCanvas();\n    return new FreehandLineBuilder(initialPoint, minSmoothingDist, maxSmoothingDist, viewport);\n});\n// Handles stroke smoothing and creates Strokes from user/stylus input.\nclass FreehandLineBuilder {\n    constructor(startPoint, minFitAllowed, maxFitAllowed, viewport) {\n        this.startPoint = startPoint;\n        this.minFitAllowed = minFitAllowed;\n        this.viewport = viewport;\n        this.isFirstSegment = true;\n        this.parts = [];\n        this.widthAverageNumSamples = 1;\n        this.curveFitter = new StrokeSmoother_1.StrokeSmoother(startPoint, minFitAllowed, maxFitAllowed, (curve) => this.addCurve(curve));\n        this.averageWidth = startPoint.width;\n        this.bbox = new math_1.Rect2(this.startPoint.pos.x, this.startPoint.pos.y, 0, 0);\n    }\n    getBBox() {\n        return this.bbox;\n    }\n    getRenderingStyle() {\n        return {\n            fill: math_1.Color4.transparent,\n            stroke: {\n                color: this.startPoint.color,\n                width: this.roundDistance(this.averageWidth),\n            },\n        };\n    }\n    previewCurrentPath() {\n        const path = this.parts.slice();\n        const commands = [...path, ...this.curveToPathCommands(this.curveFitter.preview())];\n        const startPoint = this.startPoint.pos;\n        return {\n            startPoint,\n            commands,\n            style: this.getRenderingStyle(),\n        };\n    }\n    previewFullPath() {\n        const preview = this.previewCurrentPath();\n        if (preview) {\n            return [preview];\n        }\n        return null;\n    }\n    previewStroke() {\n        const pathPreview = this.previewFullPath();\n        if (pathPreview) {\n            return new Stroke_1.default(pathPreview);\n        }\n        return null;\n    }\n    preview(renderer) {\n        const paths = this.previewFullPath();\n        if (paths) {\n            const approxBBox = this.viewport.visibleRect;\n            renderer.startObject(approxBBox);\n            for (const path of paths) {\n                renderer.drawPath(path);\n            }\n            renderer.endObject();\n        }\n    }\n    build() {\n        this.curveFitter.finalizeCurrentCurve();\n        return this.previewStroke();\n    }\n    getMinFit() {\n        let minFit = Math.min(this.minFitAllowed, this.averageWidth / 3);\n        if (minFit < 1e-10) {\n            minFit = this.minFitAllowed;\n        }\n        return minFit;\n    }\n    roundPoint(point) {\n        const minFit = this.getMinFit();\n        return Viewport_1.default.roundPoint(point, minFit);\n    }\n    roundDistance(dist) {\n        const minFit = this.getMinFit();\n        return Viewport_1.default.roundPoint(dist, minFit);\n    }\n    curveToPathCommands(curve) {\n        // Case where no points have been added\n        if (!curve) {\n            // Don't create a circle around the initial point if the stroke has more than one point.\n            if (!this.isFirstSegment) {\n                return [];\n            }\n            // Make the circle small -- because of the stroke style, we'll be drawing a stroke around it.\n            const width = Viewport_1.default.roundPoint(this.averageWidth / 10, Math.min(this.minFitAllowed, this.averageWidth / 10));\n            const center = this.roundPoint(this.startPoint.pos);\n            // Start on the right, cycle clockwise:\n            //    |\n            //  ----- ←\n            //    |\n            // Draw a circle-ish shape around the start point\n            return [\n                {\n                    kind: math_1.PathCommandType.QuadraticBezierTo,\n                    controlPoint: center.plus(math_1.Vec2.of(width, width)),\n                    // Bottom of the circle\n                    //    |\n                    //  -----\n                    //    |\n                    //    ↑\n                    endPoint: center.plus(math_1.Vec2.of(0, width)),\n                },\n                {\n                    kind: math_1.PathCommandType.QuadraticBezierTo,\n                    controlPoint: center.plus(math_1.Vec2.of(-width, width)),\n                    endPoint: center.plus(math_1.Vec2.of(-width, 0)),\n                },\n                {\n                    kind: math_1.PathCommandType.QuadraticBezierTo,\n                    controlPoint: center.plus(math_1.Vec2.of(-width, -width)),\n                    endPoint: center.plus(math_1.Vec2.of(0, -width)),\n                },\n                {\n                    kind: math_1.PathCommandType.QuadraticBezierTo,\n                    controlPoint: center.plus(math_1.Vec2.of(width, -width)),\n                    endPoint: center.plus(math_1.Vec2.of(width, 0)),\n                },\n            ];\n        }\n        const result = [];\n        if (this.isFirstSegment) {\n            result.push({\n                kind: math_1.PathCommandType.MoveTo,\n                point: this.roundPoint(curve.startPoint),\n            });\n        }\n        result.push({\n            kind: math_1.PathCommandType.QuadraticBezierTo,\n            controlPoint: this.roundPoint(curve.controlPoint),\n            endPoint: this.roundPoint(curve.endPoint),\n        });\n        return result;\n    }\n    addCurve(curve) {\n        const parts = this.curveToPathCommands(curve);\n        this.parts.push(...parts);\n        if (this.isFirstSegment) {\n            this.isFirstSegment = false;\n        }\n    }\n    addPoint(newPoint) {\n        this.curveFitter.addPoint(newPoint);\n        this.widthAverageNumSamples++;\n        this.averageWidth =\n            (this.averageWidth * (this.widthAverageNumSamples - 1)) / this.widthAverageNumSamples +\n                newPoint.width / this.widthAverageNumSamples;\n    }\n}\nexports[\"default\"] = FreehandLineBuilder;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/components/builders/FreehandLineBuilder.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/components/builders/LineBuilder.js":
/*!**************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/components/builders/LineBuilder.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.makeLineBuilder = void 0;\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\nconst RenderablePathSpec_1 = __webpack_require__(/*! ../../rendering/RenderablePathSpec */ \"./node_modules/js-draw/dist/cjs/rendering/RenderablePathSpec.js\");\nconst Stroke_1 = __importDefault(__webpack_require__(/*! ../Stroke */ \"./node_modules/js-draw/dist/cjs/components/Stroke.js\"));\nconst makeSnapToGridAutocorrect_1 = __importDefault(__webpack_require__(/*! ./autocorrect/makeSnapToGridAutocorrect */ \"./node_modules/js-draw/dist/cjs/components/builders/autocorrect/makeSnapToGridAutocorrect.js\"));\n/**\n * Creates a stroke builder that generates filled lines.\n *\n * Example:\n * [[include:doc-pages/inline-examples/changing-pen-types.md]]\n */\nexports.makeLineBuilder = (0, makeSnapToGridAutocorrect_1.default)((initialPoint, viewport) => {\n    return new LineBuilder(initialPoint, viewport);\n});\nclass LineBuilder {\n    constructor(startPoint, viewport) {\n        this.startPoint = startPoint;\n        this.viewport = viewport;\n        this.endPoint = startPoint;\n    }\n    getBBox() {\n        const preview = this.buildPreview();\n        return preview.getBBox();\n    }\n    buildPreview() {\n        const startPoint = this.startPoint.pos;\n        const endPoint = this.endPoint.pos;\n        const toEnd = endPoint.minus(startPoint).normalized();\n        const startSize = this.startPoint.width / 2;\n        const endSize = this.endPoint.width / 2;\n        const lineNormal = toEnd.orthog();\n        const scaledStartNormal = lineNormal.times(startSize);\n        const scaledEndNormal = lineNormal.times(endSize);\n        const strokeStartPoint = startPoint.minus(scaledStartNormal);\n        const path = new math_1.Path(strokeStartPoint, [\n            {\n                kind: math_1.PathCommandType.LineTo,\n                point: startPoint.plus(scaledStartNormal),\n            },\n            {\n                kind: math_1.PathCommandType.LineTo,\n                point: endPoint.plus(scaledEndNormal),\n            },\n            {\n                kind: math_1.PathCommandType.LineTo,\n                point: endPoint.minus(scaledEndNormal),\n            },\n            {\n                kind: math_1.PathCommandType.LineTo,\n                point: startPoint.minus(scaledStartNormal),\n            },\n        ]).mapPoints((point) => this.viewport.roundPoint(point));\n        const preview = new Stroke_1.default([(0, RenderablePathSpec_1.pathToRenderable)(path, { fill: this.startPoint.color })]);\n        return preview;\n    }\n    build() {\n        return this.buildPreview();\n    }\n    preview(renderer) {\n        this.buildPreview().render(renderer);\n    }\n    addPoint(point) {\n        this.endPoint = point;\n    }\n}\nexports[\"default\"] = LineBuilder;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/components/builders/LineBuilder.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/components/builders/PolylineBuilder.js":
/*!******************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/components/builders/PolylineBuilder.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.makePolylineBuilder = void 0;\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\nconst Stroke_1 = __importDefault(__webpack_require__(/*! ../Stroke */ \"./node_modules/js-draw/dist/cjs/components/Stroke.js\"));\nconst Viewport_1 = __importDefault(__webpack_require__(/*! ../../Viewport */ \"./node_modules/js-draw/dist/cjs/Viewport.js\"));\nconst makeShapeFitAutocorrect_1 = __importDefault(__webpack_require__(/*! ./autocorrect/makeShapeFitAutocorrect */ \"./node_modules/js-draw/dist/cjs/components/builders/autocorrect/makeShapeFitAutocorrect.js\"));\n/**\n * Creates a freehand line builder that creates strokes from line segments\n * rather than Bézier curves.\n *\n * Example:\n * [[include:doc-pages/inline-examples/changing-pen-types.md]]\n */\nexports.makePolylineBuilder = (0, makeShapeFitAutocorrect_1.default)((initialPoint, viewport) => {\n    // Fit to a value slightly smaller than the pixel size. A larger value can\n    // cause the stroke to appear jagged at some zoom levels.\n    const minFit = viewport.getSizeOfPixelOnCanvas() * 0.75;\n    return new PolylineBuilder(initialPoint, minFit, viewport);\n});\nclass PolylineBuilder {\n    constructor(startPoint, minFitAllowed, viewport) {\n        this.minFitAllowed = minFitAllowed;\n        this.viewport = viewport;\n        this.parts = [];\n        this.widthAverageNumSamples = 1;\n        this.lastLineSegment = null;\n        this.averageWidth = startPoint.width;\n        this.startPoint = {\n            ...startPoint,\n            pos: this.roundPoint(startPoint.pos),\n        };\n        this.lastPoint = this.startPoint.pos;\n        this.bbox = new math_1.Rect2(this.startPoint.pos.x, this.startPoint.pos.y, 0, 0);\n        this.parts = [\n            {\n                kind: math_1.PathCommandType.MoveTo,\n                point: this.startPoint.pos,\n            },\n        ];\n    }\n    getBBox() {\n        return this.bbox.grownBy(this.averageWidth);\n    }\n    getRenderingStyle() {\n        return {\n            fill: math_1.Color4.transparent,\n            stroke: {\n                color: this.startPoint.color,\n                width: this.roundDistance(this.averageWidth),\n            },\n        };\n    }\n    previewCurrentPath() {\n        const startPoint = this.startPoint.pos;\n        const commands = [...this.parts];\n        // TODO: For now, this is necesary for the path to be visible.\n        if (commands.length <= 1) {\n            commands.push({\n                kind: math_1.PathCommandType.LineTo,\n                point: startPoint.plus(math_1.Vec2.of(this.averageWidth / 4, 0)),\n            });\n        }\n        return {\n            startPoint,\n            commands,\n            style: this.getRenderingStyle(),\n        };\n    }\n    previewFullPath() {\n        return [this.previewCurrentPath()];\n    }\n    preview(renderer) {\n        const paths = this.previewFullPath();\n        if (paths) {\n            const approxBBox = this.viewport.visibleRect;\n            renderer.startObject(approxBBox);\n            for (const path of paths) {\n                renderer.drawPath(path);\n            }\n            renderer.endObject();\n        }\n    }\n    build() {\n        return new Stroke_1.default(this.previewFullPath());\n    }\n    getMinFit() {\n        let minFit = Math.min(this.minFitAllowed, this.averageWidth / 4);\n        if (minFit < 1e-10) {\n            minFit = this.minFitAllowed;\n        }\n        return minFit;\n    }\n    roundPoint(point) {\n        const minFit = this.getMinFit();\n        return Viewport_1.default.roundPoint(point, minFit);\n    }\n    roundDistance(dist) {\n        const minFit = this.getMinFit();\n        return Viewport_1.default.roundPoint(dist, minFit);\n    }\n    addPoint(newPoint) {\n        this.widthAverageNumSamples++;\n        this.averageWidth =\n            (this.averageWidth * (this.widthAverageNumSamples - 1)) / this.widthAverageNumSamples +\n                newPoint.width / this.widthAverageNumSamples;\n        const roundedPoint = this.roundPoint(newPoint.pos);\n        if (!roundedPoint.eq(this.lastPoint)) {\n            // If almost exactly in the same line as the previous\n            if (this.lastLineSegment &&\n                this.lastLineSegment.direction.dot(roundedPoint.minus(this.lastPoint).normalized()) > 0.997) {\n                this.parts.pop();\n                this.lastPoint = this.lastLineSegment.p1;\n            }\n            this.parts.push({\n                kind: math_1.PathCommandType.LineTo,\n                point: this.roundPoint(newPoint.pos),\n            });\n            this.bbox = this.bbox.grownToPoint(roundedPoint);\n            this.lastLineSegment = new math_1.LineSegment2(this.lastPoint, roundedPoint);\n            this.lastPoint = roundedPoint;\n        }\n    }\n}\nexports[\"default\"] = PolylineBuilder;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/components/builders/PolylineBuilder.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/components/builders/PressureSensitiveFreehandLineBuilder.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/components/builders/PressureSensitiveFreehandLineBuilder.js ***!
  \***************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.makePressureSensitiveFreehandLineBuilder = void 0;\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\nconst Stroke_1 = __importDefault(__webpack_require__(/*! ../Stroke */ \"./node_modules/js-draw/dist/cjs/components/Stroke.js\"));\nconst Viewport_1 = __importDefault(__webpack_require__(/*! ../../Viewport */ \"./node_modules/js-draw/dist/cjs/Viewport.js\"));\nconst StrokeSmoother_1 = __webpack_require__(/*! ../util/StrokeSmoother */ \"./node_modules/js-draw/dist/cjs/components/util/StrokeSmoother.js\");\nconst makeShapeFitAutocorrect_1 = __importDefault(__webpack_require__(/*! ./autocorrect/makeShapeFitAutocorrect */ \"./node_modules/js-draw/dist/cjs/components/builders/autocorrect/makeShapeFitAutocorrect.js\"));\nexports.makePressureSensitiveFreehandLineBuilder = (0, makeShapeFitAutocorrect_1.default)((initialPoint, viewport) => {\n    // Don't smooth if input is more than ± 3 pixels from the true curve, do smooth if\n    // less than ±1 px from the curve.\n    const maxSmoothingDist = viewport.getSizeOfPixelOnCanvas() * 3;\n    const minSmoothingDist = viewport.getSizeOfPixelOnCanvas();\n    return new PressureSensitiveFreehandLineBuilder(initialPoint, minSmoothingDist, maxSmoothingDist, viewport);\n});\n// Handles stroke smoothing and creates Strokes from user/stylus input.\nclass PressureSensitiveFreehandLineBuilder {\n    constructor(startPoint, \n    // Maximum distance from the actual curve (irrespective of stroke width)\n    // for which a point is considered 'part of the curve'.\n    // Note that the maximum will be smaller if the stroke width is less than\n    // [maxFitAllowed].\n    minFitAllowed, maxFitAllowed, viewport) {\n        this.startPoint = startPoint;\n        this.minFitAllowed = minFitAllowed;\n        this.viewport = viewport;\n        this.isFirstSegment = true;\n        this.pathStartConnector = null;\n        this.mostRecentConnector = null;\n        this.nextCurveStartConnector = null;\n        this.lastUpperBezier = null;\n        this.lastLowerBezier = null;\n        this.parts = [];\n        this.upperSegments = [];\n        this.lowerSegments = [];\n        this.curveFitter = new StrokeSmoother_1.StrokeSmoother(startPoint, minFitAllowed, maxFitAllowed, (curve) => this.addCurve(curve));\n        this.curveStartWidth = startPoint.width;\n        this.bbox = new math_1.Rect2(this.startPoint.pos.x, this.startPoint.pos.y, 0, 0);\n    }\n    getBBox() {\n        return this.bbox;\n    }\n    getRenderingStyle() {\n        return {\n            fill: this.startPoint.color ?? null,\n        };\n    }\n    previewCurrentPath(extendWithLatest = true) {\n        const upperPath = this.upperSegments.slice();\n        const lowerPath = this.lowerSegments.slice();\n        let lowerToUpperCap;\n        let pathStartConnector;\n        const currentCurve = this.curveFitter.preview();\n        if (currentCurve && extendWithLatest) {\n            const { upperCurveCommand, lowerToUpperConnector, upperToLowerConnector, lowerCurveCommand } = this.segmentToPath(currentCurve);\n            upperPath.push(upperCurveCommand);\n            lowerPath.push(lowerCurveCommand);\n            lowerToUpperCap = lowerToUpperConnector;\n            pathStartConnector = this.pathStartConnector ?? [upperToLowerConnector];\n        }\n        else {\n            if (this.mostRecentConnector === null || this.pathStartConnector === null) {\n                return null;\n            }\n            lowerToUpperCap = this.mostRecentConnector;\n            pathStartConnector = this.pathStartConnector;\n        }\n        let startPoint;\n        const lastLowerSegment = lowerPath[lowerPath.length - 1];\n        if (lastLowerSegment.kind === math_1.PathCommandType.LineTo ||\n            lastLowerSegment.kind === math_1.PathCommandType.MoveTo) {\n            startPoint = lastLowerSegment.point;\n        }\n        else {\n            startPoint = lastLowerSegment.endPoint;\n        }\n        return {\n            // Start at the end of the lower curve:\n            //    Start point\n            //     ↓\n            //  __/  __/ ← Most recent points on this end\n            // /___ /\n            //  ↑\n            //  Oldest points\n            startPoint,\n            commands: [\n                // Move to the most recent point on the upperPath:\n                //     ----→•\n                //  __/  __/\n                // /___ /\n                lowerToUpperCap,\n                // Move to the beginning of the upperPath:\n                //  __/  __/\n                // /___ /\n                //     • ←-\n                ...upperPath.reverse(),\n                // Move to the beginning of the lowerPath:\n                //  __/  __/\n                // /___ /\n                // •\n                ...pathStartConnector,\n                // Move back to the start point:\n                //     •\n                //  __/  __/\n                // /___ /\n                ...lowerPath,\n            ],\n            style: this.getRenderingStyle(),\n        };\n    }\n    previewFullPath() {\n        const preview = this.previewCurrentPath();\n        if (preview) {\n            return [...this.parts, preview];\n        }\n        return null;\n    }\n    preview(renderer) {\n        const paths = this.previewFullPath();\n        if (paths) {\n            const approxBBox = this.viewport.visibleRect;\n            renderer.startObject(approxBBox);\n            for (const path of paths) {\n                renderer.drawPath(path);\n            }\n            renderer.endObject();\n        }\n    }\n    build() {\n        this.curveFitter.finalizeCurrentCurve();\n        if (this.isFirstSegment) {\n            // Ensure we have something.\n            this.addCurve(null);\n        }\n        return new Stroke_1.default(this.previewFullPath());\n    }\n    roundPoint(point) {\n        let minFit = Math.min(this.minFitAllowed, this.curveStartWidth / 3);\n        if (minFit < 1e-10) {\n            minFit = this.minFitAllowed;\n        }\n        return Viewport_1.default.roundPoint(point, minFit);\n    }\n    // Returns true if, due to overlap with previous segments, a new RenderablePathSpec should be created.\n    shouldStartNewSegment(lowerCurve, upperCurve) {\n        if (!this.lastLowerBezier || !this.lastUpperBezier) {\n            return false;\n        }\n        const getIntersection = (curve1, curve2) => {\n            const intersections = curve1.intersectsBezier(curve2);\n            if (!intersections.length)\n                return null;\n            return intersections[0].point;\n        };\n        const getExitDirection = (curve) => {\n            return curve.p2.minus(curve.p1).normalized();\n        };\n        const getEnterDirection = (curve) => {\n            return curve.p1.minus(curve.p0).normalized();\n        };\n        // Prevent\n        //         /\n        //       / /\n        //      /  /  /|\n        //    /    /   |\n        //  /          |\n        // where the next stroke and the previous stroke are in different directions.\n        //\n        // Are the exit/enter directions of the previous and current curves in different enough directions?\n        if (getEnterDirection(upperCurve).dot(getExitDirection(this.lastUpperBezier)) < 0.35 ||\n            getEnterDirection(lowerCurve).dot(getExitDirection(this.lastLowerBezier)) < 0.35 ||\n            // Also handle if the curves exit/enter directions differ\n            getEnterDirection(upperCurve).dot(getExitDirection(upperCurve)) < 0 ||\n            getEnterDirection(lowerCurve).dot(getExitDirection(lowerCurve)) < 0) {\n            return true;\n        }\n        // Check whether the lower curve intersects the other wall:\n        //       /    / ← lower\n        //    / /   /\n        // /   / /\n        //   //\n        // / /\n        const lowerIntersection = getIntersection(lowerCurve, this.lastUpperBezier);\n        const upperIntersection = getIntersection(upperCurve, this.lastLowerBezier);\n        if (lowerIntersection || upperIntersection) {\n            return true;\n        }\n        return false;\n    }\n    addCurve(curve) {\n        // Case where no points have been added\n        if (!curve) {\n            // Don't create a circle around the initial point if the stroke has more than one point.\n            if (!this.isFirstSegment) {\n                return;\n            }\n            const width = Viewport_1.default.roundPoint(this.startPoint.width / 2.2, Math.min(this.minFitAllowed, this.startPoint.width / 4));\n            const center = this.roundPoint(this.startPoint.pos);\n            // Start on the right, cycle clockwise:\n            //    |\n            //  ----- ←\n            //    |\n            const startPoint = this.startPoint.pos.plus(math_1.Vec2.of(width, 0));\n            // Draw a circle-ish shape around the start point\n            this.lowerSegments.push({\n                kind: math_1.PathCommandType.QuadraticBezierTo,\n                controlPoint: center.plus(math_1.Vec2.of(width, width)),\n                // Bottom of the circle\n                //    |\n                //  -----\n                //    |\n                //    ↑\n                endPoint: center.plus(math_1.Vec2.of(0, width)),\n            }, {\n                kind: math_1.PathCommandType.QuadraticBezierTo,\n                controlPoint: center.plus(math_1.Vec2.of(-width, width)),\n                endPoint: center.plus(math_1.Vec2.of(-width, 0)),\n            }, {\n                kind: math_1.PathCommandType.QuadraticBezierTo,\n                controlPoint: center.plus(math_1.Vec2.of(-width, -width)),\n                endPoint: center.plus(math_1.Vec2.of(0, -width)),\n            }, {\n                kind: math_1.PathCommandType.QuadraticBezierTo,\n                controlPoint: center.plus(math_1.Vec2.of(width, -width)),\n                endPoint: center.plus(math_1.Vec2.of(width, 0)),\n            });\n            const connector = {\n                kind: math_1.PathCommandType.LineTo,\n                point: startPoint,\n            };\n            this.pathStartConnector = [connector];\n            this.mostRecentConnector = connector;\n            return;\n        }\n        const { upperCurveCommand, lowerToUpperConnector, upperToLowerConnector, lowerCurveCommand, lowerCurve, upperCurve, nextCurveStartConnector, } = this.segmentToPath(curve);\n        let shouldStartNew = this.shouldStartNewSegment(lowerCurve, upperCurve);\n        if (shouldStartNew) {\n            const part = this.previewCurrentPath(false);\n            if (part) {\n                this.parts.push(part);\n                this.upperSegments = [];\n                this.lowerSegments = [];\n            }\n            else {\n                shouldStartNew = false;\n            }\n        }\n        if (this.isFirstSegment || shouldStartNew) {\n            // We draw the upper path (reversed), then the lower path, so we need the\n            // upperToLowerConnector to join the two paths.\n            this.pathStartConnector = this.nextCurveStartConnector ?? [upperToLowerConnector];\n            this.isFirstSegment = false;\n        }\n        // With the most recent connector, we're joining the end of the lowerPath to the most recent\n        // upperPath:\n        this.mostRecentConnector = lowerToUpperConnector;\n        this.nextCurveStartConnector = nextCurveStartConnector;\n        this.lowerSegments.push(lowerCurveCommand);\n        this.upperSegments.push(upperCurveCommand);\n        this.lastLowerBezier = lowerCurve;\n        this.lastUpperBezier = upperCurve;\n        this.curveStartWidth = curve.startWidth;\n    }\n    // Returns [upper curve, connector, lower curve]\n    segmentToPath(curve) {\n        const bezier = new math_1.QuadraticBezier(curve.startPoint, curve.controlPoint, curve.endPoint);\n        let startVec = bezier.normal(0);\n        let endVec = bezier.normal(1);\n        startVec = startVec.times(curve.startWidth / 2);\n        endVec = endVec.times(curve.endWidth / 2);\n        if (!isFinite(startVec.magnitude())) {\n            console.error('Warning: startVec is NaN or ∞', startVec, endVec, curve);\n            startVec = endVec;\n        }\n        const startPt = curve.startPoint;\n        const endPt = curve.endPoint;\n        const controlPoint = curve.controlPoint;\n        // Approximate the normal at the location of the control point\n        const projectionT = bezier.nearestPointTo(controlPoint).parameterValue;\n        const halfVecT = projectionT;\n        const halfVec = bezier\n            .normal(halfVecT)\n            .times((curve.startWidth / 2) * halfVecT + (curve.endWidth / 2) * (1 - halfVecT));\n        // Each starts at startPt ± startVec\n        const lowerCurveStartPoint = this.roundPoint(startPt.plus(startVec));\n        const lowerCurveControlPoint = this.roundPoint(controlPoint.plus(halfVec));\n        const lowerCurveEndPoint = this.roundPoint(endPt.plus(endVec));\n        const upperCurveControlPoint = this.roundPoint(controlPoint.minus(halfVec));\n        const upperCurveStartPoint = this.roundPoint(endPt.minus(endVec));\n        const upperCurveEndPoint = this.roundPoint(startPt.minus(startVec));\n        const lowerCurveCommand = {\n            kind: math_1.PathCommandType.QuadraticBezierTo,\n            controlPoint: lowerCurveControlPoint,\n            endPoint: lowerCurveEndPoint,\n        };\n        // From the end of the upperCurve to the start of the lowerCurve:\n        const upperToLowerConnector = {\n            kind: math_1.PathCommandType.LineTo,\n            point: lowerCurveStartPoint,\n        };\n        // From the end of lowerCurve to the start of upperCurve:\n        const lowerToUpperConnector = {\n            kind: math_1.PathCommandType.LineTo,\n            point: upperCurveStartPoint,\n        };\n        // The segment to be used to start the next path (to insert to connect the start of its\n        // lower and the end of its upper).\n        const nextCurveStartConnector = [\n            {\n                kind: math_1.PathCommandType.LineTo,\n                point: upperCurveStartPoint,\n            },\n            {\n                kind: math_1.PathCommandType.LineTo,\n                point: lowerCurveEndPoint,\n            },\n        ];\n        const upperCurveCommand = {\n            kind: math_1.PathCommandType.QuadraticBezierTo,\n            controlPoint: upperCurveControlPoint,\n            endPoint: upperCurveEndPoint,\n        };\n        const upperCurve = new math_1.QuadraticBezier(upperCurveStartPoint, upperCurveControlPoint, upperCurveEndPoint);\n        const lowerCurve = new math_1.QuadraticBezier(lowerCurveStartPoint, lowerCurveControlPoint, lowerCurveEndPoint);\n        return {\n            upperCurveCommand,\n            upperToLowerConnector,\n            lowerToUpperConnector,\n            lowerCurveCommand,\n            upperCurve,\n            lowerCurve,\n            nextCurveStartConnector,\n        };\n    }\n    addPoint(newPoint) {\n        this.curveFitter.addPoint(newPoint);\n    }\n}\nexports[\"default\"] = PressureSensitiveFreehandLineBuilder;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/components/builders/PressureSensitiveFreehandLineBuilder.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/components/builders/RectangleBuilder.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/components/builders/RectangleBuilder.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.makeOutlinedRectangleBuilder = exports.makeFilledRectangleBuilder = void 0;\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\nconst RenderablePathSpec_1 = __webpack_require__(/*! ../../rendering/RenderablePathSpec */ \"./node_modules/js-draw/dist/cjs/rendering/RenderablePathSpec.js\");\nconst Stroke_1 = __importDefault(__webpack_require__(/*! ../Stroke */ \"./node_modules/js-draw/dist/cjs/components/Stroke.js\"));\nconst makeSnapToGridAutocorrect_1 = __importDefault(__webpack_require__(/*! ./autocorrect/makeSnapToGridAutocorrect */ \"./node_modules/js-draw/dist/cjs/components/builders/autocorrect/makeSnapToGridAutocorrect.js\"));\n/**\n * Creates filled rectangles with sharp corners.\n *\n * Example:\n * [[include:doc-pages/inline-examples/changing-pen-types.md]]\n */\nexports.makeFilledRectangleBuilder = (0, makeSnapToGridAutocorrect_1.default)((initialPoint, viewport) => {\n    return new RectangleBuilder(initialPoint, true, viewport);\n});\n/**\n * Creates outlined rectangles with sharp corners.\n *\n * Example:\n * [[include:doc-pages/inline-examples/changing-pen-types.md]]\n */\nexports.makeOutlinedRectangleBuilder = (0, makeSnapToGridAutocorrect_1.default)((initialPoint, viewport) => {\n    return new RectangleBuilder(initialPoint, false, viewport);\n});\nclass RectangleBuilder {\n    constructor(startPoint, filled, viewport) {\n        this.startPoint = startPoint;\n        this.filled = filled;\n        this.viewport = viewport;\n        // Initially, the start and end points are the same.\n        this.endPoint = startPoint;\n    }\n    getBBox() {\n        const preview = this.buildPreview();\n        return preview.getBBox();\n    }\n    buildPreview() {\n        const canvasAngle = this.viewport.getRotationAngle();\n        const rotationMat = math_1.Mat33.zRotation(-canvasAngle);\n        // Adjust startPoint and endPoint such that applying [rotationMat] to them\n        // brings them to this.startPoint and this.endPoint.\n        const startPoint = rotationMat.inverse().transformVec2(this.startPoint.pos);\n        const endPoint = rotationMat.inverse().transformVec2(this.endPoint.pos);\n        const rect = math_1.Rect2.fromCorners(startPoint, endPoint);\n        const path = math_1.Path.fromRect(rect, this.filled ? null : this.endPoint.width)\n            .transformedBy(\n        // Rotate the canvas rectangle so that its rotation matches the screen\n        rotationMat)\n            .mapPoints((point) => this.viewport.roundPoint(point));\n        const preview = new Stroke_1.default([\n            (0, RenderablePathSpec_1.pathToRenderable)(path, {\n                fill: this.endPoint.color,\n            }),\n        ]);\n        return preview;\n    }\n    build() {\n        return this.buildPreview();\n    }\n    preview(renderer) {\n        this.buildPreview().render(renderer);\n    }\n    addPoint(point) {\n        this.endPoint = point;\n    }\n}\nexports[\"default\"] = RectangleBuilder;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/components/builders/RectangleBuilder.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/components/builders/autocorrect/makeShapeFitAutocorrect.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/components/builders/autocorrect/makeShapeFitAutocorrect.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\nconst makeShapeFitAutocorrect = (sourceFactory) => {\n    return (startPoint, viewport) => {\n        return new ShapeFitBuilder(sourceFactory, startPoint, viewport);\n    };\n};\nexports[\"default\"] = makeShapeFitAutocorrect;\nconst makeLineTemplate = (startPoint, points, _bbox) => {\n    const templatePoints = [startPoint, points[points.length - 1]];\n    return { points: templatePoints };\n};\nconst makeRectangleTemplate = (_startPoint, _points, bbox) => {\n    return { points: [...bbox.corners, bbox.corners[0]] };\n};\nclass ShapeFitBuilder {\n    constructor(sourceFactory, startPoint, viewport) {\n        this.sourceFactory = sourceFactory;\n        this.startPoint = startPoint;\n        this.viewport = viewport;\n        this.builder = sourceFactory(startPoint, viewport);\n        this.points = [startPoint];\n    }\n    getBBox() {\n        return this.builder.getBBox();\n    }\n    build() {\n        return this.builder.build();\n    }\n    preview(renderer) {\n        this.builder.preview(renderer);\n    }\n    addPoint(point) {\n        this.points.push(point);\n        this.builder.addPoint(point);\n    }\n    async autocorrectShape() {\n        // Use screen points so that autocorrected shapes rotate with the screen.\n        const startPoint = this.viewport.canvasToScreen(this.startPoint.pos);\n        const points = this.points.map((point) => this.viewport.canvasToScreen(point.pos));\n        const bbox = math_1.Rect2.bboxOf(points);\n        const snappedStartPoint = this.viewport.canvasToScreen(this.viewport.snapToGrid(this.startPoint.pos));\n        const snappedPoints = this.points.map((point) => this.viewport.canvasToScreen(this.viewport.snapToGrid(point.pos)));\n        const snappedBBox = math_1.Rect2.bboxOf(snappedPoints);\n        // Only fit larger shapes\n        if (bbox.maxDimension < 32) {\n            return null;\n        }\n        const maxError = Math.min(30, bbox.maxDimension / 4);\n        // Create templates\n        const templates = [\n            {\n                ...makeLineTemplate(snappedStartPoint, snappedPoints, snappedBBox),\n                toleranceMultiplier: 0.5,\n            },\n            makeLineTemplate(startPoint, points, bbox),\n            {\n                ...makeRectangleTemplate(snappedStartPoint, snappedPoints, snappedBBox),\n                toleranceMultiplier: 0.6,\n            },\n            makeRectangleTemplate(startPoint, points, bbox),\n        ];\n        // Find a good fit fit\n        const selectTemplate = (maximumAllowedError) => {\n            for (const template of templates) {\n                const templatePoints = template.points;\n                // Maximum square error to accept the template\n                const acceptMaximumSquareError = maximumAllowedError * maximumAllowedError * (template.toleranceMultiplier ?? 1);\n                // Gets the point at index, wrapping the the start of the template if\n                // outside the array of points.\n                const templateAt = (index) => {\n                    while (index < 0) {\n                        index += templatePoints.length;\n                    }\n                    index %= templatePoints.length;\n                    return templatePoints[index];\n                };\n                let closestToFirst = null;\n                let closestToFirstSqrDist = Infinity;\n                let templateStartIndex = 0;\n                // Find the closest point to the startPoint\n                for (let i = 0; i < templatePoints.length; i++) {\n                    const current = templatePoints[i];\n                    const currentSqrDist = current.squareDistanceTo(startPoint);\n                    if (!closestToFirst || currentSqrDist < closestToFirstSqrDist) {\n                        closestToFirstSqrDist = currentSqrDist;\n                        closestToFirst = current;\n                        templateStartIndex = i;\n                    }\n                }\n                // Walk through the points and find the maximum error\n                let maximumSqrError = 0;\n                let templateIndex = templateStartIndex;\n                for (const point of points) {\n                    let minimumCurrentSqrError = Infinity;\n                    let minimumErrorAtIndex = templateIndex;\n                    const windowRadius = 6;\n                    for (let i = -windowRadius; i <= windowRadius; i++) {\n                        const index = templateIndex + i;\n                        const prevTemplatePoint = templateAt(index - 1);\n                        const currentTemplatePoint = templateAt(index);\n                        const nextTemplatePoint = templateAt(index + 1);\n                        const prevToCurrent = new math_1.LineSegment2(prevTemplatePoint, currentTemplatePoint);\n                        const currentToNext = new math_1.LineSegment2(currentTemplatePoint, nextTemplatePoint);\n                        const prevToCurrentDist = prevToCurrent.distance(point);\n                        const nextToCurrentDist = currentToNext.distance(point);\n                        const error = Math.min(prevToCurrentDist, nextToCurrentDist);\n                        const squareError = error * error;\n                        if (squareError < minimumCurrentSqrError) {\n                            minimumCurrentSqrError = squareError;\n                            minimumErrorAtIndex = index;\n                        }\n                    }\n                    templateIndex = minimumErrorAtIndex;\n                    maximumSqrError = Math.max(minimumCurrentSqrError, maximumSqrError);\n                    if (maximumSqrError > acceptMaximumSquareError) {\n                        break;\n                    }\n                }\n                if (maximumSqrError < acceptMaximumSquareError) {\n                    return templatePoints;\n                }\n            }\n            return null;\n        };\n        const template = selectTemplate(maxError);\n        if (!template) {\n            return null;\n        }\n        const lastDataPoint = this.points[this.points.length - 1];\n        const startWidth = this.startPoint.width;\n        const endWidth = lastDataPoint.width;\n        const startColor = this.startPoint.color;\n        const endColor = lastDataPoint.color;\n        const startTime = this.startPoint.time;\n        const endTime = lastDataPoint.time;\n        const templateIndexToStrokeDataPoint = (index) => {\n            const prevPoint = template[Math.max(0, Math.floor(index))];\n            const nextPoint = template[Math.min(Math.ceil(index), template.length - 1)];\n            const point = prevPoint.lerp(nextPoint, index - Math.floor(index));\n            const fractionToEnd = index / template.length;\n            return {\n                pos: this.viewport.screenToCanvas(point),\n                width: startWidth * (1 - fractionToEnd) + endWidth * fractionToEnd,\n                color: startColor.mix(endColor, fractionToEnd),\n                time: startTime * (1 - fractionToEnd) + endTime * fractionToEnd,\n            };\n        };\n        const builder = this.sourceFactory(templateIndexToStrokeDataPoint(0), this.viewport);\n        // Prevent the original builder from doing stroke smoothing if the template is short\n        // enough to likely have sharp corners.\n        const preventSmoothing = template.length < 10;\n        for (let i = 0; i < template.length; i++) {\n            if (preventSmoothing) {\n                builder.addPoint(templateIndexToStrokeDataPoint(i - 0.001));\n            }\n            builder.addPoint(templateIndexToStrokeDataPoint(i));\n            if (preventSmoothing) {\n                builder.addPoint(templateIndexToStrokeDataPoint(i + 0.001));\n            }\n        }\n        return builder.build();\n    }\n}\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/components/builders/autocorrect/makeShapeFitAutocorrect.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/components/builders/autocorrect/makeSnapToGridAutocorrect.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/components/builders/autocorrect/makeSnapToGridAutocorrect.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst makeSnapToGridAutocorrect = (sourceFactory) => {\n    return (startPoint, viewport) => {\n        return new SnapToGridAutocompleteBuilder(sourceFactory, startPoint, viewport);\n    };\n};\nexports[\"default\"] = makeSnapToGridAutocorrect;\nclass SnapToGridAutocompleteBuilder {\n    constructor(sourceFactory, startPoint, viewport) {\n        this.sourceFactory = sourceFactory;\n        this.startPoint = startPoint;\n        this.viewport = viewport;\n        this.builder = sourceFactory(startPoint, viewport);\n        this.points = [startPoint];\n    }\n    getBBox() {\n        return this.builder.getBBox();\n    }\n    build() {\n        return this.builder.build();\n    }\n    preview(renderer) {\n        this.builder.preview(renderer);\n    }\n    addPoint(point) {\n        this.points.push(point);\n        this.builder.addPoint(point);\n    }\n    async autocorrectShape() {\n        const snapToGrid = (point) => {\n            return {\n                ...point,\n                pos: this.viewport.snapToGrid(point.pos),\n            };\n        };\n        // Use screen points so that snapped shapes rotate with the screen.\n        const startPoint = snapToGrid(this.startPoint);\n        const builder = this.sourceFactory(startPoint, this.viewport);\n        const points = this.points.map((point) => snapToGrid(point));\n        for (const point of points) {\n            builder.addPoint(point);\n        }\n        return builder.build();\n    }\n}\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/components/builders/autocorrect/makeSnapToGridAutocorrect.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/components/builders/lib.js":
/*!******************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/components/builders/lib.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.makeOutlinedRectangleBuilder = exports.makeFilledRectangleBuilder = exports.makeLineBuilder = exports.makeArrowBuilder = exports.makeOutlinedCircleBuilder = exports.makePressureSensitiveFreehandLineBuilder = exports.makePolylineBuilder = exports.makeFreehandLineBuilder = void 0;\nvar FreehandLineBuilder_1 = __webpack_require__(/*! ./FreehandLineBuilder */ \"./node_modules/js-draw/dist/cjs/components/builders/FreehandLineBuilder.js\");\nObject.defineProperty(exports, \"makeFreehandLineBuilder\", ({ enumerable: true, get: function () { return FreehandLineBuilder_1.makeFreehandLineBuilder; } }));\nvar PolylineBuilder_1 = __webpack_require__(/*! ./PolylineBuilder */ \"./node_modules/js-draw/dist/cjs/components/builders/PolylineBuilder.js\");\nObject.defineProperty(exports, \"makePolylineBuilder\", ({ enumerable: true, get: function () { return PolylineBuilder_1.makePolylineBuilder; } }));\nvar PressureSensitiveFreehandLineBuilder_1 = __webpack_require__(/*! ./PressureSensitiveFreehandLineBuilder */ \"./node_modules/js-draw/dist/cjs/components/builders/PressureSensitiveFreehandLineBuilder.js\");\nObject.defineProperty(exports, \"makePressureSensitiveFreehandLineBuilder\", ({ enumerable: true, get: function () { return PressureSensitiveFreehandLineBuilder_1.makePressureSensitiveFreehandLineBuilder; } }));\nvar CircleBuilder_1 = __webpack_require__(/*! ./CircleBuilder */ \"./node_modules/js-draw/dist/cjs/components/builders/CircleBuilder.js\");\nObject.defineProperty(exports, \"makeOutlinedCircleBuilder\", ({ enumerable: true, get: function () { return CircleBuilder_1.makeOutlinedCircleBuilder; } }));\nvar ArrowBuilder_1 = __webpack_require__(/*! ./ArrowBuilder */ \"./node_modules/js-draw/dist/cjs/components/builders/ArrowBuilder.js\");\nObject.defineProperty(exports, \"makeArrowBuilder\", ({ enumerable: true, get: function () { return ArrowBuilder_1.makeArrowBuilder; } }));\nvar LineBuilder_1 = __webpack_require__(/*! ./LineBuilder */ \"./node_modules/js-draw/dist/cjs/components/builders/LineBuilder.js\");\nObject.defineProperty(exports, \"makeLineBuilder\", ({ enumerable: true, get: function () { return LineBuilder_1.makeLineBuilder; } }));\nvar RectangleBuilder_1 = __webpack_require__(/*! ./RectangleBuilder */ \"./node_modules/js-draw/dist/cjs/components/builders/RectangleBuilder.js\");\nObject.defineProperty(exports, \"makeFilledRectangleBuilder\", ({ enumerable: true, get: function () { return RectangleBuilder_1.makeFilledRectangleBuilder; } }));\nObject.defineProperty(exports, \"makeOutlinedRectangleBuilder\", ({ enumerable: true, get: function () { return RectangleBuilder_1.makeOutlinedRectangleBuilder; } }));\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/components/builders/lib.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/components/builders/types.js":
/*!********************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/components/builders/types.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/components/builders/types.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/components/lib.js":
/*!*********************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/components/lib.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ImageComponent = exports.BackgroundComponentBackgroundType = exports.BackgroundComponent = exports.StrokeComponent = exports.Text = exports.TextComponent = exports.isRestylableComponent = exports.createRestyleComponentCommand = exports.Stroke = exports.AbstractComponent = exports.StrokeSmoother = void 0;\n__exportStar(__webpack_require__(/*! ./builders/types */ \"./node_modules/js-draw/dist/cjs/components/builders/types.js\"), exports);\n__exportStar(__webpack_require__(/*! ./builders/lib */ \"./node_modules/js-draw/dist/cjs/components/builders/lib.js\"), exports);\nvar StrokeSmoother_1 = __webpack_require__(/*! ./util/StrokeSmoother */ \"./node_modules/js-draw/dist/cjs/components/util/StrokeSmoother.js\");\nObject.defineProperty(exports, \"StrokeSmoother\", ({ enumerable: true, get: function () { return __importDefault(StrokeSmoother_1).default; } }));\n__exportStar(__webpack_require__(/*! ./AbstractComponent */ \"./node_modules/js-draw/dist/cjs/components/AbstractComponent.js\"), exports);\nvar AbstractComponent_1 = __webpack_require__(/*! ./AbstractComponent */ \"./node_modules/js-draw/dist/cjs/components/AbstractComponent.js\");\nObject.defineProperty(exports, \"AbstractComponent\", ({ enumerable: true, get: function () { return __importDefault(AbstractComponent_1).default; } }));\nconst Stroke_1 = __importDefault(__webpack_require__(/*! ./Stroke */ \"./node_modules/js-draw/dist/cjs/components/Stroke.js\"));\nexports.Stroke = Stroke_1.default;\nexports.StrokeComponent = Stroke_1.default;\nconst TextComponent_1 = __importDefault(__webpack_require__(/*! ./TextComponent */ \"./node_modules/js-draw/dist/cjs/components/TextComponent.js\"));\nexports.TextComponent = TextComponent_1.default;\nexports.Text = TextComponent_1.default;\nconst ImageComponent_1 = __importDefault(__webpack_require__(/*! ./ImageComponent */ \"./node_modules/js-draw/dist/cjs/components/ImageComponent.js\"));\nexports.ImageComponent = ImageComponent_1.default;\nconst RestylableComponent_1 = __webpack_require__(/*! ./RestylableComponent */ \"./node_modules/js-draw/dist/cjs/components/RestylableComponent.js\");\nObject.defineProperty(exports, \"createRestyleComponentCommand\", ({ enumerable: true, get: function () { return RestylableComponent_1.createRestyleComponentCommand; } }));\nObject.defineProperty(exports, \"isRestylableComponent\", ({ enumerable: true, get: function () { return RestylableComponent_1.isRestylableComponent; } }));\nconst BackgroundComponent_1 = __importStar(__webpack_require__(/*! ./BackgroundComponent */ \"./node_modules/js-draw/dist/cjs/components/BackgroundComponent.js\"));\nexports.BackgroundComponent = BackgroundComponent_1.default;\nObject.defineProperty(exports, \"BackgroundComponentBackgroundType\", ({ enumerable: true, get: function () { return BackgroundComponent_1.BackgroundType; } }));\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/components/lib.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/components/localization.js":
/*!******************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/components/localization.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.defaultComponentLocalization = void 0;\nexports.defaultComponentLocalization = {\n    unlabeledImageNode: 'Unlabeled image node',\n    stroke: 'Stroke',\n    svgObject: 'SVG Object',\n    emptyBackground: 'Empty background',\n    gridBackground: 'Grid background',\n    filledBackgroundWithColor: (color) => `Filled background (${color})`,\n    text: (text) => `Text object: ${text}`,\n    imageNode: (description) => `Image: ${description}`,\n    restyledElement: (elementDescription) => `Restyled ${elementDescription}`,\n};\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/components/localization.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/components/util/StrokeSmoother.js":
/*!*************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/components/util/StrokeSmoother.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.StrokeSmoother = void 0;\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\n// Handles stroke smoothing\nclass StrokeSmoother {\n    constructor(startPoint, \n    // Maximum distance from the actual curve (irrespective of stroke width)\n    // for which a point is considered 'part of the curve'.\n    // Note that the maximum will be smaller if the stroke width is less than\n    // [maxFitAllowed].\n    minFitAllowed, maxFitAllowed, onCurveAdded) {\n        this.startPoint = startPoint;\n        this.minFitAllowed = minFitAllowed;\n        this.maxFitAllowed = maxFitAllowed;\n        this.onCurveAdded = onCurveAdded;\n        this.isFirstSegment = true;\n        this.lastExitingVec = null;\n        this.currentCurve = null;\n        this.lastPoint = this.startPoint;\n        this.buffer = [this.startPoint.pos];\n        this.momentum = math_1.Vec2.zero;\n        this.currentCurve = null;\n        this.curveStartWidth = startPoint.width;\n        this.bbox = new math_1.Rect2(this.startPoint.pos.x, this.startPoint.pos.y, 0, 0);\n    }\n    getBBox() {\n        return this.bbox;\n    }\n    preview() {\n        if (!this.currentCurve) {\n            return null;\n        }\n        return this.currentSegmentToPath();\n    }\n    // Returns the distance between the start, control, and end points of the curve.\n    approxCurrentCurveLength() {\n        if (!this.currentCurve) {\n            return 0;\n        }\n        const startPt = this.currentCurve.p0;\n        const controlPt = this.currentCurve.p1;\n        const endPt = this.currentCurve.p2;\n        const toControlDist = startPt.distanceTo(controlPt);\n        const toEndDist = endPt.distanceTo(controlPt);\n        return toControlDist + toEndDist;\n    }\n    finalizeCurrentCurve() {\n        // Case where no points have been added\n        if (!this.currentCurve) {\n            return;\n        }\n        this.onCurveAdded(this.currentSegmentToPath());\n        const lastPoint = this.buffer[this.buffer.length - 1];\n        this.lastExitingVec = this.currentCurve.p2.minus(this.currentCurve.p1);\n        console.assert(this.lastExitingVec.magnitude() !== 0, 'lastExitingVec has zero length!');\n        // Use the last two points to start a new curve (the last point isn't used\n        // in the current curve and we want connected curves to share end points)\n        this.buffer = [this.buffer[this.buffer.length - 2], lastPoint];\n        this.currentCurve = null;\n        this.isFirstSegment = false;\n    }\n    // Returns [upper curve, connector, lower curve]\n    currentSegmentToPath() {\n        if (this.currentCurve == null) {\n            throw new Error('Invalid State: currentCurve is null!');\n        }\n        const startVec = this.currentCurve.normal(0).normalized();\n        if (!isFinite(startVec.magnitude())) {\n            throw new Error(`startVec(${startVec}) is NaN or ∞`);\n        }\n        const startPt = this.currentCurve.at(0);\n        const endPt = this.currentCurve.at(1);\n        const controlPoint = this.currentCurve.p1;\n        return {\n            startPoint: startPt,\n            controlPoint,\n            endPoint: endPt,\n            startWidth: this.curveStartWidth,\n            endWidth: this.curveEndWidth,\n        };\n    }\n    // Compute the direction of the velocity at the end of this.buffer\n    computeExitingVec() {\n        return this.momentum.normalized().times(this.lastPoint.width / 2);\n    }\n    addPoint(newPoint) {\n        if (this.lastPoint) {\n            // Ignore points that are identical\n            const fuzzEq = 1e-10;\n            const deltaTime = newPoint.time - this.lastPoint.time;\n            if (newPoint.pos.eq(this.lastPoint.pos, fuzzEq) || deltaTime === 0) {\n                return;\n            }\n            else if (isNaN(newPoint.pos.magnitude())) {\n                console.warn('Discarding NaN point.', newPoint);\n                return;\n            }\n            const threshold = Math.min(this.lastPoint.width, newPoint.width) / 3;\n            const shouldSnapToInitial = this.startPoint.pos.distanceTo(newPoint.pos) < threshold && this.isFirstSegment;\n            // Snap to the starting point if the stroke is contained within a small ball centered\n            // at the starting point.\n            // This allows us to create a circle/dot at the start of the stroke.\n            if (shouldSnapToInitial) {\n                return;\n            }\n            const deltaTimeSeconds = deltaTime / 1000;\n            const velocity = newPoint.pos.minus(this.lastPoint.pos).times(1 / deltaTimeSeconds);\n            // TODO: Do we need momentum smoothing? (this.momentum.lerp(velocity, 0.9);)\n            this.momentum = velocity;\n        }\n        const lastPoint = this.lastPoint ?? newPoint;\n        this.lastPoint = newPoint;\n        this.buffer.push(newPoint.pos);\n        const pointRadius = newPoint.width;\n        const prevEndWidth = this.curveEndWidth;\n        this.curveEndWidth = pointRadius;\n        // recompute bbox\n        this.bbox = this.bbox.grownToPoint(newPoint.pos, pointRadius);\n        // If the last curve just ended or it's the first curve,\n        if (this.currentCurve === null) {\n            const p1 = lastPoint.pos;\n            const p2 = lastPoint.pos.plus(this.lastExitingVec ?? math_1.Vec2.unitX);\n            const p3 = newPoint.pos;\n            // Quadratic Bézier curve\n            this.currentCurve = new math_1.QuadraticBezier(p1, p2, p3);\n            console.assert(!isNaN(p1.magnitude()) && !isNaN(p2.magnitude()) && !isNaN(p3.magnitude()), 'Expected !NaN');\n            if (this.isFirstSegment) {\n                // The start of a curve often lacks accurate pressure information. Update it.\n                this.curveStartWidth = (this.curveStartWidth + pointRadius) / 2;\n            }\n            else {\n                this.curveStartWidth = prevEndWidth;\n            }\n        }\n        // If there isn't an entering vector (e.g. because this.isFirstCurve), approximate it.\n        let enteringVec = this.lastExitingVec;\n        if (!enteringVec) {\n            let sampleIdx = Math.ceil(this.buffer.length / 2);\n            if (sampleIdx === 0 || sampleIdx >= this.buffer.length) {\n                sampleIdx = this.buffer.length - 1;\n            }\n            enteringVec = this.buffer[sampleIdx].minus(this.buffer[0]);\n        }\n        let exitingVec = this.computeExitingVec();\n        // Find the intersection between the entering vector and the exiting vector\n        const maxRelativeLength = 1.7;\n        const segmentStart = this.buffer[0];\n        const segmentEnd = newPoint.pos;\n        const startEndDist = segmentEnd.distanceTo(segmentStart);\n        const maxControlPointDist = maxRelativeLength * startEndDist;\n        // Exit in cases where we would divide by zero\n        if (maxControlPointDist === 0 ||\n            exitingVec.magnitude() === 0 ||\n            !isFinite(exitingVec.magnitude())) {\n            return;\n        }\n        console.assert(isFinite(enteringVec.magnitude()), 'Pre-normalized enteringVec has NaN or ∞ magnitude!');\n        enteringVec = enteringVec.normalized();\n        exitingVec = exitingVec.normalized();\n        console.assert(isFinite(enteringVec.magnitude()), 'Normalized enteringVec has NaN or ∞ magnitude!');\n        const lineFromStart = new math_1.LineSegment2(segmentStart, segmentStart.plus(enteringVec.times(maxControlPointDist)));\n        const lineFromEnd = new math_1.LineSegment2(segmentEnd.minus(exitingVec.times(maxControlPointDist)), segmentEnd);\n        const intersection = lineFromEnd.intersection(lineFromStart);\n        // Position the control point at this intersection\n        let controlPoint = null;\n        if (intersection) {\n            controlPoint = intersection.point;\n        }\n        // No intersection?\n        if (!controlPoint) {\n            // Estimate the control point position based on the entering tangent line\n            controlPoint = segmentStart\n                .lerp(segmentEnd, 0.5)\n                .lerp(segmentStart.plus(enteringVec.times(startEndDist)), 0.1);\n        }\n        // Equal to an endpoint?\n        if (segmentStart.eq(controlPoint) || segmentEnd.eq(controlPoint)) {\n            // Position the control point closer to the first -- the connecting\n            // segment will be roughly a line.\n            controlPoint = segmentStart.plus(enteringVec.times(startEndDist / 5));\n        }\n        console.assert(!segmentStart.eq(controlPoint, 1e-11), 'Start and control points are equal!');\n        console.assert(!controlPoint.eq(segmentEnd, 1e-11), 'Control and end points are equal!');\n        const prevCurve = this.currentCurve;\n        this.currentCurve = new math_1.QuadraticBezier(segmentStart, controlPoint, segmentEnd);\n        if (isNaN(this.currentCurve.normal(0).magnitude())) {\n            console.error('NaN normal at 0. Curve:', this.currentCurve);\n            this.currentCurve = prevCurve;\n        }\n        // Should we start making a new curve? Check whether all buffer points are within\n        // ±strokeWidth of the curve.\n        const curveMatchesPoints = (curve) => {\n            const minFit = Math.min(Math.max(Math.min(this.curveStartWidth, this.curveEndWidth) / 4, this.minFitAllowed), this.maxFitAllowed);\n            // The sum of distances greater than minFit must not exceed this:\n            const maxNonMatchingDistSum = minFit;\n            // Sum of distances greater than minFit.\n            let nonMatchingDistSum = 0;\n            for (const point of this.buffer) {\n                let dist = curve.approximateDistance(point);\n                if (dist > minFit) {\n                    // Use the more accurate distance function\n                    dist = curve.distance(point);\n                    nonMatchingDistSum += Math.max(0, dist - minFit);\n                    if (nonMatchingDistSum > maxNonMatchingDistSum) {\n                        return false; // false: Curve doesn't match points well enough.\n                    }\n                }\n            }\n            return true;\n        };\n        if (this.buffer.length > 3 && this.approxCurrentCurveLength() > this.curveStartWidth / 2) {\n            if (!curveMatchesPoints(this.currentCurve)) {\n                // Use a curve that better fits the points\n                this.currentCurve = prevCurve;\n                this.curveEndWidth = prevEndWidth;\n                // Reset the last point -- the current point was not added to the curve.\n                this.lastPoint = lastPoint;\n                this.finalizeCurrentCurve();\n                return;\n            }\n        }\n    }\n}\nexports.StrokeSmoother = StrokeSmoother;\nexports[\"default\"] = StrokeSmoother;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/components/util/StrokeSmoother.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/components/util/describeComponentList.js":
/*!********************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/components/util/describeComponentList.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// Returns the description of all given elements, if identical, otherwise,\n// returns null.\nexports[\"default\"] = (localizationTable, elems) => {\n    if (elems.length === 0) {\n        return null;\n    }\n    const description = elems[0].description(localizationTable);\n    for (const elem of elems) {\n        if (elem.description(localizationTable) !== description) {\n            return null;\n        }\n    }\n    return description;\n};\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/components/util/describeComponentList.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/dialogs/makeAboutDialog.js":
/*!******************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/dialogs/makeAboutDialog.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst makeMessageDialog_1 = __importDefault(__webpack_require__(/*! ./makeMessageDialog */ \"./node_modules/js-draw/dist/cjs/dialogs/makeMessageDialog.js\"));\nconst makeAboutDialog = (editor, entries) => {\n    const dialog = (0, makeMessageDialog_1.default)(editor, {\n        title: editor.localization.about,\n        contentClassNames: ['about-dialog-content'],\n    });\n    for (const entry of entries) {\n        const container = document.createElement(entry.minimized ? 'details' : 'div');\n        container.classList.add('about-entry');\n        const header = document.createElement(entry.minimized ? 'summary' : 'h2');\n        if (typeof entry.heading === 'string') {\n            header.innerText = entry.heading;\n        }\n        else {\n            const link = document.createElement('a');\n            link.href = entry.heading.href.replace(/^javascript:/i, '');\n            link.text = entry.heading.text;\n            header.appendChild(link);\n        }\n        container.appendChild(header);\n        if (entry.text) {\n            const bodyText = document.createElement('div');\n            bodyText.innerText = entry.text;\n            container.appendChild(bodyText);\n        }\n        dialog.appendChild(container);\n    }\n    return {\n        close: () => {\n            return dialog.close();\n        },\n    };\n};\nexports[\"default\"] = makeAboutDialog;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/dialogs/makeAboutDialog.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/dialogs/makeMessageDialog.js":
/*!********************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/dialogs/makeMessageDialog.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst waitForTimeout_1 = __importDefault(__webpack_require__(/*! ../util/waitForTimeout */ \"./node_modules/js-draw/dist/cjs/util/waitForTimeout.js\"));\nconst makeAboutDialog = (editor, options) => {\n    const overlay = document.createElement('div');\n    const { remove: removeOverlay } = editor.createHTMLOverlay(overlay);\n    overlay.classList.add('dialog-container', 'message-dialog-container', ...(options.classNames ?? []));\n    const dialog = document.createElement('dialog');\n    const contentWrapper = document.createElement('div');\n    contentWrapper.classList.add('message-dialog-content', ...(options.contentClassNames ?? []));\n    const heading = document.createElement('h1');\n    heading.textContent = options.title;\n    heading.setAttribute('autofocus', 'true');\n    const closeButton = document.createElement('button');\n    closeButton.innerText = editor.localization.closeDialog;\n    closeButton.classList.add('close');\n    const scrollRegion = document.createElement('div');\n    scrollRegion.classList.add('scroll');\n    // Allow scrolling in the scrollable container -- don't forward wheel events.\n    scrollRegion.onwheel = (evt) => evt.stopPropagation();\n    contentWrapper.replaceChildren(heading, scrollRegion, closeButton);\n    dialog.replaceChildren(contentWrapper);\n    overlay.replaceChildren(dialog);\n    const closeTimeout = 300;\n    dialog.style.setProperty('--close-delay', `${closeTimeout}ms`);\n    const closeDialog = async () => {\n        dialog.classList.add('-closing');\n        await (0, waitForTimeout_1.default)(closeTimeout);\n        dialog.close();\n    };\n    const addCloseListeners = () => {\n        dialog.addEventListener('pointerdown', (event) => {\n            if (event.target === dialog) {\n                void closeDialog();\n            }\n        });\n        dialog.onclose = () => {\n            removeOverlay();\n        };\n        closeButton.onclick = () => closeDialog();\n    };\n    addCloseListeners();\n    dialog.showModal();\n    return {\n        close: () => {\n            return closeDialog();\n        },\n        appendChild: (child) => {\n            scrollRegion.appendChild(child);\n        },\n    };\n};\nexports[\"default\"] = makeAboutDialog;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/dialogs/makeMessageDialog.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/image/EditorImage.js":
/*!************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/image/EditorImage.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nvar __setFunctionName = (this && this.__setFunctionName) || function (f, name, prefix) {\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n    return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar _a, _b, _c;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RootImageNode = exports.ImageNode = exports.computeFirstIndexToRender = exports.EditorImageEventType = exports.sortLeavesByZIndex = void 0;\nconst Viewport_1 = __importDefault(__webpack_require__(/*! ../Viewport */ \"./node_modules/js-draw/dist/cjs/Viewport.js\"));\nconst AbstractComponent_1 = __importStar(__webpack_require__(/*! ../components/AbstractComponent */ \"./node_modules/js-draw/dist/cjs/components/AbstractComponent.js\"));\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\nconst SerializableCommand_1 = __importDefault(__webpack_require__(/*! ../commands/SerializableCommand */ \"./node_modules/js-draw/dist/cjs/commands/SerializableCommand.js\"));\nconst EventDispatcher_1 = __importDefault(__webpack_require__(/*! ../EventDispatcher */ \"./node_modules/js-draw/dist/cjs/EventDispatcher.js\"));\nconst assertions_1 = __webpack_require__(/*! ../util/assertions */ \"./node_modules/js-draw/dist/cjs/util/assertions.js\");\nconst Command_1 = __importDefault(__webpack_require__(/*! ../commands/Command */ \"./node_modules/js-draw/dist/cjs/commands/Command.js\"));\n// @internal Sort by z-index, low to high\nconst sortLeavesByZIndex = (leaves) => {\n    leaves.sort((a, b) => a.getContent().getZIndex() - b.getContent().getZIndex());\n};\nexports.sortLeavesByZIndex = sortLeavesByZIndex;\nvar EditorImageEventType;\n(function (EditorImageEventType) {\n    EditorImageEventType[EditorImageEventType[\"ExportViewportChanged\"] = 0] = \"ExportViewportChanged\";\n    EditorImageEventType[EditorImageEventType[\"AutoresizeModeChanged\"] = 1] = \"AutoresizeModeChanged\";\n})(EditorImageEventType || (exports.EditorImageEventType = EditorImageEventType = {}));\nlet debugMode = false;\n/**\n * @summary Handles lookup/storage of elements in the image.\n *\n * `js-draw` images are made up of a collection of {@link AbstractComponent}s (which\n * includes {@link Stroke}s, {@link TextComponent}s, etc.). An `EditorImage`\n * is the data structure that stores these components.\n *\n * Here's how to do a few common operations:\n * - **Get all components in a {@link @js-draw/math!Rect2 | Rect2}**:\n *    {@link EditorImage.getElementsIntersectingRegion}.\n * - **Draw an `EditorImage` onto a canvas/SVG**: {@link EditorImage.render}.\n * - **Adding a new component**: {@link EditorImage.addElement}.\n *\n * **Example**:\n * [[include:doc-pages/inline-examples/image-add-and-lookup.md]]\n */\nclass EditorImage {\n    // @internal\n    constructor() {\n        this.componentCount = 0;\n        this.settingExportRect = false;\n        this.root = new RootImageNode();\n        this.background = new RootImageNode();\n        this.componentsById = Object.create(null);\n        this.notifier = new EventDispatcher_1.default();\n        this.importExportViewport = new Viewport_1.default(() => {\n            this.onExportViewportChanged();\n        });\n        // Default to a 500x500 image\n        this.importExportViewport.updateScreenSize(math_1.Vec2.of(500, 500));\n        this.shouldAutoresizeExportViewport = false;\n    }\n    // Returns all components that make up the background of this image. These\n    // components are rendered below all other components.\n    getBackgroundComponents() {\n        const result = [];\n        const leaves = this.background.getLeaves();\n        (0, exports.sortLeavesByZIndex)(leaves);\n        for (const leaf of leaves) {\n            const content = leaf.getContent();\n            if (content) {\n                result.push(content);\n            }\n        }\n        return result;\n    }\n    // Returns the parent of the given element, if it exists.\n    findParent(elem) {\n        return this.background.getChildWithContent(elem) ?? this.root.getChildWithContent(elem);\n    }\n    // Forces a re-render of `elem` when the image is next re-rendered as a whole.\n    // Does nothing if `elem` is not in this.\n    queueRerenderOf(elem) {\n        // TODO: Make more efficient (e.g. increase IDs of all parents,\n        // make cache take into account last modified time instead of IDs, etc.)\n        const parent = this.findParent(elem);\n        if (parent) {\n            parent.remove();\n            this.addElementDirectly(elem);\n        }\n    }\n    /** @internal */\n    renderWithCache(screenRenderer, cache, viewport) {\n        this.background.render(screenRenderer, viewport.visibleRect);\n        // If in debug mode, avoid rendering with cache to show additional debug information\n        if (!debugMode) {\n            cache.render(screenRenderer, this.root, viewport);\n        }\n        else {\n            this.root.render(screenRenderer, viewport.visibleRect);\n        }\n    }\n    /**\n     * Renders this image to the given `renderer`.\n     *\n     * If `viewport` is non-null, only components that can be seen from that viewport\n     * will be rendered. If `viewport` is `null`, **all** components are rendered.\n     *\n     * **Example**:\n     * [[include:doc-pages/inline-examples/canvas-renderer.md]]\n     */\n    render(renderer, viewport) {\n        this.background.render(renderer, viewport?.visibleRect);\n        this.root.render(renderer, viewport?.visibleRect);\n    }\n    /**\n     * Like {@link renderAll}, but can be stopped early and paused.\n     *\n     * **Note**: If the image is being edited during an async rendering, there is no\n     * guarantee that all nodes will be rendered correctly (some may be missing).\n     *\n     * @internal\n     */\n    async renderAllAsync(renderer, preRenderComponent) {\n        const stoppedEarly = !(await this.background.renderAllAsync(renderer, preRenderComponent));\n        if (!stoppedEarly) {\n            return await this.root.renderAllAsync(renderer, preRenderComponent);\n        }\n        return false;\n    }\n    /**\n     * Renders all nodes, even ones not within the viewport.\n     *\n     * This can be slow for large images\n     * @internal\n     */\n    renderAll(renderer) {\n        this.render(renderer, null);\n    }\n    /**\n     * @returns all elements in the image, sorted by z-index (low to high).\n     *\n     * This can be slow for large images. If you only need all elemenst in part of the image,\n     * consider using {@link getElementsIntersectingRegion} instead.\n     *\n     * **Note**: The result does not include background elements. See {@link getBackgroundComponents}.\n     */\n    getAllElements() {\n        const leaves = this.root.getLeaves();\n        (0, exports.sortLeavesByZIndex)(leaves);\n        return leaves.map((leaf) => leaf.getContent());\n    }\n    /** Returns the number of elements added to this image. @internal */\n    estimateNumElements() {\n        return this.componentCount;\n    }\n    /**\n     * @returns a list of `AbstractComponent`s intersecting `region`, sorted by increasing z-index.\n     *\n     * Components in the background layer are only included if `includeBackground` is `true`.\n     */\n    getElementsIntersectingRegion(region, includeBackground = false) {\n        let leaves = this.root.getLeavesIntersectingRegion(region);\n        if (includeBackground) {\n            leaves = leaves.concat(this.background.getLeavesIntersectingRegion(region));\n        }\n        (0, exports.sortLeavesByZIndex)(leaves);\n        return leaves.map((leaf) => leaf.getContent());\n    }\n    /** Called whenever (just after) an element is completely removed. @internal */\n    onDestroyElement(elem) {\n        this.componentCount--;\n        delete this.componentsById[elem.getId()];\n        this.autoresizeExportViewport();\n    }\n    /** Called just after an element is added. @internal */\n    onElementAdded(elem) {\n        this.componentCount++;\n        this.componentsById[elem.getId()] = elem;\n        this.autoresizeExportViewport();\n    }\n    /**\n     * @returns the AbstractComponent with `id`, if it exists.\n     *\n     * @see {@link AbstractComponent.getId}\n     */\n    lookupElement(id) {\n        return this.componentsById[id] ?? null;\n    }\n    addElementDirectly(elem) {\n        // Because onAddToImage can affect the element's bounding box,\n        // this needs to be called before parentTree.addLeaf.\n        elem.onAddToImage(this);\n        // If a background component, add to the background. Else,\n        // add to the normal component tree.\n        const parentTree = elem.isBackground() ? this.background : this.root;\n        const result = parentTree.addLeaf(elem);\n        this.onElementAdded(elem);\n        return result;\n    }\n    removeElementDirectly(element) {\n        const container = this.findParent(element);\n        container?.remove();\n        if (container) {\n            this.onDestroyElement(element);\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Returns a command that adds the given element to the `EditorImage`.\n     * If `applyByFlattening` is true, the content of the wet ink renderer is\n     * rendered onto the main rendering canvas instead of doing a full re-render.\n     *\n     * @see {@link Display.flatten}\n     *\n     * **Example**:\n     *\n     * [[include:doc-pages/inline-examples/adding-a-stroke.md]]\n     */\n    static addElement(elem, applyByFlattening = false) {\n        return new _a.AddElementCommand(elem, applyByFlattening);\n    }\n    /** @see EditorImage.addElement */\n    addElement(elem, applyByFlattening) {\n        return _a.addElement(elem, applyByFlattening);\n    }\n    /**\n     * @returns a `Viewport` for rendering the image when importing/exporting.\n     */\n    getImportExportViewport() {\n        return this.importExportViewport;\n    }\n    /**\n     * @see {@link setImportExportRect}\n     */\n    getImportExportRect() {\n        return this.getImportExportViewport().visibleRect;\n    }\n    /**\n     * Sets the import/export rectangle to the given `imageRect`. Disables\n     * autoresize if it was previously enabled.\n     *\n     * **Note**: The import/export rectangle is the same as the size of any\n     * {@link BackgroundComponent}s (and other components that auto-resize).\n     */\n    setImportExportRect(imageRect) {\n        return _a.SetImportExportRectCommand.of(this, imageRect, false);\n    }\n    /** @see {@link setAutoresizeEnabled} */\n    getAutoresizeEnabled() {\n        return this.shouldAutoresizeExportViewport;\n    }\n    /**\n     * Returns a `Command` that sets whether the image should autoresize when\n     * {@link AbstractComponent}s are added/removed.\n     *\n     * @example\n     *\n     * ```ts,runnable\n     * import { Editor } from 'js-draw';\n     *\n     * const editor = new Editor(document.body);\n     * const toolbar = editor.addToolbar();\n     *\n     * // Add a save button to demonstrate what the output looks like\n     * // (it should change size to fit whatever was drawn)\n     * toolbar.addSaveButton(() => {\n     *   document.body.replaceChildren(editor.toSVG({ sanitize: true }));\n     * });\n     *\n     * // Actually using setAutoresizeEnabled:\n     * //\n     * // To set autoresize without announcing for accessibility/making undoable\n     * const addToHistory = false;\n     * editor.dispatchNoAnnounce(editor.image.setAutoresizeEnabled(true), addToHistory);\n     *\n     * // Add to undo history **and** announce for accessibility\n     * //editor.dispatch(editor.image.setAutoresizeEnabled(true), true);\n     * ```\n     */\n    setAutoresizeEnabled(autoresize) {\n        if (autoresize === this.shouldAutoresizeExportViewport) {\n            return Command_1.default.empty;\n        }\n        const newBBox = this.root.getBBox();\n        return _a.SetImportExportRectCommand.of(this, newBBox, autoresize);\n    }\n    setAutoresizeEnabledDirectly(shouldAutoresize) {\n        if (shouldAutoresize !== this.shouldAutoresizeExportViewport) {\n            this.shouldAutoresizeExportViewport = shouldAutoresize;\n            this.notifier.dispatch(EditorImageEventType.AutoresizeModeChanged, {\n                image: this,\n            });\n        }\n    }\n    /** Updates the size/position of the viewport */\n    autoresizeExportViewport() {\n        // Only autoresize if in autoresize mode -- otherwise resizing the image\n        // should be done with undoable commands.\n        if (this.shouldAutoresizeExportViewport) {\n            this.setExportRectDirectly(this.root.getBBox());\n        }\n    }\n    /**\n     * Sets the import/export viewport directly, without returning a `Command`.\n     * As such, this is not undoable.\n     *\n     * See setImportExportRect\n     *\n     * Returns true if changes to the viewport were made (and thus\n     * ExportViewportChanged was fired.)\n     */\n    setExportRectDirectly(newRect) {\n        const viewport = this.getImportExportViewport();\n        const lastSize = viewport.getScreenRectSize();\n        const lastTransform = viewport.canvasToScreenTransform;\n        const newTransform = math_1.Mat33.translation(newRect.topLeft.times(-1));\n        if (!lastSize.eq(newRect.size) || !lastTransform.eq(newTransform)) {\n            // Prevent the ExportViewportChanged event from being fired\n            // multiple times for the same viewport change: Set settingExportRect\n            // to true.\n            this.settingExportRect = true;\n            viewport.updateScreenSize(newRect.size);\n            viewport.resetTransform(newTransform);\n            this.settingExportRect = false;\n            this.onExportViewportChanged();\n            return true;\n        }\n        return false;\n    }\n    onExportViewportChanged() {\n        // Prevent firing duplicate events -- changes\n        // made by exportViewport.resetTransform may cause this method to be\n        // called.\n        if (!this.settingExportRect) {\n            this.notifier.dispatch(EditorImageEventType.ExportViewportChanged, {\n                image: this,\n            });\n        }\n    }\n    /**\n     * @internal\n     *\n     * Enables debug mode for **all** `EditorImage`s.\n     *\n     * **Only use for debugging**.\n     *\n     * @internal\n     */\n    static setDebugMode(newDebugMode) {\n        debugMode = newDebugMode;\n    }\n}\n_a = EditorImage;\n// A Command that can access private [EditorImage] functionality\nEditorImage.AddElementCommand = (_b = class extends SerializableCommand_1.default {\n        // If [applyByFlattening], then the rendered content of this element\n        // is present on the display's wet ink canvas. As such, no re-render is necessary\n        // the first time this command is applied (the surfaces are joined instead).\n        constructor(element, applyByFlattening = false) {\n            super('add-element');\n            this.element = element;\n            this.applyByFlattening = applyByFlattening;\n            this.serializedElem = null;\n            // FIXME: The serialized version of this command may be inaccurate if this is\n            //        serialized when this command is not on the top of the undo stack.\n            //\n            // Caching the element's serialized data leads to additional memory usage *and*\n            // sometimes incorrect behavior in collaborative editing.\n            this.serializedElem = null;\n            if (isNaN(element.getBBox().area)) {\n                throw new Error('Elements in the image cannot have NaN bounding boxes');\n            }\n        }\n        apply(editor) {\n            editor.image.addElementDirectly(this.element);\n            if (!this.applyByFlattening) {\n                editor.queueRerender();\n            }\n            else {\n                this.applyByFlattening = false;\n                editor.display.flatten();\n            }\n        }\n        unapply(editor) {\n            editor.image.removeElementDirectly(this.element);\n            editor.queueRerender();\n        }\n        description(_editor, localization) {\n            return localization.addElementAction(this.element.description(localization));\n        }\n        serializeToJSON() {\n            return {\n                elemData: this.serializedElem ?? this.element.serialize(),\n            };\n        }\n    },\n    __setFunctionName(_b, \"AddElementCommand\"),\n    (() => {\n        SerializableCommand_1.default.register('add-element', (json, editor) => {\n            const id = json.elemData.id;\n            const foundElem = editor.image.lookupElement(id);\n            const elem = foundElem ?? AbstractComponent_1.default.deserialize(json.elemData);\n            const result = new _a.AddElementCommand(elem);\n            result.serializedElem = json.elemData;\n            return result;\n        });\n    })(),\n    _b);\n// Handles resizing the background import/export region of the image.\nEditorImage.SetImportExportRectCommand = (_c = class extends SerializableCommand_1.default {\n        constructor(originalSize, originalTransform, originalAutoresize, newExportRect, newAutoresize) {\n            super(_a.SetImportExportRectCommand.commandId);\n            this.originalSize = originalSize;\n            this.originalTransform = originalTransform;\n            this.originalAutoresize = originalAutoresize;\n            this.newExportRect = newExportRect;\n            this.newAutoresize = newAutoresize;\n        }\n        // Uses `image` to store the original size/transform\n        static of(image, newExportRect, newAutoresize) {\n            const importExportViewport = image.getImportExportViewport();\n            const originalSize = importExportViewport.visibleRect.size;\n            const originalTransform = importExportViewport.canvasToScreenTransform;\n            const originalAutoresize = image.getAutoresizeEnabled();\n            return new _a.SetImportExportRectCommand(originalSize, originalTransform, originalAutoresize, newExportRect, newAutoresize);\n        }\n        apply(editor) {\n            editor.image.setAutoresizeEnabledDirectly(this.newAutoresize);\n            editor.image.setExportRectDirectly(this.newExportRect);\n            editor.queueRerender();\n        }\n        unapply(editor) {\n            const viewport = editor.image.getImportExportViewport();\n            editor.image.setAutoresizeEnabledDirectly(this.originalAutoresize);\n            viewport.updateScreenSize(this.originalSize);\n            viewport.resetTransform(this.originalTransform);\n            editor.queueRerender();\n        }\n        description(_editor, localization) {\n            if (this.newAutoresize !== this.originalAutoresize) {\n                if (this.newAutoresize) {\n                    return localization.enabledAutoresizeOutputCommand;\n                }\n                else {\n                    return localization.disabledAutoresizeOutputCommand;\n                }\n            }\n            return localization.resizeOutputCommand(this.newExportRect);\n        }\n        serializeToJSON() {\n            return {\n                originalSize: this.originalSize.xy,\n                originalTransform: this.originalTransform.toArray(),\n                newRegion: {\n                    x: this.newExportRect.x,\n                    y: this.newExportRect.y,\n                    w: this.newExportRect.w,\n                    h: this.newExportRect.h,\n                },\n                autoresize: this.newAutoresize,\n                originalAutoresize: this.originalAutoresize,\n            };\n        }\n    },\n    __setFunctionName(_c, \"SetImportExportRectCommand\"),\n    _c.commandId = 'set-import-export-rect',\n    (() => {\n        const commandId = _c.commandId;\n        SerializableCommand_1.default.register(commandId, (json, _editor) => {\n            (0, assertions_1.assertIsNumber)(json.originalSize.x);\n            (0, assertions_1.assertIsNumber)(json.originalSize.y);\n            (0, assertions_1.assertIsNumberArray)(json.originalTransform);\n            (0, assertions_1.assertIsNumberArray)([\n                json.newRegion.x,\n                json.newRegion.y,\n                json.newRegion.w,\n                json.newRegion.h,\n            ]);\n            (0, assertions_1.assertIsBoolean)(json.autoresize ?? false);\n            (0, assertions_1.assertIsBoolean)(json.originalAutoresize ?? false);\n            const originalSize = math_1.Vec2.ofXY(json.originalSize);\n            const originalTransform = new math_1.Mat33(...json.originalTransform);\n            const finalRect = new math_1.Rect2(json.newRegion.x, json.newRegion.y, json.newRegion.w, json.newRegion.h);\n            const autoresize = json.autoresize ?? false;\n            const originalAutoresize = json.originalAutoresize ?? false;\n            return new _a.SetImportExportRectCommand(originalSize, originalTransform, originalAutoresize, finalRect, autoresize);\n        });\n    })(),\n    _c);\nexports[\"default\"] = EditorImage;\n/**\n * Determines the first index in `sortedLeaves` that needs to be rendered\n * (based on occlusion -- everything before that index can be skipped and\n * produce a visually-equivalent image).\n *\n * Does nothing if visibleRect is not provided\n *\n * @internal\n */\nconst computeFirstIndexToRender = (sortedLeaves, visibleRect) => {\n    let startIndex = 0;\n    if (visibleRect) {\n        for (let i = sortedLeaves.length - 1; i >= 1; i--) {\n            if (\n            // Check for occlusion\n            sortedLeaves[i].getBBox().containsRect(visibleRect) &&\n                sortedLeaves[i].getContent()?.occludesEverythingBelowWhenRenderedInRect(visibleRect)) {\n                startIndex = i;\n                break;\n            }\n        }\n    }\n    return startIndex;\n};\nexports.computeFirstIndexToRender = computeFirstIndexToRender;\n/**\n * Part of the Editor's image. Does not handle fullscreen/invisible components.\n * @internal\n */\nclass ImageNode {\n    constructor(parent = null) {\n        this.parent = parent;\n        this.targetChildCount = 30;\n        this.children = [];\n        this.bbox = math_1.Rect2.empty;\n        this.content = null;\n        this.id = ImageNode.idCounter++;\n    }\n    getId() {\n        return this.id;\n    }\n    onContentChange() {\n        this.id = ImageNode.idCounter++;\n    }\n    getContent() {\n        return this.content;\n    }\n    getParent() {\n        return this.parent;\n    }\n    // Override this to change how children are considered within a given region.\n    getChildrenIntersectingRegion(region, isTooSmallFilter) {\n        return this.children.filter((child) => {\n            const bbox = child.getBBox();\n            return !isTooSmallFilter?.(bbox) && bbox.intersects(region);\n        });\n    }\n    getChildrenOrSelfIntersectingRegion(region, isTooSmall) {\n        if (this.content && this.bbox.intersects(region) && !isTooSmall?.(this.bbox)) {\n            return [this];\n        }\n        return this.getChildrenIntersectingRegion(region, isTooSmall);\n    }\n    /**\n     * Returns a list of `ImageNode`s with content (and thus no children).\n     * Override getChildrenIntersectingRegion to customize how this method\n     * determines whether/which children are in `region`.\n     *\n     * @paran region - All resultant `ImageNode`s must intersect `region`.\n     * @param isTooSmall - If `isTooSmall` returns true for an image node, that node\n     *                     is excluded from the output.\n     *\n     */\n    getLeavesIntersectingRegion(region, isTooSmall) {\n        const result = [];\n        const workList = [];\n        workList.push(this);\n        while (workList.length > 0) {\n            const current = workList.pop();\n            // Split the children into leaves and non-leaves\n            const processed = current.getChildrenOrSelfIntersectingRegion(region, isTooSmall);\n            for (const item of processed) {\n                if (item.content) {\n                    result.push(item);\n                }\n                else {\n                    // Non-leaves need to be processed\n                    workList.push(item);\n                }\n            }\n        }\n        return result;\n    }\n    // Returns the child of this with the target content or `null` if no\n    // such child exists.\n    //\n    // Note: Relies on all children to have valid bounding boxes.\n    getChildWithContent(target) {\n        const candidates = this.getLeavesIntersectingRegion(target.getBBox());\n        for (const candidate of candidates) {\n            if (candidate.getContent() === target) {\n                return candidate;\n            }\n        }\n        return null;\n    }\n    // Returns a list of leaves with this as an ancestor.\n    // Like getLeavesInRegion, but does not check whether ancestors are in a given rectangle\n    getLeaves() {\n        if (this.content) {\n            return [this];\n        }\n        const result = [];\n        for (const child of this.children) {\n            result.push(...child.getLeaves());\n        }\n        return result;\n    }\n    addLeaf(leaf) {\n        this.onContentChange();\n        if (this.content === null && this.children.length === 0) {\n            this.content = leaf;\n            this.recomputeBBox(true);\n            return this;\n        }\n        if (this.content !== null) {\n            console.assert(this.children.length === 0);\n            const contentNode = new ImageNode(this);\n            contentNode.content = this.content;\n            this.content = null;\n            this.children.push(contentNode);\n            contentNode.recomputeBBox(false);\n        }\n        // If this node is contained within the leaf, make this and the leaf\n        // share a parent.\n        const leafBBox = leaf.getBBox();\n        if (leafBBox.containsRect(this.getBBox())) {\n            const nodeForNewLeaf = new ImageNode(this);\n            if (this.children.length < this.targetChildCount) {\n                this.children.push(nodeForNewLeaf);\n            }\n            else {\n                const nodeForChildren = new ImageNode(this);\n                nodeForChildren.children = this.children;\n                this.children = [nodeForNewLeaf, nodeForChildren];\n                nodeForChildren.updateParents();\n                nodeForChildren.recomputeBBox(true);\n            }\n            return nodeForNewLeaf.addLeaf(leaf);\n        }\n        const containingNodes = this.children.filter((child) => child.getBBox().containsRect(leafBBox));\n        // Does the leaf already fit within one of the children?\n        if (containingNodes.length > 0 && this.children.length >= this.targetChildCount) {\n            // Sort the containers in ascending order by area\n            containingNodes.sort((a, b) => a.getBBox().area - b.getBBox().area);\n            // Choose the smallest child that contains the new element.\n            const result = containingNodes[0].addLeaf(leaf);\n            result.rebalance();\n            return result;\n        }\n        const newNode = ImageNode.createLeafNode(this, leaf);\n        this.children.push(newNode);\n        newNode.recomputeBBox(true);\n        if (this.children.length >= this.targetChildCount) {\n            this.rebalance();\n        }\n        return newNode;\n    }\n    // Creates a new leaf node with the given content.\n    // This only establishes the parent-child linking in one direction. Callers\n    // must add the resultant node to the list of children manually.\n    static createLeafNode(parent, content) {\n        const newNode = new ImageNode(parent);\n        newNode.content = content;\n        return newNode;\n    }\n    getBBox() {\n        return this.bbox;\n    }\n    // Recomputes this' bounding box. If [bubbleUp], also recompute\n    // this' ancestors bounding boxes. This also re-computes this' bounding box\n    // in the z-direction (z-indicies).\n    recomputeBBox(bubbleUp) {\n        const oldBBox = this.bbox;\n        if (this.content !== null) {\n            this.bbox = this.content.getBBox();\n        }\n        else {\n            this.bbox = math_1.Rect2.union(...this.children.map((child) => child.getBBox()));\n        }\n        if (bubbleUp && !oldBBox.eq(this.bbox)) {\n            if (this.bbox.containsRect(oldBBox)) {\n                this.parent?.unionBBoxWith(this.bbox);\n            }\n            else {\n                this.parent?.recomputeBBox(true);\n            }\n        }\n        this.checkRep();\n    }\n    // Grows this' bounding box to also include `other`.\n    // Always bubbles up.\n    unionBBoxWith(other) {\n        this.bbox = this.bbox.union(other);\n        this.parent?.unionBBoxWith(other);\n    }\n    updateParents(recursive = false) {\n        for (const child of this.children) {\n            child.parent = this;\n            if (recursive) {\n                child.updateParents(recursive);\n            }\n        }\n    }\n    rebalance() {\n        // If the current node is its parent's only child,\n        if (this.parent && this.parent.children.length === 1) {\n            console.assert(this.parent.content === null);\n            console.assert(this.parent.children[0] === this);\n            // Remove this' parent, if this' parent isn't the root.\n            const oldParent = this.parent;\n            if (oldParent.parent !== null) {\n                const newParent = oldParent.parent;\n                newParent.children = newParent.children.filter((c) => c !== oldParent);\n                oldParent.parent = null;\n                oldParent.children = [];\n                this.parent = newParent;\n                newParent.children.push(this);\n                this.parent.recomputeBBox(false);\n            }\n            else if (this.content === null) {\n                // Remove this and transfer this' children to the parent.\n                this.parent.children = this.children;\n                this.parent.updateParents();\n                this.parent = null;\n            }\n        }\n        // Create virtual containers for children. Handles the case where there\n        // are many small, often non-overlapping children that we still want to be grouped.\n        if (this.children.length > this.targetChildCount * 10) {\n            const grid = this.getBBox().divideIntoGrid(4, 4);\n            const indexToCount = [];\n            while (indexToCount.length < grid.length) {\n                indexToCount.push(0);\n            }\n            for (const child of this.children) {\n                for (let i = 0; i < grid.length; i++) {\n                    if (grid[i].containsRect(child.getBBox())) {\n                        indexToCount[i]++;\n                    }\n                }\n            }\n            let indexWithGreatest = 0;\n            let greatestCount = indexToCount[0];\n            for (let i = 1; i < indexToCount.length; i++) {\n                if (indexToCount[i] > greatestCount) {\n                    indexWithGreatest = i;\n                    greatestCount = indexToCount[i];\n                }\n            }\n            const targetGridSquare = grid[indexWithGreatest];\n            // Avoid clustering if just a few children would be grouped.\n            // Unnecessary clustering can lead to unnecessarily nested nodes.\n            if (greatestCount > 4) {\n                const newChildren = [];\n                const childNodeChildren = [];\n                for (const child of this.children) {\n                    if (targetGridSquare.containsRect(child.getBBox())) {\n                        childNodeChildren.push(child);\n                    }\n                    else {\n                        newChildren.push(child);\n                    }\n                }\n                if (childNodeChildren.length < this.children.length) {\n                    this.children = newChildren;\n                    const child = new ImageNode(this);\n                    this.children.push(child);\n                    child.children = childNodeChildren;\n                    child.updateParents(false);\n                    child.recomputeBBox(false);\n                    child.rebalance();\n                }\n            }\n        }\n        // Empty?\n        if (this.parent && this.children.length === 0 && this.content === null) {\n            this.remove();\n        }\n    }\n    // Removes the parent-to-child link.\n    // Called internally by `.remove`\n    removeChild(child) {\n        this.checkRep();\n        const oldChildCount = this.children.length;\n        this.children = this.children.filter((node) => {\n            return node !== child;\n        });\n        console.assert(this.children.length === oldChildCount - 1, `${oldChildCount - 1} ≠ ${this.children.length} after removing all nodes equal to ${child}. Nodes should only be removed once.`);\n        this.children.forEach((child) => {\n            child.rebalance();\n        });\n        this.recomputeBBox(true);\n        this.rebalance();\n        this.checkRep();\n    }\n    // Remove this node and all of its children\n    remove() {\n        this.content?.onRemoveFromImage();\n        if (!this.parent) {\n            this.content = null;\n            this.children = [];\n            return;\n        }\n        this.parent.removeChild(this);\n        // Remove the child-to-parent link and invalid this\n        this.parent = null;\n        this.content = null;\n        this.children = [];\n        this.checkRep();\n    }\n    // Creates a (potentially incomplete) async rendering of this image.\n    // Returns false if stopped early\n    async renderAllAsync(renderer, \n    // Used to pause/stop the renderer process\n    preRenderComponent) {\n        const leaves = this.getLeaves();\n        (0, exports.sortLeavesByZIndex)(leaves);\n        const totalLeaves = leaves.length;\n        for (let leafIndex = 0; leafIndex < totalLeaves; leafIndex++) {\n            const leaf = leaves[leafIndex];\n            const component = leaf.getContent();\n            // Even though leaf was originally a leaf, it might not be any longer --\n            // rendering is async and the tree can change during that time.\n            if (!component) {\n                continue;\n            }\n            const shouldContinue = await preRenderComponent(component, leafIndex, totalLeaves);\n            if (!shouldContinue) {\n                return false;\n            }\n            component.render(renderer, undefined);\n        }\n        return true;\n    }\n    render(renderer, visibleRect) {\n        let leaves;\n        if (visibleRect) {\n            leaves = this.getLeavesIntersectingRegion(visibleRect, (rect) => renderer.isTooSmallToRender(rect));\n        }\n        else {\n            leaves = this.getLeaves();\n        }\n        (0, exports.sortLeavesByZIndex)(leaves);\n        // If some components hide others (and we're permitted to simplify,\n        // which is true in the case of visibleRect being defined), then only\n        // draw the non-hidden components:\n        const startIndex = (0, exports.computeFirstIndexToRender)(leaves);\n        for (let i = startIndex; i < leaves.length; i++) {\n            const leaf = leaves[i];\n            // Leaves by definition have content\n            leaf.getContent().render(renderer, visibleRect);\n        }\n        // Show debug information\n        if (debugMode && visibleRect) {\n            if (startIndex !== 0) {\n                console.log('EditorImage: skipped ', startIndex, 'nodes due to occlusion');\n            }\n            this.renderDebugBoundingBoxes(renderer, visibleRect);\n        }\n    }\n    // Debug only: Shows bounding boxes of this and all children.\n    renderDebugBoundingBoxes(renderer, visibleRect, depth = 0) {\n        const bbox = this.getBBox();\n        const pixelSize = 1 / (renderer.getSizeOfCanvasPixelOnScreen() || 1);\n        if (bbox.maxDimension < 3 * pixelSize || !bbox.intersects(visibleRect)) {\n            return;\n        }\n        // Render debug information for this\n        renderer.startObject(bbox);\n        // Different styling for leaf nodes\n        const isLeaf = !!this.content;\n        const fill = isLeaf ? math_1.Color4.ofRGBA(1, 0, 1, 0.4) : math_1.Color4.ofRGBA(0, 1, Math.sin(depth), 0.6);\n        const lineWidth = isLeaf ? 1 * pixelSize : 2 * pixelSize;\n        renderer.drawRect(bbox.intersection(visibleRect), lineWidth, { fill });\n        renderer.endObject();\n        if (bbox.maxDimension > visibleRect.maxDimension / 3) {\n            const textStyle = {\n                fontFamily: 'monospace',\n                size: bbox.minDimension / 20,\n                renderingStyle: { fill: math_1.Color4.red },\n            };\n            renderer.drawText(`Depth: ${depth}`, math_1.Mat33.translation(bbox.bottomLeft), textStyle);\n        }\n        // Render debug information for children\n        for (const child of this.children) {\n            child.renderDebugBoundingBoxes(renderer, visibleRect, depth + 1);\n        }\n    }\n    checkRep(depth = 0) {\n        // Slow -- disabld by default\n        if (debugMode) {\n            if (this.parent && !this.parent.children.includes(this)) {\n                throw new Error(`Parent does not have this node as a child. (depth: ${depth})`);\n            }\n            let expectedBBox = null;\n            const seenChildren = new Set();\n            for (const child of this.children) {\n                expectedBBox ??= child.getBBox();\n                expectedBBox = expectedBBox.union(child.getBBox());\n                if (child.parent !== this) {\n                    throw new Error(`Child with bbox ${child.getBBox()} and ${child.children.length} has wrong parent (was ${child.parent}).`);\n                }\n                // Children should only be present once\n                if (seenChildren.has(child)) {\n                    throw new Error(`Child ${child} is present twice or more in its parent's child list`);\n                }\n                seenChildren.add(child);\n            }\n            const tolerance = this.bbox.minDimension / 100;\n            if (expectedBBox && !this.bbox.eq(expectedBBox, tolerance)) {\n                throw new Error(`Wrong bounding box ${expectedBBox} \\\\neq ${this.bbox} (depth: ${depth})`);\n            }\n        }\n    }\n}\nexports.ImageNode = ImageNode;\nImageNode.idCounter = 0;\n/** An `ImageNode` that can properly handle fullscreen/data components. @internal */\nclass RootImageNode extends ImageNode {\n    constructor() {\n        super(...arguments);\n        // Nodes that will always take up the entire screen\n        this.fullscreenChildren = [];\n        // Nodes that will never be visible unless a full render is done.\n        this.dataComponents = [];\n    }\n    getChildrenIntersectingRegion(region, _isTooSmall) {\n        const result = super.getChildrenIntersectingRegion(region);\n        for (const node of this.fullscreenChildren) {\n            result.push(node);\n        }\n        return result;\n    }\n    getChildrenOrSelfIntersectingRegion(region, _isTooSmall) {\n        const content = this.getContent();\n        // Fullscreen components always intersect/contain\n        if (content && content.getSizingMode() === AbstractComponent_1.ComponentSizingMode.FillScreen) {\n            return [this];\n        }\n        return super.getChildrenOrSelfIntersectingRegion(region, _isTooSmall);\n    }\n    getLeaves() {\n        const leaves = super.getLeaves();\n        // Add fullscreen/data components — this method should\n        // return *all* leaves.\n        return this.dataComponents.concat(this.fullscreenChildren, leaves);\n    }\n    removeChild(child) {\n        let removed = false;\n        const checkTargetChild = (component) => {\n            const isTarget = component === child;\n            removed ||= isTarget;\n            return !isTarget;\n        };\n        // Check whether the child is stored in the data/fullscreen\n        // component arrays first.\n        this.dataComponents = this.dataComponents.filter(checkTargetChild);\n        this.fullscreenChildren = this.fullscreenChildren.filter(checkTargetChild);\n        if (!removed) {\n            super.removeChild(child);\n        }\n    }\n    getChildWithContent(target) {\n        const searchExtendedChildren = () => {\n            // Search through all extended children\n            const candidates = this.fullscreenChildren.concat(this.dataComponents);\n            for (const candidate of candidates) {\n                if (candidate.getContent() === target) {\n                    return candidate;\n                }\n            }\n            return null;\n        };\n        // If positioned as if a standard child, search using the superclass first.\n        // Because it could be mislabeled, also search the extended children if the superclass\n        // search fails.\n        if (target.getSizingMode() === AbstractComponent_1.ComponentSizingMode.BoundingBox) {\n            return super.getChildWithContent(target) ?? searchExtendedChildren();\n        }\n        // Fall back to the superclass -- it's possible that the component has\n        // changed labels.\n        return super.getChildWithContent(target) ?? searchExtendedChildren();\n    }\n    addLeaf(leafContent) {\n        const sizingMode = leafContent.getSizingMode();\n        if (sizingMode === AbstractComponent_1.ComponentSizingMode.BoundingBox) {\n            return super.addLeaf(leafContent);\n        }\n        else if (sizingMode === AbstractComponent_1.ComponentSizingMode.FillScreen) {\n            this.onContentChange();\n            const newNode = ImageNode.createLeafNode(this, leafContent);\n            this.fullscreenChildren.push(newNode);\n            return newNode;\n        }\n        else if (sizingMode === AbstractComponent_1.ComponentSizingMode.Anywhere) {\n            this.onContentChange();\n            const newNode = ImageNode.createLeafNode(this, leafContent);\n            this.dataComponents.push(newNode);\n            return newNode;\n        }\n        else {\n            const exhaustivenessCheck = sizingMode;\n            throw new Error(`Invalid sizing mode, ${sizingMode}`);\n            return exhaustivenessCheck;\n        }\n    }\n}\nexports.RootImageNode = RootImageNode;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/image/EditorImage.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/image/export/adjustExportedSVGSize.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/image/export/adjustExportedSVGSize.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\n// @internal\nconst adjustExportedSVGSize = (svg, exportRect, options) => {\n    // Adjust the width/height as necessary\n    let width = exportRect.w;\n    let height = exportRect.h;\n    if (options?.minDimension && width < options.minDimension) {\n        const newWidth = options.minDimension;\n        height *= newWidth / (width || 1);\n        width = newWidth;\n    }\n    if (options?.minDimension && height < options.minDimension) {\n        const newHeight = options.minDimension;\n        width *= newHeight / (height || 1);\n        height = newHeight;\n    }\n    svg.setAttribute('width', (0, math_1.toRoundedString)(width));\n    svg.setAttribute('height', (0, math_1.toRoundedString)(height));\n};\nexports[\"default\"] = adjustExportedSVGSize;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/image/export/adjustExportedSVGSize.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/image/export/editorImageToSVG.js":
/*!************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/image/export/editorImageToSVG.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.editorImageToSVGAsync = exports.editorImageToSVGSync = void 0;\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\nconst SVGRenderer_1 = __importDefault(__webpack_require__(/*! ../../rendering/renderers/SVGRenderer */ \"./node_modules/js-draw/dist/cjs/rendering/renderers/SVGRenderer.js\"));\nconst SVGLoader_1 = __webpack_require__(/*! ../../SVGLoader/SVGLoader */ \"./node_modules/js-draw/dist/cjs/SVGLoader/SVGLoader.js\");\nconst adjustExportedSVGSize_1 = __importDefault(__webpack_require__(/*! ./adjustExportedSVGSize */ \"./node_modules/js-draw/dist/cjs/image/export/adjustExportedSVGSize.js\"));\nconst toSVGInternal = (image, renderFunction, options) => {\n    const importExportViewport = image.getImportExportViewport().getTemporaryClone();\n    // If the rectangle has zero width or height, its size can't be increased\n    // -- set its size to the minimum.\n    if (options?.minDimension) {\n        const originalRect = importExportViewport.visibleRect;\n        let rect = originalRect;\n        if (rect.w <= 0) {\n            rect = new math_1.Rect2(rect.x, rect.y, options.minDimension, rect.h);\n        }\n        if (rect.h <= 0) {\n            rect = new math_1.Rect2(rect.x, rect.y, rect.w, options.minDimension);\n        }\n        if (!rect.eq(originalRect)) {\n            importExportViewport.updateScreenSize(rect.size);\n        }\n    }\n    const { element: result, renderer } = SVGRenderer_1.default.fromViewport(importExportViewport, {\n        sanitize: options.sanitize ?? false,\n        useViewBoxForPositioning: true,\n    });\n    // Use a callback rather than async/await to allow this function to create\n    // both sync and async render functions\n    renderFunction(renderer, () => {\n        if (image.getAutoresizeEnabled()) {\n            result.classList.add(SVGLoader_1.svgLoaderAutoresizeClassName);\n        }\n        else {\n            result.classList.remove(SVGLoader_1.svgLoaderAutoresizeClassName);\n        }\n        const exportRect = importExportViewport.visibleRect;\n        (0, adjustExportedSVGSize_1.default)(result, exportRect, options);\n        return result;\n    });\n    return result;\n};\nconst editorImageToSVGSync = (image, options) => {\n    return toSVGInternal(image, (renderer, onComplete) => {\n        image.renderAll(renderer);\n        onComplete();\n    }, options);\n};\nexports.editorImageToSVGSync = editorImageToSVGSync;\nconst editorImageToSVGAsync = (image, preRenderComponent, options) => {\n    return new Promise((resolve) => {\n        toSVGInternal(image, async (renderer, onComplete) => {\n            await image.renderAllAsync(renderer, preRenderComponent);\n            const result = onComplete();\n            resolve(result);\n        }, options);\n    });\n};\nexports.editorImageToSVGAsync = editorImageToSVGAsync;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/image/export/editorImageToSVG.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/image/lib.js":
/*!****************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/image/lib.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EditorImage = void 0;\nvar EditorImage_1 = __webpack_require__(/*! ./EditorImage */ \"./node_modules/js-draw/dist/cjs/image/EditorImage.js\");\nObject.defineProperty(exports, \"EditorImage\", ({ enumerable: true, get: function () { return __importDefault(EditorImage_1).default; } }));\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/image/lib.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/inputEvents.js":
/*!******************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/inputEvents.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isPointerEvt = exports.keyPressEventFromHTMLEvent = exports.keyUpEventFromHTMLEvent = exports.InputEvtType = void 0;\nvar InputEvtType;\n(function (InputEvtType) {\n    InputEvtType[InputEvtType[\"PointerDownEvt\"] = 0] = \"PointerDownEvt\";\n    InputEvtType[InputEvtType[\"PointerMoveEvt\"] = 1] = \"PointerMoveEvt\";\n    InputEvtType[InputEvtType[\"PointerUpEvt\"] = 2] = \"PointerUpEvt\";\n    InputEvtType[InputEvtType[\"GestureCancelEvt\"] = 3] = \"GestureCancelEvt\";\n    InputEvtType[InputEvtType[\"WheelEvt\"] = 4] = \"WheelEvt\";\n    InputEvtType[InputEvtType[\"KeyPressEvent\"] = 5] = \"KeyPressEvent\";\n    InputEvtType[InputEvtType[\"KeyUpEvent\"] = 6] = \"KeyUpEvent\";\n    InputEvtType[InputEvtType[\"CopyEvent\"] = 7] = \"CopyEvent\";\n    InputEvtType[InputEvtType[\"PasteEvent\"] = 8] = \"PasteEvent\";\n    InputEvtType[InputEvtType[\"ContextMenu\"] = 9] = \"ContextMenu\";\n})(InputEvtType || (exports.InputEvtType = InputEvtType = {}));\n// Constructor\nconst keyEventFromHTMLEvent = (kind, event) => {\n    return {\n        kind,\n        key: event.key,\n        code: event.code,\n        ctrlKey: event.ctrlKey || event.metaKey,\n        altKey: event.altKey,\n        shiftKey: event.shiftKey,\n    };\n};\nconst keyUpEventFromHTMLEvent = (event) => {\n    return keyEventFromHTMLEvent(InputEvtType.KeyUpEvent, event);\n};\nexports.keyUpEventFromHTMLEvent = keyUpEventFromHTMLEvent;\nconst keyPressEventFromHTMLEvent = (event) => {\n    return keyEventFromHTMLEvent(InputEvtType.KeyPressEvent, event);\n};\nexports.keyPressEventFromHTMLEvent = keyPressEventFromHTMLEvent;\nconst isPointerEvt = (event) => {\n    return (event.kind === InputEvtType.PointerDownEvt ||\n        event.kind === InputEvtType.PointerMoveEvt ||\n        event.kind === InputEvtType.PointerUpEvt);\n};\nexports.isPointerEvt = isPointerEvt;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/inputEvents.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/lib.js":
/*!**********************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/lib.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * The main entrypoint for the NPM package. Everything exported by this file\n * is available through the [`js-draw` package](https://www.npmjs.com/package/js-draw).\n *\n * ## Example\n *\n * [[include:doc-pages/inline-examples/main-js-draw-example.md]]\n *\n * @see\n * - {@link Editor}\n * - {@link Editor.loadFromSVG}\n * - {@link AbstractToolbar.addActionButton }\n * - {@link EditorSettings}\n *\n * @packageDocumentation\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.HTMLToolbar = exports.AbstractToolbar = exports.Editor = exports.__js_draw__version = exports.UndoRedoHistory = exports.PointerDevice = exports.Pointer = exports.EventDispatcher = exports.Viewport = exports.SVGLoader = exports.matchingLocalizationTable = exports.getLocalizationTable = void 0;\nconst Editor_1 = __importDefault(__webpack_require__(/*! ./Editor */ \"./node_modules/js-draw/dist/cjs/Editor.js\"));\nexports.Editor = Editor_1.default;\n__exportStar(__webpack_require__(/*! ./image/lib */ \"./node_modules/js-draw/dist/cjs/image/lib.js\"), exports);\n__exportStar(__webpack_require__(/*! ./types */ \"./node_modules/js-draw/dist/cjs/types.js\"), exports);\n__exportStar(__webpack_require__(/*! ./inputEvents */ \"./node_modules/js-draw/dist/cjs/inputEvents.js\"), exports);\nvar getLocalizationTable_1 = __webpack_require__(/*! ./localizations/getLocalizationTable */ \"./node_modules/js-draw/dist/cjs/localizations/getLocalizationTable.js\");\nObject.defineProperty(exports, \"getLocalizationTable\", ({ enumerable: true, get: function () { return __importDefault(getLocalizationTable_1).default; } }));\nObject.defineProperty(exports, \"matchingLocalizationTable\", ({ enumerable: true, get: function () { return getLocalizationTable_1.matchingLocalizationTable; } }));\n__exportStar(__webpack_require__(/*! ./localization */ \"./node_modules/js-draw/dist/cjs/localization.js\"), exports);\nvar SVGLoader_1 = __webpack_require__(/*! ./SVGLoader/SVGLoader */ \"./node_modules/js-draw/dist/cjs/SVGLoader/SVGLoader.js\");\nObject.defineProperty(exports, \"SVGLoader\", ({ enumerable: true, get: function () { return __importDefault(SVGLoader_1).default; } }));\nvar Viewport_1 = __webpack_require__(/*! ./Viewport */ \"./node_modules/js-draw/dist/cjs/Viewport.js\");\nObject.defineProperty(exports, \"Viewport\", ({ enumerable: true, get: function () { return __importDefault(Viewport_1).default; } }));\n__exportStar(__webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\"), exports);\n__exportStar(__webpack_require__(/*! ./components/lib */ \"./node_modules/js-draw/dist/cjs/components/lib.js\"), exports);\n__exportStar(__webpack_require__(/*! ./commands/lib */ \"./node_modules/js-draw/dist/cjs/commands/lib.js\"), exports);\n__exportStar(__webpack_require__(/*! ./tools/lib */ \"./node_modules/js-draw/dist/cjs/tools/lib.js\"), exports);\n__exportStar(__webpack_require__(/*! ./toolbar/lib */ \"./node_modules/js-draw/dist/cjs/toolbar/lib.js\"), exports);\n__exportStar(__webpack_require__(/*! ./rendering/lib */ \"./node_modules/js-draw/dist/cjs/rendering/lib.js\"), exports);\n__exportStar(__webpack_require__(/*! ./testing/lib */ \"./node_modules/js-draw/dist/cjs/testing/lib.js\"), exports);\n__exportStar(__webpack_require__(/*! ./shortcuts/lib */ \"./node_modules/js-draw/dist/cjs/shortcuts/lib.js\"), exports);\nvar EventDispatcher_1 = __webpack_require__(/*! ./EventDispatcher */ \"./node_modules/js-draw/dist/cjs/EventDispatcher.js\");\nObject.defineProperty(exports, \"EventDispatcher\", ({ enumerable: true, get: function () { return __importDefault(EventDispatcher_1).default; } }));\nvar Pointer_1 = __webpack_require__(/*! ./Pointer */ \"./node_modules/js-draw/dist/cjs/Pointer.js\");\nObject.defineProperty(exports, \"Pointer\", ({ enumerable: true, get: function () { return __importDefault(Pointer_1).default; } }));\nObject.defineProperty(exports, \"PointerDevice\", ({ enumerable: true, get: function () { return Pointer_1.PointerDevice; } }));\nvar UndoRedoHistory_1 = __webpack_require__(/*! ./UndoRedoHistory */ \"./node_modules/js-draw/dist/cjs/UndoRedoHistory.js\");\nObject.defineProperty(exports, \"UndoRedoHistory\", ({ enumerable: true, get: function () { return __importDefault(UndoRedoHistory_1).default; } }));\n__exportStar(__webpack_require__(/*! ./util/lib */ \"./node_modules/js-draw/dist/cjs/util/lib.js\"), exports);\n// @internal\nvar version_1 = __webpack_require__(/*! ./version */ \"./node_modules/js-draw/dist/cjs/version.js\");\nObject.defineProperty(exports, \"__js_draw__version\", ({ enumerable: true, get: function () { return __importDefault(version_1).default; } }));\nconst AbstractToolbar_1 = __importDefault(__webpack_require__(/*! ./toolbar/AbstractToolbar */ \"./node_modules/js-draw/dist/cjs/toolbar/AbstractToolbar.js\"));\nexports.AbstractToolbar = AbstractToolbar_1.default;\nexports.HTMLToolbar = AbstractToolbar_1.default;\nexports[\"default\"] = Editor_1.default;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/lib.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/localization.js":
/*!*******************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/localization.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.defaultEditorLocalization = void 0;\nconst localization_1 = __webpack_require__(/*! ./commands/localization */ \"./node_modules/js-draw/dist/cjs/commands/localization.js\");\nconst localization_2 = __webpack_require__(/*! ./components/localization */ \"./node_modules/js-draw/dist/cjs/components/localization.js\");\nconst localization_3 = __webpack_require__(/*! ./rendering/localization */ \"./node_modules/js-draw/dist/cjs/rendering/localization.js\");\nconst localization_4 = __webpack_require__(/*! ./toolbar/localization */ \"./node_modules/js-draw/dist/cjs/toolbar/localization.js\");\nconst localization_5 = __webpack_require__(/*! ./tools/localization */ \"./node_modules/js-draw/dist/cjs/tools/localization.js\");\nexports.defaultEditorLocalization = {\n    ...localization_4.defaultToolbarLocalization,\n    ...localization_5.defaultToolLocalization,\n    ...localization_1.defaultCommandLocalization,\n    ...localization_2.defaultComponentLocalization,\n    ...localization_3.defaultTextRendererLocalization,\n    accessibilityInputInstructions: [\n        'Press \"t\" to read the contents of the viewport as text.',\n        'Use the arrow keys to move the viewport, click and drag to draw strokes.',\n        'Press \"w\" to zoom in and \"s\" to zoom out.',\n    ].join(' '),\n    loading: (percentage) => `Loading ${percentage}%...`,\n    imageEditor: 'Image Editor',\n    doneLoading: 'Done loading',\n    undoAnnouncement: (commandDescription) => `Undid ${commandDescription}`,\n    redoAnnouncement: (commandDescription) => `Redid ${commandDescription}`,\n    softwareLibraries: 'Libraries',\n    developerInformation: 'Developer information',\n};\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/localization.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/localizations/de.js":
/*!***********************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/localizations/de.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst localization_1 = __webpack_require__(/*! ../localization */ \"./node_modules/js-draw/dist/cjs/localization.js\");\n// German localization\nconst localization = {\n    ...localization_1.defaultEditorLocalization,\n    pen: 'Stift',\n    eraser: 'Radierer',\n    select: 'Auswahl',\n    handTool: 'Verschieben',\n    zoom: 'Vergrößerung',\n    image: 'Bild',\n    inputAltText: 'Alt-Text: ',\n    chooseFile: 'Wähle Datei: ',\n    submit: 'Absenden',\n    cancel: 'Abbrechen',\n    resetView: 'Ansicht zurücksetzen',\n    thicknessLabel: 'Dicke: ',\n    colorLabel: 'Farbe: ',\n    fontLabel: 'Schriftart: ',\n    textSize: 'Größe: ',\n    resizeImageToSelection: 'Bildgröße an Auswahl anpassen',\n    deleteSelection: 'Auswahl löschen',\n    duplicateSelection: 'Auswahl duplizieren',\n    undo: 'Rückgängig',\n    redo: 'Wiederholen',\n    pickColorFromScreen: 'Farbe von Bildschirm auswählen',\n    clickToPickColorAnnouncement: 'Klicke auf den Bildschirm, um eine Farbe auszuwählen',\n    selectionToolKeyboardShortcuts: 'Auswahl-Werkzeug: Verwende die Pfeiltasten, um ausgewählte Elemente zu verschieben und ‚i‘ und ‚o‘, um ihre Größe zu ändern.',\n    touchPanning: 'Ansicht mit Touchscreen verschieben',\n    anyDevicePanning: 'Ansicht mit jedem Eingabegerät verschieben',\n    selectPenType: 'Objekt-Typ: ',\n    roundedTipPen: 'Freihand',\n    flatTipPen: 'Stift (druckempfindlich)',\n    arrowPen: 'Pfeil',\n    linePen: 'Linie',\n    outlinedRectanglePen: 'Umrissenes Rechteck',\n    filledRectanglePen: 'Ausgefülltes Rechteck',\n    lockRotation: 'Sperre Rotation',\n    paste: 'Einfügen',\n    dropdownShown: (toolName) => `Dropdown-Menü für ${toolName} angezeigt`,\n    dropdownHidden: (toolName) => `Dropdown-Menü für ${toolName} versteckt`,\n    zoomLevel: (zoomPercent) => `Vergößerung: ${zoomPercent}%`,\n    colorChangedAnnouncement: (color) => `Farbe zu ${color} geändert`,\n    imageSize: (size, units) => `Bild-Größe: ${size} ${units}`,\n    imageLoadError: (message) => `Fehler beim Laden des Bildes: ${message}`,\n    errorImageHasZeroSize: 'Fehler: Bild hat Größe Null',\n    penTool: (penNumber) => `Stift ${penNumber}`,\n    selectionTool: 'Auswahl',\n    eraserTool: 'Radiergummi',\n    touchPanTool: 'Ansicht mit Touchscreen verschieben',\n    twoFingerPanZoomTool: 'Ansicht verschieben und vergrößern',\n    undoRedoTool: 'Rückgängig/Wiederholen',\n    rightClickDragPanTool: 'Rechtsklick-Ziehen',\n    pipetteTool: 'Farbe von Bildschirm auswählen',\n    keyboardPanZoom: 'Tastaturkürzel zum Verschieben/Vergrößern der Ansicht',\n    textTool: 'Text',\n    enterTextToInsert: 'Einzufügender Text',\n    changeTool: 'Wechsle Werkzeug',\n    pasteHandler: 'Copy-Paste-Handler',\n    findLabel: 'Finde',\n    toNextMatch: 'Nächstes',\n    closeDialog: 'Schließen',\n    findDialogShown: 'Finde-Dialog angezeigt',\n    findDialogHidden: 'Finde-Dialog versteckt',\n    focusedFoundText: (matchIdx, totalMatches) => `Sieh Treffer ${matchIdx} von ${totalMatches} an`,\n    toolEnabledAnnouncement: (toolName) => `${toolName} aktiviert`,\n    toolDisabledAnnouncement: (toolName) => `${toolName} deaktiviert`,\n    updatedViewport: 'Transformierte Ansicht',\n    transformedElements: (elemCount) => `${elemCount} Element${1 === elemCount ? '' : 'e'} transformiert`,\n    resizeOutputCommand: (newSize) => `Bildgröße auf ${newSize.w}x${newSize.h} geändert`,\n    addElementAction: (componentDescription) => `${componentDescription} hinzugefügt`,\n    eraseAction: (elemDescription, countErased) => `${countErased} ${elemDescription} gelöscht`,\n    duplicateAction: (elemDescription, countErased) => `${countErased} ${elemDescription} dupliziert`,\n    inverseOf: (actionDescription) => `${actionDescription} umgekehrt`,\n    elements: 'Elemente',\n    erasedNoElements: 'Nichts entfernt',\n    duplicatedNoElements: 'Nichts dupliziert',\n    rotatedBy: (degrees) => `${Math.abs(degrees)} Grad ${degrees < 0 ? 'im Uhrzeigersinn' : 'gegen den Uhrzeigersinn'} gedreht`,\n    movedLeft: 'Nacht links bewegt',\n    movedUp: 'Nacht oben bewegt',\n    movedDown: 'Nacht unten bewegt',\n    movedRight: 'Nacht rechts bewegt',\n    zoomedOut: 'Ansicht verkleinert',\n    zoomedIn: 'Ansicht vergrößert',\n    selectedElements: (count) => `${count} Element${1 === count ? '' : 'e'} ausgewählt`,\n    stroke: 'Strich',\n    svgObject: 'SVG-Objekt',\n    text: (text) => `Text-Objekt: ${text}`,\n    pathNodeCount: (count) => `Es gibt ${count} sichtbare Pfad-Objekte.`,\n    textNodeCount: (count) => `Es gibt ${count} sichtbare Text-Knotenpunkte.`,\n    textNode: (content) => `Text: ${content}`,\n    imageNodeCount: (nodeCount) => `Es gibt ${nodeCount} sichtbare Bild-Knoten.`,\n    imageNode: (label) => `Bild: ${label}`,\n    unlabeledImageNode: 'Bild ohne Label',\n    rerenderAsText: 'Als Text darstellen',\n    accessibilityInputInstructions: 'Drücke ‚t‘, um den Inhalt des Ansichtsfensters als Text zu lesen. Verwende die Pfeiltasten, um die Ansicht zu verschieben, und klicke und ziehe, um Striche zu zeichnen. Drücke ‚w‘ zum Vergrößern und ‚s‘ zum Verkleinern der Ansicht.',\n    loading: (percentage) => `Laden ${percentage}%...`,\n    doneLoading: 'Laden fertig',\n    imageEditor: 'Bild-Editor',\n    undoAnnouncement: (commandDescription) => `${commandDescription} rückgängig gemacht`,\n    redoAnnouncement: (commandDescription) => `${commandDescription} wiederholt`,\n    reformatSelection: 'Formatiere Auswahl',\n    documentProperties: 'Seite',\n    backgroundColor: 'Hintergrundfarbe: ',\n    imageWidthOption: 'Breite: ',\n    imageHeightOption: 'Höhe: ',\n    useGridOption: 'Gitter: ',\n    toggleOverflow: 'Mehr',\n    selectAllTool: 'Alle auswählen',\n    soundExplorer: 'Klangbasierte Bilderkundung',\n    disableAccessibilityExploreTool: 'Deaktiviere klangbasierte Erkundung',\n    enableAccessibilityExploreTool: 'Aktiviere klangbasierte Erkundung',\n    unionOf: (actionDescription, actionCount) => `Vereinigung: ${actionCount} ${actionDescription}`,\n    emptyBackground: 'Leerer Hintergrund',\n    filledBackgroundWithColor: (color) => `Gefüllter Hintergrund (${color})`,\n    restyledElement: (elementDescription) => `${elementDescription} umgestaltet`,\n};\nexports[\"default\"] = localization;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/localizations/de.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/localizations/en.js":
/*!***********************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/localizations/en.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst localization_1 = __webpack_require__(/*! ../localization */ \"./node_modules/js-draw/dist/cjs/localization.js\");\n// Default localizations are already in English.\nconst localization = {\n    ...localization_1.defaultEditorLocalization,\n};\nexports[\"default\"] = localization;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/localizations/en.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/localizations/es.js":
/*!***********************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/localizations/es.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst localization_1 = __webpack_require__(/*! ../localization */ \"./node_modules/js-draw/dist/cjs/localization.js\");\n// A partial Spanish localization\nconst localization = {\n    ...localization_1.defaultEditorLocalization,\n    pen: 'Lapiz',\n    eraser: 'Borrador',\n    select: 'Selecciona',\n    handTool: 'Mover',\n    image: 'Imagen',\n    inputAltText: 'Texto alternativo',\n    resetImage: 'Reiniciar',\n    chooseFile: 'Seleccionar archivo',\n    cancel: 'Cancelar',\n    resetView: 'Reiniciar vista',\n    thicknessLabel: 'Tamaño',\n    fontLabel: 'Fuente:',\n    textSize: 'Tamaño',\n    resizeImageToSelection: 'Redimensionar la imagen a lo que está seleccionado',\n    deleteSelection: 'Borra la selección',\n    duplicateSelection: 'Duplica la selección',\n    exit: 'Salir',\n    save: 'Guardar',\n    undo: 'Deshace',\n    redo: 'Rehace',\n    selectPenType: 'Punta',\n    selectShape: 'Forma',\n    pickColorFromScreen: 'Selecciona un color de la pantalla',\n    clickToPickColorAnnouncement: 'Haga un clic en la pantalla para seleccionar un color',\n    documentProperties: 'Fondo',\n    backgroundColor: 'Color de fondo',\n    imageWidthOption: 'Ancho',\n    imageHeightOption: 'Alto',\n    enableAutoresizeOption: 'Redimensionar automático',\n    toggleOverflow: 'Más',\n    about: 'Acerca de',\n    touchPanning: 'Mover la pantalla con un dedo',\n    roundedTipPen: 'Lapiz Redondeado',\n    arrowPen: 'Flecha',\n    linePen: 'Línea',\n    outlinedRectanglePen: 'Rectángulo delineado',\n    filledRectanglePen: 'Rectángulo sin borde',\n    lockRotation: 'Bloquea rotación',\n    paste: 'Pegar',\n    selectionMenu__paste: 'Pegar',\n    selectionMenu__delete: 'Eliminar',\n    selectionMenu__duplicate: 'Duplicar',\n    closeSidebar: (toolName) => `Close sidebar for ${toolName}`,\n    dropdownShown: (toolName) => `Menú por ${toolName} es visible`,\n    dropdownHidden: (toolName) => {\n        return `Menú por ${toolName} fue ocultado`;\n    },\n    zoomLevel: (zoomPercent) => `Zoom: ${zoomPercent}%`,\n    colorChangedAnnouncement: (color) => {\n        return `Color fue cambiado a ${color}`;\n    },\n    imageSize: (size, units) => `Tamaño del imagen: ${size} ${units}`,\n    imageLoadError: (message) => `Error cargando imagen: ${message}`,\n    penTool: (penId) => `Lapiz ${penId}`,\n    selectionTool: 'Selecciona',\n    eraserTool: 'Borrador',\n    touchPanTool: 'Instrumento de mover la pantalla con un dedo',\n    undoRedoTool: 'Deshace/rehace',\n    pipetteTool: 'Seleccione un color de la pantalla',\n    keyboardPanZoom: 'Mover la pantalla con el teclado',\n    textTool: 'Texto',\n    enterTextToInsert: 'Entra texto',\n    findLabel: 'Buscar',\n    toNextMatch: 'Próxima',\n    closeDialog: 'Cerrar',\n    anyDevicePanning: 'Mover la pantalla con todo dispotivo',\n    copied: (count) => `${count} cosas fueron copiados`,\n    pasted: (count) => (count === 1 ? 'Pegado' : `${count} cosas fueron pegados`),\n    toolEnabledAnnouncement: (toolName) => `${toolName} fue activado`,\n    toolDisabledAnnouncement: (toolName) => `${toolName} fue desactivado`,\n    resizeOutputCommand: (newSize) => `Tamaño de imagen fue cambiado a ${newSize.w}x${newSize.h}`,\n    eraseAction: (componentDescription, numElems) => `Borrado: ${numElems} ${componentDescription}`,\n    rerenderAsText: 'Redibuja la pantalla al texto',\n    loading: (percentage) => `Cargando: ${percentage}%...`,\n    imageEditor: 'Editor de dibujos',\n    doneLoading: 'El cargado terminó',\n    undoAnnouncement: (commandDescription) => `${commandDescription} fue deshecho`,\n    redoAnnouncement: (commandDescription) => `${commandDescription} fue rehecho`,\n};\nexports[\"default\"] = localization;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/localizations/es.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/localizations/getLocalizationTable.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/localizations/getLocalizationTable.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.matchingLocalizationTable = exports.allLocales = void 0;\nconst localization_1 = __webpack_require__(/*! ../localization */ \"./node_modules/js-draw/dist/cjs/localization.js\");\nconst de_1 = __importDefault(__webpack_require__(/*! ./de */ \"./node_modules/js-draw/dist/cjs/localizations/de.js\"));\nconst en_1 = __importDefault(__webpack_require__(/*! ./en */ \"./node_modules/js-draw/dist/cjs/localizations/en.js\"));\nconst es_1 = __importDefault(__webpack_require__(/*! ./es */ \"./node_modules/js-draw/dist/cjs/localizations/es.js\"));\nexports.allLocales = {\n    de: de_1.default,\n    en: en_1.default,\n    es: es_1.default,\n};\n// [locale]: A string in the format languageCode_Region or just languageCode. For example, en_US.\nconst languageFromLocale = (locale) => {\n    const matches = /^(\\w+)[_-](\\w+)$/.exec(locale);\n    if (!matches) {\n        // If not in languageCode_region format, the locale should be the\n        // languageCode. Return that.\n        return locale;\n    }\n    return matches[1];\n};\n/**\n * Return the localization table in `localizationTables` that best matches\n * the list of `userLocales`. If there is no matching language, returns\n * `defaultLocalizationTable`.\n */\nconst matchingLocalizationTable = (userLocales, localizationTables, defaultLocalizationTable) => {\n    let prevLanguage;\n    for (const locale of userLocales) {\n        const language = languageFromLocale(locale);\n        // If the specific localization of the language is not available, but\n        // a localization for the language is,\n        if (prevLanguage && language !== prevLanguage) {\n            if (prevLanguage in localizationTables) {\n                return localizationTables[prevLanguage];\n            }\n        }\n        // If the full locale (e.g. en_US) is available,\n        if (locale in localizationTables) {\n            return localizationTables[locale];\n        }\n        prevLanguage = language;\n    }\n    if (prevLanguage && prevLanguage in localizationTables) {\n        return localizationTables[prevLanguage];\n    }\n    else {\n        return defaultLocalizationTable;\n    }\n};\nexports.matchingLocalizationTable = matchingLocalizationTable;\n/**\n * Returns a localization table for the `Editor` that matches\n * the user's current locale.\n *\n * Returns the default localization table if no appropriate localization\n * exists.\n */\nconst getLocalizationTable = (userLocales) => {\n    userLocales ??= navigator.languages;\n    return (0, exports.matchingLocalizationTable)(userLocales, exports.allLocales, localization_1.defaultEditorLocalization);\n};\nexports[\"default\"] = getLocalizationTable;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/localizations/getLocalizationTable.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/rendering/Display.js":
/*!************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/rendering/Display.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RenderingMode = void 0;\nconst CanvasRenderer_1 = __importDefault(__webpack_require__(/*! ./renderers/CanvasRenderer */ \"./node_modules/js-draw/dist/cjs/rendering/renderers/CanvasRenderer.js\"));\nconst types_1 = __webpack_require__(/*! ../types */ \"./node_modules/js-draw/dist/cjs/types.js\");\nconst DummyRenderer_1 = __importDefault(__webpack_require__(/*! ./renderers/DummyRenderer */ \"./node_modules/js-draw/dist/cjs/rendering/renderers/DummyRenderer.js\"));\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\nconst RenderingCache_1 = __importDefault(__webpack_require__(/*! ./caching/RenderingCache */ \"./node_modules/js-draw/dist/cjs/rendering/caching/RenderingCache.js\"));\nconst TextOnlyRenderer_1 = __importDefault(__webpack_require__(/*! ./renderers/TextOnlyRenderer */ \"./node_modules/js-draw/dist/cjs/rendering/renderers/TextOnlyRenderer.js\"));\nvar RenderingMode;\n(function (RenderingMode) {\n    RenderingMode[RenderingMode[\"DummyRenderer\"] = 0] = \"DummyRenderer\";\n    RenderingMode[RenderingMode[\"CanvasRenderer\"] = 1] = \"CanvasRenderer\";\n    // SVGRenderer is not supported by the main display\n})(RenderingMode || (exports.RenderingMode = RenderingMode = {}));\n/**\n * Handles `HTMLCanvasElement`s (or other drawing surfaces if being used) used to display the editor's contents.\n *\n * @example\n * ```\n * const editor = new Editor(document.body);\n * const w = editor.display.width;\n * const h = editor.display.height;\n * const center = Vec2.of(w / 2, h / 2);\n * const colorAtCenter = editor.display.getColorAt(center);\n * ```\n */\nclass Display {\n    /** @internal */\n    constructor(editor, mode, parent) {\n        this.editor = editor;\n        this.parent = parent;\n        this.textRerenderOutput = null;\n        this.devicePixelRatio = window.devicePixelRatio ?? 1;\n        /**\n         * @returns the color at the given point on the dry ink renderer, or `null` if `screenPos`\n         * \tis not on the display.\n         */\n        this.getColorAt = (_screenPos) => {\n            return null;\n        };\n        if (mode === RenderingMode.CanvasRenderer) {\n            this.initializeCanvasRendering();\n        }\n        else if (mode === RenderingMode.DummyRenderer) {\n            this.dryInkRenderer = new DummyRenderer_1.default(editor.viewport);\n            this.wetInkRenderer = new DummyRenderer_1.default(editor.viewport);\n        }\n        else {\n            throw new Error(`Unknown rendering mode, ${mode}!`);\n        }\n        this.textRenderer = new TextOnlyRenderer_1.default(editor.viewport, editor.localization);\n        this.initializeTextRendering();\n        const cacheBlockResolution = math_1.Vec2.of(600, 600);\n        this.cache = new RenderingCache_1.default({\n            createRenderer: () => {\n                if (mode === RenderingMode.DummyRenderer) {\n                    return new DummyRenderer_1.default(editor.viewport);\n                }\n                else if (mode !== RenderingMode.CanvasRenderer) {\n                    throw new Error('Unspported rendering mode');\n                }\n                // Make the canvas slightly larger than each cache block to prevent\n                // seams.\n                const canvas = document.createElement('canvas');\n                canvas.width = cacheBlockResolution.x + 1;\n                canvas.height = cacheBlockResolution.y + 1;\n                const ctx = canvas.getContext('2d');\n                return new CanvasRenderer_1.default(ctx, editor.viewport);\n            },\n            isOfCorrectType: (renderer) => {\n                return this.dryInkRenderer.canRenderFromWithoutDataLoss(renderer);\n            },\n            blockResolution: cacheBlockResolution,\n            cacheSize: 600 * 600 * 4 * 90,\n            // On higher resolution displays, don't scale cache blocks as much to decrease blurriness.\n            // TODO: Decrease the minimum cache scale as well.\n            maxScale: Math.max(1, 1.3 / window.devicePixelRatio),\n            // Require about 20 strokes with 4 parts each to cache an image in one of the\n            // parts of the cache grid.\n            minProportionalRenderTimePerCache: 20 * 4,\n            // Require about 105 strokes with 4 parts each to use the cache at all.\n            minProportionalRenderTimeToUseCache: 105 * 4,\n        });\n        this.editor.notifier.on(types_1.EditorEventType.DisplayResized, (event) => {\n            if (event.kind !== types_1.EditorEventType.DisplayResized) {\n                throw new Error('Mismatched event.kinds!');\n            }\n            this.resizeSurfacesCallback?.();\n        });\n    }\n    /**\n     * @returns the visible width of the display (e.g. how much\n     * space the display's element takes up in the x direction\n     * in the DOM).\n     */\n    get width() {\n        return this.dryInkRenderer.displaySize().x;\n    }\n    /** @returns the visible height of the display. See {@link width}. */\n    get height() {\n        return this.dryInkRenderer.displaySize().y;\n    }\n    /** @internal */\n    getCache() {\n        return this.cache;\n    }\n    initializeCanvasRendering() {\n        const dryInkCanvas = document.createElement('canvas');\n        const wetInkCanvas = document.createElement('canvas');\n        const dryInkCtx = dryInkCanvas.getContext('2d');\n        const wetInkCtx = wetInkCanvas.getContext('2d');\n        this.dryInkRenderer = new CanvasRenderer_1.default(dryInkCtx, this.editor.viewport);\n        this.wetInkRenderer = new CanvasRenderer_1.default(wetInkCtx, this.editor.viewport);\n        dryInkCanvas.className = 'dryInkCanvas';\n        wetInkCanvas.className = 'wetInkCanvas';\n        if (this.parent) {\n            this.parent.appendChild(dryInkCanvas);\n            this.parent.appendChild(wetInkCanvas);\n        }\n        this.resizeSurfacesCallback = () => {\n            const expectedWidth = (canvas) => {\n                const widthInPixels = Math.ceil(canvas.clientWidth * this.devicePixelRatio);\n                // Avoid setting the canvas width to zero -- doing so can cause errors when attempting\n                // to use the canvas:\n                return widthInPixels || canvas.width;\n            };\n            const expectedHeight = (canvas) => {\n                const heightInPixels = Math.ceil(canvas.clientHeight * this.devicePixelRatio);\n                return heightInPixels || canvas.height; // Zero-size canvases can cause errors.\n            };\n            const hasSizeMismatch = (canvas) => {\n                return expectedHeight(canvas) !== canvas.height || expectedWidth(canvas) !== canvas.width;\n            };\n            // Ensure that the drawing surfaces sizes match the\n            // canvas' sizes to prevent stretching.\n            if (hasSizeMismatch(dryInkCanvas) || hasSizeMismatch(wetInkCanvas)) {\n                dryInkCanvas.width = expectedWidth(dryInkCanvas);\n                dryInkCanvas.height = expectedHeight(dryInkCanvas);\n                wetInkCanvas.width = expectedWidth(wetInkCanvas);\n                wetInkCanvas.height = expectedHeight(wetInkCanvas);\n                // Ensure correct drawing operations on high-resolution screens.\n                // See\n                // https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Optimizing_canvas#scaling_for_high_resolution_displays\n                //\n                // This scaling causes the rendering contexts to automatically convert\n                // between screen coordinates and pixel coordinates.\n                wetInkCtx.resetTransform();\n                dryInkCtx.resetTransform();\n                dryInkCtx.scale(this.devicePixelRatio, this.devicePixelRatio);\n                wetInkCtx.scale(this.devicePixelRatio, this.devicePixelRatio);\n                this.editor.notifier.dispatch(types_1.EditorEventType.DisplayResized, {\n                    kind: types_1.EditorEventType.DisplayResized,\n                    newSize: math_1.Vec2.of(this.width, this.height),\n                });\n            }\n        };\n        this.resizeSurfacesCallback();\n        this.flattenCallback = () => {\n            dryInkCtx.save();\n            dryInkCtx.resetTransform();\n            dryInkCtx.drawImage(wetInkCanvas, 0, 0);\n            dryInkCtx.restore();\n        };\n        this.getColorAt = (screenPos) => {\n            // getImageData isn't affected by a transformation matrix -- we need to\n            // pre-transform screenPos to convert it from screen coordinates into pixel\n            // coordinates.\n            const adjustedScreenPos = screenPos.times(this.devicePixelRatio);\n            const pixel = dryInkCtx.getImageData(adjustedScreenPos.x, adjustedScreenPos.y, 1, 1);\n            const data = pixel?.data;\n            if (data) {\n                const color = math_1.Color4.ofRGBA(data[0] / 255, data[1] / 255, data[2] / 255, data[3] / 255);\n                return color;\n            }\n            return null;\n        };\n    }\n    initializeTextRendering() {\n        const textRendererOutputContainer = document.createElement('div');\n        textRendererOutputContainer.classList.add('textRendererOutputContainer');\n        const rerenderButton = document.createElement('button');\n        rerenderButton.classList.add('rerenderButton');\n        rerenderButton.innerText = this.editor.localization.rerenderAsText;\n        this.textRerenderOutput = document.createElement('div');\n        this.textRerenderOutput.setAttribute('aria-live', 'polite');\n        rerenderButton.onclick = () => {\n            this.rerenderAsText();\n        };\n        textRendererOutputContainer.replaceChildren(rerenderButton, this.textRerenderOutput);\n        this.editor.createHTMLOverlay(textRendererOutputContainer);\n    }\n    /**\n     * Sets the device-pixel-ratio.\n     *\n     * Intended for debugging. Users do not need to call this manually.\n     *\n     * @internal\n     */\n    setDevicePixelRatio(dpr) {\n        const minDpr = 0.001;\n        const maxDpr = 10;\n        if (isFinite(dpr) && dpr >= minDpr && dpr <= maxDpr && dpr !== this.devicePixelRatio) {\n            this.devicePixelRatio = dpr;\n            this.resizeSurfacesCallback?.();\n            return this.editor.queueRerender();\n        }\n        return undefined;\n    }\n    /** @internal */\n    getDevicePixelRatio() {\n        return this.devicePixelRatio;\n    }\n    /**\n     * Rerenders the text-based display.\n     * The text-based display is intended for screen readers and can be navigated to by pressing `tab`.\n     */\n    rerenderAsText() {\n        this.textRenderer.clear();\n        this.editor.image.render(this.textRenderer, this.editor.viewport);\n        if (this.textRerenderOutput) {\n            this.textRerenderOutput.innerText = this.textRenderer.getDescription();\n        }\n    }\n    /**\n     * Clears the main drawing surface and otherwise prepares for a rerender.\n     *\n     * @returns the dry ink renderer.\n     */\n    startRerender() {\n        this.resizeSurfacesCallback?.();\n        this.dryInkRenderer.clear();\n        return this.dryInkRenderer;\n    }\n    /**\n     * If `draftMode`, the dry ink renderer is configured to render\n     * low-quality output.\n     */\n    setDraftMode(draftMode) {\n        this.dryInkRenderer.setDraftMode(draftMode);\n    }\n    /** @internal */\n    getDryInkRenderer() {\n        return this.dryInkRenderer;\n    }\n    /**\n     * @returns The renderer used for showing action previews (e.g. an unfinished stroke).\n     * The `wetInkRenderer`'s surface is stacked above the `dryInkRenderer`'s.\n     */\n    getWetInkRenderer() {\n        return this.wetInkRenderer;\n    }\n    /** Re-renders the contents of the wetInkRenderer onto the dryInkRenderer. */\n    flatten() {\n        this.flattenCallback?.();\n    }\n}\nexports[\"default\"] = Display;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/rendering/Display.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/rendering/RenderablePathSpec.js":
/*!***********************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/rendering/RenderablePathSpec.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.visualEquivalent = exports.simplifyPathToFullScreenOrEmpty = exports.pathToRenderable = exports.pathFromRenderable = void 0;\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\n/** Converts a renderable path (a path with a `startPoint`, `commands`, and `style`). */\nconst pathFromRenderable = (renderable) => {\n    if (renderable.path) {\n        return renderable.path;\n    }\n    return new math_1.Path(renderable.startPoint, renderable.commands);\n};\nexports.pathFromRenderable = pathFromRenderable;\n/**\n * Converts `path` into a format that can be rendered (by passing to a {@link Stroke} constructor\n * or directly to an {@link AbstractRenderer.drawPath}).\n */\nconst pathToRenderable = (path, style) => {\n    return {\n        startPoint: path.startPoint,\n        style,\n        commands: path.parts,\n        path,\n    };\n};\nexports.pathToRenderable = pathToRenderable;\n/**\n * Fills the optional `path` field in `RenderablePathSpec`\n * with `path` if not already filled\n */\nconst pathIncluded = (renderablePath, path) => {\n    if (renderablePath.path) {\n        return renderablePath;\n    }\n    return {\n        ...renderablePath,\n        path,\n    };\n};\n/**\n * Tries to simplify the given path to a fullscreen rectangle.\n * Returns `null` on failure.\n *\n * @internal\n */\nconst simplifyPathToFullScreenOrEmpty = (renderablePath, visibleRect, options = {\n    fastCheck: true,\n    expensiveCheck: true,\n}) => {\n    const path = (0, exports.pathFromRenderable)(renderablePath);\n    const strokeWidth = renderablePath.style.stroke?.width ?? 0;\n    const onlyStroked = strokeWidth > 0 && renderablePath.style.fill.a === 0;\n    const styledPathBBox = path.bbox.grownBy(strokeWidth);\n    // Are we close enough to the path that it fills the entire screen?\n    const isOnlyStrokedAndCouldFillScreen = onlyStroked &&\n        strokeWidth > visibleRect.maxDimension &&\n        styledPathBBox.containsRect(visibleRect);\n    if (options.fastCheck && isOnlyStrokedAndCouldFillScreen && renderablePath.style.stroke) {\n        const strokeRadius = strokeWidth / 2;\n        // Are we completely within the stroke?\n        // Do a fast, but with many false negatives, check.\n        for (const point of path.startEndPoints()) {\n            // If within the strokeRadius of any point\n            if (visibleRect.isWithinRadiusOf(strokeRadius, point)) {\n                return {\n                    rectangle: visibleRect,\n                    path: (0, exports.pathToRenderable)(math_1.Path.fromRect(visibleRect), {\n                        fill: renderablePath.style.stroke.color,\n                    }),\n                    fullScreen: true,\n                };\n            }\n        }\n    }\n    // Try filtering again, but with slightly more expensive checks\n    if (options.expensiveCheck &&\n        isOnlyStrokedAndCouldFillScreen &&\n        renderablePath.style.stroke &&\n        strokeWidth > visibleRect.maxDimension * 3) {\n        const signedDist = path.signedDistance(visibleRect.center, strokeWidth / 2);\n        const margin = strokeWidth / 6;\n        if (signedDist < -visibleRect.maxDimension / 2 - margin) {\n            return {\n                path: (0, exports.pathToRenderable)(math_1.Path.fromRect(visibleRect), {\n                    fill: renderablePath.style.stroke.color,\n                }),\n                rectangle: visibleRect,\n                fullScreen: true,\n            };\n        }\n        else if (signedDist > visibleRect.maxDimension / 2 + margin) {\n            return {\n                path: (0, exports.pathToRenderable)(math_1.Path.empty, { fill: math_1.Color4.transparent }),\n                rectangle: math_1.Rect2.empty,\n                fullScreen: false,\n            };\n        }\n    }\n    return null;\n};\nexports.simplifyPathToFullScreenOrEmpty = simplifyPathToFullScreenOrEmpty;\n/**\n * @returns a Path that, when rendered, looks roughly equivalent to the given path.\n */\nconst visualEquivalent = (renderablePath, visibleRect) => {\n    const path = (0, exports.pathFromRenderable)(renderablePath);\n    const strokeWidth = renderablePath.style.stroke?.width ?? 0;\n    const onlyStroked = strokeWidth > 0 && renderablePath.style.fill.a === 0;\n    const styledPathBBox = path.bbox.grownBy(strokeWidth);\n    let rectangleSimplification = (0, exports.simplifyPathToFullScreenOrEmpty)(renderablePath, visibleRect, {\n        fastCheck: true,\n        expensiveCheck: false,\n    });\n    if (rectangleSimplification) {\n        return rectangleSimplification.path;\n    }\n    // Scale the expanded rect --- the visual equivalent is only close for huge strokes.\n    const expandedRect = visibleRect\n        .grownBy(strokeWidth)\n        .transformedBoundingBox(math_1.Mat33.scaling2D(4, visibleRect.center));\n    // TODO: Handle simplifying very small paths.\n    if (expandedRect.containsRect(styledPathBBox)) {\n        return pathIncluded(renderablePath, path);\n    }\n    const parts = [];\n    let startPoint = path.startPoint;\n    for (const part of path.parts) {\n        const partBBox = math_1.Path.computeBBoxForSegment(startPoint, part).grownBy(strokeWidth);\n        let endPoint;\n        if (part.kind === math_1.PathCommandType.LineTo || part.kind === math_1.PathCommandType.MoveTo) {\n            endPoint = part.point;\n        }\n        else {\n            endPoint = part.endPoint;\n        }\n        const intersectsVisible = partBBox.intersects(visibleRect);\n        if (intersectsVisible) {\n            // TODO: Can we trim parts of paths that intersect the visible rectangle?\n            parts.push(part);\n        }\n        else if (onlyStroked || part.kind === math_1.PathCommandType.MoveTo) {\n            // We're stroking (not filling) and the path doesn't intersect the bounding box.\n            // Don't draw it, but preserve the endpoints.\n            parts.push({\n                kind: math_1.PathCommandType.MoveTo,\n                point: endPoint,\n            });\n        }\n        else {\n            // Otherwise, we may be filling. Try to roughly preserve the filled region.\n            parts.push({\n                kind: math_1.PathCommandType.LineTo,\n                point: endPoint,\n            });\n        }\n        startPoint = endPoint;\n    }\n    const newPath = new math_1.Path(path.startPoint, parts);\n    const newStyle = renderablePath.style;\n    rectangleSimplification = (0, exports.simplifyPathToFullScreenOrEmpty)(renderablePath, visibleRect, {\n        fastCheck: false,\n        expensiveCheck: true,\n    });\n    if (rectangleSimplification) {\n        return rectangleSimplification.path;\n    }\n    return (0, exports.pathToRenderable)(newPath, newStyle);\n};\nexports.visualEquivalent = visualEquivalent;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/rendering/RenderablePathSpec.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/rendering/RenderingStyle.js":
/*!*******************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/rendering/RenderingStyle.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.styleFromJSON = exports.styleToJSON = exports.stylesEqual = exports.cloneStyle = void 0;\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\nconst cloneStyle = (style) => {\n    return {\n        fill: style.fill,\n        stroke: style.stroke\n            ? {\n                ...style.stroke,\n            }\n            : undefined,\n    };\n};\nexports.cloneStyle = cloneStyle;\nconst stylesEqual = (a, b) => {\n    const result = a === b ||\n        (a.fill.eq(b.fill) &&\n            (a.stroke == undefined) === (b.stroke == undefined) &&\n            (a.stroke?.color?.eq(b.stroke?.color) ?? true) &&\n            a.stroke?.width === b.stroke?.width);\n    // Map undefined/null -> false\n    return result ?? false;\n};\nexports.stylesEqual = stylesEqual;\n// Returns an object that can be converted to a JSON string with\n// JSON.stringify.\nconst styleToJSON = (style) => {\n    const stroke = !style.stroke\n        ? undefined\n        : {\n            color: style.stroke.color.toHexString(),\n            width: style.stroke.width,\n        };\n    return {\n        fill: style.fill.toHexString(),\n        stroke,\n    };\n};\nexports.styleToJSON = styleToJSON;\nconst styleFromJSON = (json) => {\n    const stroke = json.stroke\n        ? {\n            color: math_1.Color4.fromHex(json.stroke.color),\n            width: json.stroke.width,\n        }\n        : undefined;\n    return {\n        fill: math_1.Color4.fromHex(json.fill),\n        stroke,\n    };\n};\nexports.styleFromJSON = styleFromJSON;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/rendering/RenderingStyle.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/rendering/TextRenderingStyle.js":
/*!***********************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/rendering/TextRenderingStyle.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.textStyleToJSON = exports.textStyleFromJSON = exports.cloneTextStyle = void 0;\nconst RenderingStyle_1 = __webpack_require__(/*! ./RenderingStyle */ \"./node_modules/js-draw/dist/cjs/rendering/RenderingStyle.js\");\nconst cloneTextStyle = (style) => {\n    return {\n        ...style,\n        renderingStyle: (0, RenderingStyle_1.cloneStyle)(style.renderingStyle),\n    };\n};\nexports.cloneTextStyle = cloneTextStyle;\n/** `json` can either be a `string` or an `object`. */\nconst textStyleFromJSON = (json) => {\n    if (typeof json === 'string') {\n        json = JSON.parse(json);\n    }\n    if (typeof json.fontFamily !== 'string') {\n        throw new Error('Serialized textStyle missing string fontFamily attribute!');\n    }\n    const style = {\n        renderingStyle: (0, RenderingStyle_1.styleFromJSON)(json.renderingStyle),\n        size: json.size,\n        fontWeight: json.fontWeight,\n        fontVariant: json.fontVariant,\n        fontFamily: json.fontFamily,\n    };\n    return style;\n};\nexports.textStyleFromJSON = textStyleFromJSON;\nconst textStyleToJSON = (style) => {\n    return {\n        ...style,\n        renderingStyle: (0, RenderingStyle_1.styleToJSON)(style.renderingStyle),\n    };\n};\nexports.textStyleToJSON = textStyleToJSON;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/rendering/TextRenderingStyle.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/rendering/caching/CacheRecord.js":
/*!************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/rendering/caching/CacheRecord.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\n// Represents a cached renderer/canvas\n// This is not a [CacheNode] -- it handles cached renderers and does not have sub-renderers.\nclass CacheRecord {\n    constructor(onBeforeDeallocCallback, cacheState) {\n        this.onBeforeDeallocCallback = onBeforeDeallocCallback;\n        this.cacheState = cacheState;\n        this.allocd = false;\n        // For debugging\n        this.allocCount = 0;\n        this.renderer = cacheState.props.createRenderer();\n        this.lastUsedCycle = -1;\n        this.allocd = true;\n    }\n    startRender() {\n        this.lastUsedCycle = this.cacheState.currentRenderingCycle;\n        if (!this.allocd) {\n            throw new Error(\"Only alloc'd canvases can be rendered to\");\n        }\n        return this.renderer;\n    }\n    dealloc() {\n        this.onBeforeDeallocCallback?.();\n        this.allocd = false;\n        this.onBeforeDeallocCallback = null;\n        this.lastUsedCycle = 0;\n    }\n    isAllocd() {\n        return this.allocd;\n    }\n    realloc(newDeallocCallback) {\n        if (this.allocd) {\n            this.dealloc();\n        }\n        this.allocd = true;\n        this.onBeforeDeallocCallback = newDeallocCallback;\n        this.lastUsedCycle = this.cacheState.currentRenderingCycle;\n        this.allocCount++;\n    }\n    getLastUsedCycle() {\n        return this.lastUsedCycle;\n    }\n    // Returns the transformation that maps [drawTo] to this' renderable region\n    // (i.e. a [cacheProps.blockResolution]-sized rectangle with top left at (0, 0))\n    getTransform(drawTo) {\n        const transform = math_1.Mat33.scaling2D(this.cacheState.props.blockResolution.x / drawTo.size.x).rightMul(math_1.Mat33.translation(drawTo.topLeft.times(-1)));\n        return transform;\n    }\n    setRenderingRegion(drawTo) {\n        const transform = this.getTransform(drawTo);\n        this.renderer.setTransform(transform);\n        // The visible region may be slightly larger than where we're actually drawing\n        // to (because of rounding).\n        this.renderer.overrideVisibleRect(drawTo.grownBy(1 / transform.getScaleFactor()));\n    }\n}\nexports[\"default\"] = CacheRecord;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/rendering/caching/CacheRecord.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/rendering/caching/CacheRecordManager.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/rendering/caching/CacheRecordManager.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CacheRecordManager = void 0;\nconst CacheRecord_1 = __importDefault(__webpack_require__(/*! ./CacheRecord */ \"./node_modules/js-draw/dist/cjs/rendering/caching/CacheRecord.js\"));\nclass CacheRecordManager {\n    constructor(cacheProps) {\n        // Fixed-size array: Cache blocks are assigned indicies into [cachedCanvases].\n        this.cacheRecords = [];\n        this.maxCanvases = Math.ceil(\n        // Assuming four components per pixel:\n        cacheProps.cacheSize / 4 / cacheProps.blockResolution.x / cacheProps.blockResolution.y);\n    }\n    setSharedState(state) {\n        this.cacheState = state;\n    }\n    allocCanvas(drawTo, onDealloc) {\n        if (this.cacheRecords.length < this.maxCanvases) {\n            const record = new CacheRecord_1.default(onDealloc, this.cacheState);\n            record.setRenderingRegion(drawTo);\n            this.cacheRecords.push(record);\n            if (this.cacheState.debugMode) {\n                console.log('[Cache] Cache spaces used: ', this.cacheRecords.length, ' of ', this.maxCanvases);\n            }\n            return record;\n        }\n        else {\n            const lru = this.getLeastRecentlyUsedRecord();\n            if (this.cacheState.debugMode) {\n                console.log('[Cache] Re-alloc. Times allocated: ', lru.allocCount, '\\nLast used cycle: ', lru.getLastUsedCycle(), '\\nCurrent cycle: ', this.cacheState.currentRenderingCycle);\n            }\n            lru.realloc(onDealloc);\n            lru.setRenderingRegion(drawTo);\n            if (this.cacheState.debugMode) {\n                console.log(\"[Cache] Now re-alloc'd. Last used cycle: \", lru.getLastUsedCycle());\n                console.assert(lru['cacheState'] === this.cacheState, '[Cache] Unequal cache states! cacheState should be a shared object!');\n            }\n            return lru;\n        }\n    }\n    // Returns null if there are no cache records. Returns an unalloc'd record if one exists.\n    getLeastRecentlyUsedRecord() {\n        this.cacheRecords.sort((a, b) => a.getLastUsedCycle() - b.getLastUsedCycle());\n        return this.cacheRecords[0];\n    }\n    // Returns information to (hopefully) help debug performance issues\n    getDebugInfo() {\n        let numberAllocd = 0;\n        let averageReassignedCount = 0;\n        for (const cacheRecord of this.cacheRecords) {\n            averageReassignedCount += cacheRecord.allocCount;\n            if (cacheRecord.isAllocd()) {\n                numberAllocd++;\n            }\n        }\n        averageReassignedCount /= Math.max(this.cacheRecords.length, 1);\n        const debugInfo = [\n            `${this.cacheRecords.length} cache records (max ${this.maxCanvases})`,\n            `${numberAllocd} assigned to screen regions`,\n            `Average number of times reassigned: ${Math.round(averageReassignedCount * 100) / 100}`,\n        ];\n        return debugInfo.join('\\n');\n    }\n}\nexports.CacheRecordManager = CacheRecordManager;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/rendering/caching/CacheRecordManager.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/rendering/caching/RenderingCache.js":
/*!***************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/rendering/caching/RenderingCache.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\nconst RenderingCacheNode_1 = __importDefault(__webpack_require__(/*! ./RenderingCacheNode */ \"./node_modules/js-draw/dist/cjs/rendering/caching/RenderingCacheNode.js\"));\nconst CacheRecordManager_1 = __webpack_require__(/*! ./CacheRecordManager */ \"./node_modules/js-draw/dist/cjs/rendering/caching/CacheRecordManager.js\");\nclass RenderingCache {\n    constructor(cacheProps) {\n        this.recordManager = new CacheRecordManager_1.CacheRecordManager(cacheProps);\n        this.sharedState = {\n            props: cacheProps,\n            currentRenderingCycle: 0,\n            recordManager: this.recordManager,\n            debugMode: false,\n        };\n        this.recordManager.setSharedState(this.sharedState);\n    }\n    render(screenRenderer, image, viewport) {\n        const visibleRect = viewport.visibleRect;\n        this.sharedState.currentRenderingCycle++;\n        // If we can't use the cache,\n        if (!this.sharedState.props.isOfCorrectType(screenRenderer)) {\n            image.render(screenRenderer, visibleRect);\n            return;\n        }\n        if (!this.rootNode) {\n            // Adjust the node so that it has the correct aspect ratio\n            const res = this.sharedState.props.blockResolution;\n            const topLeft = visibleRect.topLeft;\n            this.rootNode = new RenderingCacheNode_1.default(new math_1.Rect2(topLeft.x, topLeft.y, res.x, res.y), this.sharedState);\n        }\n        while (!this.rootNode.region.containsRect(visibleRect)) {\n            this.rootNode = this.rootNode.generateParent();\n        }\n        this.rootNode = this.rootNode.smallestChildContaining(visibleRect) ?? this.rootNode;\n        const visibleLeaves = image.getLeavesIntersectingRegion(viewport.visibleRect, (rect) => screenRenderer.isTooSmallToRender(rect));\n        let approxVisibleRenderTime = 0;\n        for (const leaf of visibleLeaves) {\n            approxVisibleRenderTime += leaf.getContent().getProportionalRenderingTime();\n        }\n        if (approxVisibleRenderTime > this.sharedState.props.minProportionalRenderTimeToUseCache) {\n            this.rootNode.renderItems(screenRenderer, [image], viewport);\n        }\n        else {\n            image.render(screenRenderer, visibleRect);\n        }\n    }\n    getDebugInfo() {\n        return this.recordManager.getDebugInfo();\n    }\n    setIsDebugMode(debugMode) {\n        this.sharedState.debugMode = debugMode;\n    }\n}\nexports[\"default\"] = RenderingCache;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/rendering/caching/RenderingCache.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/rendering/caching/RenderingCacheNode.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/rendering/caching/RenderingCacheNode.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// A cache record with sub-nodes.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst EditorImage_1 = __webpack_require__(/*! ../../image/EditorImage */ \"./node_modules/js-draw/dist/cjs/image/EditorImage.js\");\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\n// 3x3 divisions for each node.\nconst cacheDivisionSize = 3;\nclass RenderingCacheNode {\n    constructor(region, cacheState) {\n        this.region = region;\n        this.cacheState = cacheState;\n        // invariant: instantiatedChildren.length === 9\n        this.instantiatedChildren = [];\n        this.parent = null;\n        this.cachedRenderer = null;\n        // invariant: sortedInAscendingOrder(renderedIds)\n        this.renderedIds = [];\n        this.renderedMaxZIndex = null;\n    }\n    // Creates a previous layer of the cache tree and adds this as a child near the\n    // center of the previous layer's children.\n    // Returns this' parent if it already exists.\n    generateParent() {\n        if (this.parent) {\n            return this.parent;\n        }\n        const parentRegion = math_1.Rect2.fromCorners(this.region.topLeft.minus(this.region.size), this.region.bottomRight.plus(this.region.size));\n        const parent = new RenderingCacheNode(parentRegion, this.cacheState);\n        parent.generateChildren();\n        // Ensure the new node is matches the middle child's region.\n        const checkTolerance = this.region.maxDimension / 100;\n        const middleChildIdx = (parent.instantiatedChildren.length - 1) / 2;\n        if (!parent.instantiatedChildren[middleChildIdx].region.eq(this.region, checkTolerance)) {\n            console.error(parent.instantiatedChildren[middleChildIdx].region, '≠', this.region);\n            throw new Error(\"Logic error: [this] is not contained within its parent's center child\");\n        }\n        // Replace the middle child\n        parent.instantiatedChildren[middleChildIdx] = this;\n        this.parent = parent;\n        return parent;\n    }\n    // Generates children, if missing.\n    generateChildren() {\n        if (this.instantiatedChildren.length === 0) {\n            if (this.region.size.x / cacheDivisionSize === 0 ||\n                this.region.size.y / cacheDivisionSize === 0) {\n                console.warn('Cache element has zero size! Not generating children.');\n                return;\n            }\n            const childRects = this.region.divideIntoGrid(cacheDivisionSize, cacheDivisionSize);\n            console.assert(childRects.length === cacheDivisionSize * cacheDivisionSize, 'Warning: divideIntoGrid created the wrong number of subrectangles!');\n            for (const rect of childRects) {\n                const child = new RenderingCacheNode(rect, this.cacheState);\n                child.parent = this;\n                this.instantiatedChildren.push(child);\n            }\n        }\n        this.checkRep();\n    }\n    // Returns CacheNodes directly contained within this.\n    getChildren() {\n        this.checkRep();\n        this.generateChildren();\n        return this.instantiatedChildren;\n    }\n    smallestChildContaining(rect) {\n        const largerThanChildren = rect.maxDimension > this.region.maxDimension / cacheDivisionSize;\n        if (!this.region.containsRect(rect) || largerThanChildren) {\n            return null;\n        }\n        for (const child of this.getChildren()) {\n            if (child.region.containsRect(rect)) {\n                return child.smallestChildContaining(rect) ?? child;\n            }\n        }\n        return null;\n    }\n    // => [true] iff [this] can be rendered without too much scaling\n    renderingWouldBeHighEnoughResolution(viewport) {\n        // Determine how 1px in this corresponds to 1px on the canvas.\n        //  this.region.w is in canvas units. Thus,\n        const sizeOfThisPixelOnCanvas = this.region.w / this.cacheState.props.blockResolution.x;\n        const sizeOfThisPixelOnScreen = viewport.getScaleFactor() * sizeOfThisPixelOnCanvas;\n        if (sizeOfThisPixelOnScreen > this.cacheState.props.maxScale) {\n            return false;\n        }\n        return true;\n    }\n    // => [true] if all children of this can be rendered from their caches.\n    allChildrenCanRender(viewport, leavesSortedById) {\n        if (this.instantiatedChildren.length === 0) {\n            return false;\n        }\n        for (const child of this.instantiatedChildren) {\n            if (!child.region.intersects(viewport.visibleRect)) {\n                continue;\n            }\n            if (!child.renderingIsUpToDate(this.idsOfIntersecting(leavesSortedById))) {\n                return false;\n            }\n        }\n        return true;\n    }\n    computeSortedByLeafIds(leaves) {\n        const ids = leaves.slice();\n        ids.sort((a, b) => a.getId() - b.getId());\n        return ids;\n    }\n    // Returns a list of the ids of the nodes intersecting this\n    idsOfIntersecting(nodes) {\n        const result = [];\n        for (const node of nodes) {\n            if (node.getBBox().intersects(this.region)) {\n                result.push(node.getId());\n            }\n        }\n        return result;\n    }\n    // Returns true iff all elems of this.renderedIds are in sortedIds.\n    // sortedIds should be sorted by z-index (or some other order, so long as they are\n    // sorted by the same thing as this.renderedIds.)\n    allRenderedIdsIn(sortedIds) {\n        if (this.renderedIds.length > sortedIds.length) {\n            return false;\n        }\n        for (let i = 0; i < this.renderedIds.length; i++) {\n            if (sortedIds[i] !== this.renderedIds[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    renderingIsUpToDate(sortedIds) {\n        if (this.cachedRenderer === null || sortedIds.length !== this.renderedIds.length) {\n            return false;\n        }\n        return this.allRenderedIdsIn(sortedIds);\n    }\n    // Render all [items] within [viewport]\n    renderItems(screenRenderer, items, viewport) {\n        if (!viewport.visibleRect.intersects(this.region) || items.length === 0) {\n            return;\n        }\n        // Divide [items] until nodes are smaller than this, or are leaves.\n        const divideUntilSmallerThanThis = (itemsToDivide) => {\n            const newItems = [];\n            for (const item of itemsToDivide) {\n                const bbox = item.getBBox();\n                if (!bbox.intersects(this.region)) {\n                    continue;\n                }\n                if (bbox.maxDimension >= this.region.maxDimension) {\n                    newItems.push(...item.getChildrenOrSelfIntersectingRegion(this.region));\n                }\n                else {\n                    newItems.push(item);\n                }\n            }\n            return newItems;\n        };\n        items = divideUntilSmallerThanThis(items);\n        // Can we cache at all?\n        if (!this.cacheState.props.isOfCorrectType(screenRenderer)) {\n            for (const item of items) {\n                item.render(screenRenderer, viewport.visibleRect);\n            }\n            return;\n        }\n        if (this.cacheState.debugMode) {\n            screenRenderer.drawRect(this.region, viewport.getSizeOfPixelOnCanvas(), {\n                fill: math_1.Color4.yellow,\n            });\n        }\n        // Could we render direclty from [this] or do we need to recurse?\n        const couldRender = this.renderingWouldBeHighEnoughResolution(viewport);\n        if (!couldRender) {\n            for (const child of this.getChildren()) {\n                child.renderItems(screenRenderer, items.filter((item) => {\n                    return item.getBBox().intersects(child.region);\n                }), viewport);\n            }\n        }\n        else {\n            // Determine whether we already have rendered the items\n            const tooSmallToRender = (rect) => rect.w / this.region.w < 1 / this.cacheState.props.blockResolution.x;\n            const leaves = [];\n            for (const item of items) {\n                leaves.push(...item.getLeavesIntersectingRegion(this.region, tooSmallToRender));\n            }\n            (0, EditorImage_1.sortLeavesByZIndex)(leaves);\n            const leavesByIds = this.computeSortedByLeafIds(leaves);\n            // No intersecting leaves? No need to render\n            if (leavesByIds.length === 0) {\n                return;\n            }\n            const leafIds = leavesByIds.map((leaf) => leaf.getId());\n            let thisRenderer;\n            if (!this.renderingIsUpToDate(leafIds)) {\n                if (this.allChildrenCanRender(viewport, leavesByIds)) {\n                    for (const child of this.getChildren()) {\n                        child.renderItems(screenRenderer, items, viewport);\n                    }\n                    return;\n                }\n                let leafApproxRenderTime = 0;\n                for (const leaf of leavesByIds) {\n                    if (!tooSmallToRender(leaf.getBBox())) {\n                        leafApproxRenderTime += leaf.getContent().getProportionalRenderingTime();\n                    }\n                }\n                // Is it worth it to render the items?\n                if (leafApproxRenderTime > this.cacheState.props.minProportionalRenderTimePerCache) {\n                    let fullRerenderNeeded = true;\n                    if (!this.cachedRenderer) {\n                        this.cachedRenderer = this.cacheState.recordManager.allocCanvas(this.region, () => this.onRegionDealloc());\n                    }\n                    else if (leavesByIds.length > this.renderedIds.length &&\n                        this.allRenderedIdsIn(leafIds) &&\n                        this.renderedMaxZIndex !== null) {\n                        // We often don't need to do a full re-render even if something's changed.\n                        // Check whether we can just draw on top of the existing cache.\n                        const newLeaves = [];\n                        let minNewZIndex = null;\n                        for (let i = 0; i < leavesByIds.length; i++) {\n                            const leaf = leavesByIds[i];\n                            const content = leaf.getContent();\n                            const zIndex = content.getZIndex();\n                            if (i >= this.renderedIds.length || leaf.getId() !== this.renderedIds[i]) {\n                                newLeaves.push(leaf);\n                                if (minNewZIndex === null || zIndex < minNewZIndex) {\n                                    minNewZIndex = zIndex;\n                                }\n                            }\n                        }\n                        if (minNewZIndex !== null && minNewZIndex > this.renderedMaxZIndex) {\n                            fullRerenderNeeded = false;\n                            thisRenderer = this.cachedRenderer.startRender();\n                            // Looping is faster than re-sorting.\n                            for (let i = 0; i < leaves.length; i++) {\n                                const leaf = leaves[i];\n                                const zIndex = leaf.getContent().getZIndex();\n                                if (zIndex > this.renderedMaxZIndex) {\n                                    leaf.render(thisRenderer, this.region);\n                                    this.renderedMaxZIndex = zIndex;\n                                }\n                            }\n                            if (this.cacheState.debugMode) {\n                                // Clay for adding new elements\n                                screenRenderer.drawRect(this.region, 2 * viewport.getSizeOfPixelOnCanvas(), {\n                                    fill: math_1.Color4.clay,\n                                });\n                            }\n                        }\n                    }\n                    else if (this.cacheState.debugMode) {\n                        console.log('Decided on a full re-render. Reason: At least one of the following is false:', '\\n leafIds.length > this.renderedIds.length: ', leafIds.length > this.renderedIds.length, '\\n this.allRenderedIdsIn(leafIds): ', this.allRenderedIdsIn(leafIds), '\\n this.renderedMaxZIndex !== null: ', this.renderedMaxZIndex !== null, '\\n\\nthis.rerenderedIds: ', this.renderedIds, ', leafIds: ', leafIds);\n                    }\n                    if (fullRerenderNeeded) {\n                        thisRenderer = this.cachedRenderer.startRender();\n                        thisRenderer.clear();\n                        this.renderedMaxZIndex = null;\n                        const startIndex = (0, EditorImage_1.computeFirstIndexToRender)(leaves, this.region);\n                        for (let i = startIndex; i < leaves.length; i++) {\n                            const leaf = leaves[i];\n                            const content = leaf.getContent();\n                            this.renderedMaxZIndex ??= content.getZIndex();\n                            this.renderedMaxZIndex = Math.max(this.renderedMaxZIndex, content.getZIndex());\n                            leaf.render(thisRenderer, this.region);\n                        }\n                        if (this.cacheState.debugMode) {\n                            // Red for full rerender\n                            screenRenderer.drawRect(this.region, 3 * viewport.getSizeOfPixelOnCanvas(), {\n                                fill: math_1.Color4.red,\n                            });\n                        }\n                    }\n                    this.renderedIds = leafIds;\n                }\n                else {\n                    this.cachedRenderer?.dealloc();\n                    // Slightly increase the clip region to prevent seams.\n                    // Divide by two because grownBy expands the rectangle on all sides.\n                    const pixelSize = viewport.getSizeOfPixelOnCanvas();\n                    const expandedRegion = new math_1.Rect2(this.region.x, this.region.y, this.region.w + pixelSize, this.region.h + pixelSize);\n                    const clip = true;\n                    screenRenderer.startObject(expandedRegion, clip);\n                    for (const leaf of leaves) {\n                        leaf.render(screenRenderer, this.region.intersection(viewport.visibleRect));\n                    }\n                    screenRenderer.endObject();\n                    if (this.cacheState.debugMode) {\n                        // Green for no cache needed render\n                        screenRenderer.drawRect(this.region, 2 * viewport.getSizeOfPixelOnCanvas(), {\n                            fill: math_1.Color4.green,\n                        });\n                    }\n                }\n            }\n            else {\n                thisRenderer = this.cachedRenderer.startRender();\n            }\n            if (thisRenderer) {\n                const transformMat = this.cachedRenderer.getTransform(this.region).inverse();\n                screenRenderer.renderFromOtherOfSameType(transformMat, thisRenderer);\n            }\n            // Can we clean up this' children? (Are they unused?)\n            if (this.instantiatedChildren.every((child) => child.isEmpty())) {\n                this.instantiatedChildren = [];\n            }\n        }\n        this.checkRep();\n    }\n    // Returns true iff this/its children have no cached state.\n    isEmpty() {\n        if (this.cachedRenderer !== null) {\n            return false;\n        }\n        return this.instantiatedChildren.every((child) => child.isEmpty());\n    }\n    onRegionDealloc() {\n        this.cachedRenderer = null;\n        if (this.isEmpty()) {\n            this.instantiatedChildren = [];\n        }\n    }\n    checkRep() {\n        if (this.instantiatedChildren.length !== cacheDivisionSize * cacheDivisionSize &&\n            this.instantiatedChildren.length !== 0) {\n            throw new Error(`Repcheck: Wrong number of children. Got ${this.instantiatedChildren.length}`);\n        }\n        if (this.renderedIds[1] !== undefined && this.renderedIds[0] >= this.renderedIds[1]) {\n            console.error(this.renderedIds);\n            throw new Error('Repcheck: First two ids are not in ascending order!');\n        }\n        for (const child of this.instantiatedChildren) {\n            if (child.parent !== this) {\n                throw new Error('Children should be linked to their parents!');\n            }\n        }\n        if (this.cachedRenderer && !this.cachedRenderer.isAllocd()) {\n            throw new Error(\"this' cachedRenderer != null, but is dealloc'd\");\n        }\n    }\n}\nexports[\"default\"] = RenderingCacheNode;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/rendering/caching/RenderingCacheNode.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/rendering/lib.js":
/*!********************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/rendering/lib.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.pathVisualEquivalent = exports.pathFromRenderable = exports.pathToRenderable = exports.RenderingMode = exports.Display = exports.CanvasRenderer = exports.SVGRenderer = exports.DummyRenderer = exports.AbstractRenderer = void 0;\nvar AbstractRenderer_1 = __webpack_require__(/*! ./renderers/AbstractRenderer */ \"./node_modules/js-draw/dist/cjs/rendering/renderers/AbstractRenderer.js\");\nObject.defineProperty(exports, \"AbstractRenderer\", ({ enumerable: true, get: function () { return __importDefault(AbstractRenderer_1).default; } }));\nvar DummyRenderer_1 = __webpack_require__(/*! ./renderers/DummyRenderer */ \"./node_modules/js-draw/dist/cjs/rendering/renderers/DummyRenderer.js\");\nObject.defineProperty(exports, \"DummyRenderer\", ({ enumerable: true, get: function () { return __importDefault(DummyRenderer_1).default; } }));\nvar SVGRenderer_1 = __webpack_require__(/*! ./renderers/SVGRenderer */ \"./node_modules/js-draw/dist/cjs/rendering/renderers/SVGRenderer.js\");\nObject.defineProperty(exports, \"SVGRenderer\", ({ enumerable: true, get: function () { return __importDefault(SVGRenderer_1).default; } }));\nvar CanvasRenderer_1 = __webpack_require__(/*! ./renderers/CanvasRenderer */ \"./node_modules/js-draw/dist/cjs/rendering/renderers/CanvasRenderer.js\");\nObject.defineProperty(exports, \"CanvasRenderer\", ({ enumerable: true, get: function () { return __importDefault(CanvasRenderer_1).default; } }));\nvar Display_1 = __webpack_require__(/*! ./Display */ \"./node_modules/js-draw/dist/cjs/rendering/Display.js\");\nObject.defineProperty(exports, \"Display\", ({ enumerable: true, get: function () { return __importDefault(Display_1).default; } }));\nObject.defineProperty(exports, \"RenderingMode\", ({ enumerable: true, get: function () { return Display_1.RenderingMode; } }));\nvar RenderablePathSpec_1 = __webpack_require__(/*! ./RenderablePathSpec */ \"./node_modules/js-draw/dist/cjs/rendering/RenderablePathSpec.js\");\nObject.defineProperty(exports, \"pathToRenderable\", ({ enumerable: true, get: function () { return RenderablePathSpec_1.pathToRenderable; } }));\nObject.defineProperty(exports, \"pathFromRenderable\", ({ enumerable: true, get: function () { return RenderablePathSpec_1.pathFromRenderable; } }));\nObject.defineProperty(exports, \"pathVisualEquivalent\", ({ enumerable: true, get: function () { return RenderablePathSpec_1.visualEquivalent; } }));\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/rendering/lib.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/rendering/localization.js":
/*!*****************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/rendering/localization.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.defaultTextRendererLocalization = void 0;\nexports.defaultTextRendererLocalization = {\n    pathNodeCount: (count) => `There are ${count} visible path objects.`,\n    textNodeCount: (count) => `There are ${count} visible text nodes.`,\n    imageNodeCount: (nodeCount) => `There are ${nodeCount} visible image nodes.`,\n    textNode: (content) => `Text: ${content}`,\n    imageNode: (label) => `Image: ${label}`,\n    unlabeledImageNode: 'Unlabeled image',\n    rerenderAsText: 'Re-render as text',\n};\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/rendering/localization.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/rendering/renderers/AbstractRenderer.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/rendering/renderers/AbstractRenderer.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\nconst RenderingStyle_1 = __webpack_require__(/*! ../RenderingStyle */ \"./node_modules/js-draw/dist/cjs/rendering/RenderingStyle.js\");\nconst RenderablePathSpec_1 = __webpack_require__(/*! ../RenderablePathSpec */ \"./node_modules/js-draw/dist/cjs/rendering/RenderablePathSpec.js\");\n/**\n * Abstract base class for renderers.\n *\n * @see {@link EditorImage.render}\n */\nclass AbstractRenderer {\n    constructor(viewport) {\n        this.viewport = viewport;\n        // If null, this' transformation is linked to the Viewport\n        this.selfTransform = null;\n        this.transformStack = [];\n        this.objectLevel = 0;\n        this.currentPaths = null;\n    }\n    /**\n     * this.canvasToScreen, etc. should be used instead of the corresponding\n     * methods on `Viewport`, because the viewport may not accurately reflect\n     * what is rendered.\n     */\n    getViewport() {\n        return this.viewport;\n    }\n    setDraftMode(_draftMode) { }\n    flushPath() {\n        if (!this.currentPaths) {\n            return;\n        }\n        let lastStyle = null;\n        for (const path of this.currentPaths) {\n            const { startPoint, commands, style } = path;\n            if (!lastStyle || !(0, RenderingStyle_1.stylesEqual)(lastStyle, style)) {\n                if (lastStyle) {\n                    this.endPath(lastStyle);\n                }\n                this.beginPath(startPoint);\n                lastStyle = style;\n            }\n            else {\n                this.moveTo(startPoint);\n            }\n            for (const command of commands) {\n                if (command.kind === math_1.PathCommandType.LineTo) {\n                    this.lineTo(command.point);\n                }\n                else if (command.kind === math_1.PathCommandType.MoveTo) {\n                    this.moveTo(command.point);\n                }\n                else if (command.kind === math_1.PathCommandType.CubicBezierTo) {\n                    this.traceCubicBezierCurve(command.controlPoint1, command.controlPoint2, command.endPoint);\n                }\n                else if (command.kind === math_1.PathCommandType.QuadraticBezierTo) {\n                    this.traceQuadraticBezierCurve(command.controlPoint, command.endPoint);\n                }\n            }\n        }\n        if (lastStyle) {\n            this.endPath(lastStyle);\n        }\n        this.currentPaths = [];\n    }\n    /**\n     * Draws a styled path. If within an object started by {@link startObject},\n     * the resultant path may not be visible until {@link endObject} is called.\n     */\n    drawPath(path) {\n        // If we're being called outside of an object,\n        // we can't delay rendering\n        if (this.objectLevel === 0 || this.currentPaths === null) {\n            this.currentPaths = [path];\n            this.flushPath();\n            this.currentPaths = null;\n        }\n        else {\n            // Otherwise, don't render paths all at once. This prevents faint lines between\n            // segments of the same stroke from being visible.\n            this.currentPaths.push(path);\n        }\n    }\n    // Strokes a rectangle. Boundary lines have width [lineWidth] and are filled with [lineFill].\n    // This is equivalent to `drawPath(Path.fromRect(...).toRenderable(...))`.\n    drawRect(rect, lineWidth, lineFill) {\n        const path = math_1.Path.fromRect(rect, lineWidth);\n        this.drawPath((0, RenderablePathSpec_1.pathToRenderable)(path, lineFill));\n    }\n    /** Draws a filled rectangle. */\n    fillRect(rect, fill) {\n        const path = math_1.Path.fromRect(rect);\n        this.drawPath((0, RenderablePathSpec_1.pathToRenderable)(path, { fill }));\n    }\n    /**\n     * This should be called whenever a new object is being drawn.\n     *\n     * @param _boundingBox The bounding box of the object to be drawn.\n     * @param _clip Whether content outside `_boundingBox` should be drawn. Renderers\n     *              that override this method are not required to support `_clip`.\n     */\n    startObject(_boundingBox, _clip) {\n        if (this.objectLevel > 0) {\n            this.flushPath();\n        }\n        this.currentPaths = [];\n        this.objectLevel++;\n    }\n    /**\n     * Notes the end of an object.\n     * @param _loaderData - a map from strings to JSON-ifyable objects\n     * and contains properties attached to the object by whatever loader loaded the image. This\n     * is used to preserve attributes not supported by js-draw when loading/saving an image.\n     * Renderers may ignore this.\n     *\n     * @param _objectTags - a list of labels (e.g. `className`s) to be attached to the object.\n     * Renderers may ignore this.\n     */\n    endObject(_loaderData, _objectTags) {\n        // Render the paths all at once\n        this.flushPath();\n        this.currentPaths = null;\n        this.objectLevel--;\n        if (this.objectLevel < 0) {\n            throw new Error('More objects have ended than have been started (negative object nesting level)!');\n        }\n    }\n    getNestingLevel() {\n        return this.objectLevel;\n    }\n    // Returns true iff other can be rendered onto this without data loss.\n    canRenderFromWithoutDataLoss(_other) {\n        return false;\n    }\n    // MUST throw if other and this are not of the same base class.\n    renderFromOtherOfSameType(_renderTo, other) {\n        throw new Error(`Unable to render from ${other}: Not implemented`);\n    }\n    // Set a transformation to apply to things before rendering,\n    // replacing the viewport's transform.\n    setTransform(transform) {\n        this.selfTransform = transform;\n    }\n    pushTransform(transform) {\n        this.transformStack.push(this.selfTransform);\n        this.setTransform(this.getCanvasToScreenTransform().rightMul(transform));\n    }\n    popTransform() {\n        if (this.transformStack.length === 0) {\n            throw new Error('Unable to pop more transforms than have been pushed!');\n        }\n        this.setTransform(this.transformStack.pop() ?? null);\n    }\n    // Get the matrix that transforms a vector on the canvas to a vector on this'\n    // rendering target.\n    getCanvasToScreenTransform() {\n        if (this.selfTransform) {\n            return this.selfTransform;\n        }\n        return this.viewport.canvasToScreenTransform;\n    }\n    canvasToScreen(vec) {\n        return this.getCanvasToScreenTransform().transformVec2(vec);\n    }\n    getSizeOfCanvasPixelOnScreen() {\n        return this.getCanvasToScreenTransform().transformVec3(math_1.Vec2.unitX).length();\n    }\n    /**\n     * @internal\n     */\n    overrideVisibleRect(rect) {\n        this.visibleRectOverride = rect;\n    }\n    // Returns the region in canvas space that is visible within the viewport this\n    // canvas is rendering to.\n    //\n    // Note that in some cases this might not be the same as the `visibleRect` given\n    // to components in their `render` method.\n    getVisibleRect() {\n        return this.visibleRectOverride ?? this.viewport.visibleRect;\n    }\n}\nexports[\"default\"] = AbstractRenderer;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/rendering/renderers/AbstractRenderer.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/rendering/renderers/CanvasRenderer.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/rendering/renderers/CanvasRenderer.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst TextComponent_1 = __importDefault(__webpack_require__(/*! ../../components/TextComponent */ \"./node_modules/js-draw/dist/cjs/components/TextComponent.js\"));\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\nconst AbstractRenderer_1 = __importDefault(__webpack_require__(/*! ./AbstractRenderer */ \"./node_modules/js-draw/dist/cjs/rendering/renderers/AbstractRenderer.js\"));\nconst RenderablePathSpec_1 = __webpack_require__(/*! ../RenderablePathSpec */ \"./node_modules/js-draw/dist/cjs/rendering/RenderablePathSpec.js\");\n/**\n * Renders onto a `CanvasRenderingContext2D`.\n *\n * **Example**:\n * [[include:doc-pages/inline-examples/canvas-renderer.md]]\n */\nclass CanvasRenderer extends AbstractRenderer_1.default {\n    /**\n     * Creates a new `CanvasRenderer` that renders to the given rendering context.\n     * The `viewport` is used to determine the translation/rotation/scaling of the content\n     * to draw.\n     */\n    constructor(ctx, viewport) {\n        super(viewport);\n        this.ctx = ctx;\n        this.ignoreObjectsAboveLevel = null;\n        this.ignoringObject = false;\n        this.currentObjectBBox = null;\n        this.clipLevels = [];\n        this.setDraftMode(false);\n    }\n    transformBy(transformBy) {\n        // From MDN, transform(a,b,c,d,e,f)\n        // takes input such that\n        // ⎡ a c e ⎤\n        // ⎢ b d f ⎥ transforms content drawn to [ctx].\n        // ⎣ 0 0 1 ⎦\n        this.ctx.transform(transformBy.a1, transformBy.b1, // a, b\n        transformBy.a2, transformBy.b2, // c, d\n        transformBy.a3, transformBy.b3);\n    }\n    canRenderFromWithoutDataLoss(other) {\n        return other instanceof CanvasRenderer;\n    }\n    renderFromOtherOfSameType(transformBy, other) {\n        if (!(other instanceof CanvasRenderer)) {\n            throw new Error(`${other} cannot be rendered onto ${this}`);\n        }\n        transformBy = this.getCanvasToScreenTransform().rightMul(transformBy);\n        this.ctx.save();\n        this.transformBy(transformBy);\n        this.ctx.drawImage(other.ctx.canvas, 0, 0);\n        this.ctx.restore();\n    }\n    // Set parameters for lower/higher quality rendering\n    setDraftMode(draftMode) {\n        if (draftMode) {\n            this.minSquareCurveApproxDist = 9;\n            this.minRenderSizeBothDimens = 1;\n            this.minRenderSizeAnyDimen = 0.1;\n        }\n        else {\n            this.minSquareCurveApproxDist = 0.5;\n            this.minRenderSizeBothDimens = 0.1;\n            this.minRenderSizeAnyDimen = 1e-6;\n        }\n    }\n    displaySize() {\n        return math_1.Vec2.of(this.ctx.canvas.clientWidth, this.ctx.canvas.clientHeight);\n    }\n    clear() {\n        this.ctx.save();\n        this.ctx.resetTransform();\n        this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);\n        this.ctx.restore();\n    }\n    beginPath(startPoint) {\n        startPoint = this.canvasToScreen(startPoint);\n        this.ctx.beginPath();\n        this.ctx.moveTo(startPoint.x, startPoint.y);\n    }\n    endPath(style) {\n        // Saving and restoring can be slow in some browsers\n        // (e.g. 0.50ms). Avoid.\n        //this.ctx.save();\n        // If not a transparent fill\n        if (style.fill.a > 0) {\n            this.ctx.fillStyle = style.fill.toHexString();\n            this.ctx.fill();\n        }\n        if (style.stroke) {\n            this.ctx.strokeStyle = style.stroke.color.toHexString();\n            this.ctx.lineWidth = this.getSizeOfCanvasPixelOnScreen() * style.stroke.width;\n            this.ctx.lineCap = 'round';\n            this.ctx.lineJoin = 'round';\n            this.ctx.stroke();\n            this.ctx.lineWidth = 1;\n        }\n        this.ctx.closePath();\n        //this.ctx.restore();\n    }\n    lineTo(point) {\n        point = this.canvasToScreen(point);\n        this.ctx.lineTo(point.x, point.y);\n    }\n    moveTo(point) {\n        point = this.canvasToScreen(point);\n        this.ctx.moveTo(point.x, point.y);\n    }\n    traceCubicBezierCurve(p1, p2, p3) {\n        p1 = this.canvasToScreen(p1);\n        p2 = this.canvasToScreen(p2);\n        p3 = this.canvasToScreen(p3);\n        // Approximate the curve if small enough.\n        const delta1 = p2.minus(p1);\n        const delta2 = p3.minus(p2);\n        if (delta1.magnitudeSquared() < this.minSquareCurveApproxDist &&\n            delta2.magnitudeSquared() < this.minSquareCurveApproxDist) {\n            this.ctx.lineTo(p3.x, p3.y);\n        }\n        else {\n            this.ctx.bezierCurveTo(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);\n        }\n    }\n    traceQuadraticBezierCurve(controlPoint, endPoint) {\n        controlPoint = this.canvasToScreen(controlPoint);\n        endPoint = this.canvasToScreen(endPoint);\n        // Approximate the curve with a line if small enough\n        const delta = controlPoint.minus(endPoint);\n        if (delta.magnitudeSquared() < this.minSquareCurveApproxDist) {\n            this.ctx.lineTo(endPoint.x, endPoint.y);\n        }\n        else {\n            this.ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, endPoint.x, endPoint.y);\n        }\n    }\n    drawPath(path) {\n        if (this.ignoringObject) {\n            return;\n        }\n        // If part of a huge object, it might be worth trimming the path\n        const visibleRect = this.getVisibleRect();\n        if (this.currentObjectBBox?.containsRect(visibleRect)) {\n            // Try to trim/remove parts of the path outside of the bounding box.\n            path = (0, RenderablePathSpec_1.visualEquivalent)(path, visibleRect);\n        }\n        super.drawPath(path);\n    }\n    drawText(text, transform, style) {\n        this.ctx.save();\n        transform = this.getCanvasToScreenTransform().rightMul(transform);\n        this.transformBy(transform);\n        TextComponent_1.default.applyTextStyles(this.ctx, style);\n        if (style.renderingStyle.fill.a !== 0) {\n            this.ctx.fillStyle = style.renderingStyle.fill.toHexString();\n            this.ctx.fillText(text, 0, 0);\n        }\n        if (style.renderingStyle.stroke) {\n            this.ctx.strokeStyle = style.renderingStyle.stroke.color.toHexString();\n            this.ctx.lineWidth = style.renderingStyle.stroke.width;\n            this.ctx.strokeText(text, 0, 0);\n        }\n        this.ctx.restore();\n    }\n    drawImage(image) {\n        // .drawImage can fail for zero-size images.\n        if (image.image.width === 0 || image.image.height === 0) {\n            return;\n        }\n        this.ctx.save();\n        const transform = this.getCanvasToScreenTransform().rightMul(image.transform);\n        this.transformBy(transform);\n        this.ctx.drawImage(image.image, 0, 0);\n        this.ctx.restore();\n    }\n    startObject(boundingBox, clip) {\n        if (this.isTooSmallToRender(boundingBox)) {\n            this.ignoreObjectsAboveLevel = this.getNestingLevel();\n            this.ignoringObject = true;\n        }\n        super.startObject(boundingBox);\n        this.currentObjectBBox = boundingBox;\n        if (!this.ignoringObject && clip) {\n            // Don't clip if it would only remove content already trimmed by\n            // the edge of the screen.\n            const clippedIsOutsideScreen = boundingBox.containsRect(this.getVisibleRect());\n            if (!clippedIsOutsideScreen) {\n                this.clipLevels.push(this.objectLevel);\n                this.ctx.save();\n                this.ctx.beginPath();\n                for (const corner of boundingBox.corners) {\n                    const screenCorner = this.canvasToScreen(corner);\n                    this.ctx.lineTo(screenCorner.x, screenCorner.y);\n                }\n                this.ctx.clip();\n            }\n        }\n    }\n    endObject() {\n        // Cache this.objectLevel — it may be decremented by super.endObject.\n        const objectLevel = this.objectLevel;\n        this.currentObjectBBox = null;\n        super.endObject();\n        if (!this.ignoringObject && this.clipLevels.length > 0) {\n            if (this.clipLevels[this.clipLevels.length - 1] === objectLevel) {\n                this.ctx.restore();\n                this.clipLevels.pop();\n            }\n        }\n        // If exiting an object with a too-small-to-draw bounding box,\n        if (this.ignoreObjectsAboveLevel !== null &&\n            this.getNestingLevel() <= this.ignoreObjectsAboveLevel) {\n            this.ignoreObjectsAboveLevel = null;\n            this.ignoringObject = false;\n        }\n    }\n    // @internal\n    drawPoints(...points) {\n        const pointRadius = 10;\n        for (let i = 0; i < points.length; i++) {\n            const point = this.canvasToScreen(points[i]);\n            this.ctx.beginPath();\n            this.ctx.arc(point.x, point.y, pointRadius, 0, Math.PI * 2);\n            this.ctx.fillStyle = math_1.Color4.ofRGBA(0.5 + Math.sin(i) / 2, 1.0, 0.5 + Math.cos(i * 0.2) / 4, 0.5).toHexString();\n            this.ctx.lineWidth = 2;\n            this.ctx.fill();\n            this.ctx.stroke();\n            this.ctx.closePath();\n            this.ctx.textAlign = 'center';\n            this.ctx.textBaseline = 'middle';\n            this.ctx.fillStyle = 'black';\n            this.ctx.fillText(`${i}`, point.x, point.y, pointRadius * 2);\n        }\n    }\n    // @internal\n    isTooSmallToRender(rect) {\n        // Should we ignore all objects within this object's bbox?\n        const diagonal = rect.size.times(this.getSizeOfCanvasPixelOnScreen());\n        const bothDimenMinSize = this.minRenderSizeBothDimens;\n        const bothTooSmall = Math.abs(diagonal.x) < bothDimenMinSize && Math.abs(diagonal.y) < bothDimenMinSize;\n        const anyDimenMinSize = this.minRenderSizeAnyDimen;\n        const anyTooSmall = Math.abs(diagonal.x) < anyDimenMinSize || Math.abs(diagonal.y) < anyDimenMinSize;\n        return bothTooSmall || anyTooSmall;\n    }\n    // @internal\n    static fromViewport(exportViewport, options = {}) {\n        const canvas = document.createElement('canvas');\n        const exportRectSize = exportViewport.getScreenRectSize();\n        let canvasSize = options.canvasSize ?? exportRectSize;\n        if (options.maxCanvasDimen && canvasSize.maximumEntryMagnitude() > options.maxCanvasDimen) {\n            canvasSize = canvasSize.times(options.maxCanvasDimen / canvasSize.maximumEntryMagnitude());\n        }\n        canvas.width = canvasSize.x;\n        canvas.height = canvasSize.y;\n        const ctx = canvas.getContext('2d');\n        // Scale to ensure that the entire output is visible.\n        const scaleFactor = Math.min(canvasSize.x / exportRectSize.x, canvasSize.y / exportRectSize.y);\n        ctx.scale(scaleFactor, scaleFactor);\n        return { renderer: new CanvasRenderer(ctx, exportViewport), element: canvas };\n    }\n}\nexports[\"default\"] = CanvasRenderer;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/rendering/renderers/CanvasRenderer.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/rendering/renderers/DummyRenderer.js":
/*!****************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/rendering/renderers/DummyRenderer.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\nconst AbstractRenderer_1 = __importDefault(__webpack_require__(/*! ./AbstractRenderer */ \"./node_modules/js-draw/dist/cjs/rendering/renderers/AbstractRenderer.js\"));\n// Renderer that outputs almost nothing. Useful for automated tests.\nclass DummyRenderer extends AbstractRenderer_1.default {\n    constructor(viewport) {\n        super(viewport);\n        // Variables that track the state of what's been rendered\n        this.clearedCount = 0;\n        this.renderedPathCount = 0;\n        this.lastFillStyle = null;\n        this.lastPoint = null;\n        this.objectNestingLevel = 0;\n        this.lastText = null;\n        this.lastImage = null;\n        // List of points drawn since the last clear.\n        this.pointBuffer = [];\n    }\n    displaySize() {\n        // Do we have a stored viewport size?\n        const viewportSize = this.getViewport().getScreenRectSize();\n        // Don't use a 0x0 viewport — DummyRenderer is often used\n        // for tests that run without a display, so pretend we have a\n        // reasonable-sized display.\n        if (viewportSize.x === 0 || viewportSize.y === 0) {\n            return math_1.Vec2.of(640, 480);\n        }\n        return viewportSize;\n    }\n    clear() {\n        this.clearedCount++;\n        this.renderedPathCount = 0;\n        this.pointBuffer = [];\n        this.lastText = null;\n        this.lastImage = null;\n        // Ensure all objects finished rendering\n        if (this.objectNestingLevel > 0) {\n            throw new Error(`Within an object while clearing! Nesting level: ${this.objectNestingLevel}`);\n        }\n    }\n    beginPath(startPoint) {\n        this.lastPoint = startPoint;\n        this.pointBuffer.push(startPoint);\n    }\n    endPath(style) {\n        this.renderedPathCount++;\n        this.lastFillStyle = style;\n    }\n    lineTo(point) {\n        point = this.canvasToScreen(point);\n        this.lastPoint = point;\n        this.pointBuffer.push(point);\n    }\n    moveTo(point) {\n        point = this.canvasToScreen(point);\n        this.lastPoint = point;\n        this.pointBuffer.push(point);\n    }\n    traceCubicBezierCurve(p1, p2, p3) {\n        p1 = this.canvasToScreen(p1);\n        p2 = this.canvasToScreen(p2);\n        p3 = this.canvasToScreen(p3);\n        this.lastPoint = p3;\n        this.pointBuffer.push(p1, p2, p3);\n    }\n    traceQuadraticBezierCurve(controlPoint, endPoint) {\n        controlPoint = this.canvasToScreen(controlPoint);\n        endPoint = this.canvasToScreen(endPoint);\n        this.lastPoint = endPoint;\n        this.pointBuffer.push(controlPoint, endPoint);\n    }\n    drawPoints(..._points) {\n        // drawPoints is intended for debugging.\n        // As such, it is unlikely to be the target of automated tests.\n    }\n    drawText(text, _transform, _style) {\n        this.lastText = text;\n    }\n    drawImage(image) {\n        this.lastImage = image;\n    }\n    startObject(boundingBox, _clip) {\n        super.startObject(boundingBox);\n        this.objectNestingLevel += 1;\n    }\n    endObject() {\n        super.endObject();\n        this.objectNestingLevel -= 1;\n    }\n    isTooSmallToRender(_rect) {\n        return false;\n    }\n    canRenderFromWithoutDataLoss(other) {\n        return other instanceof DummyRenderer;\n    }\n    renderFromOtherOfSameType(transform, other) {\n        if (!(other instanceof DummyRenderer)) {\n            throw new Error(`${other} cannot be rendered onto ${this}`);\n        }\n        this.renderedPathCount += other.renderedPathCount;\n        this.lastFillStyle = other.lastFillStyle;\n        this.lastPoint = other.lastPoint;\n        this.pointBuffer.push(...other.pointBuffer.map((point) => {\n            return transform.transformVec2(point);\n        }));\n    }\n    toString() {\n        return '[DummyRenderer]';\n    }\n}\nexports[\"default\"] = DummyRenderer;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/rendering/renderers/DummyRenderer.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/rendering/renderers/SVGRenderer.js":
/*!**************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/rendering/renderers/SVGRenderer.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.renderedStylesheetId = void 0;\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\nconst SVGLoader_1 = __webpack_require__(/*! ../../SVGLoader/SVGLoader */ \"./node_modules/js-draw/dist/cjs/SVGLoader/SVGLoader.js\");\nconst RenderingStyle_1 = __webpack_require__(/*! ../RenderingStyle */ \"./node_modules/js-draw/dist/cjs/rendering/RenderingStyle.js\");\nconst AbstractRenderer_1 = __importDefault(__webpack_require__(/*! ./AbstractRenderer */ \"./node_modules/js-draw/dist/cjs/rendering/renderers/AbstractRenderer.js\"));\nconst RenderablePathSpec_1 = __webpack_require__(/*! ../RenderablePathSpec */ \"./node_modules/js-draw/dist/cjs/rendering/RenderablePathSpec.js\");\nconst listPrefixMatch_1 = __importDefault(__webpack_require__(/*! ../../util/listPrefixMatch */ \"./node_modules/js-draw/dist/cjs/util/listPrefixMatch.js\"));\nexports.renderedStylesheetId = 'js-draw-style-sheet';\nconst svgNameSpace = 'http://www.w3.org/2000/svg';\nconst defaultTextStyle = {\n    fontWeight: '400',\n    fontStyle: 'normal',\n};\n/**\n * Renders onto an `SVGElement`.\n *\n * @see {@link Editor.toSVG}\n */\nclass SVGRenderer extends AbstractRenderer_1.default {\n    /**\n     * Creates a renderer that renders onto `elem`. If `sanitize`, don't render potentially untrusted data.\n     *\n     * `viewport` is used to determine the translation/rotation/scaling/output size of the rendered\n     * data.\n     */\n    constructor(elem, viewport, sanitize = false) {\n        super(viewport);\n        this.elem = elem;\n        this.sanitize = sanitize;\n        this.lastPathStyle = null;\n        this.lastPathString = [];\n        this.lastContainerIDList = [];\n        // Elements that make up the current object (as created by startObject)\n        // if any.\n        this.objectElems = null;\n        this.overwrittenAttrs = {};\n        this.textContainer = null;\n        this.textContainerTransform = null;\n        this.textParentStyle = defaultTextStyle;\n        this.clear();\n        this.addStyleSheet();\n    }\n    addStyleSheet() {\n        if (!this.elem.querySelector(`#${exports.renderedStylesheetId}`)) {\n            // Default to rounded strokes.\n            const styleSheet = document.createElementNS('http://www.w3.org/2000/svg', 'style');\n            styleSheet.appendChild(document.createTextNode(`\n\t\t\t\tpath {\n\t\t\t\t\tstroke-linecap: round;\n\t\t\t\t\tstroke-linejoin: round;\n\t\t\t\t}\n\n\t\t\t\ttext {\n\t\t\t\t\twhite-space: pre;\n\t\t\t\t}\n\t\t\t`.replace(/\\s+/g, '')));\n            styleSheet.setAttribute('id', exports.renderedStylesheetId);\n            this.elem.appendChild(styleSheet);\n        }\n    }\n    // Sets an attribute on the root SVG element.\n    setRootSVGAttribute(name, value) {\n        if (this.sanitize) {\n            return;\n        }\n        // Make the original value of the attribute restorable on clear\n        if (!(name in this.overwrittenAttrs)) {\n            this.overwrittenAttrs[name] = this.elem.getAttribute(name);\n        }\n        if (value !== null) {\n            this.elem.setAttribute(name, value);\n        }\n        else {\n            this.elem.removeAttribute(name);\n        }\n    }\n    displaySize() {\n        return math_1.Vec2.of(this.elem.clientWidth, this.elem.clientHeight);\n    }\n    clear() {\n        this.lastPathString = [];\n        this.lastContainerIDList = [];\n        if (!this.sanitize) {\n            // Restore all all attributes\n            for (const attrName in this.overwrittenAttrs) {\n                const value = this.overwrittenAttrs[attrName];\n                if (value) {\n                    this.elem.setAttribute(attrName, value);\n                }\n                else {\n                    this.elem.removeAttribute(attrName);\n                }\n            }\n            this.overwrittenAttrs = {};\n        }\n    }\n    // Push `this.fullPath` to the SVG. Returns the path added to the SVG, if any.\n    // @internal\n    addPathToSVG() {\n        if (!this.lastPathStyle || this.lastPathString.length === 0) {\n            return null;\n        }\n        const pathElem = document.createElementNS(svgNameSpace, 'path');\n        pathElem.setAttribute('d', this.lastPathString.join(' '));\n        const style = this.lastPathStyle;\n        if (style.fill.a > 0) {\n            pathElem.setAttribute('fill', style.fill.toHexString());\n        }\n        else {\n            pathElem.setAttribute('fill', 'none');\n        }\n        if (style.stroke) {\n            pathElem.setAttribute('stroke', style.stroke.color.toHexString());\n            pathElem.setAttribute('stroke-width', (0, math_1.toRoundedString)(style.stroke.width * this.getSizeOfCanvasPixelOnScreen()));\n        }\n        this.elem.appendChild(pathElem);\n        this.objectElems?.push(pathElem);\n        return pathElem;\n    }\n    drawPath(pathSpec) {\n        const style = pathSpec.style;\n        const path = (0, RenderablePathSpec_1.pathFromRenderable)(pathSpec).transformedBy(this.getCanvasToScreenTransform());\n        // Try to extend the previous path, if possible\n        if (this.lastPathString.length === 0 ||\n            !this.lastPathStyle ||\n            !(0, RenderingStyle_1.stylesEqual)(this.lastPathStyle, style)) {\n            this.addPathToSVG();\n            this.lastPathStyle = style;\n            this.lastPathString = [];\n        }\n        this.lastPathString.push(path.toString());\n    }\n    // Apply [elemTransform] to [elem]. Uses both a `matrix` and `.x`, `.y` properties if `setXY` is true.\n    // Otherwise, just uses a `matrix`.\n    transformFrom(elemTransform, elem, inCanvasSpace = false) {\n        const transform = !inCanvasSpace\n            ? this.getCanvasToScreenTransform().rightMul(elemTransform)\n            : elemTransform;\n        if (!transform.eq(math_1.Mat33.identity)) {\n            const matrixString = transform.toCSSMatrix();\n            elem.style.transform = matrixString;\n            // Most browsers round the components of CSS transforms.\n            // Include a higher precision copy of the element's transform.\n            elem.setAttribute('data-highp-transform', matrixString);\n        }\n        else {\n            elem.style.transform = '';\n        }\n    }\n    drawText(text, transform, style) {\n        const applyTextStyles = (elem, style) => {\n            if (style.fontFamily !== this.textParentStyle?.fontFamily) {\n                elem.style.fontFamily = style.fontFamily;\n            }\n            if (style.fontVariant !== this.textParentStyle?.fontVariant) {\n                elem.style.fontVariant = style.fontVariant ?? '';\n            }\n            if (style.fontWeight !== this.textParentStyle?.fontWeight) {\n                elem.style.fontWeight = style.fontWeight ?? '';\n            }\n            if (style.fontStyle !== this.textParentStyle?.fontStyle) {\n                elem.style.fontStyle = style.fontStyle ?? '';\n            }\n            if (style.size !== this.textParentStyle?.size) {\n                elem.style.fontSize = style.size + 'px';\n            }\n            const fillString = style.renderingStyle.fill.toHexString();\n            // TODO: Uncomment at some future major version release --- currently causes incompatibility due\n            //       to an SVG parsing bug in older versions.\n            //const parentFillString = this.textParentStyle?.renderingStyle?.fill?.toHexString();\n            //if (fillString !== parentFillString) {\n            elem.style.fill = fillString;\n            //}\n            if (style.renderingStyle.stroke) {\n                const strokeStyle = style.renderingStyle.stroke;\n                elem.style.stroke = strokeStyle.color.toHexString();\n                elem.style.strokeWidth = strokeStyle.width + 'px';\n            }\n        };\n        transform = this.getCanvasToScreenTransform().rightMul(transform);\n        if (!this.textContainer) {\n            const container = document.createElementNS(svgNameSpace, 'text');\n            container.appendChild(document.createTextNode(text));\n            this.transformFrom(transform, container, true);\n            applyTextStyles(container, style);\n            this.elem.appendChild(container);\n            this.objectElems?.push(container);\n            if (this.objectLevel > 0) {\n                this.textContainer = container;\n                this.textContainerTransform = transform;\n                this.textParentStyle = { ...defaultTextStyle, ...style };\n            }\n        }\n        else {\n            const elem = document.createElementNS(svgNameSpace, 'tspan');\n            elem.appendChild(document.createTextNode(text));\n            this.textContainer.appendChild(elem);\n            // Make .x/.y relative to the parent.\n            transform = this.textContainerTransform.inverse().rightMul(transform);\n            // .style.transform does nothing to tspan elements. As such, we need to set x/y:\n            const translation = transform.transformVec2(math_1.Vec2.zero);\n            elem.setAttribute('x', `${(0, math_1.toRoundedString)(translation.x)}`);\n            elem.setAttribute('y', `${(0, math_1.toRoundedString)(translation.y)}`);\n            applyTextStyles(elem, style);\n        }\n    }\n    drawImage(image) {\n        let label = image.label ?? image.image.getAttribute('aria-label') ?? '';\n        if (label === '') {\n            label = image.image.getAttribute('alt') ?? '';\n        }\n        const svgImgElem = document.createElementNS(svgNameSpace, 'image');\n        svgImgElem.setAttribute('href', image.base64Url);\n        svgImgElem.setAttribute('width', image.image.getAttribute('width') ?? '');\n        svgImgElem.setAttribute('height', image.image.getAttribute('height') ?? '');\n        svgImgElem.setAttribute('aria-label', label);\n        this.transformFrom(image.transform, svgImgElem);\n        this.elem.appendChild(svgImgElem);\n        this.objectElems?.push(svgImgElem);\n    }\n    startObject(boundingBox) {\n        super.startObject(boundingBox);\n        // Only accumulate a path within an object\n        this.lastPathString = [];\n        this.lastPathStyle = null;\n        this.textContainer = null;\n        this.textParentStyle = defaultTextStyle;\n        this.objectElems = [];\n    }\n    endObject(loaderData, elemClassNames) {\n        super.endObject(loaderData);\n        // Don't extend paths across objects\n        this.addPathToSVG();\n        // If empty/not an object, stop.\n        if (!this.objectElems) {\n            return;\n        }\n        if (loaderData && !this.sanitize) {\n            // Restore any attributes unsupported by the app.\n            for (const elem of this.objectElems) {\n                const attrs = loaderData[SVGLoader_1.svgAttributesDataKey];\n                const styleAttrs = loaderData[SVGLoader_1.svgStyleAttributesDataKey];\n                if (attrs) {\n                    for (const [attr, value] of attrs) {\n                        elem.setAttribute(attr, value);\n                    }\n                }\n                if (styleAttrs) {\n                    for (const attr of styleAttrs) {\n                        elem.style.setProperty(attr.key, attr.value, attr.priority);\n                    }\n                }\n            }\n            // Update the parent\n            const containerIDData = loaderData[SVGLoader_1.svgLoaderAttributeContainerID];\n            let containerIDList = [];\n            if (containerIDData && containerIDData[0]) {\n                // If a string list,\n                if (containerIDData[0].length) {\n                    containerIDList = containerIDData[0];\n                }\n            }\n            if (containerIDList.length > 0 &&\n                // containerIDList must share a prefix with the last ID list\n                // otherwise, the z order of elements may have been changed from\n                // the original image.\n                // In the case that the z order has been changed, keep the current\n                // element as a child of the root to preserve z order.\n                (0, listPrefixMatch_1.default)(this.lastContainerIDList, containerIDList) &&\n                // The component can add at most one more parent than the previous item.\n                this.lastContainerIDList.length >= containerIDList.length - 1) {\n                // Select the last\n                const containerID = containerIDList[containerIDList.length - 1];\n                const containerCandidates = this.elem.querySelectorAll(`g#${containerID}`);\n                if (containerCandidates.length >= 1) {\n                    const container = containerCandidates[0];\n                    // If this is the first time we're entering the group, the\n                    // group should be empty.\n                    // Otherwise, this may be a case that would break z-ordering.\n                    if (container.children.length === 0 ||\n                        this.lastContainerIDList.length >= containerIDList.length) {\n                        // Move all objectElems to the found container\n                        for (const elem of this.objectElems) {\n                            elem.remove();\n                            container.appendChild(elem);\n                        }\n                    }\n                    else {\n                        containerIDList = [];\n                    }\n                }\n            }\n            else {\n                containerIDList = [];\n            }\n            this.lastContainerIDList = containerIDList;\n        }\n        // Add class names to the object, if given.\n        if (elemClassNames && this.objectElems) {\n            if (this.objectElems.length === 1) {\n                this.objectElems[0].classList.add(...elemClassNames);\n            }\n            else {\n                const wrapper = document.createElementNS(svgNameSpace, 'g');\n                wrapper.classList.add(...elemClassNames);\n                for (const elem of this.objectElems) {\n                    elem.remove();\n                    wrapper.appendChild(elem);\n                }\n                this.elem.appendChild(wrapper);\n            }\n        }\n    }\n    // Not implemented -- use drawPath instead.\n    unimplementedMessage() {\n        throw new Error('Not implemenented!');\n    }\n    beginPath(_startPoint) {\n        this.unimplementedMessage();\n    }\n    endPath(_style) {\n        this.unimplementedMessage();\n    }\n    lineTo(_point) {\n        this.unimplementedMessage();\n    }\n    moveTo(_point) {\n        this.unimplementedMessage();\n    }\n    traceCubicBezierCurve(_controlPoint1, _controlPoint2, _endPoint) {\n        this.unimplementedMessage();\n    }\n    traceQuadraticBezierCurve(_controlPoint, _endPoint) {\n        this.unimplementedMessage();\n    }\n    drawPoints(...points) {\n        points.map((point) => {\n            const elem = document.createElementNS(svgNameSpace, 'circle');\n            elem.setAttribute('cx', `${point.x}`);\n            elem.setAttribute('cy', `${point.y}`);\n            elem.setAttribute('r', '15');\n            this.elem.appendChild(elem);\n        });\n    }\n    // Renders a **copy** of the given element.\n    drawSVGElem(elem) {\n        if (this.sanitize) {\n            return;\n        }\n        // Don't add multiple copies of the default stylesheet.\n        if (elem.tagName.toLowerCase() === 'style' &&\n            elem.getAttribute('id') === exports.renderedStylesheetId) {\n            return;\n        }\n        const elemToDraw = elem.cloneNode(true);\n        this.elem.appendChild(elemToDraw);\n        this.objectElems?.push(elemToDraw);\n    }\n    isTooSmallToRender(_rect) {\n        return false;\n    }\n    /**\n     * Creates a new SVG element and `SVGRenerer` with `width`, `height`, `viewBox`,\n     * and other metadata attributes set for the given `Viewport`.\n     *\n     * If `options` is a `boolean`, it is interpreted as whether to sanitize (not add unknown\n     * SVG entities to) the output.\n     */\n    static fromViewport(viewport, options = true) {\n        let sanitize;\n        let useViewBoxForPositioning;\n        if (typeof options === 'boolean') {\n            sanitize = options;\n            useViewBoxForPositioning = false;\n        }\n        else {\n            sanitize = options.sanitize ?? true;\n            useViewBoxForPositioning = options.useViewBoxForPositioning ?? false;\n        }\n        const svgNameSpace = 'http://www.w3.org/2000/svg';\n        const result = document.createElementNS(svgNameSpace, 'svg');\n        const screenRectSize = viewport.getScreenRectSize();\n        const visibleRect = viewport.visibleRect;\n        let viewBoxComponents;\n        if (useViewBoxForPositioning) {\n            const exportRect = viewport.visibleRect;\n            viewBoxComponents = [exportRect.x, exportRect.y, exportRect.w, exportRect.h];\n            // Replace the viewport with a copy that has a modified transform.\n            // (Avoids modifying the original viewport).\n            viewport = viewport.getTemporaryClone();\n            // TODO: This currently discards any rotation information.\n            // Render with (0,0) at (0,0) -- the translation is handled by the viewBox.\n            viewport.resetTransform(math_1.Mat33.identity);\n        }\n        else {\n            viewBoxComponents = [0, 0, screenRectSize.x, screenRectSize.y];\n        }\n        // rect.x -> size of rect in x direction, rect.y -> size of rect in y direction.\n        result.setAttribute('viewBox', viewBoxComponents.map((part) => (0, math_1.toRoundedString)(part)).join(' '));\n        result.setAttribute('width', (0, math_1.toRoundedString)(screenRectSize.x));\n        result.setAttribute('height', (0, math_1.toRoundedString)(screenRectSize.y));\n        // Ensure the image can be identified as an SVG if downloaded.\n        // See https://jwatt.org/svg/authoring/\n        result.setAttribute('version', '1.1');\n        result.setAttribute('baseProfile', 'full');\n        result.setAttribute('xmlns', svgNameSpace);\n        const renderer = new SVGRenderer(result, viewport, sanitize);\n        if (!visibleRect.eq(viewport.visibleRect)) {\n            renderer.overrideVisibleRect(visibleRect);\n        }\n        return { element: result, renderer };\n    }\n}\nexports[\"default\"] = SVGRenderer;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/rendering/renderers/SVGRenderer.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/rendering/renderers/TextOnlyRenderer.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/rendering/renderers/TextOnlyRenderer.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\nconst AbstractRenderer_1 = __importDefault(__webpack_require__(/*! ./AbstractRenderer */ \"./node_modules/js-draw/dist/cjs/rendering/renderers/AbstractRenderer.js\"));\n// Outputs a description of what was rendered.\nclass TextOnlyRenderer extends AbstractRenderer_1.default {\n    constructor(viewport, localizationTable) {\n        super(viewport);\n        this.localizationTable = localizationTable;\n        this.descriptionBuilder = [];\n        this.pathCount = 0;\n        this.textNodeCount = 0;\n        this.imageNodeCount = 0;\n    }\n    displaySize() {\n        // We don't have a graphical display, export a reasonable size.\n        return math_1.Vec2.of(500, 500);\n    }\n    clear() {\n        this.descriptionBuilder = [];\n        this.pathCount = 0;\n        this.textNodeCount = 0;\n        this.imageNodeCount = 0;\n    }\n    getDescription() {\n        return [\n            this.localizationTable.pathNodeCount(this.pathCount),\n            ...(this.textNodeCount > 0 ? [this.localizationTable.textNodeCount(this.textNodeCount)] : []),\n            ...(this.imageNodeCount > 0\n                ? [this.localizationTable.imageNodeCount(this.imageNodeCount)]\n                : []),\n            ...this.descriptionBuilder,\n        ].join('\\n');\n    }\n    beginPath(_startPoint) { }\n    endPath(_style) {\n        this.pathCount++;\n    }\n    lineTo(_point) { }\n    moveTo(_point) { }\n    traceCubicBezierCurve(_p1, _p2, _p3) { }\n    traceQuadraticBezierCurve(_controlPoint, _endPoint) { }\n    drawText(text, _transform, _style) {\n        this.descriptionBuilder.push(this.localizationTable.textNode(text));\n        this.textNodeCount++;\n    }\n    drawImage(image) {\n        const label = image.label\n            ? this.localizationTable.imageNode(image.label)\n            : this.localizationTable.unlabeledImageNode;\n        this.descriptionBuilder.push(label);\n        this.imageNodeCount++;\n    }\n    isTooSmallToRender(rect) {\n        return rect.maxDimension < 15 / this.getSizeOfCanvasPixelOnScreen();\n    }\n    drawPoints(..._points) { }\n}\nexports[\"default\"] = TextOnlyRenderer;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/rendering/renderers/TextOnlyRenderer.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/shortcuts/KeyBinding.js":
/*!***************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/shortcuts/KeyBinding.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst isUppercaseLetter = (text) => {\n    return text.toUpperCase() === text && text.toLowerCase() !== text && text.length === 1;\n};\nconst isLowercaseLetter = (text) => {\n    return text.toLowerCase() === text && text.toUpperCase() !== text && text.length === 1;\n};\n/** Represents a key combination that can trigger a keyboard shortcut. */\nclass KeyBinding {\n    constructor(trigger) {\n        this.key = trigger.key;\n        this.shiftKey = trigger.shiftKey;\n        this.ctrlKey = trigger.ctrlKey;\n        this.altKey = trigger.altKey;\n        this.metaKey = trigger.metaKey;\n        this.controlOrMeta = trigger.controlOrMeta;\n    }\n    /** Returns true if and only if `keyEvent` should trigger this shortcut. */\n    matchesEvent(keyEvent) {\n        const lowercaseKey = keyEvent.key?.toLowerCase();\n        // Determine whether the input is an upper case letter or not.\n        const isUpperCaseKey = isUppercaseLetter(keyEvent.key ?? '');\n        const isLowercaseKey = isLowercaseLetter(keyEvent.key ?? '');\n        const ctrlKey = (keyEvent.ctrlKey ?? false) || lowercaseKey === 'control';\n        const altKey = (keyEvent.altKey ?? false) || lowercaseKey === 'alt';\n        const metaKey = (keyEvent.metaKey ?? false) || lowercaseKey === 'meta';\n        const shiftKey = (keyEvent.shiftKey ?? isUpperCaseKey) || lowercaseKey === 'shift';\n        const keyEventHasCtrlOrMeta = keyEvent.controlOrMeta || keyEvent.ctrlKey || keyEvent.metaKey || false;\n        // If we're not working with key codes,\n        if (this.key !== keyEvent.code) {\n            // Different keys entirely? They don't match.\n            if (this.key.toLowerCase() !== lowercaseKey) {\n                return false;\n            }\n            // If a case where the ASCII case of the given key might matter,\n            // compare.\n            if ((isUpperCaseKey || isLowercaseKey) && this.key !== keyEvent.key) {\n                // this.shiftKey may be interpreted as allowing this shortcut to be uppercased.\n                // If so, try making this.key uppercase and matching the shortcut.\n                const uppercaseKeyMatches = this.shiftKey === true && this.key.toUpperCase() === keyEvent.key;\n                if (!uppercaseKeyMatches) {\n                    return false;\n                }\n            }\n        }\n        const shortcutControlOrMeta = this.controlOrMeta;\n        // Match ctrl/meta if the shortcut doesn't have controlOrMeta specified\n        // (controlOrMeta should match either).\n        const ctrlAndMetaMatches = ctrlKey === this.ctrlKey && metaKey === this.metaKey && !shortcutControlOrMeta;\n        const matches = (ctrlAndMetaMatches || (shortcutControlOrMeta && keyEventHasCtrlOrMeta)) &&\n            altKey === this.altKey &&\n            (shiftKey === this.shiftKey || this.shiftKey === undefined);\n        return matches;\n    }\n    /**\n     * Returns a string representation of this shortcut in the same format accepted by\n     * {@link fromString}.\n     */\n    toString() {\n        const result = [];\n        if (this.ctrlKey && this.key !== 'control') {\n            result.push('Ctrl');\n        }\n        if (this.controlOrMeta) {\n            result.push('CtrlOrMeta');\n        }\n        if (this.altKey && this.key !== 'alt') {\n            result.push('Alt');\n        }\n        if (this.metaKey && this.key !== 'meta') {\n            result.push('Meta');\n        }\n        if (this.shiftKey && this.key !== 'shift') {\n            result.push('Shift');\n        }\n        result.push(this.key);\n        return result.join('+');\n    }\n    /**\n     * Accepts a string in the form `modifier1+modifier2+...+key` (e.g. `Ctrl+Shift+a`)\n     * and returns the corresponding `KeyboardShortcut`.\n     */\n    static fromString(shortcutStr) {\n        const getDefaultModifiers = (key) => {\n            // Unless a letter, as long as the given key matches, it shouldn't matter whether\n            // the shift key is pressed.\n            let shiftKey = undefined;\n            if (isUppercaseLetter(key)) {\n                shiftKey = true;\n            }\n            else if (isLowercaseLetter(key)) {\n                shiftKey = false;\n            }\n            // If not just a single character (e.g. a key code like KeyA), shift must\n            // be specified manually.\n            else if (key.length > 1) {\n                shiftKey = false;\n            }\n            const lowercaseKey = key.toLowerCase();\n            // shiftKey should always be true if the key is 'shift'\n            if (lowercaseKey === 'shift') {\n                shiftKey = true;\n            }\n            return {\n                shiftKey,\n                ctrlKey: lowercaseKey === 'control' || lowercaseKey === 'ctrl',\n                altKey: lowercaseKey === 'alt',\n                metaKey: lowercaseKey === 'meta',\n                controlOrMeta: lowercaseKey === 'control or meta' || lowercaseKey === 'ctrlormeta',\n            };\n        };\n        const hasNoModifiers = shortcutStr.search(/[-+]/) === -1 || shortcutStr.length === 1;\n        if (hasNoModifiers) {\n            const modifiers = getDefaultModifiers(shortcutStr);\n            return new KeyBinding({\n                key: shortcutStr,\n                ...modifiers,\n            });\n        }\n        const keyModifiersExp = /^(.*[-+])?(.+)$/g;\n        const match = keyModifiersExp.exec(shortcutStr);\n        if (!match) {\n            throw new Error(`Invalid shortcut expression, ${shortcutStr}!`);\n        }\n        const key = match[2];\n        const defaultModifiers = getDefaultModifiers(key);\n        const modifierStrings = (match[1] ?? '').split(/[-+]/);\n        let shiftKey = defaultModifiers.shiftKey;\n        let ctrlKey = defaultModifiers.ctrlKey;\n        let altKey = defaultModifiers.altKey;\n        let metaKey = defaultModifiers.metaKey;\n        let controlOrMeta = defaultModifiers.controlOrMeta;\n        for (const modifier of modifierStrings) {\n            if (modifier === '') {\n                continue;\n            }\n            switch (modifier.toLowerCase()) {\n                case 'shift':\n                    shiftKey = true;\n                    break;\n                case 'anyshift':\n                    shiftKey = undefined;\n                    break;\n                case 'ctrl':\n                case 'control':\n                    ctrlKey = true;\n                    break;\n                case 'meta':\n                    metaKey = true;\n                    break;\n                case 'ctrlormeta':\n                case 'ctrl or meta':\n                case 'controlormeta':\n                    controlOrMeta = true;\n                    break;\n                case 'alt':\n                    altKey = true;\n                    break;\n                default:\n                    throw new Error(`Unknown modifier: \"${modifier}\" in shortcut ${shortcutStr}.`);\n            }\n        }\n        const shortcut = new KeyBinding({\n            key,\n            shiftKey,\n            ctrlKey,\n            altKey,\n            metaKey,\n            controlOrMeta,\n        });\n        return shortcut;\n    }\n}\nexports[\"default\"] = KeyBinding;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/shortcuts/KeyBinding.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/shortcuts/KeyboardShortcutManager.js":
/*!****************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/shortcuts/KeyboardShortcutManager.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst getLocalizationTable_1 = __webpack_require__(/*! ../localizations/getLocalizationTable */ \"./node_modules/js-draw/dist/cjs/localizations/getLocalizationTable.js\");\nconst KeyBinding_1 = __importDefault(__webpack_require__(/*! ./KeyBinding */ \"./node_modules/js-draw/dist/cjs/shortcuts/KeyBinding.js\"));\n/**\n * Allows adding/changing keyboard shortcuts. This class provides static methods for registering\n * default shortcuts. An instance of this class must be used to access or change keyboard shortcuts.\n */\nclass KeyboardShortcutManager {\n    /**\n     * Creates a new `ShortcutManager` with an initial set of shortcut overrides.\n     *\n     * @internal\n     */\n    constructor(initialOverrides) {\n        this.shortcutOverrides = Object.create(null);\n        for (const id in initialOverrides) {\n            this.overrideShortcut(id, initialOverrides[id]);\n        }\n    }\n    /**\n     * Override an existing shortcut with a custom set of triggers.\n     * @internal\n     */\n    overrideShortcut(shortcutId, overrideWith) {\n        this.shortcutOverrides[shortcutId] = [...overrideWith];\n    }\n    /** Returns true if `keyEvent` matches the shortcut with `shortcutId`. @internal */\n    matchesShortcut(shortcutId, keyEvent) {\n        // Get all shortcucts associated with `shortcutId`.\n        let shortcutList = this.shortcutOverrides[shortcutId];\n        if (!shortcutList) {\n            if (shortcutId in KeyboardShortcutManager.shortcuts) {\n                shortcutList = KeyboardShortcutManager.shortcuts[shortcutId];\n            }\n            else {\n                throw new Error(`No shortcut with ID ${shortcutId} exists!`);\n            }\n        }\n        // return true if keyEvent matches *any* shortcuts in shortcutList\n        for (const shortcut of shortcutList) {\n            if (shortcut.matchesEvent(keyEvent)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Registers a default keyboard shortcut that can be overridden by individual instances\n     * of `ShortcutManager`. Note that `id` should be a globally unique identifier.\n     *\n     * Only the first call to this method for a given `id` has an effect.\n     *\n     * @example\n     * ```ts\n     * const shortcutId = 'io.github.personalizedrefrigerator.js-draw.select-all';\n     *\n     * // Associate two shortcuts with the same ID\n     * const shortcut1 = KeyBinding.fromString('ctrlOrMeta+a');\n     * const shortcut2 = KeyBinding.fromString('ctrlOrMeta+shift+a');\n     * KeyboardShortcutManager.registerDefaultKeyboardShortcut(\n     * \tshortcutId,\n     * \t[ shortcut1, shortcut2 ],\n     * \t\"Select All\",\n     * );\n     *\n     * // Provide a localized description\n     * KeyboardShortcutManager.provideShortcutDescription(\n     * \tshotcutId,\n     * \t'es',\n     * \t'Seleccionar todo',\n     * );\n     * ```\n     *\n     * @internal\n     */\n    static registerDefaultKeyboardShortcut(id, shortcuts, defaultDescription) {\n        if (id in KeyboardShortcutManager.shortcuts) {\n            return false;\n        }\n        // Convert the strings to shortcut maps.\n        const shortcutsAsShortcuts = shortcuts.map((shortcut) => {\n            if (typeof shortcut === 'string') {\n                return KeyBinding_1.default.fromString(shortcut);\n            }\n            return shortcut;\n        });\n        KeyboardShortcutManager.shortcuts[id] = [...shortcutsAsShortcuts];\n        KeyboardShortcutManager.shortcutDefaultDescriptions[id] = defaultDescription;\n        return true;\n    }\n    /** Provides a localized description of a keyboard shortcut. @internal */\n    static provideShortcutDescription(id, locale, description) {\n        if (!(locale in KeyboardShortcutManager.shortcutLocalizedDescriptions)) {\n            KeyboardShortcutManager.shortcutLocalizedDescriptions[locale] = Object.create(null);\n        }\n        KeyboardShortcutManager.shortcutLocalizedDescriptions[locale][id] = description;\n    }\n    /**\n     * Gets all registered keyboard shortcut IDs.\n     *\n     * @see {@link getShortcutDescription}\n     */\n    static getAllShortcutIds() {\n        const ids = [];\n        for (const id in this.shortcuts) {\n            ids.push(id);\n        }\n        return ids;\n    }\n    /**\n     * Get the default keybindings associated with a keyboard shortcut.\n     *\n     * Any keybinding in the resultant list, by default, can trigger the function associated\n     * with the shortcut.\n     */\n    static getShortcutDefaultKeybindings(shortcutId) {\n        if (!(shortcutId in KeyboardShortcutManager.shortcuts)) {\n            throw new Error(`No shortcut with ID ${shortcutId} exists!`);\n        }\n        return KeyboardShortcutManager.shortcuts[shortcutId];\n    }\n    /**\n     * Get a description of a keyboard shortcut.\n     *\n     * `localeList`, if given, attempts to\n     */\n    static getShortcutDescription(id, localeList) {\n        const localizationTable = (0, getLocalizationTable_1.matchingLocalizationTable)(localeList ?? [], this.shortcutLocalizedDescriptions, this.shortcutDefaultDescriptions);\n        return localizationTable[id] ?? this.shortcutDefaultDescriptions[id] ?? null;\n    }\n}\nKeyboardShortcutManager.shortcuts = Object.create(null);\nKeyboardShortcutManager.shortcutDefaultDescriptions = Object.create(null);\nKeyboardShortcutManager.shortcutLocalizedDescriptions = Object.create(null);\nexports[\"default\"] = KeyboardShortcutManager;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/shortcuts/KeyboardShortcutManager.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/shortcuts/lib.js":
/*!********************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/shortcuts/lib.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.KeyBinding = exports.KeyboardShortcutManager = void 0;\nvar KeyboardShortcutManager_1 = __webpack_require__(/*! ./KeyboardShortcutManager */ \"./node_modules/js-draw/dist/cjs/shortcuts/KeyboardShortcutManager.js\");\nObject.defineProperty(exports, \"KeyboardShortcutManager\", ({ enumerable: true, get: function () { return __importDefault(KeyboardShortcutManager_1).default; } }));\nvar KeyBinding_1 = __webpack_require__(/*! ./KeyBinding */ \"./node_modules/js-draw/dist/cjs/shortcuts/KeyBinding.js\");\nObject.defineProperty(exports, \"KeyBinding\", ({ enumerable: true, get: function () { return __importDefault(KeyBinding_1).default; } }));\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/shortcuts/lib.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/testing/getUniquePointerId.js":
/*!*********************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/testing/getUniquePointerId.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/** Returns the smallest ID not used by the pointers in the given list. */\nconst getUniquePointerId = (pointers) => {\n    let ptrId = 0;\n    const pointerIds = pointers.map((ptr) => ptr.id);\n    pointerIds.sort();\n    for (const pointerId of pointerIds) {\n        if (ptrId === pointerId) {\n            ptrId = pointerId + 1;\n        }\n    }\n    return ptrId;\n};\nexports[\"default\"] = getUniquePointerId;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/testing/getUniquePointerId.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/testing/lib.js":
/*!******************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/testing/lib.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.sendTouchEvent = exports.sendPenEvent = void 0;\nvar sendPenEvent_1 = __webpack_require__(/*! ./sendPenEvent */ \"./node_modules/js-draw/dist/cjs/testing/sendPenEvent.js\");\nObject.defineProperty(exports, \"sendPenEvent\", ({ enumerable: true, get: function () { return __importDefault(sendPenEvent_1).default; } }));\nvar sendTouchEvent_1 = __webpack_require__(/*! ./sendTouchEvent */ \"./node_modules/js-draw/dist/cjs/testing/sendTouchEvent.js\");\nObject.defineProperty(exports, \"sendTouchEvent\", ({ enumerable: true, get: function () { return __importDefault(sendTouchEvent_1).default; } }));\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/testing/lib.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/testing/sendPenEvent.js":
/*!***************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/testing/sendPenEvent.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Pointer_1 = __importStar(__webpack_require__(/*! ../Pointer */ \"./node_modules/js-draw/dist/cjs/Pointer.js\"));\nconst inputEvents_1 = __webpack_require__(/*! ../inputEvents */ \"./node_modules/js-draw/dist/cjs/inputEvents.js\");\nconst getUniquePointerId_1 = __importDefault(__webpack_require__(/*! ./getUniquePointerId */ \"./node_modules/js-draw/dist/cjs/testing/getUniquePointerId.js\"));\n/**\n * Dispatch a pen event to the currently selected tool.\n * Intended for unit tests.\n *\n * @see {@link sendTouchEvent}\n */\nconst sendPenEvent = (editor, eventType, point, allPointers, deviceType = Pointer_1.PointerDevice.Pen) => {\n    const id = (0, getUniquePointerId_1.default)(allPointers ?? []);\n    const mainPointer = Pointer_1.default.ofCanvasPoint(point, eventType !== inputEvents_1.InputEvtType.PointerUpEvt, editor.viewport, id, deviceType);\n    editor.toolController.dispatchInputEvent({\n        kind: eventType,\n        allPointers: allPointers ?? [mainPointer],\n        current: mainPointer,\n    });\n    return mainPointer;\n};\nexports[\"default\"] = sendPenEvent;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/testing/sendPenEvent.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/testing/sendTouchEvent.js":
/*!*****************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/testing/sendTouchEvent.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Pointer_1 = __importStar(__webpack_require__(/*! ../Pointer */ \"./node_modules/js-draw/dist/cjs/Pointer.js\"));\nconst inputEvents_1 = __webpack_require__(/*! ../inputEvents */ \"./node_modules/js-draw/dist/cjs/inputEvents.js\");\nconst getUniquePointerId_1 = __importDefault(__webpack_require__(/*! ./getUniquePointerId */ \"./node_modules/js-draw/dist/cjs/testing/getUniquePointerId.js\"));\n/**\n * Dispatch a touch event to the currently selected tool. Intended for unit tests.\n *\n * @see {@link sendPenEvent}\n *\n * @example\n * **Simulating a horizontal swipe gesture:**\n * ```ts\n * sendTouchEvent(editor, InputEvtType.PointerDownEvt, Vec2.of(0, 0));\n * for (let i = 1; i <= 10; i++) {\n *   jest.advanceTimersByTime(10);\n *   sendTouchEvent(editor, InputEvtType.PointerMoveEvt, Vec2.of(i * 10, 0));\n * }\n * ```\n *\n * @example\n * **Simulating a pinch gesture.** This example assumes that you're using [Jest with timer mocks enabled](https://jestjs.io/docs/timer-mocks).\n * ```ts\n * let firstPointer = sendTouchEvent(editor, InputEvtType.PointerDownEvt, Vec2.of(0, 0));\n * let secondPointer = sendTouchEvent(editor, InputEvtType.PointerDownEvt, Vec2.of(100, 0), [ firstPointer ]);\n *\n * // Simulate a pinch\n * const maxIterations = 10;\n * for (let i = 0; i < maxIterations; i++) {\n *   // Use the unit testing framework's tool for increasing the current time\n *   // returned by (new Date()).getTime(), etc.\n *   jest.advanceTimersByTime(100);\n *\n *   const point1 = Vec2.of(-i * 5, 0);\n *   const point2 = Vec2.of(i * 5 + 100, 0);\n *\n *   firstPointer = sendTouchEvent(editor, InputEvtType.PointerMoveEvt, point1, [ secondPointer ]);\n *   secondPointer = sendTouchEvent(editor, InputEvtType.PointerMoveEvt, point2, [ firstPointer ]);\n * }\n * ```\n */\nconst sendTouchEvent = (editor, eventType, screenPos, allOtherPointers) => {\n    const canvasPos = editor.viewport.screenToCanvas(screenPos);\n    // Get a unique ID for the main pointer\n    // (try to use id=0, but don't use it if it's already in use).\n    const ptrId = (0, getUniquePointerId_1.default)(allOtherPointers ?? []);\n    const mainPointer = Pointer_1.default.ofCanvasPoint(canvasPos, eventType !== inputEvents_1.InputEvtType.PointerUpEvt, editor.viewport, ptrId, Pointer_1.PointerDevice.Touch);\n    editor.toolController.dispatchInputEvent({\n        kind: eventType,\n        allPointers: [...(allOtherPointers ?? []), mainPointer],\n        current: mainPointer,\n    });\n    return mainPointer;\n};\nexports[\"default\"] = sendTouchEvent;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/testing/sendTouchEvent.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/toolbar/AbstractToolbar.js":
/*!******************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/toolbar/AbstractToolbar.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar _AbstractToolbar_listeners, _AbstractToolbar_widgetsById, _AbstractToolbar_widgetList, _AbstractToolbar_updateColoris;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst types_1 = __webpack_require__(/*! ../types */ \"./node_modules/js-draw/dist/cjs/types.js\");\nconst coloris_1 = __webpack_require__(/*! @melloware/coloris */ \"./node_modules/@melloware/coloris/dist/umd/coloris.js\");\nconst localization_1 = __webpack_require__(/*! ./localization */ \"./node_modules/js-draw/dist/cjs/toolbar/localization.js\");\nconst SelectionTool_1 = __importDefault(__webpack_require__(/*! ../tools/SelectionTool/SelectionTool */ \"./node_modules/js-draw/dist/cjs/tools/SelectionTool/SelectionTool.js\"));\nconst PanZoom_1 = __importDefault(__webpack_require__(/*! ../tools/PanZoom */ \"./node_modules/js-draw/dist/cjs/tools/PanZoom.js\"));\nconst TextTool_1 = __importDefault(__webpack_require__(/*! ../tools/TextTool */ \"./node_modules/js-draw/dist/cjs/tools/TextTool.js\"));\nconst Eraser_1 = __importDefault(__webpack_require__(/*! ../tools/Eraser */ \"./node_modules/js-draw/dist/cjs/tools/Eraser.js\"));\nconst Pen_1 = __importDefault(__webpack_require__(/*! ../tools/Pen */ \"./node_modules/js-draw/dist/cjs/tools/Pen.js\"));\nconst PenToolWidget_1 = __importDefault(__webpack_require__(/*! ./widgets/PenToolWidget */ \"./node_modules/js-draw/dist/cjs/toolbar/widgets/PenToolWidget.js\"));\nconst EraserToolWidget_1 = __importDefault(__webpack_require__(/*! ./widgets/EraserToolWidget */ \"./node_modules/js-draw/dist/cjs/toolbar/widgets/EraserToolWidget.js\"));\nconst SelectionToolWidget_1 = __importDefault(__webpack_require__(/*! ./widgets/SelectionToolWidget */ \"./node_modules/js-draw/dist/cjs/toolbar/widgets/SelectionToolWidget.js\"));\nconst TextToolWidget_1 = __importDefault(__webpack_require__(/*! ./widgets/TextToolWidget */ \"./node_modules/js-draw/dist/cjs/toolbar/widgets/TextToolWidget.js\"));\nconst HandToolWidget_1 = __importDefault(__webpack_require__(/*! ./widgets/HandToolWidget */ \"./node_modules/js-draw/dist/cjs/toolbar/widgets/HandToolWidget.js\"));\nconst BaseWidget_1 = __webpack_require__(/*! ./widgets/BaseWidget */ \"./node_modules/js-draw/dist/cjs/toolbar/widgets/BaseWidget.js\");\nconst ActionButtonWidget_1 = __importDefault(__webpack_require__(/*! ./widgets/ActionButtonWidget */ \"./node_modules/js-draw/dist/cjs/toolbar/widgets/ActionButtonWidget.js\"));\nconst InsertImageWidget_1 = __importDefault(__webpack_require__(/*! ./widgets/InsertImageWidget/InsertImageWidget */ \"./node_modules/js-draw/dist/cjs/toolbar/widgets/InsertImageWidget/InsertImageWidget.js\"));\nconst DocumentPropertiesWidget_1 = __importDefault(__webpack_require__(/*! ./widgets/DocumentPropertiesWidget */ \"./node_modules/js-draw/dist/cjs/toolbar/widgets/DocumentPropertiesWidget.js\"));\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"./node_modules/js-draw/dist/cjs/toolbar/constants.js\");\nconst SaveActionWidget_1 = __importDefault(__webpack_require__(/*! ./widgets/SaveActionWidget */ \"./node_modules/js-draw/dist/cjs/toolbar/widgets/SaveActionWidget.js\"));\nconst ExitActionWidget_1 = __importDefault(__webpack_require__(/*! ./widgets/ExitActionWidget */ \"./node_modules/js-draw/dist/cjs/toolbar/widgets/ExitActionWidget.js\"));\nconst assertions_1 = __webpack_require__(/*! ../util/assertions */ \"./node_modules/js-draw/dist/cjs/util/assertions.js\");\n/**\n * Abstract base class for js-draw editor toolbars.\n *\n * See {@link Editor.addToolbar}, {@link makeDropdownToolbar}, and {@link makeEdgeToolbar}.\n */\nclass AbstractToolbar {\n    /** @internal */\n    constructor(editor, localizationTable = localization_1.defaultToolbarLocalization) {\n        this.editor = editor;\n        this.localizationTable = localizationTable;\n        _AbstractToolbar_listeners.set(this, []);\n        _AbstractToolbar_widgetsById.set(this, {});\n        _AbstractToolbar_widgetList.set(this, []);\n        _AbstractToolbar_updateColoris.set(this, null);\n        this.closeColorPickerOverlay = null;\n        if (!AbstractToolbar.colorisStarted) {\n            (0, coloris_1.init)();\n            AbstractToolbar.colorisStarted = true;\n        }\n        this.setupColorPickers();\n    }\n    setupCloseColorPickerOverlay() {\n        if (this.closeColorPickerOverlay)\n            return;\n        this.closeColorPickerOverlay = document.createElement('div');\n        this.closeColorPickerOverlay.className = `${constants_1.toolbarCSSPrefix}closeColorPickerOverlay`;\n        this.editor.createHTMLOverlay(this.closeColorPickerOverlay);\n        // Hide the color picker when attempting to draw on the overlay.\n        __classPrivateFieldGet(this, _AbstractToolbar_listeners, \"f\").push(this.editor.handlePointerEventsExceptClicksFrom(this.closeColorPickerOverlay, (eventName) => {\n            if (eventName === 'pointerdown') {\n                (0, coloris_1.close)();\n            }\n            // Transfer focus to the editor to allow keyboard events to be handled.\n            if (eventName === 'pointerup') {\n                this.editor.focus();\n            }\n            // Send the event to the editor\n            return true;\n        }));\n    }\n    // @internal\n    setupColorPickers() {\n        // Much of the setup only needs to be done once.\n        if (__classPrivateFieldGet(this, _AbstractToolbar_updateColoris, \"f\")) {\n            __classPrivateFieldGet(this, _AbstractToolbar_updateColoris, \"f\").call(this);\n            return;\n        }\n        this.setupCloseColorPickerOverlay();\n        const maxSwatchLen = 12;\n        const swatches = [\n            math_1.Color4.red.toHexString(),\n            math_1.Color4.purple.toHexString(),\n            math_1.Color4.blue.toHexString(),\n            math_1.Color4.clay.toHexString(),\n            math_1.Color4.black.toHexString(),\n            math_1.Color4.white.toHexString(),\n        ];\n        const presetColorEnd = swatches.length;\n        // Keeps track of whether a Coloris initialization is scheduled.\n        let colorisInitScheduled = false;\n        // (Re)init Coloris -- update the swatches list.\n        const initColoris = () => {\n            try {\n                (0, coloris_1.coloris)({\n                    el: '.coloris_input',\n                    format: 'hex',\n                    selectInput: false,\n                    focusInput: false,\n                    themeMode: 'auto',\n                    swatches,\n                });\n            }\n            catch (err) {\n                console.warn('Failed to initialize Coloris. Error: ', err);\n                // Try again --- a known issue is that Coloris fails to load if the document\n                // isn't ready.\n                if (!colorisInitScheduled) {\n                    colorisInitScheduled = true;\n                    // Wait to initialize after the document has loaded\n                    document.addEventListener('load', () => {\n                        initColoris();\n                    }, { once: true });\n                }\n            }\n        };\n        initColoris();\n        __classPrivateFieldSet(this, _AbstractToolbar_updateColoris, initColoris, \"f\");\n        const addColorToSwatch = (newColor) => {\n            let alreadyPresent = false;\n            for (const color of swatches) {\n                if (color === newColor) {\n                    alreadyPresent = true;\n                }\n            }\n            if (!alreadyPresent) {\n                swatches.push(newColor);\n                if (swatches.length > maxSwatchLen) {\n                    swatches.splice(presetColorEnd, 1);\n                }\n                initColoris();\n            }\n        };\n        __classPrivateFieldGet(this, _AbstractToolbar_listeners, \"f\").push(this.editor.notifier.on(types_1.EditorEventType.ColorPickerToggled, (event) => {\n            if (event.kind !== types_1.EditorEventType.ColorPickerToggled) {\n                return;\n            }\n            // Show/hide the overlay. Making the overlay visible gives users a surface to click\n            // on that shows/hides the color picker.\n            if (this.closeColorPickerOverlay) {\n                this.closeColorPickerOverlay.style.display = event.open ? 'block' : 'none';\n            }\n        }));\n        // Add newly-selected colors to the swatch.\n        __classPrivateFieldGet(this, _AbstractToolbar_listeners, \"f\").push(this.editor.notifier.on(types_1.EditorEventType.ColorPickerColorSelected, (event) => {\n            if (event.kind === types_1.EditorEventType.ColorPickerColorSelected) {\n                addColorToSwatch(event.color.toHexString());\n            }\n        }));\n    }\n    closeColorPickers() {\n        (0, coloris_1.close)?.();\n    }\n    getWidgetUniqueId(widget) {\n        return widget.getUniqueIdIn(__classPrivateFieldGet(this, _AbstractToolbar_widgetsById, \"f\"));\n    }\n    getWidgetFromId(id) {\n        return __classPrivateFieldGet(this, _AbstractToolbar_widgetsById, \"f\")[id];\n    }\n    /** Do **not** modify the return value. */\n    getAllWidgets() {\n        return __classPrivateFieldGet(this, _AbstractToolbar_widgetList, \"f\");\n    }\n    /**\n     * Adds an `ActionButtonWidget` or `BaseToolWidget`. The widget should not have already have a parent\n     * (i.e. its `addTo` method should not have been called).\n     *\n     * @example\n     * ```ts\n     * const toolbar = editor.addToolbar();\n     * const insertImageWidget = new InsertImageWidget(editor);\n     * toolbar.addWidget(insertImageWidget);\n     * ```\n     */\n    addWidget(widget) {\n        // Prevent name collisions\n        const id = widget.getUniqueIdIn(__classPrivateFieldGet(this, _AbstractToolbar_widgetsById, \"f\"));\n        // Add the widget\n        __classPrivateFieldGet(this, _AbstractToolbar_widgetsById, \"f\")[id] = widget;\n        __classPrivateFieldGet(this, _AbstractToolbar_widgetList, \"f\").push(widget);\n        this.addWidgetInternal(widget);\n        this.setupColorPickers();\n    }\n    /** Removes the given `widget` from this toolbar. */\n    removeWidget(widget) {\n        const id = widget.getUniqueIdIn(__classPrivateFieldGet(this, _AbstractToolbar_widgetsById, \"f\"));\n        this.removeWidgetInternal(widget);\n        delete __classPrivateFieldGet(this, _AbstractToolbar_widgetsById, \"f\")[id];\n        __classPrivateFieldSet(this, _AbstractToolbar_widgetList, __classPrivateFieldGet(this, _AbstractToolbar_widgetList, \"f\").filter((otherWidget) => otherWidget !== widget), \"f\");\n    }\n    /** Returns a snapshot of the state of widgets in the toolbar. */\n    serializeState() {\n        const result = {};\n        for (const widgetId in __classPrivateFieldGet(this, _AbstractToolbar_widgetsById, \"f\")) {\n            result[widgetId] = __classPrivateFieldGet(this, _AbstractToolbar_widgetsById, \"f\")[widgetId].serializeState();\n        }\n        result[AbstractToolbar.rootToolbarId] = this.serializeInternal();\n        return JSON.stringify(result);\n    }\n    /**\n     * Deserialize toolbar widgets from the given state.\n     * Assumes that toolbar widgets are in the same order as when state was serialized.\n     */\n    deserializeState(state) {\n        const data = JSON.parse(state);\n        (0, assertions_1.assertIsObject)(data);\n        (0, assertions_1.assertTruthy)(data);\n        const rootId = AbstractToolbar.rootToolbarId;\n        if (rootId in data && typeof data[rootId] !== 'undefined') {\n            this.deserializeInternal(data[rootId]);\n        }\n        for (const widgetId in data) {\n            if (widgetId === rootId) {\n                continue;\n            }\n            if (!(widgetId in __classPrivateFieldGet(this, _AbstractToolbar_widgetsById, \"f\"))) {\n                console.warn(`Unable to deserialize widget ${widgetId} ­— no such widget.`);\n                continue;\n            }\n            if (typeof data[widgetId] === 'object' && data[widgetId]) {\n                __classPrivateFieldGet(this, _AbstractToolbar_widgetsById, \"f\")[widgetId].deserializeFrom(data[widgetId]);\n            }\n        }\n    }\n    /**\n     * Called by `serializeState` to attach any additional JSONifyable data\n     * to the serialized result.\n     *\n     * @returns an object that can be converted to JSON with `JSON.stringify`.\n     */\n    serializeInternal() { }\n    /**\n     * Called by `deserializeState` with a version of the JSON outputted\n     * previously by `serializeInternal`.\n     */\n    deserializeInternal(_json) { }\n    /**\n     * Creates, but does not add, an action button to this container.\n     *\n     * @see\n     * {@link addActionButton}\n     */\n    makeActionButton(title, command, options = true) {\n        // Parse options\n        if (typeof options === 'boolean') {\n            options = {\n                mustBeToplevel: options,\n            };\n        }\n        const mustBeToplevel = options.mustBeToplevel ?? true;\n        const autoDisableInReadOnlyEditors = options.autoDisableInReadOnlyEditors ?? true;\n        const titleString = typeof title === 'string' ? title : title.label;\n        const widgetId = 'action-button';\n        const makeIcon = () => {\n            if (typeof title === 'string') {\n                return null;\n            }\n            return title.icon;\n        };\n        const widget = new ActionButtonWidget_1.default(this.editor, widgetId, makeIcon, titleString, command, this.editor.localization, mustBeToplevel, autoDisableInReadOnlyEditors);\n        return widget;\n    }\n    /**\n     * Adds an action button with `title` to this toolbar (or to the given `parent` element).\n     *\n     * `options` can either be an object with properties `mustBeToplevel` and/or\n     * `autoDisableInReadOnlyEditors` or a boolean value. If a boolean, it is interpreted\n     * as being the value of `mustBeToplevel`.\n     *\n     * @return The added button.\n     *\n     * **Example**:\n     * ```ts,runnable\n     * import { Editor } from 'js-draw';\n     * const editor = new Editor(document.body);\n     * const toolbar = editor.addToolbar();\n     *\n     * function makeTrashIcon() {\n     *   const container = document.createElement('div');\n     *   container.textContent = '🗑️';\n     *   return container;\n     * }\n     *\n     * toolbar.addActionButton({\n     *   icon: makeTrashIcon(), // can be any Element not in the DOM\n     *   label: 'Delete all',\n     * }, () => {\n     *   alert('to-do!');\n     * });\n     */\n    addActionButton(title, command, options = true) {\n        const widget = this.makeActionButton(title, command, options);\n        this.addWidget(widget);\n        return widget;\n    }\n    /**\n     * Like {@link addActionButton}, except associates `tags` with the button that allow\n     * different toolbar styles to give the button tag-dependent styles.\n     */\n    addTaggedActionButton(tags, title, command, options = true) {\n        const widget = this.makeActionButton(title, command, options);\n        widget.setTags(tags);\n        this.addWidget(widget);\n        return widget;\n    }\n    /**\n     * Adds a save button that, when clicked, calls `saveCallback`.\n     *\n     * @example\n     * ```ts,runnable\n     * import { Editor, makeDropdownToolbar } from 'js-draw';\n     *\n     * const editor = new Editor(document.body);\n     * const toolbar = makeDropdownToolbar(editor);\n     *\n     * toolbar.addDefaults();\n     * toolbar.addSaveButton(() => alert('save clicked!'));\n     * ```\n     *\n     * `labelOverride` can optionally be used to change the `label` or `icon` of the button.\n     */\n    addSaveButton(saveCallback, labelOverride = {}) {\n        const widget = new SaveActionWidget_1.default(this.editor, this.localizationTable, saveCallback, labelOverride);\n        this.addWidget(widget);\n        return widget;\n    }\n    /**\n     * Adds an \"Exit\" button that, when clicked, calls `exitCallback`.\n     *\n     * **Note**: This is *roughly* equivalent to\n     * ```ts\n     * toolbar.addTaggedActionButton([ ToolbarWidgetTag.Exit ], {\n     *   label: this.editor.localization.exit,\n     *   icon: this.editor.icons.makeCloseIcon(),\n     *\n     *   // labelOverride can be used to override label or icon.\n     *   ...labelOverride,\n     * }, () => {\n     *   exitCallback();\n     * });\n     * ```\n     * with some additional configuration.\n     *\n     * @final\n     */\n    addExitButton(exitCallback, labelOverride = {}) {\n        const widget = new ExitActionWidget_1.default(this.editor, this.localizationTable, exitCallback, labelOverride);\n        this.addWidget(widget);\n        return widget;\n    }\n    /**\n     * Adds undo and redo buttons that trigger the editor's built-in undo and redo\n     * functionality.\n     */\n    addUndoRedoButtons(undoFirst = true) {\n        const makeUndo = () => {\n            return this.addTaggedActionButton([BaseWidget_1.ToolbarWidgetTag.Undo], {\n                label: this.localizationTable.undo,\n                icon: this.editor.icons.makeUndoIcon(),\n            }, () => {\n                this.editor.history.undo();\n            });\n        };\n        const makeRedo = () => {\n            return this.addTaggedActionButton([BaseWidget_1.ToolbarWidgetTag.Redo], {\n                label: this.localizationTable.redo,\n                icon: this.editor.icons.makeRedoIcon(),\n            }, () => {\n                this.editor.history.redo();\n            });\n        };\n        let undoButton;\n        let redoButton;\n        if (undoFirst) {\n            undoButton = makeUndo();\n            redoButton = makeRedo();\n        }\n        else {\n            redoButton = makeRedo();\n            undoButton = makeUndo();\n        }\n        undoButton.setDisabled(true);\n        redoButton.setDisabled(true);\n        this.editor.notifier.on(types_1.EditorEventType.UndoRedoStackUpdated, (event) => {\n            if (event.kind !== types_1.EditorEventType.UndoRedoStackUpdated) {\n                throw new Error('Wrong event type!');\n            }\n            undoButton.setDisabled(event.undoStackSize === 0);\n            redoButton.setDisabled(event.redoStackSize === 0);\n        });\n    }\n    /**\n     * Adds widgets for pen/eraser/selection/text/pan-zoom primary tools.\n     *\n     * If `filter` returns `false` for a tool, no widget is added for that tool.\n     * See {@link addDefaultToolWidgets}\n     */\n    addWidgetsForPrimaryTools(filter) {\n        for (const tool of this.editor.toolController.getPrimaryTools()) {\n            if (filter && !filter?.(tool)) {\n                continue;\n            }\n            if (tool instanceof Pen_1.default) {\n                const widget = new PenToolWidget_1.default(this.editor, tool, this.localizationTable);\n                this.addWidget(widget);\n            }\n            else if (tool instanceof Eraser_1.default) {\n                this.addWidget(new EraserToolWidget_1.default(this.editor, tool, this.localizationTable));\n            }\n            else if (tool instanceof SelectionTool_1.default) {\n                this.addWidget(new SelectionToolWidget_1.default(this.editor, tool, this.localizationTable));\n            }\n            else if (tool instanceof TextTool_1.default) {\n                this.addWidget(new TextToolWidget_1.default(this.editor, tool, this.localizationTable));\n            }\n            else if (tool instanceof PanZoom_1.default) {\n                this.addWidget(new HandToolWidget_1.default(this.editor, tool, this.localizationTable));\n            }\n        }\n    }\n    /**\n     * Adds toolbar widgets based on the enabled tools, and additional tool-like\n     * buttons (e.g. {@link DocumentPropertiesWidget} and {@link InsertImageWidget}).\n     */\n    addDefaultToolWidgets() {\n        this.addWidgetsForPrimaryTools();\n        this.addDefaultEditorControlWidgets();\n    }\n    /**\n     * Adds widgets that don't correspond to tools, but do allow the user to control\n     * the editor in some way.\n     *\n     * By default, this includes {@link DocumentPropertiesWidget} and {@link InsertImageWidget}.\n     */\n    addDefaultEditorControlWidgets() {\n        this.addWidget(new DocumentPropertiesWidget_1.default(this.editor, this.localizationTable));\n        this.addWidget(new InsertImageWidget_1.default(this.editor, this.localizationTable));\n    }\n    addDefaultActionButtons() {\n        this.addUndoRedoButtons();\n    }\n    /**\n     * Remove this toolbar from its container and clean up listeners.\n     * This should only be called **once** for a given toolbar.\n     */\n    remove() {\n        this.closeColorPickerOverlay?.remove();\n        for (const listener of __classPrivateFieldGet(this, _AbstractToolbar_listeners, \"f\")) {\n            listener.remove();\n        }\n        __classPrivateFieldSet(this, _AbstractToolbar_listeners, [], \"f\");\n        this.onRemove();\n        for (const widget of __classPrivateFieldGet(this, _AbstractToolbar_widgetList, \"f\")) {\n            widget.remove();\n        }\n    }\n    /**\n     * Removes `listener` when {@link remove} is called.\n     */\n    manageListener(listener) {\n        __classPrivateFieldGet(this, _AbstractToolbar_listeners, \"f\").push(listener);\n    }\n}\n_AbstractToolbar_listeners = new WeakMap(), _AbstractToolbar_widgetsById = new WeakMap(), _AbstractToolbar_widgetList = new WeakMap(), _AbstractToolbar_updateColoris = new WeakMap();\nAbstractToolbar.colorisStarted = false;\nAbstractToolbar.rootToolbarId = 'root-toolbar--';\nexports[\"default\"] = AbstractToolbar;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/toolbar/AbstractToolbar.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/toolbar/DropdownToolbar.js":
/*!******************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/toolbar/DropdownToolbar.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.makeDropdownToolbar = void 0;\nconst localization_1 = __webpack_require__(/*! ./localization */ \"./node_modules/js-draw/dist/cjs/toolbar/localization.js\");\nconst OverflowWidget_1 = __importDefault(__webpack_require__(/*! ./widgets/OverflowWidget */ \"./node_modules/js-draw/dist/cjs/toolbar/widgets/OverflowWidget.js\"));\nconst AbstractToolbar_1 = __importDefault(__webpack_require__(/*! ./AbstractToolbar */ \"./node_modules/js-draw/dist/cjs/toolbar/AbstractToolbar.js\"));\nconst constants_1 = __webpack_require__(/*! ./constants */ \"./node_modules/js-draw/dist/cjs/toolbar/constants.js\");\n/**\n * @example\n *\n * ```ts,runnable\n * import { makeDropdownToolbar, Editor } from 'js-draw';\n *\n * const editor = new Editor(document.body);\n * const toolbar = makeDropdownToolbar(editor);\n * toolbar.addDefaults();\n *\n * toolbar.addExitButton(editor => {\n *   // TODO\n * });\n *\n * toolbar.addSaveButton(editor => {\n *   // TODO\n * });\n * ```\n *\n * Returns a subclass of {@link AbstractToolbar}.\n *\n * @see\n * - {@link makeEdgeToolbar}\n * - {@link AbstractToolbar.addSaveButton}\n * - {@link AbstractToolbar.addExitButton}\n */\nconst makeDropdownToolbar = (editor) => {\n    return new DropdownToolbar(editor, editor.getRootElement());\n};\nexports.makeDropdownToolbar = makeDropdownToolbar;\nclass DropdownToolbar extends AbstractToolbar_1.default {\n    /** @internal */\n    constructor(editor, parent, localizationTable = localization_1.defaultToolbarLocalization) {\n        super(editor, localizationTable);\n        // Flex-order of the next widget to be added.\n        this.widgetOrderCounter = 0;\n        // Widget to toggle overflow menu.\n        this.overflowWidget = null;\n        this.reLayoutQueued = false;\n        this.container = document.createElement('div');\n        this.container.classList.add(`${constants_1.toolbarCSSPrefix}root`);\n        this.container.classList.add(`${constants_1.toolbarCSSPrefix}element`);\n        this.container.classList.add(`${constants_1.toolbarCSSPrefix}dropdown-toolbar`);\n        this.container.setAttribute('role', 'toolbar');\n        parent.appendChild(this.container);\n        if ('ResizeObserver' in window) {\n            this.resizeObserver = new ResizeObserver((_entries) => {\n                this.reLayout();\n            });\n            this.resizeObserver.observe(this.container);\n        }\n        else {\n            console.warn('ResizeObserver not supported. Toolbar will not resize.');\n        }\n    }\n    queueReLayout() {\n        if (!this.reLayoutQueued) {\n            this.reLayoutQueued = true;\n            requestAnimationFrame(() => this.reLayout());\n        }\n    }\n    reLayout() {\n        this.reLayoutQueued = false;\n        if (!this.overflowWidget) {\n            return;\n        }\n        const getTotalWidth = (widgetList) => {\n            let totalWidth = 0;\n            for (const widget of widgetList) {\n                if (!widget.isHidden()) {\n                    totalWidth += widget.getButtonWidth();\n                }\n            }\n            return totalWidth;\n        };\n        // Returns true if there is enough empty space to move the first child\n        // from the overflow menu to the main menu.\n        const canRemoveFirstChildFromOverflow = (freeSpaceInMainMenu) => {\n            const overflowChildren = this.overflowWidget?.getChildWidgets() ?? [];\n            if (overflowChildren.length === 0) {\n                return false;\n            }\n            return overflowChildren[0].getButtonWidth() <= freeSpaceInMainMenu;\n        };\n        const allWidgets = this.getAllWidgets();\n        let overflowWidgetsWidth = getTotalWidth(this.overflowWidget.getChildWidgets());\n        let shownWidgetWidth = getTotalWidth(allWidgets) - overflowWidgetsWidth;\n        let availableWidth = this.container.clientWidth * 0.87;\n        // If on a device that has enough vertical space, allow\n        // showing two rows of buttons.\n        // TODO: Fix magic numbers\n        if (window.innerHeight > availableWidth * 1.75) {\n            availableWidth *= 1.75;\n        }\n        let updatedChildren = false;\n        // If we can remove at least one child from the overflow menu,\n        if (canRemoveFirstChildFromOverflow(availableWidth - shownWidgetWidth)) {\n            // Move widgets to the main menu.\n            const overflowChildren = this.overflowWidget.clearChildren();\n            for (const child of overflowChildren) {\n                child.addTo(this.container);\n                child.setIsToplevel(true);\n                if (!child.isHidden()) {\n                    shownWidgetWidth += child.getButtonWidth();\n                }\n            }\n            overflowWidgetsWidth = 0;\n            updatedChildren = true;\n        }\n        if (shownWidgetWidth >= availableWidth) {\n            // Move widgets to the overflow menu.\n            // Start with the rightmost widget, move to the leftmost\n            for (let i = allWidgets.length - 1; i >= 0 && shownWidgetWidth >= availableWidth; i--) {\n                const child = allWidgets[i];\n                if (this.overflowWidget.hasAsChild(child)) {\n                    continue;\n                }\n                if (child.canBeInOverflowMenu()) {\n                    shownWidgetWidth -= child.getButtonWidth();\n                    this.overflowWidget.addToOverflow(child);\n                }\n            }\n            updatedChildren = true;\n        }\n        // Hide/show the overflow widget.\n        this.overflowWidget.setHidden(this.overflowWidget.getChildWidgets().length === 0);\n        if (updatedChildren) {\n            this.setupColorPickers();\n        }\n    }\n    addWidgetInternal(widget) {\n        const container = widget.addTo(this.container);\n        // Ensure that the widget gets displayed in the correct\n        // place in the toolbar, even if it's removed and re-added.\n        container.style.order = `${this.widgetOrderCounter++}`;\n        this.queueReLayout();\n    }\n    removeWidgetInternal(widget) {\n        widget.remove();\n        this.queueReLayout();\n    }\n    addSpacer(options = {}) {\n        const spacer = document.createElement('div');\n        spacer.classList.add(`${constants_1.toolbarCSSPrefix}spacer`);\n        if (options.grow) {\n            spacer.style.flexGrow = `${options.grow}`;\n        }\n        if (options.minSize) {\n            spacer.style.minWidth = options.minSize;\n        }\n        if (options.maxSize) {\n            spacer.style.maxWidth = options.maxSize;\n        }\n        spacer.style.order = `${this.widgetOrderCounter++}`;\n        this.container.appendChild(spacer);\n    }\n    /**\n     * Adds a widget that toggles the overflow menu. Call `addOverflowWidget` to ensure\n     * that this widget is in the correct space (if shown).\n     *\n     * @example\n     * ```ts\n     * toolbar.addDefaultToolWidgets();\n     * toolbar.addOverflowWidget();\n     * toolbar.addDefaultActionButtons();\n     * ```\n     * shows the overflow widget between the default tool widgets and the default action buttons,\n     * if shown.\n     */\n    addOverflowWidget() {\n        this.overflowWidget = new OverflowWidget_1.default(this.editor, this.localizationTable);\n        this.addWidget(this.overflowWidget);\n    }\n    /**\n     * Adds both the default tool widgets and action buttons. Equivalent to\n     * ```ts\n     * toolbar.addDefaultToolWidgets();\n     * toolbar.addOverflowWidget();\n     * toolbar.addDefaultActionButtons();\n     * ```\n     */\n    addDefaults() {\n        this.addDefaultToolWidgets();\n        this.addOverflowWidget();\n        this.addDefaultActionButtons();\n    }\n    onRemove() {\n        this.container.remove();\n        this.resizeObserver.disconnect();\n    }\n}\nexports[\"default\"] = DropdownToolbar;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/toolbar/DropdownToolbar.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/toolbar/EdgeToolbar.js":
/*!**************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/toolbar/EdgeToolbar.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.makeEdgeToolbar = void 0;\nconst BaseWidget_1 = __webpack_require__(/*! ./widgets/BaseWidget */ \"./node_modules/js-draw/dist/cjs/toolbar/widgets/BaseWidget.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"./node_modules/js-draw/dist/cjs/toolbar/constants.js\");\nconst EdgeToolbarLayoutManager_1 = __importDefault(__webpack_require__(/*! ./widgets/layout/EdgeToolbarLayoutManager */ \"./node_modules/js-draw/dist/cjs/toolbar/widgets/layout/EdgeToolbarLayoutManager.js\"));\nconst ReactiveValue_1 = __webpack_require__(/*! ../util/ReactiveValue */ \"./node_modules/js-draw/dist/cjs/util/ReactiveValue.js\");\nconst AbstractToolbar_1 = __importDefault(__webpack_require__(/*! ./AbstractToolbar */ \"./node_modules/js-draw/dist/cjs/toolbar/AbstractToolbar.js\"));\nconst stopPropagationOfScrollingWheelEvents_1 = __importDefault(__webpack_require__(/*! ../util/stopPropagationOfScrollingWheelEvents */ \"./node_modules/js-draw/dist/cjs/util/stopPropagationOfScrollingWheelEvents.js\"));\nconst makeDraggable_1 = __importDefault(__webpack_require__(/*! ./utils/makeDraggable */ \"./node_modules/js-draw/dist/cjs/toolbar/utils/makeDraggable.js\"));\n/**\n * Creates an `EdgeToolbar`.\n *\n * [Credit for the original design of this UI](https://www.figma.com/file/NA5F2AMWO3wUuaoDfUaAb8/Material-3-wireframes?type=design&node-id=54490%3A1103&mode=design&t=Ee0UwnPnQ2bNC2uM-1).\n *\n * @example\n *\n * ```ts,runnable\n * import { makeEdgeToolbar, Editor } from 'js-draw';\n *\n * const editor = new Editor(document.body);\n * const toolbar = makeEdgeToolbar(editor);\n * toolbar.addDefaults();\n *\n * toolbar.addSaveButton(editor => {\n *   // TODO\n * });\n *\n * toolbar.addExitButton(editor => {\n *   // TODO\n * });\n * ```\n *\n * @see\n * - {@link makeDropdownToolbar}\n * - {@link AbstractToolbar.addSaveButton}\n * - {@link AbstractToolbar.addExitButton}\n */\nconst makeEdgeToolbar = (editor) => {\n    return new EdgeToolbar(editor, editor.getRootElement(), editor.localization);\n};\nexports.makeEdgeToolbar = makeEdgeToolbar;\nclass EdgeToolbar extends AbstractToolbar_1.default {\n    /** @internal */\n    constructor(editor, parent, localizationTable) {\n        super(editor, localizationTable);\n        this.clearDragListeners = null;\n        this.toolbarContainer = document.createElement('div');\n        this.toolbarContainer.classList.add(`${constants_1.toolbarCSSPrefix}root`);\n        this.toolbarContainer.classList.add(`${constants_1.toolbarCSSPrefix}element`);\n        this.toolbarContainer.classList.add(`${constants_1.toolbarCSSPrefix}edge-toolbar`);\n        this.toolbarContainer.setAttribute('role', 'toolbar');\n        this.toolbarActionRow = document.createElement('div');\n        this.toolbarActionRow.classList.add('toolbar-element', 'toolbar-action-row');\n        this.toolbarToolRow = document.createElement('div');\n        this.toolbarToolRow.classList.add('toolbar-element', 'toolbar-tool-row');\n        (0, stopPropagationOfScrollingWheelEvents_1.default)(this.toolbarToolRow);\n        if ('ResizeObserver' in window) {\n            this.toolRowResizeObserver = new ResizeObserver((_entries) => {\n                this.onToolbarRowResize();\n            });\n            this.toolRowResizeObserver.observe(this.toolbarToolRow);\n        }\n        else {\n            console.warn('ResizeObserver not supported. Toolbar will not resize.');\n        }\n        this.toolbarContainer.replaceChildren(this.toolbarActionRow, this.toolbarToolRow);\n        parent.appendChild(this.toolbarContainer);\n        this.sidebarVisible = ReactiveValue_1.ReactiveValue.fromInitialValue(false);\n        this.sidebarY = ReactiveValue_1.ReactiveValue.fromInitialValue(0);\n        // Create the container elements\n        this.menuContainer = document.createElement('div');\n        this.menuContainer.classList.add(`${constants_1.toolbarCSSPrefix}edgemenu-container`);\n        this.sidebarContainer = document.createElement('div');\n        this.sidebarContainer.classList.add(`${constants_1.toolbarCSSPrefix}edgemenu`, `${constants_1.toolbarCSSPrefix}element`);\n        this.sidebarContainer.classList.add(`${constants_1.toolbarCSSPrefix}tool-properties`);\n        this.sidebarContent = document.createElement('div');\n        // Setup resizing/dragging\n        this.sidebarY.onUpdateAndNow((y) => {\n            const belowEdgeClassName = 'dropdown-below-edge';\n            if (y > 0) {\n                this.sidebarContainer.style.transform = `translate(0, ${y}px)`;\n                this.sidebarContainer.style.paddingBottom = '';\n                this.menuContainer.classList.add(belowEdgeClassName);\n            }\n            else {\n                this.sidebarContainer.style.transform = '';\n                this.sidebarContainer.style.paddingBottom = `${-y}px`;\n                this.menuContainer.classList.remove(belowEdgeClassName);\n            }\n        });\n        this.closeButton = document.createElement('button');\n        this.closeButton.classList.add('drag-elem');\n        // The close button has default focus -- forward its events to the main editor so that keyboard\n        // shortcuts still work.\n        this.editor.handleKeyEventsFrom(this.closeButton, (event) => {\n            // Don't send\n            return event.code !== 'Space' && event.code !== 'Enter' && event.code !== 'Tab';\n        });\n        // Close the sidebar when pressing escape\n        this.sidebarContainer.addEventListener('keyup', (event) => {\n            if (!event.defaultPrevented && event.code === 'Escape') {\n                this.sidebarVisible.set(false);\n                event.preventDefault();\n            }\n        });\n        this.initDragListeners();\n        // Initialize the layout manager\n        const setSidebarContent = (...content) => {\n            this.sidebarContent.replaceChildren(...content);\n            this.setupColorPickers();\n        };\n        this.sidebarTitle = ReactiveValue_1.MutableReactiveValue.fromInitialValue('');\n        this.layoutManager = new EdgeToolbarLayoutManager_1.default(setSidebarContent, this.sidebarTitle, this.sidebarVisible, editor.announceForAccessibility.bind(editor), localizationTable);\n        this.sidebarTitle.onUpdateAndNow((title) => {\n            this.closeButton.setAttribute('aria-label', localizationTable.closeSidebar(title));\n        });\n        // Make things visible/keep hidden.\n        this.listenForVisibilityChanges();\n        this.sidebarContainer.replaceChildren(this.closeButton, this.sidebarContent);\n        this.menuContainer.replaceChildren(this.sidebarContainer);\n        parent.appendChild(this.menuContainer);\n    }\n    listenForVisibilityChanges() {\n        let animationTimeout = null;\n        const animationDuration = 170;\n        if (!this.sidebarVisible.get()) {\n            this.menuContainer.style.display = 'none';\n            // Set the initial opacity to 0 to allow the `transition` property\n            // to animate it to 1.\n            this.menuContainer.style.opacity = '0';\n        }\n        const prefersReduceMotion = window.matchMedia?.('(prefers-reduced-motion: reduce)') ?? '';\n        this.sidebarVisible.onUpdate((visible) => {\n            const animationProperties = `${animationDuration}ms ease`;\n            // We need to use different animations when reducing motion.\n            const reduceMotion = prefersReduceMotion.matches ? '-reduce-motion' : '';\n            if (visible) {\n                this.sidebarY.set(this.snappedSidebarY());\n                if (animationTimeout) {\n                    clearTimeout(animationTimeout);\n                    animationTimeout = null;\n                }\n                this.menuContainer.style.display = '';\n                this.sidebarContainer.style.animation = `${animationProperties} ${constants_1.toolbarCSSPrefix}-edgemenu-transition-in${reduceMotion}`;\n                this.menuContainer.style.animation = `${animationProperties} ${constants_1.toolbarCSSPrefix}-edgemenu-container-transition-in${reduceMotion}`;\n                this.menuContainer.style.opacity = '1';\n                // Focus the close button when first shown, but prevent scroll because the button\n                // is likely at the bottom of the screen (and we want the full sidebar to remain\n                // visible).\n                this.closeButton.focus({ preventScroll: true });\n            }\n            else {\n                this.closeColorPickers();\n                if (animationTimeout === null) {\n                    this.sidebarContainer.style.animation = `${animationProperties} ${constants_1.toolbarCSSPrefix}-edgemenu-transition-out${reduceMotion}`;\n                    this.menuContainer.style.animation = `${animationProperties} ${constants_1.toolbarCSSPrefix}-edgemenu-container-transition-out${reduceMotion}`;\n                    // Manually set the container's opacity to prevent flickering when closing\n                    // the toolbar.\n                    this.menuContainer.style.opacity = '0';\n                    // Hide overflow -- don't show the part of the edge toolbar that's outside of\n                    // the editor.\n                    //this.menuContainer.style.overflowY = 'hidden';\n                    this.editor.announceForAccessibility(this.localizationTable.dropdownHidden(this.sidebarTitle.get()));\n                    animationTimeout = setTimeout(() => {\n                        this.menuContainer.style.display = 'none';\n                        this.menuContainer.style.overflowY = '';\n                        animationTimeout = null;\n                    }, animationDuration);\n                }\n            }\n        });\n    }\n    onToolbarRowResize() {\n        const setExtraPadding = () => {\n            const visibleWidth = this.toolbarToolRow.clientWidth;\n            // Determine whether extra spacing needs to be added so that one button is cut\n            // in half. Ideally, when there is scroll, one button will be cut in half to show\n            // that scrolling is possible.\n            let currentWidth = 0;\n            let extraPadding = 0;\n            let numVisibleButtons = 0;\n            for (const child of this.toolbarToolRow.children) {\n                // Use the first child -- padding is applied around that child. Assumes\n                // that the button's width is its height plus some padding.\n                const buttonBaseSize = child.clientHeight;\n                currentWidth += buttonBaseSize;\n                numVisibleButtons++;\n                if (currentWidth > visibleWidth) {\n                    // We want extraPadding + (currentWidth - buttonWidth / 2) = visibleWidth.\n                    // Thus, extraPadding = visibleWidth - currentWidth + buttonWidth / 2;\n                    extraPadding = visibleWidth - currentWidth + buttonBaseSize / 2;\n                    // Ensure that the padding is positive\n                    if (extraPadding < 0) {\n                        extraPadding += buttonBaseSize;\n                    }\n                    break;\n                }\n            }\n            const perButtonPadding = Math.round((extraPadding / numVisibleButtons) * 10) / 10;\n            this.toolbarToolRow.style.setProperty('--extra-left-right-padding', `${perButtonPadding}px`);\n        };\n        const actionRowBBox = this.toolbarActionRow.getBoundingClientRect();\n        const toolbarRowBBox = this.toolbarToolRow.getBoundingClientRect();\n        const onDifferentRows = actionRowBBox.y + actionRowBBox.height <= toolbarRowBBox.y;\n        if (onDifferentRows) {\n            this.toolbarContainer.classList.remove('one-row');\n        }\n        else {\n            this.toolbarContainer.classList.add('one-row');\n        }\n        if (this.toolbarToolRow.clientWidth < this.toolbarToolRow.scrollWidth) {\n            this.toolbarToolRow.classList.add('has-scroll');\n            // Note: This can potentially change the size of the tool row.\n            // Because this is run inside of a ResizeObserver callback, special\n            // care must be taken to ensure that this change doesn't re-trigger\n            // the resize observer.\n            setExtraPadding();\n        }\n        else {\n            this.toolbarToolRow.classList.remove('has-scroll', 'extra-padding');\n        }\n    }\n    addSpacer(_options) {\n        //throw new Error('Method not implemented.');\n        // Unused for this toolbar.\n    }\n    addUndoRedoButtons() {\n        super.addUndoRedoButtons(false);\n    }\n    addDefaults() {\n        this.addDefaultActionButtons();\n        this.addDefaultToolWidgets();\n    }\n    updateWidgetCSSClasses(widget) {\n        const tags = widget.getTags();\n        widget.removeCSSClassFromContainer('label-inline');\n        widget.removeCSSClassFromContainer('label-left');\n        widget.removeCSSClassFromContainer('label-right');\n        if (tags.includes(BaseWidget_1.ToolbarWidgetTag.Save)) {\n            widget.addCSSClassToContainer('label-inline');\n            widget.addCSSClassToContainer('label-left');\n        }\n        if (tags.includes(BaseWidget_1.ToolbarWidgetTag.Exit)) {\n            widget.addCSSClassToContainer('label-inline');\n            widget.addCSSClassToContainer('label-right');\n        }\n    }\n    addWidgetInternal(widget) {\n        this.updateWidgetCSSClasses(widget);\n        widget.setLayoutManager(this.layoutManager);\n        if (widget.mustBeInToplevelMenu()) {\n            widget.addTo(this.toolbarActionRow);\n        }\n        else {\n            widget.addTo(this.toolbarToolRow);\n        }\n    }\n    removeWidgetInternal(widget) {\n        widget.remove();\n    }\n    onRemove() {\n        this.toolbarContainer.remove();\n        this.menuContainer.remove();\n        this.toolRowResizeObserver.disconnect();\n        this.clearDragListeners?.();\n    }\n    initDragListeners() {\n        const dragElements = [this.closeButton, this.sidebarContainer, this.sidebarContent];\n        // Forward longer touch events from the menu background to the\n        // editor (and close the sidebar).\n        this.manageListener(this.editor.handlePointerEventsExceptClicksFrom(this.menuContainer, (eventName, event) => {\n            if (event.target === this.menuContainer) {\n                if (eventName === 'pointerdown') {\n                    this.sidebarVisible.set(false);\n                    // A delay seems necessary for the editor\n                    setTimeout(() => this.editor.focus(), 0);\n                }\n                return true;\n            }\n            if (!this.sidebarVisible.get()) {\n                return true;\n            }\n            // Don't send pointer events that don't directly target mainContainer\n            // to the editor\n            return false;\n        }, (_eventName, event) => {\n            return event.target === this.menuContainer;\n        }));\n        // Set lastGestureWasRoughlyClick to `true` initially because on page load\n        // performance.now() is zero.\n        let lastGestureWasRoughlyClick = true;\n        let gestureEndTimestamp = 0;\n        const dragController = (0, makeDraggable_1.default)(this.sidebarContainer, {\n            draggableChildElements: dragElements,\n            onDrag: (deltaX, deltaY) => this.handleDrag(deltaX, deltaY),\n            onDragEnd: (dragStatistics) => {\n                gestureEndTimestamp = dragStatistics.endTimestamp;\n                lastGestureWasRoughlyClick = dragStatistics.roughlyClick;\n                this.finalizeDrag();\n            },\n        });\n        this.clearDragListeners = () => dragController.removeListeners();\n        this.closeButton.onclick = () => {\n            const wasJustDragging = performance.now() - gestureEndTimestamp < 100;\n            // Ignore the click event if it was caused by dragging the button.\n            if ((wasJustDragging && lastGestureWasRoughlyClick) || !wasJustDragging) {\n                this.sidebarVisible.set(false);\n            }\n        };\n    }\n    /**\n     * Updates the position of this menu **during** a drag. After a drag ends,\n     * {@link finalizeDrag} should be called.\n     */\n    handleDrag(_deltaX, deltaY) {\n        this.sidebarContainer.style.transition = 'none';\n        this.sidebarY.set(this.sidebarY.get() + deltaY);\n    }\n    /** Returns `this.sidebarY` rounded to a valid value. */\n    snappedSidebarY(sidebarY) {\n        const y = sidebarY ?? this.sidebarY.get();\n        const snapYs = [-100, 0];\n        // Allow some amount of scrolling if the sidebar is too tall to fit entirely\n        // in the window.\n        if (this.sidebarContainer.clientHeight > window.innerHeight) {\n            snapYs.push(100);\n        }\n        let closestSnap = snapYs[0];\n        for (const snapY of snapYs) {\n            if (Math.abs(snapY - y) < Math.abs(closestSnap - y)) {\n                closestSnap = snapY;\n            }\n        }\n        return closestSnap;\n    }\n    /**\n     * Moves the menu to a valid location or closes it, depending on\n     * the position set by the drag.\n     */\n    finalizeDrag() {\n        this.sidebarContainer.style.transition = '';\n        if (this.sidebarY.get() > this.sidebarContainer.clientHeight / 2) {\n            this.sidebarVisible.set(false);\n        }\n        else {\n            // Snap to the closest valid Y.\n            this.sidebarY.set(this.snappedSidebarY());\n        }\n    }\n    serializeInternal() {\n        return {\n            menuSizeY: this.snappedSidebarY(),\n        };\n    }\n    deserializeInternal(json) {\n        if (typeof json === 'object' && typeof json['menuSizeY'] === 'number') {\n            // Load the y-position of the sidebar  -- call snappedSidebarY to ensure validity.\n            this.sidebarY.set(this.snappedSidebarY(json['menuSizeY']));\n        }\n    }\n}\nexports[\"default\"] = EdgeToolbar;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/toolbar/EdgeToolbar.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/toolbar/IconProvider.js":
/*!***************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/toolbar/IconProvider.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar _IconProvider_instances, _IconProvider_makeXIcon;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\nconst SVGRenderer_1 = __importDefault(__webpack_require__(/*! ../rendering/renderers/SVGRenderer */ \"./node_modules/js-draw/dist/cjs/rendering/renderers/SVGRenderer.js\"));\nconst Viewport_1 = __importDefault(__webpack_require__(/*! ../Viewport */ \"./node_modules/js-draw/dist/cjs/Viewport.js\"));\nconst FreehandLineBuilder_1 = __webpack_require__(/*! ../components/builders/FreehandLineBuilder */ \"./node_modules/js-draw/dist/cjs/components/builders/FreehandLineBuilder.js\");\nconst PolylineBuilder_1 = __webpack_require__(/*! ../components/builders/PolylineBuilder */ \"./node_modules/js-draw/dist/cjs/components/builders/PolylineBuilder.js\");\nconst Eraser_1 = __webpack_require__(/*! ../tools/Eraser */ \"./node_modules/js-draw/dist/cjs/tools/Eraser.js\");\nconst createElement_1 = __webpack_require__(/*! ../util/createElement */ \"./node_modules/js-draw/dist/cjs/util/createElement.js\");\nconst svgNamespace = 'http://www.w3.org/2000/svg';\nlet checkerboardIdCounter = 0;\nconst makeCheckerboardPattern = () => {\n    const id = `checkerboard-${checkerboardIdCounter++}`;\n    const patternElement = (0, createElement_1.createSvgElement)('pattern', {\n        id: id,\n        viewBox: '0,0,10,10',\n        width: '20%',\n        height: '20%',\n        patternUnits: 'userSpaceOnUse',\n        children: (0, createElement_1.createSvgElements)('rect', [\n            { x: 0, y: 0, width: 10, height: 10, fill: 'white' },\n            { x: 0, y: 0, width: 5, height: 5, fill: 'gray' },\n            { x: 5, y: 5, width: 5, height: 5, fill: 'gray' },\n        ]),\n    });\n    const patternRef = `url(#${id})`;\n    return {\n        patternDefElement: patternElement,\n        // @deprecated use patternDefElement\n        get patternDef() {\n            return patternElement.innerHTML;\n        },\n        patternRef,\n    };\n};\nconst makeRedoIcon = (mirror) => {\n    const icon = document.createElementNS(svgNamespace, 'svg');\n    icon.innerHTML = `\n\t\t<style>\n\t\t\t.toolbar-svg-undo-redo-icon {\n\t\t\t\tstroke: var(--icon-color);\n\t\t\t\tstroke-width: 12;\n\t\t\t\tstroke-linejoin: round;\n\t\t\t\tstroke-linecap: round;\n\t\t\t\tfill: none;\n\n\t\t\t\ttransform-origin: center;\n\t\t\t}\n\t\t</style>\n\t`;\n    const path = document.createElementNS(svgNamespace, 'path');\n    path.setAttribute('d', 'M20,20 A15,15 0 0 1 70,80 L80,90 L60,70 L65,90 L87,90 L65,80');\n    path.classList.add('toolbar-svg-undo-redo-icon');\n    if (mirror) {\n        path.style.transform = 'scale(-1, 1)';\n    }\n    icon.appendChild(path);\n    icon.setAttribute('viewBox', '0 0 100 100');\n    return icon;\n};\n/**\n * Provides icons that can be used in the toolbar and other locations.\n *\n * To customize the icons used by the editor, extend this class and override methods.\n *\n * @example\n * ```ts,runnable\n * import * as jsdraw from 'js-draw';\n *\n * class CustomIconProvider extends jsdraw.IconProvider {\n *     // Use '☺' instead of the default dropdown symbol.\n *     public override makeDropdownIcon() {\n *         const icon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n *         icon.innerHTML = `\n *             <text x='5' y='55' style='fill: var(--icon-color); font-size: 50pt;'>☺</text>\n *         `;\n *         icon.setAttribute('viewBox', '0 0 100 100');\n *         return icon;\n *     }\n * }\n *\n * const icons = new CustomIconProvider();\n * const editor = new jsdraw.Editor(document.body, {\n *     // The icon pack to use is specified through the editor's initial\n *     // configuration object:\n *     iconProvider: icons,\n * });\n *\n * // Add a toolbar that uses these icons\n * jsdraw.makeDropdownToolbar(editor).addDefaults();\n * ```\n */\nclass IconProvider {\n    constructor() {\n        _IconProvider_instances.add(this);\n    }\n    makeUndoIcon() {\n        return makeRedoIcon(true);\n    }\n    // @returns a redo icon.\n    makeRedoIcon() {\n        return makeRedoIcon(false);\n    }\n    makeDropdownIcon() {\n        const icon = this.makeIconFromPath('M5,10 L50,90 L95,10 Z');\n        icon.setAttribute('viewBox', '-10 -10 110 110');\n        return icon;\n    }\n    makeEraserIcon(eraserSize, mode) {\n        eraserSize ??= 10;\n        const scaledSize = eraserSize / 4;\n        const eraserColor = '#ff70af';\n        // Draw an eraser-like shape. Created with Inkscape\n        const icon = (0, createElement_1.createSvgElement)('svg', {\n            viewBox: '0 0 120 120',\n            children: [\n                (0, createElement_1.createSvgElement)('defs', {\n                    children: [\n                        (0, createElement_1.createSvgElement)('linearGradient', {\n                            id: 'dash-pattern',\n                            children: (0, createElement_1.createSvgElements)('stop', [\n                                { offset: '80%', 'stop-color': eraserColor },\n                                { offset: '85%', 'stop-color': 'white' },\n                                { offset: '90%', 'stop-color': eraserColor },\n                            ]),\n                        }),\n                    ],\n                }),\n                (0, createElement_1.createSvgElement)('path', {\n                    fill: mode === Eraser_1.EraserMode.PartialStroke ? 'url(#dash-pattern)' : eraserColor,\n                    stroke: 'black',\n                    transform: 'rotate(41.35)',\n                    d: `\n\t\t\t\t\t\tM 52.5 27\n\t\t\t\t\t\tC 50 28.9 48.9 31.7 48.9 34.8\n\t\t\t\t\t\tL 48.9 39.8\n\t\t\t\t\t\tC 48.9 45.3 53.4 49.8 58.9 49.8\n\t\t\t\t\t\tL 103.9 49.8\n\t\t\t\t\t\tC 105.8 49.8 107.6 49.2 109.1 48.3\n\t\t\t\t\t\tL 110.2 ${scaledSize + 49.5} L 159.7 ${scaledSize + 5}\n\t\t\t\t\t\tL 157.7 ${-scaledSize + 5.2} L 112.4 ${49.5 - scaledSize}\n\t\t\t\t\t\tC 113.4 43.5 113.9 41.7 113.9 39.8\n\t\t\t\t\t\tL 113.9 34.8\n\t\t\t\t\t\tC 113.9 29.3 109.4 24.8 103.9 24.8\n\t\t\t\t\t\tL 58.9 24.8\n\t\t\t\t\t\tC 56.5 24.8 54.3 25.7 52.5 27\n\t\t\t\t\t\tz\n\t\t\t\t\t`,\n                }),\n                (0, createElement_1.createSvgElement)('rect', {\n                    stroke: '#cc8077',\n                    fill: 'var(--icon-color)',\n                    width: 65,\n                    height: 75,\n                    x: 48.9,\n                    y: -38.7,\n                    transform: 'rotate(41.35)',\n                }),\n            ],\n        });\n        return icon;\n    }\n    makeSelectionIcon() {\n        const icon = document.createElementNS(svgNamespace, 'svg');\n        // Draw a cursor-like shape\n        icon.innerHTML = `\n\t\t<g>\n\t\t\t<rect x=\"10\" y=\"10\" width=\"70\" height=\"70\" fill=\"pink\" stroke=\"black\"/>\n\t\t\t<rect x=\"75\" y=\"75\" width=\"10\" height=\"10\" fill=\"white\" stroke=\"black\"/>\n\t\t</g>\n\t\t`;\n        icon.setAttribute('viewBox', '0 0 100 100');\n        return icon;\n    }\n    makeRotateIcon() {\n        const icon = document.createElementNS(svgNamespace, 'svg');\n        icon.innerHTML = `\n\t\t\t<defs>\n\t\t\t\t<marker\n\t\t\t\t\tid=\"arrow-marker\"\n\t\t\t\t\tviewBox=\"0 0 10 10\"\n\t\t\t\t\trefX=\"3\" refY=\"5\"\n\t\t\t\t\tmarkerWidth=\"3\" markerHeight=\"3\"\n\t\t\t\t\torient=\"auto-start-reverse\"\n\t\t\t\t>\n\t\t\t\t\t<path\n\t\t\t\t\t\td=\"M0,0 L8,5 L0,10z\"\n\t\t\t\t\t\tfill=\"var(--icon-color)\"\n\t\t\t\t\t/>\n\t\t\t\t</marker>\n\t\t\t</defs>\n\n\t\t\t<path\n\t\t\t\tmarker-start=\"url(#arrow-marker)\"\n\t\t\t\td=\"\n\t\t\t\t\tM20,20\n\t\t\t\t\tA30,30 0 1 1 80 80\n\t\t\t\t\"\n\t\t\t\tfill=\"none\"\n\t\t\t\tstroke=\"var(--icon-color)\"\n\t\t\t\tstroke-width=\"12\"\n\t\t\t/>\n\t\t\t<path\n\t\t\t\td=\"\n\t\t\t\t\tM80,80\n\t\t\t\t\tA30,30 0 1 1 20 20\n\t\t\t\t\"\n\t\t\t\tfill=\"none\"\n\t\t\t\tstroke=\"var(--icon-color)\"\n\t\t\t\tstroke-width=\"12\"\n\t\t\t\tstroke-dasharray=\"30 10 20 10 20 10 10\"\n\t\t\t\tstyle=\"stroke-linecap: butt;\"\n\t\t\t/>\n\t\t`;\n        icon.setAttribute('viewBox', '-5 -5 110 110');\n        return icon;\n    }\n    makeHandToolIcon() {\n        const fill = 'none';\n        const strokeColor = 'var(--icon-color)';\n        const strokeWidth = '3';\n        // Draw a cursor-like shape\n        return this.makeIconFromPath(`\n\t\t\tm 10,60\n\t\t\t\t5,30\n\t\t\tH 90\n\t\t\tV 30\n\t\t\tC 90,20 75,20 75,30\n\t\t\tV 60\n\t\t\t\t20\n\t\t\tC 75,10 60,10 60,20\n\t\t\tV 60\n\t\t\t\t15\n\t\t\tC 60,5 45,5 45,15\n\t\t\tV 60\n\t\t\t\t25\n\t\t\tC 45,15 30,15 30,25\n\t\t\tV 60\n\t\t\t\t75\n\t\t\tL 25,60\n\t\t\tC 20,45 10,50 10,60\n\t\t\tZ\n\t\t`, fill, strokeColor, strokeWidth);\n    }\n    makeTouchPanningIcon() {\n        const fill = 'none';\n        const strokeColor = 'var(--icon-color)';\n        const strokeWidth = '3';\n        return this.makeIconFromPath(`\n\t\t\tM 5,5.5\n\t\t\tV 17.2\n\t\t\tL 16.25,5.46\n\t\t\tZ\n\t\n\t\t\tm 33.75,0\n\t\t\tL 50,17\n\t\t\tV 5.5\n\t\t\tZ\n\t\n\t\t\tM 5,40.7\n\t\t\tv 11.7\n\t\t\th 11.25\n\t\t\tz\n\t\n\t\t\tM 26,19\n\t\t\tC 19.8,19.4 17.65,30.4 21.9,34.8\n\t\t\tL 50,70\n\t\t\tH 27.5\n\t\t\tc -11.25,0 -11.25,17.6 0,17.6\n\t\t\tH 61.25\n\t\t\tC 94.9,87.8 95,87.6 95,40.7 78.125,23 67,29 55.6,46.5\n\t\t\tL 33.1,23\n\t\t\tC 30.3125,20.128192 27.9,19 25.830078,19.119756\n\t\t\tZ\n\t\t`, fill, strokeColor, strokeWidth);\n    }\n    /** Unused by js-draw. @deprecated */\n    makeAllDevicePanningIcon() {\n        const fill = 'none';\n        const strokeColor = 'var(--icon-color)';\n        const strokeWidth = '3';\n        return this.makeIconFromPath(`\n\t\t\tM 5 5\n\t\t\tL 5 17.5\n\t\t\t\t17.5 5\n\t\t\t\t5 5\n\t\t\tz\n\t\n\t\t\tM 42.5 5\n\t\t\tL 55 17.5\n\t\t\t\t55 5\n\t\t\t\t42.5 5\n\t\t\tz\n\t\n\t\t\tM 70 10\n\t\t\tL 70 21\n\t\t\t\t61 15\n\t\t\t\t55.5 23\n\t\t\t\t66 30\n\t\t\t\t56 37\n\t\t\t\t61 45\n\t\t\t\t70 39\n\t\t\t\t70 50\n\t\t\t\t80 50\n\t\t\t\t80 39\n\t\t\t\t89 45\n\t\t\t\t95 36\n\t\t\t\t84 30\n\t\t\t\t95 23\n\t\t\t\t89 15\n\t\t\t\t80 21\n\t\t\t\t80 10\n\t\t\t\t70 10\n\t\t\tz\n\t\n\t\t\tM 27.5 26.25\n\t\t\tL 27.5 91.25\n\t\t\tL 43.75 83.125\n\t\t\tL 52 99\n\t\t\tL 68 91\n\t\t\tL 60 75\n\t\t\tL 76.25 66.875\n\t\t\tL 27.5 26.25\n\t\t\tz\n\t\n\t\t\tM 5 42.5\n\t\t\tL 5 55\n\t\t\tL 17.5 55\n\t\t\tL 5 42.5\n\t\t\tz\n\t\t`, fill, strokeColor, strokeWidth);\n    }\n    makeZoomIcon() {\n        const icon = document.createElementNS(svgNamespace, 'svg');\n        icon.setAttribute('viewBox', '0 0 100 100');\n        const addTextNode = (text, x, y) => {\n            const textNode = document.createElementNS(svgNamespace, 'text');\n            textNode.appendChild(document.createTextNode(text));\n            textNode.setAttribute('x', x.toString());\n            textNode.setAttribute('y', y.toString());\n            textNode.style.textAlign = 'center';\n            textNode.style.textAnchor = 'middle';\n            textNode.style.fontSize = '55px';\n            textNode.style.fill = 'var(--icon-color)';\n            textNode.style.fontFamily = 'monospace';\n            icon.appendChild(textNode);\n        };\n        addTextNode('+', 40, 45);\n        addTextNode('-', 70, 75);\n        return icon;\n    }\n    makeRotationLockIcon() {\n        const icon = this.makeIconFromPath(`\n\t\t\tM 40.1 25.1 \n\t\t\tC 32.5 25 27.9 34.1 27.9 34.1 \n\t\t\tL 25.7 30 \n\t\t\tL 28 44.7 \n\t\t\tL 36.6 40.3 \n\t\t\tL 32.3 38.3 \n\t\t\tC 33.6 28 38.1 25.2 45.1 31.8 \n\t\t\tL 49.4 29.6 \n\t\t\tC 45.9 26.3 42.8 25.1 40.1 25.1 \n\t\t\tz\n\n\t\t\tM 51.7 34.2 \n\t\t\tL 43.5 39.1 \n\t\t\tL 48 40.8 \n\t\t\tC 47.4 51.1 43.1 54.3 35.7 48.2 \n\t\t\tL 31.6 50.7 \n\t\t\tC 45.5 62.1 52.6 44.6 52.6 44.6 \n\t\t\tL 55.1 48.6 \n\t\t\tL 51.7 34.2 \n\t\t\tz\n\n\t\t\tM 56.9 49.9 \n\t\t\tC 49.8 49.9 49.2 57.3 49.3 60.9 \n\t\t\tL 47.6 60.9 \n\t\t\tL 47.6 73.7 \n\t\t\tL 66.1 73.7 \n\t\t\tL 66.1 60.9 \n\t\t\tL 64.4 60.9 \n\t\t\tC 64.5 57.3 63.9 49.9 56.9 49.9 \n\t\t\tz\n\n\t\t\tM 56.9 53.5 \n\t\t\tC 60.8 53.5 61 58.2 60.8 60.9 \n\t\t\tL 52.9 60.9 \n\t\t\tC 52.7 58.2 52.9 53.5 56.9 53.5 \n\t\t\tz\n\t\t`);\n        icon.setAttribute('viewBox', '10 10 70 70');\n        return icon;\n    }\n    makeInsertImageIcon() {\n        return this.makeIconFromPath(`\n\t\t\tM 5 10 L 5 90 L 95 90 L 95 10 L 5 10 z\n\t\t\tM 10 15 L 90 15 L 90 50 L 70 75 L 40 50 L 10 75 L 10 15 z\n\t\t\tM 22.5 25 A 7.5 7.5 0 0 0 15 32.5 A 7.5 7.5 0 0 0 22.5 40 A 7.5 7.5 0 0 0 30 32.5 A 7.5 7.5 0 0 0 22.5 25 z \n\t\t`);\n    }\n    makeUploadFileIcon() {\n        return this.makeIconFromPath(`\n\t\t\tM 48,10 32,34 43,33 42,68\n\t\t\tH 54\n\t\t\tL 53,33 64,34 Z\n\t\n\t\t\tM 8,66 V 86 H 88 V 66 H 78 V 76 H 18 V 66 Z\n\t\t`);\n    }\n    makeTextIcon(textStyle) {\n        const icon = document.createElementNS(svgNamespace, 'svg');\n        icon.setAttribute('viewBox', '0 0 100 100');\n        const textNode = document.createElementNS(svgNamespace, 'text');\n        textNode.appendChild(document.createTextNode('T'));\n        textNode.style.fontFamily = textStyle.fontFamily;\n        textNode.style.fontWeight = textStyle.fontWeight ?? '';\n        textNode.style.fontVariant = textStyle.fontVariant ?? '';\n        textNode.style.fill = textStyle.renderingStyle.fill.toHexString();\n        textNode.style.textAnchor = 'middle';\n        textNode.setAttribute('x', '50');\n        textNode.setAttribute('y', '75');\n        textNode.style.fontSize = '65px';\n        textNode.style.filter = 'drop-shadow(0px 0px 10px var(--shadow-color))';\n        icon.appendChild(textNode);\n        return icon;\n    }\n    makePenIcon(penStyle) {\n        // Use a square-root scale to prevent the pen's tip from overflowing.\n        const strokeSize = Math.round(Math.sqrt(penStyle.thickness) * 4);\n        const color = penStyle.color;\n        const rounded = this.isRoundedTipPen(penStyle);\n        const tipThickness = strokeSize / 2;\n        const inkTipPath = `\n\t\t\tM ${15 - tipThickness},${80 - tipThickness}\n\t\t\t  ${15 - tipThickness},${80 + tipThickness}\n\t\t\t  30,83\n\t\t\t  15,65\n\t\t\tZ\n\t\t`;\n        const trailStartEndY = 80 + tipThickness;\n        const inkTrailPath = `\n\t\t\tm ${15 - tipThickness * 1.1},${trailStartEndY}\n\t\t\tc 35,10 55,15 60,30\n\t\t\tl ${35 + tipThickness * 1.2},${-10 - tipThickness}\n\t\t\tC 80.47,98.32 50.5,${90 + tipThickness} 20,${trailStartEndY} Z\n\t\t`;\n        const colorBubblePath = `\n\t\t\tM 72.45,35.67\n\t\t\tA 10,15 41.8 0 1 55,40.2 10,15 41.8 0 1 57.55,22.3 10,15 41.8 0 1 75,17.8 10,15 41.8 0 1 72.5,35.67\n\t\t\tZ\n\t\t`;\n        let gripMainPath = 'M 85,-25 25,35 h 10 v 10 h 10 v 10 h 10 v 10 h 10 l -5,10 60,-60 z';\n        let gripShadow1Path = 'M 25,35 H 35 L 90,-15 85,-25 Z';\n        let gripShadow2Path = 'M 60,75 65,65 H 55 l 55,-55 10,5 z';\n        if (rounded) {\n            gripMainPath = 'M 85,-25 25,35 c 15,0 40,30 35,40 l 60,-60 z';\n            gripShadow1Path = 'm 25,35 c 3.92361,0.384473 7.644275,0.980572 10,3 l 55,-53 -5,-10 z';\n            gripShadow2Path = 'M 60,75 C 61,66 59,65 56,59 l 54,-54 10,10 z';\n        }\n        const penTipPath = `M 25,35 ${10 - tipThickness / 4},${70 - tipThickness / 2} 20,75 25,85 60,75 70,55 45,25 Z`;\n        const pencilTipColor = math_1.Color4.fromHex('#f4d7d7');\n        const tipColor = pencilTipColor.mix(color, tipThickness / 40 - 0.1).toHexString();\n        const checkerboardPattern = makeCheckerboardPattern();\n        const colorString = color.toHexString();\n        const ink = (0, createElement_1.createSvgPaths)({\n            fill: checkerboardPattern.patternRef,\n            d: inkTipPath,\n        }, {\n            fill: checkerboardPattern.patternRef,\n            d: inkTrailPath,\n        }, {\n            fill: colorString,\n            d: inkTipPath,\n        }, {\n            fill: colorString,\n            d: inkTrailPath,\n        });\n        const penTip = (0, createElement_1.createSvgPaths)({ fill: checkerboardPattern.patternRef, d: penTipPath }, { fill: tipColor, stroke: colorString, d: penTipPath });\n        const grip = (0, createElement_1.createSvgPaths)({ fill: 'var(--icon-color)', stroke: 'var(--icon-color)', d: gripMainPath }, \n        // Shadows\n        { fill: 'rgba(150, 150, 150, 0.3)', d: gripShadow1Path }, { fill: 'rgba(100, 100, 100, 0.2)', d: gripShadow2Path }, \n        // Color bubble\n        { fill: checkerboardPattern.patternRef, d: colorBubblePath }, { fill: colorString, d: colorBubblePath });\n        const icon = document.createElementNS(svgNamespace, 'svg');\n        icon.setAttribute('viewBox', '0 0 100 100');\n        const iconMainContent = (0, createElement_1.createSvgElement)('g', {\n            children: [ink, penTip, grip].flat(),\n        });\n        const defs = (0, createElement_1.createSvgElement)('defs', {\n            children: [checkerboardPattern.patternDefElement],\n        });\n        icon.replaceChildren(defs, iconMainContent);\n        return icon;\n    }\n    makeIconFromFactory(penStyle) {\n        // Increase the thickness we use to generate the icon less with larger actual thicknesses.\n        // We want the icon to be recognisable with a large range of thicknesses.\n        const thickness = Math.sqrt(penStyle.thickness) * 3;\n        const nowTime = performance.now();\n        const startPoint = {\n            pos: math_1.Vec2.of(10, 10),\n            width: thickness,\n            color: penStyle.color,\n            time: nowTime - 100,\n        };\n        const endPoint = {\n            pos: math_1.Vec2.of(90, 90),\n            width: thickness,\n            color: penStyle.color,\n            time: nowTime,\n        };\n        const viewport = new Viewport_1.default(() => { });\n        const builder = penStyle.factory(startPoint, viewport);\n        builder.addPoint(endPoint);\n        const icon = document.createElementNS(svgNamespace, 'svg');\n        icon.setAttribute('viewBox', '0 0 100 100');\n        viewport.updateScreenSize(math_1.Vec2.of(100, 100));\n        let renderer;\n        // Any transparency? Include a checkerboard grid.\n        const includeTransparencyGrid = penStyle.color.a < 1;\n        if (includeTransparencyGrid) {\n            const checkerboardPattern = makeCheckerboardPattern();\n            const defs = document.createElementNS(svgNamespace, 'defs');\n            defs.appendChild(checkerboardPattern.patternDefElement);\n            icon.appendChild(defs);\n            const background = document.createElementNS(svgNamespace, 'g');\n            icon.appendChild(background);\n            renderer = new (class extends SVGRenderer_1.default {\n                constructor() {\n                    super(icon, viewport);\n                }\n                addPathToSVG() {\n                    const addedPath = super.addPathToSVG();\n                    if (addedPath) {\n                        // Add a copy of the path on the background\n                        const copy = addedPath.cloneNode(true);\n                        copy.style.zIndex = '-1';\n                        if (copy.hasAttribute('stroke')) {\n                            copy.setAttribute('stroke', checkerboardPattern.patternRef);\n                        }\n                        // Note: Assumes that the component wouldn't normally be both stroked\n                        // and filled.\n                        else if (copy.hasAttribute('fill')) {\n                            copy.setAttribute('fill', checkerboardPattern.patternRef);\n                        }\n                        background.appendChild(copy);\n                    }\n                    return addedPath;\n                }\n            })();\n        }\n        else {\n            renderer = new SVGRenderer_1.default(icon, viewport);\n        }\n        builder.preview(renderer);\n        // If only a single path was rendered, try to give it a checkerboard background to\n        // emphasize transparency. TODO: This is very fragile\n        const bbox = builder.getBBox();\n        icon.setAttribute('viewBox', `${bbox.x} ${bbox.y} ${bbox.w} ${bbox.h}`);\n        return icon;\n    }\n    makePipetteIcon(color) {\n        const icon = document.createElementNS(svgNamespace, 'svg');\n        const mainGroup = document.createElementNS(svgNamespace, 'g');\n        mainGroup.style.rotate = '45deg';\n        mainGroup.style.transformOrigin = 'center';\n        const pipette = document.createElementNS(svgNamespace, 'g');\n        pipette.innerHTML = `\n\t\t<path\n\t\t\tstyle=\"fill: var(--icon-color); stroke-linecap:round; stroke-linejoin:round;\"\n\t\t\td=\"\n\t\t\t\tm 32,12 v 68\n\t\t\t\tc 0,1 0.5,2 1.33,2.5 1.67,1.15 3.67,2.1 5.17,3.2 1.4,1.1 2.3,2.1 2.5,3.1 0.6,2.1 1,4.6 1,6.2 0,3.7 5.45,4.1 6,0.4 l 0.9,-6.8\n\t\t\t\tc 0.3,-0.9 1.1,-1.9 2.6,-2.9 1.5,-1.1 3.4,-2 5.1,-3.2\n\t\t\t\tC 57.5,82 58,81 58,80\n\t\t\t\tV 12 Z m 20,25 v 41.3\n\t\t\t\tc 0,1.7 -2.5,1.6 -4,2.7 -1,0.76 -2.1,1.5 -3,2.6\n\t\t\t\tC 44,82.5 43.02,81.75 42,81 40.51,79.92 38,80 38,78.34\n\t\t\t\tV 51 Z\n\t\t\t\"\n\t\t/>\n\t\t<rect\n\t\t\tstyle=\"fill: var(--icon-color);\"\n\t\t\twidth=\"32\"\n\t\t\theight=\"9\"\n\t\t\tx=\"29\"\n\t\t\ty=\"2\"\n\t\t\try=\"4.5\"\n\t\t/>\n\t\t<path\n\t\t\tstyle=\"fill: var(--icon-color);\"\n\t\t\td=\"m 45,-25 c -5.54,0 -11,4.26 -11,9 V 0 h 22 v -16 c 0,-4.74 -5.46,-9 -11,-9 z\"\n\t\t/>\n\t\t`;\n        if (color) {\n            const checkerboardPattern = makeCheckerboardPattern();\n            const defs = document.createElementNS(svgNamespace, 'defs');\n            defs.appendChild(checkerboardPattern.patternDefElement);\n            icon.appendChild(defs);\n            const fluidBackground = document.createElementNS(svgNamespace, 'path');\n            const fluid = document.createElementNS(svgNamespace, 'path');\n            const fluidPathData = `\n\t\t\t\tM 35,36 H 55 V 78.678012 83 L 45,87 35,83 Z\n\t\t\t`;\n            fluid.setAttribute('d', fluidPathData);\n            fluidBackground.setAttribute('d', fluidPathData);\n            fluid.style.fill = color.toHexString();\n            fluidBackground.style.fill = checkerboardPattern.patternRef;\n            mainGroup.appendChild(fluidBackground);\n            mainGroup.appendChild(fluid);\n        }\n        mainGroup.appendChild(pipette);\n        icon.appendChild(mainGroup);\n        icon.setAttribute('viewBox', '5 -40 140 140');\n        return icon;\n    }\n    makeShapeAutocorrectIcon() {\n        const fill = 'none';\n        const strokeColor = 'var(--icon-color)';\n        return this.makeIconFromPath(`\n\t\t\tm 79.129476,33.847107 9.967823,-0.03218 v 55 h -55 l 0.03218,-9.96782\n\t\t\tM 71.1,40.8 a 30,30 0 0 1 -30,30 30,30 0 0 1 -30,-30 30,30 0 0 1 30,-30 30,30 0 0 1 30,30 L 71.1,40.8\n\t\t\tM 34.1,58.8 v -25 h 25 v 0\n\t\t`, fill, strokeColor, '7px');\n    }\n    makeStrokeSmoothingIcon() {\n        const fill = 'none';\n        const strokeColor = 'var(--icon-color)';\n        return this.makeIconFromPath(`\n\t\t\tm 31,83.2 c -50,0 30,-65 -20,-65\n\t\t\tM 75,17.3 40,59.7 38.2,77.6 55.5,72.4 90.5,30 Z\n\t\t`, fill, strokeColor, '7px');\n    }\n    /** Unused. @deprecated */\n    makeFormatSelectionIcon() {\n        return this.makeIconFromPath(`\n\t\t\tM 5 10\n\t\t\tL 5 20 L 10 20 L 10 15 L 20 15 L 20 40 L 15 40 L 15 45 L 35 45 L 35 40 L 30 40 L 30 15 L 40 15 L 40 20 L 45 20 L 45 15 L 45 10 L 5 10 z\n\t\t\tM 90 10 C 90 10 86.5 13.8 86 14 C 86 14 76.2 24.8 76 25 L 60 25 L 60 65 C 75 70 85 70 90 65 L 90 25 L 80 25 L 76.7 25 L 90 10 z\n\t\t\tM 60 25 L 55 25 L 50 30 L 60 25 z\n\t\t\tM 10 55 L 10 90 L 41 90 L 41 86 L 45 86 L 45 55 L 10 55 z\n\t\t\tM 42 87 L 42 93 L 48 93 L 48 87 L 42 87 z \n\t\t`);\n    }\n    makeResizeImageToSelectionIcon() {\n        return this.makeIconFromPath(`\n\t\t\tM 75 5 75 10 90 10 90 25 95 25 95 5 75 5 z\n\t\t\tM 15 15 15 30 20 30 20 20 30 20 30 15 15 15 z\n\t\t\tM 84 15 82 17 81 16 81 20 85 20 84 19 86 17 84 15 z\n\t\t\tM 26 24 24 26 26 28 25 29 29 29 29 25 28 26 26 24 z\n\t\t\tM 25 71 26 72 24 74 26 76 28 74 29 75 29 71 25 71 z\n\t\t\tM 15 75 15 85 25 85 25 80 20 80 20 75 15 75 z\n\t\t\tM 90 75 90 90 75 90 75 95 95 95 95 75 90 75 z\n\t\t\tM 81 81 81 85 82 84 84 86 86 84 84 82 85 81 81 81 z\n\t\t`);\n    }\n    /** Renamed to {@link makeResizeImageToSelectionIcon} @deprecated */\n    makeResizeViewportIcon() {\n        return this.makeResizeImageToSelectionIcon();\n    }\n    makeDuplicateSelectionIcon() {\n        return this.makeIconFromPath(`\n\t\t\tM 45,10 45,55 90,55 90,10 45,10 z\n\t\t\tM 10,25 10,90 70,90 70,60 40,60 40,25 10,25 z \n\t\t`);\n    }\n    makeCopyIcon() {\n        return this.makeIconFromPath(`\n\t\t\tM 45,10 45,55 90,55 90,10 45,10 z\n\t\t\tM 10,25 10,90 70,90 70,60 40,60 40,25 10,25 z \n\t\t`);\n    }\n    makePasteIcon() {\n        const icon = this.makeIconFromPath(`\n\t\t\tM 50 0 L 50 5 L 35 5 L 40 24.75 L 20 25 L 20 100 L 85 100 L 100 90 L 100 24 L 75.1 24.3 L 80 5 L 65 5 L 65 0 L 50 0 z\n\t\t\tM 10 15 L 10 115 L 110 115 L 110 15 L 85 15 L 83 20 L 105 20 L 105 110 L 15 110 L 15 20 L 32 20 L 30 15 L 10 15 z\n\t\t\tM 25 35 L 90 35 L 90 40 L 25 40 L 25 35 z\n\t\t\tM 25 45 L 90 45 L 90 50 L 25 50 L 25 45 z\n\t\t\tM 25 55 L 85 55 L 85 60 L 25 60 L 25 55 z\n\t\t\tM 25 65 L 90 65 L 90 70 L 25 70 L 25 65 z \n\t\t`);\n        icon.setAttribute('viewBox', '0 0 120 120');\n        return icon;\n    }\n    makeDeleteSelectionIcon() {\n        return __classPrivateFieldGet(this, _IconProvider_instances, \"m\", _IconProvider_makeXIcon).call(this);\n    }\n    makeCloseIcon() {\n        return __classPrivateFieldGet(this, _IconProvider_instances, \"m\", _IconProvider_makeXIcon).call(this);\n    }\n    makeSaveIcon() {\n        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n        svg.innerHTML = `\n\t\t\t<style>\n\t\t\t\t.toolbar-save-icon {\n\t\t\t\t\tstroke: var(--icon-color);\n\t\t\t\t\tstroke-width: 6;\n\t\t\t\t\tstroke-linejoin: round;\n\t\t\t\t\tstroke-linecap: round;\n\t\t\t\t\tfill: none;\n\t\t\t\t}\n\t\t\t</style>\n\t\t\t<path\n\t\t\t\td='\n\t\t\t\t\tM 15,55 30,70 85,20\n\t\t\t\t'\n\t\t\t\tclass='toolbar-save-icon'\n\t\t\t/>\n\t\t`;\n        svg.setAttribute('viewBox', '0 0 100 100');\n        return svg;\n    }\n    makeConfigureDocumentIcon() {\n        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n        svg.innerHTML = `\n\t\t\t<path\n\t\t\t\td='\n\t\t\t\t\tM 5,5 V 95 H 95 V 5 Z m 5,5 H 90 V 90 H 10 Z\n\t\t\t\t\tm 5,10 V 30 H 50 V 25 H 20 v -5 z\n\t\t\t\t\tm 40,0 V 50 H 85 V 20 Z\n\t\t\t\t\tm 2,2 H 83 V 39 L 77,28 70,42 64,35 57,45 Z\n\t\t\t\t\tm 8.5,5 C 64.67,27 64,27.67 64,28.5 64,29.33 64.67,30 65.5,30 66.33,30 67,29.33 67,28.5 67,27.67 66.33,27 65.5,27 Z\n\t\t\t\t\tM 15,40 v 5 h 35 v -5 z\n\t\t\t\t\tm 0,15 v 5 h 70 v -5 z\n\t\t\t\t\tm 0,15 v 5 h 70 v -5 z\n\t\t\t\t'\n\t\t\t\tstyle='fill: var(--icon-color);'\n\t\t\t/>\n\t\t`;\n        svg.setAttribute('viewBox', '0 0 100 100');\n        return svg;\n    }\n    makeOverflowIcon() {\n        return this.makeIconFromPath(`\n\t\t\tM 15 40\n\t\t\tA 12.5 12.5 0 0 0 2.5 52.5\n\t\t\tA 12.5 12.5 0 0 0 15 65\n\t\t\tA 12.5 12.5 0 0 0 27.5 52.5\n\t\t\tA 12.5 12.5 0 0 0 15 40\n\t\t\tz\n\t\n\t\t\tM 50 40\n\t\t\tA 12.5 12.5 0 0 0 37.5 52.5\n\t\t\tA 12.5 12.5 0 0 0 50 65\n\t\t\tA 12.5 12.5 0 0 0 62.5 52.5\n\t\t\tA 12.5 12.5 0 0 0 50 40\n\t\t\tz\n\t\t\t\n\t\t\tM 85 40\n\t\t\tA 12.5 12.5 0 0 0 72.5 52.5\n\t\t\tA 12.5 12.5 0 0 0 85 65\n\t\t\tA 12.5 12.5 0 0 0 97.5 52.5\n\t\t\tA 12.5 12.5 0 0 0 85 40\n\t\t\tz\n\t\t`);\n    }\n    makeHelpIcon() {\n        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n        svg.innerHTML = `\n\t\t\t<circle\n\t\t\t\tstyle=\"stroke-width:1.587; stroke: var(--icon-color);\"\n\t\t\t\tfill=\"none\"\n\t\t\t\tcx=\"13.23\"\n\t\t\t\tcy=\"13.23\"\n\t\t\t\tr=\"11.9\"\n\t\t\t/>\n\t\t\t<path\n\t\t\t\tstyle=\"stroke-width: 3; stroke-linecap: butt; stroke: var(--icon-color);\"\n\t\t\t\tfill=\"none\"\n\t\t\t\td=\"M 9.26,6.61 C 18.7,3.25 19.95,10.4 14.3,13.4 c -1.15,0.61 -1.32,1.32 -1.32,2.65 v 2.12\"\n\t\t\t/>\n\t\t\t<circle\n\t\t\t\tstyle=\"fill: var(--icon-color);\"\n\t\t\t\tcx=\"13\"\n\t\t\t\tcy=\"21.32\"\n\t\t\t\tr=\"1.9\"\n\t\t\t/>\n\t\t`;\n        svg.setAttribute('viewBox', '0 0 26.46 26.46');\n        svg.setAttribute('width', '100');\n        svg.setAttribute('height', '100');\n        return svg;\n    }\n    /**\n     * @param pathData - SVG path data (e.g. `m10,10l30,30z`)\n     * @param fill - A valid CSS color (e.g. `var(--icon-color)` or `#f0f`). This can be `none`.\n     */\n    makeIconFromPath(pathData, fill = 'var(--icon-color)', strokeColor = 'none', strokeWidth = '0px') {\n        const icon = document.createElementNS(svgNamespace, 'svg');\n        const path = document.createElementNS(svgNamespace, 'path');\n        path.setAttribute('d', pathData);\n        path.style.fill = fill;\n        path.style.stroke = strokeColor;\n        path.style.strokeWidth = strokeWidth;\n        icon.appendChild(path);\n        icon.setAttribute('viewBox', '0 0 100 100');\n        return icon;\n    }\n    /**\n     * @returns An object with both the definition of a checkerboard pattern and the syntax to\n     * reference that pattern. The defs provided by this function should be wrapped within a\n     * `<defs></defs>` element.\n     *\n     * **Note**: This function's return value includes both `patternDefElement` (which returns\n     * an Element) and a (deprecated) `patternDef` string. Avoid using the `patternDef` result.\n     */\n    makeCheckerboardPattern() {\n        return makeCheckerboardPattern();\n    }\n    /**\n     * @returns true if the given `penStyle` is known to match a rounded tip type of pen.\n     */\n    isRoundedTipPen(penStyle) {\n        return penStyle.factory === FreehandLineBuilder_1.makeFreehandLineBuilder || penStyle.factory === PolylineBuilder_1.makePolylineBuilder;\n    }\n    isPolylinePen(penStyle) {\n        return penStyle.factory === PolylineBuilder_1.makePolylineBuilder;\n    }\n    /** Must be overridden by icon packs that need attribution. */\n    licenseInfo() {\n        return null;\n    }\n}\n_IconProvider_instances = new WeakSet(), _IconProvider_makeXIcon = function _IconProvider_makeXIcon() {\n    const strokeWidth = '6px';\n    const strokeColor = 'var(--icon-color)';\n    const fillColor = 'none';\n    return this.makeIconFromPath(`\n\t\t\tM 15,15 85,85\n\t\t\tM 15,85 85,15\n\t\t`, fillColor, strokeColor, strokeWidth);\n};\nexports[\"default\"] = IconProvider;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/toolbar/IconProvider.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/toolbar/constants.js":
/*!************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/toolbar/constants.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.toolbarCSSPrefix = void 0;\nexports.toolbarCSSPrefix = 'toolbar-';\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/toolbar/constants.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/toolbar/lib.js":
/*!******************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/toolbar/lib.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.makeEdgeToolbar = exports.makeDropdownToolbar = exports.IconProvider = void 0;\n__exportStar(__webpack_require__(/*! ./widgets/lib */ \"./node_modules/js-draw/dist/cjs/toolbar/widgets/lib.js\"), exports);\n__exportStar(__webpack_require__(/*! ./widgets/components/makeColorInput */ \"./node_modules/js-draw/dist/cjs/toolbar/widgets/components/makeColorInput.js\"), exports);\nvar IconProvider_1 = __webpack_require__(/*! ./IconProvider */ \"./node_modules/js-draw/dist/cjs/toolbar/IconProvider.js\");\nObject.defineProperty(exports, \"IconProvider\", ({ enumerable: true, get: function () { return __importDefault(IconProvider_1).default; } }));\nvar DropdownToolbar_1 = __webpack_require__(/*! ./DropdownToolbar */ \"./node_modules/js-draw/dist/cjs/toolbar/DropdownToolbar.js\");\nObject.defineProperty(exports, \"makeDropdownToolbar\", ({ enumerable: true, get: function () { return DropdownToolbar_1.makeDropdownToolbar; } }));\nvar EdgeToolbar_1 = __webpack_require__(/*! ./EdgeToolbar */ \"./node_modules/js-draw/dist/cjs/toolbar/EdgeToolbar.js\");\nObject.defineProperty(exports, \"makeEdgeToolbar\", ({ enumerable: true, get: function () { return EdgeToolbar_1.makeEdgeToolbar; } }));\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/toolbar/lib.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/toolbar/localization.js":
/*!***************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/toolbar/localization.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.defaultToolbarLocalization = void 0;\nconst localization_1 = __webpack_require__(/*! ./utils/localization */ \"./node_modules/js-draw/dist/cjs/toolbar/utils/localization.js\");\nexports.defaultToolbarLocalization = {\n    ...localization_1.defaultToolbarUtilsLocalization,\n    pen: 'Pen',\n    eraser: 'Eraser',\n    select: 'Select',\n    handTool: 'Pan',\n    zoom: 'Zoom',\n    image: 'Image',\n    reformatSelection: 'Format selection',\n    inputAltText: 'Alt text',\n    decreaseImageSize: 'Decrease size',\n    resetImage: 'Reset',\n    chooseFile: 'Choose file',\n    dragAndDropHereOrBrowse: 'Drag and drop here\\nor\\n{{browse}}',\n    submit: 'Submit',\n    addAll: 'Add all',\n    cancel: 'Cancel',\n    resetView: 'Reset view',\n    thicknessLabel: 'Thickness',\n    colorLabel: 'Color',\n    fontLabel: 'Font',\n    textSize: 'Size',\n    resizeImageToSelection: 'Resize image to selection',\n    deleteSelection: 'Delete selection',\n    duplicateSelection: 'Duplicate selection',\n    exit: 'Exit',\n    save: 'Save',\n    undo: 'Undo',\n    redo: 'Redo',\n    fullStrokeEraser: 'Full stroke eraser',\n    selectPenType: 'Pen type',\n    selectShape: 'Shape',\n    pickColorFromScreen: 'Pick color from screen',\n    clickToPickColorAnnouncement: 'Click on the screen to pick a color',\n    colorSelectionCanceledAnnouncement: 'Color selection canceled',\n    selectionToolKeyboardShortcuts: 'Selection tool: Use arrow keys to move selected items, lowercase/uppercase ‘i’ and ‘o’ to resize.',\n    documentProperties: 'Page',\n    backgroundColor: 'Background color',\n    imageWidthOption: 'Width',\n    imageHeightOption: 'Height',\n    useGridOption: 'Grid',\n    enableAutoresizeOption: 'Auto-resize',\n    toggleOverflow: 'More',\n    about: 'About',\n    inputStabilization: 'Stabilization',\n    strokeAutocorrect: 'Autocorrect',\n    touchPanning: 'Scroll with touch',\n    roundedTipPen: 'Round',\n    roundedTipPen2: 'Polyline',\n    flatTipPen: 'Flat',\n    arrowPen: 'Arrow',\n    linePen: 'Line',\n    outlinedRectanglePen: 'Outlined rectangle',\n    filledRectanglePen: 'Filled rectangle',\n    outlinedCirclePen: 'Outlined circle',\n    lockRotation: 'Lock rotation',\n    paste: 'Paste',\n    errorImageHasZeroSize: 'Error: Image has zero size',\n    describeTheImage: 'Image description',\n    fileInput__loading: 'Loading...',\n    fileInput__andNMoreFiles: (n) => `(...${n} more)`,\n    // Help text\n    penDropdown__baseHelpText: 'This tool draws shapes or freehand lines.',\n    penDropdown__colorHelpText: \"Changes the pen's color\",\n    penDropdown__thicknessHelpText: 'Changes the thickness of strokes drawn by the pen.',\n    penDropdown__penTypeHelpText: 'Changes the pen style.\\n\\nEither a “pen” style or “shape” can be chosen. Choosing a “pen” style draws freehand lines. Choosing a “shape” draws shapes.',\n    penDropdown__autocorrectHelpText: 'Converts approximate freehand lines and rectangles to perfect ones.\\n\\nThe pen must be held stationary at the end of a stroke to trigger a correction.',\n    penDropdown__stabilizationHelpText: 'Draws smoother strokes.\\n\\nThis also adds a short delay between the mouse/stylus and the stroke.',\n    handDropdown__baseHelpText: 'This tool is responsible for scrolling, rotating, and zooming the editor.',\n    handDropdown__zoomInHelpText: 'Zooms in.',\n    handDropdown__zoomOutHelpText: 'Zooms out.',\n    handDropdown__resetViewHelpText: 'Resets the zoom level to 100% and resets scroll.',\n    handDropdown__zoomDisplayHelpText: 'Shows the current zoom level. 100% shows the image at its actual size.',\n    handDropdown__touchPanningHelpText: 'When enabled, touchscreen gestures move the image rather than select or draw.',\n    handDropdown__lockRotationHelpText: 'When enabled, prevents touch gestures from rotating the screen.',\n    eraserDropdown__baseHelpText: 'This tool removes strokes, images, and text under the cursor.',\n    eraserDropdown__thicknessHelpText: 'Changes the size of the eraser.',\n    eraserDropdown__fullStrokeEraserHelpText: 'When in full-stroke mode, entire shapes are erased.\\n\\nWhen not in full-stroke mode, shapes can be partially erased.',\n    selectionDropdown__baseHelpText: 'Selects content and manipulates the selection',\n    selectionDropdown__resizeToHelpText: \"Crops the drawing to the size of what's currently selected.\\n\\nIf auto-resize is enabled, it will be disabled.\",\n    selectionDropdown__deleteHelpText: 'Erases selected items.',\n    selectionDropdown__duplicateHelpText: 'Makes a copy of selected items.',\n    selectionDropdown__changeColorHelpText: 'Changes the color of selected items.',\n    pageDropdown__baseHelpText: \"Controls the drawing canvas' background color, pattern, and size.\",\n    pageDropdown__backgroundColorHelpText: 'Changes the background color of the drawing canvas.',\n    pageDropdown__gridCheckboxHelpText: 'Enables/disables a background grid pattern.',\n    pageDropdown__autoresizeCheckboxHelpText: 'When checked, the page grows to fit the drawing.\\n\\nWhen unchecked, the page is visible and its size can be set manually.',\n    pageDropdown__aboutButtonHelpText: 'Shows version, debug, and other information.',\n    colorPickerPipetteHelpText: 'Picks a color from the screen.',\n    colorPickerToggleHelpText: 'Opens/closes the color picker.',\n    closeSidebar: (toolName) => `Close sidebar for ${toolName}`,\n    dropdownShown: (toolName) => `Menu for ${toolName} shown`,\n    dropdownHidden: (toolName) => `Menu for ${toolName} hidden`,\n    zoomLevel: (zoomPercent) => `Zoom: ${zoomPercent}%`,\n    colorChangedAnnouncement: (color) => `Color changed to ${color}`,\n    imageSize: (size, units) => `Image size: ${size} ${units}`,\n    imageLoadError: (message) => `Error loading image: ${message}`,\n};\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/toolbar/localization.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/toolbar/utils/HelpDisplay.js":
/*!********************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/toolbar/utils/HelpDisplay.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar _HelpDisplay_helpData;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\nconst makeDraggable_1 = __importDefault(__webpack_require__(/*! ./makeDraggable */ \"./node_modules/js-draw/dist/cjs/toolbar/utils/makeDraggable.js\"));\nconst ReactiveValue_1 = __webpack_require__(/*! ../../util/ReactiveValue */ \"./node_modules/js-draw/dist/cjs/util/ReactiveValue.js\");\nconst cloneElementWithStyles_1 = __importDefault(__webpack_require__(/*! ../../util/cloneElementWithStyles */ \"./node_modules/js-draw/dist/cjs/util/cloneElementWithStyles.js\"));\nconst addLongPressOrHoverCssClasses_1 = __importDefault(__webpack_require__(/*! ../../util/addLongPressOrHoverCssClasses */ \"./node_modules/js-draw/dist/cjs/util/addLongPressOrHoverCssClasses.js\"));\n/**\n * Creates the main content of the help overlay.\n *\n * Shows the label for a `HelpRecord` and a highlighted copy\n * of that label's `targetElements`.\n */\nconst createHelpPage = (helpItems, onItemClick, onBackgroundClick, context) => {\n    const container = document.createElement('div');\n    container.classList.add('help-page-container');\n    const textLabel = document.createElement('div');\n    textLabel.classList.add('label', '-space-above');\n    textLabel.setAttribute('aria-live', 'polite');\n    // The current active item in helpItems.\n    // (Only one item is active at a time, but each item can have multiple HTMLElements).\n    let currentItemIndex = 0;\n    let currentItem = helpItems[0] ?? null;\n    // Each help item can have multiple associated elements. We store clones of each\n    // of these elements in their own container.\n    //\n    // clonedElementContainers maps from help item indicies to **arrays** of containers.\n    //\n    // For example, clonedElementContainers would be\n    //   [ [ Container1, Container2 ], [ Container3 ], [ Container4 ]]\n    //       ↑                            ↑              ↑\n    //       HelpItem 1                   HelpItem 2     HelpItem 3\n    // if the first help item had two elements (and thus two cloned element containers).\n    //\n    // We also store the original bounding box -- the bounding box of the clones can change\n    // while dragging to switch pages.\n    let clonedElementContainers = [];\n    // Clicking on the background of the help area should send an event (e.g. to allow the\n    // help container to be closed).\n    container.addEventListener('click', (event) => {\n        // If clicking directly on the container (and not on a child)\n        if (event.target === container) {\n            onBackgroundClick();\n        }\n    });\n    // Returns the combined bounding box of all elements associated with the currentItem\n    // (all active help items).\n    const getCombinedBBox = () => {\n        if (!currentItem) {\n            return math_1.Rect2.empty;\n        }\n        const itemBoundingBoxes = currentItem.targetElements.map((element) => math_1.Rect2.of(element.getBoundingClientRect()));\n        return math_1.Rect2.union(...itemBoundingBoxes);\n    };\n    // Updates each cloned element's click listener and CSS classes based on whether\n    // that element is the current focused element.\n    const updateClonedElementStates = () => {\n        const currentItemBBox = getCombinedBBox();\n        for (let index = 0; index < clonedElementContainers.length; index++) {\n            for (const { container, bbox: containerBBox } of clonedElementContainers[index]) {\n                if (index === currentItemIndex) {\n                    container.classList.add('-active');\n                    container.classList.remove('-clickable', '-background');\n                    container.onclick = () => { };\n                }\n                // Otherwise, if not containing the current element\n                else {\n                    if (!containerBBox.containsRect(currentItemBBox)) {\n                        container.classList.add('-clickable');\n                        container.classList.remove('-active', '-background');\n                    }\n                    else {\n                        container.classList.add('-background');\n                        container.classList.remove('-active', '-clickable');\n                    }\n                    const containerIndex = index;\n                    container.onclick = () => {\n                        onItemClick(containerIndex);\n                    };\n                }\n            }\n        }\n    };\n    // Ensures that the item label doesn't overlap the current help item's cloned element.\n    const updateLabelPosition = () => {\n        const labelBBox = math_1.Rect2.of(textLabel.getBoundingClientRect());\n        const combinedBBox = getCombinedBBox();\n        if (labelBBox.intersects(combinedBBox)) {\n            const containerBBox = math_1.Rect2.of(container.getBoundingClientRect());\n            const spaceAboveCombined = combinedBBox.topLeft.y;\n            const spaceBelowCombined = containerBBox.bottomLeft.y - combinedBBox.bottomLeft.y;\n            if (spaceAboveCombined > spaceBelowCombined && spaceAboveCombined > labelBBox.height / 3) {\n                // Push to the very top\n                textLabel.classList.remove('-small-space-above', '-large-space-above');\n                textLabel.classList.add('-large-space-below');\n            }\n            if (spaceAboveCombined < spaceBelowCombined && spaceBelowCombined > labelBBox.height) {\n                // Push to the very bottom\n                textLabel.classList.add('-large-space-above');\n                textLabel.classList.remove('-large-space-below');\n            }\n        }\n    };\n    const refreshContent = () => {\n        container.replaceChildren();\n        // Add the text label first so that screen readers will visit it first.\n        textLabel.classList.remove('-large-space-above');\n        textLabel.classList.add('-small-space-above', '-large-space-below');\n        container.appendChild(textLabel);\n        const screenBBox = new math_1.Rect2(0, 0, window.innerWidth, window.innerHeight);\n        clonedElementContainers = [];\n        for (let itemIndex = 0; itemIndex < helpItems.length; itemIndex++) {\n            const item = helpItems[itemIndex];\n            const itemCloneContainers = [];\n            for (const targetElement of item.targetElements) {\n                let targetBBox = math_1.Rect2.of(targetElement.getBoundingClientRect());\n                // Move the element onto the screen if not visible\n                if (!screenBBox.intersects(targetBBox)) {\n                    const screenBottomCenter = screenBBox.bottomLeft.lerp(screenBBox.bottomRight, 0.5);\n                    const targetBottomCenter = targetBBox.bottomLeft.lerp(targetBBox.bottomRight, 0.5);\n                    const delta = screenBottomCenter.minus(targetBottomCenter);\n                    targetBBox = targetBBox.translatedBy(delta);\n                }\n                const clonedElement = (0, cloneElementWithStyles_1.default)(targetElement);\n                // Interacting with the clone won't trigger event listeners, so disable\n                // all inputs.\n                for (const input of clonedElement.querySelectorAll('input')) {\n                    input.disabled = true;\n                }\n                clonedElement.style.margin = '0';\n                const clonedElementContainer = document.createElement('div');\n                clonedElementContainer.classList.add('cloned-element-container');\n                clonedElementContainer.style.position = 'absolute';\n                clonedElementContainer.style.left = `${targetBBox.topLeft.x}px`;\n                clonedElementContainer.style.top = `${targetBBox.topLeft.y}px`;\n                clonedElementContainer.replaceChildren(clonedElement);\n                (0, addLongPressOrHoverCssClasses_1.default)(clonedElementContainer, { timeout: 0 });\n                itemCloneContainers.push({ container: clonedElementContainer, bbox: targetBBox });\n                container.appendChild(clonedElementContainer);\n            }\n            clonedElementContainers.push(itemCloneContainers);\n        }\n        updateClonedElementStates();\n    };\n    const refresh = () => {\n        refreshContent();\n        updateLabelPosition();\n    };\n    const onItemChange = () => {\n        const helpTextElement = document.createElement('div');\n        helpTextElement.innerText = currentItem?.helpText ?? '';\n        // For tests\n        helpTextElement.classList.add('current-item-help');\n        const navigationHelpElement = document.createElement('div');\n        navigationHelpElement.innerText = context.localization.helpScreenNavigationHelp;\n        navigationHelpElement.classList.add('navigation-help');\n        textLabel.replaceChildren(helpTextElement, ...(currentItemIndex === 0 ? [navigationHelpElement] : []));\n        updateClonedElementStates();\n    };\n    onItemChange();\n    return {\n        addToParent: (parent) => {\n            refreshContent();\n            parent.appendChild(container);\n            updateLabelPosition();\n        },\n        refresh,\n        setPageIndex: (pageIndex) => {\n            currentItemIndex = pageIndex;\n            currentItem = helpItems[pageIndex];\n            onItemChange();\n        },\n    };\n};\n/**\n * Creates and manages an overlay that shows help text for a set of\n * `HTMLElement`s.\n *\n * @see {@link BaseWidget.fillDropdown}.\n */\nclass HelpDisplay {\n    /** Constructed internally by BaseWidget. @internal */\n    constructor(createOverlay, context) {\n        this.createOverlay = createOverlay;\n        this.context = context;\n        _HelpDisplay_helpData.set(this, []);\n    }\n    /** @internal */\n    showHelpOverlay() {\n        const overlay = document.createElement('dialog');\n        overlay.setAttribute('autofocus', 'true');\n        overlay.classList.add('toolbar-help-overlay');\n        // Closes the overlay with a closing animation\n        const closing = false;\n        const closeOverlay = () => {\n            if (closing)\n                return;\n            // If changing animationDelay, be sure to also update the CSS.\n            const animationDelay = 250; // ms\n            overlay.classList.add('-hiding');\n            setTimeout(() => overlay.close(), animationDelay);\n        };\n        let lastDragTimestamp = 0;\n        const onBackgroundClick = () => {\n            const wasJustDragging = performance.now() - lastDragTimestamp < 100;\n            if (!wasJustDragging) {\n                closeOverlay();\n            }\n        };\n        const makeCloseButton = () => {\n            const closeButton = document.createElement('button');\n            closeButton.classList.add('close-button');\n            closeButton.appendChild(this.context.icons.makeCloseIcon());\n            const label = this.context.localization.close;\n            closeButton.setAttribute('aria-label', label);\n            closeButton.setAttribute('title', label);\n            closeButton.onclick = () => {\n                closeOverlay();\n            };\n            return closeButton;\n        };\n        // Wraps the label and clickable help elements\n        const makeNavigationContent = () => {\n            const currentPage = ReactiveValue_1.MutableReactiveValue.fromInitialValue(0);\n            const content = document.createElement('div');\n            content.classList.add('navigation-content');\n            const helpPage = createHelpPage(__classPrivateFieldGet(this, _HelpDisplay_helpData, \"f\"), (newPageIndex) => currentPage.set(newPageIndex), onBackgroundClick, this.context);\n            helpPage.addToParent(content);\n            const showPage = (pageIndex) => {\n                if (pageIndex >= __classPrivateFieldGet(this, _HelpDisplay_helpData, \"f\").length || pageIndex < 0) {\n                    // Hide if out of bounds\n                    console.warn('Help screen: Navigated to out-of-bounds page', pageIndex);\n                    content.style.display = 'none';\n                }\n                else {\n                    content.style.display = '';\n                    helpPage.setPageIndex(pageIndex);\n                }\n            };\n            currentPage.onUpdateAndNow(showPage);\n            const navigationControl = {\n                content,\n                currentPage,\n                toNext: () => {\n                    if (navigationControl.hasNext()) {\n                        currentPage.set(currentPage.get() + 1);\n                    }\n                },\n                toPrevious: () => {\n                    if (navigationControl.hasPrevious()) {\n                        currentPage.set(currentPage.get() - 1);\n                    }\n                },\n                hasNext: () => {\n                    return currentPage.get() + 1 < __classPrivateFieldGet(this, _HelpDisplay_helpData, \"f\").length;\n                },\n                hasPrevious: () => {\n                    return currentPage.get() > 0;\n                },\n                refreshCurrent: () => {\n                    helpPage.refresh();\n                },\n            };\n            return navigationControl;\n        };\n        // Creates next/previous buttons.\n        const makeNavigationButtons = (navigation) => {\n            const navigationButtonContainer = document.createElement('div');\n            navigationButtonContainer.classList.add('navigation-buttons');\n            const nextButton = document.createElement('button');\n            const previousButton = document.createElement('button');\n            nextButton.innerText = this.context.localization.next;\n            previousButton.innerText = this.context.localization.previous;\n            nextButton.classList.add('next');\n            previousButton.classList.add('previous');\n            const updateButtonVisibility = () => {\n                navigationButtonContainer.classList.remove('-has-next', '-has-previous');\n                if (navigation.hasNext()) {\n                    navigationButtonContainer.classList.add('-has-next');\n                    nextButton.disabled = false;\n                }\n                else {\n                    navigationButtonContainer.classList.remove('-has-next');\n                    nextButton.disabled = true;\n                }\n                if (navigation.hasPrevious()) {\n                    navigationButtonContainer.classList.add('-has-previous');\n                    previousButton.disabled = false;\n                }\n                else {\n                    navigationButtonContainer.classList.remove('-has-previous');\n                    previousButton.disabled = true;\n                }\n            };\n            navigation.currentPage.onUpdateAndNow(updateButtonVisibility);\n            nextButton.onclick = () => {\n                navigation.toNext();\n            };\n            previousButton.onclick = () => {\n                navigation.toPrevious();\n            };\n            navigationButtonContainer.replaceChildren(previousButton, nextButton);\n            return navigationButtonContainer;\n        };\n        const navigation = makeNavigationContent();\n        const navigationButtons = makeNavigationButtons(navigation);\n        overlay.replaceChildren(makeCloseButton(), navigationButtons, navigation.content);\n        this.createOverlay(overlay);\n        overlay.showModal();\n        const minDragOffsetToTransition = 30;\n        const setDragOffset = (offset) => {\n            if (offset > 0 && !navigation.hasPrevious()) {\n                offset = 0;\n            }\n            if (offset < 0 && !navigation.hasNext()) {\n                offset = 0;\n            }\n            // Clamp offset\n            if (offset > minDragOffsetToTransition || offset < -minDragOffsetToTransition) {\n                offset = minDragOffsetToTransition * Math.sign(offset);\n            }\n            overlay.style.transform = `translate(${offset}px, 0px)`;\n            if (offset >= minDragOffsetToTransition) {\n                navigationButtons.classList.add('-highlight-previous');\n            }\n            else {\n                navigationButtons.classList.remove('-highlight-previous');\n            }\n            if (offset <= -minDragOffsetToTransition) {\n                navigationButtons.classList.add('-highlight-next');\n            }\n            else {\n                navigationButtons.classList.remove('-highlight-next');\n            }\n        };\n        // Listeners\n        const dragListener = (0, makeDraggable_1.default)(overlay, {\n            draggableChildElements: [navigation.content],\n            onDrag: (_deltaX, _deltaY, totalDisplacement) => {\n                overlay.classList.add('-dragging');\n                setDragOffset(totalDisplacement.x);\n            },\n            onDragEnd: (dragStatistics) => {\n                overlay.classList.remove('-dragging');\n                setDragOffset(0);\n                if (!dragStatistics.roughlyClick) {\n                    const xDisplacement = dragStatistics.displacement.x;\n                    if (xDisplacement > minDragOffsetToTransition) {\n                        navigation.toPrevious();\n                    }\n                    else if (xDisplacement < -minDragOffsetToTransition) {\n                        navigation.toNext();\n                    }\n                    lastDragTimestamp = dragStatistics.endTimestamp;\n                }\n            },\n        });\n        let resizeObserver;\n        if (window.ResizeObserver) {\n            resizeObserver = new ResizeObserver(() => {\n                navigation.refreshCurrent();\n            });\n            resizeObserver.observe(overlay);\n        }\n        const onMediaChangeListener = () => {\n            // Refresh the cloned elements and their styles after a delay.\n            // This is necessary because styles are cloned, in addition to elements.\n            requestAnimationFrame(() => navigation.refreshCurrent());\n        };\n        // matchMedia is unsupported by jsdom\n        const mediaQueryList = window.matchMedia?.('(prefers-color-scheme: dark)');\n        mediaQueryList?.addEventListener('change', onMediaChangeListener);\n        // Close the overlay when clicking on the background (*directly* on any of the\n        // elements in closeOverlayTriggers).\n        const closeOverlayTriggers = [navigation.content, navigationButtons, overlay];\n        overlay.onclick = (event) => {\n            if (closeOverlayTriggers.includes(event.target)) {\n                onBackgroundClick();\n            }\n        };\n        overlay.onkeyup = (event) => {\n            if (event.code === 'Escape') {\n                closeOverlay();\n                event.preventDefault();\n            }\n            else if (event.code === 'ArrowRight') {\n                navigation.toNext();\n                event.preventDefault();\n            }\n            else if (event.code === 'ArrowLeft') {\n                navigation.toPrevious();\n                event.preventDefault();\n            }\n        };\n        overlay.addEventListener('close', () => {\n            this.context.announceForAccessibility(this.context.localization.helpHidden);\n            mediaQueryList?.removeEventListener('change', onMediaChangeListener);\n            dragListener.removeListeners();\n            resizeObserver?.disconnect();\n            overlay.remove();\n        });\n    }\n    /** Marks `helpText` as associated with a single `targetElement`. */\n    registerTextHelpForElement(targetElement, helpText) {\n        this.registerTextHelpForElements([targetElement], helpText);\n    }\n    /** Marks `helpText` as associated with all elements in `targetElements`. */\n    registerTextHelpForElements(targetElements, helpText) {\n        __classPrivateFieldGet(this, _HelpDisplay_helpData, \"f\").push({ targetElements: [...targetElements], helpText });\n    }\n    /** Returns true if any help text has been registered. */\n    hasHelpText() {\n        return __classPrivateFieldGet(this, _HelpDisplay_helpData, \"f\").length > 0;\n    }\n    /**\n     * Creates and returns a button that toggles the help display.\n     */\n    createToggleButton() {\n        const buttonContainer = document.createElement('div');\n        buttonContainer.classList.add('toolbar-help-overlay-button');\n        const helpButton = document.createElement('button');\n        helpButton.classList.add('button');\n        const icon = this.context.icons.makeHelpIcon();\n        icon.classList.add('icon');\n        helpButton.appendChild(icon);\n        helpButton.setAttribute('aria-label', this.context.localization.help);\n        helpButton.onclick = () => {\n            this.showHelpOverlay();\n        };\n        buttonContainer.appendChild(helpButton);\n        return buttonContainer;\n    }\n}\n_HelpDisplay_helpData = new WeakMap();\nexports[\"default\"] = HelpDisplay;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/toolbar/utils/HelpDisplay.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/toolbar/utils/localization.js":
/*!*********************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/toolbar/utils/localization.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.defaultToolbarUtilsLocalization = void 0;\nexports.defaultToolbarUtilsLocalization = {\n    help: 'Help',\n    helpHidden: 'Help hidden',\n    next: 'Next',\n    previous: 'Previous',\n    close: 'Close',\n    helpScreenNavigationHelp: 'Click on a control for more information.',\n};\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/toolbar/utils/localization.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/toolbar/utils/makeDraggable.js":
/*!**********************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/toolbar/utils/makeDraggable.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\nconst makeDraggable = (dragElement, options) => {\n    const dragElements = [...options.draggableChildElements, dragElement];\n    let lastX = 0;\n    let lastY = 0;\n    let startX = 0;\n    let startY = 0;\n    let pointerDown = false;\n    let capturedPointerId = null;\n    const isDraggableElement = (element) => {\n        if (!element) {\n            return false;\n        }\n        if (dragElements.includes(element)) {\n            return true;\n        }\n        // Some inputs handle dragging themselves. Don't also interpret such gestures\n        // as dragging the dropdown.\n        const undraggableElementTypes = ['INPUT', 'SELECT', 'IMG'];\n        let hasSuitableAncestors = false;\n        let ancestor = element.parentElement;\n        while (ancestor) {\n            if (undraggableElementTypes.includes(ancestor.tagName)) {\n                break;\n            }\n            if (dragElements.includes(ancestor)) {\n                hasSuitableAncestors = true;\n                break;\n            }\n            ancestor = ancestor.parentElement;\n        }\n        return !undraggableElementTypes.includes(element.tagName) && hasSuitableAncestors;\n    };\n    const removeEventListenerCallbacks = [];\n    const addEventListener = (listenerType, listener, options) => {\n        dragElement.addEventListener(listenerType, listener, options);\n        removeEventListenerCallbacks.push(() => {\n            dragElement.removeEventListener(listenerType, listener);\n        });\n    };\n    const clickThreshold = 5;\n    // Returns whether the current (or if no current, **the last**) gesture is roughly a click.\n    // Because this can be called **after** a gesture has just ended, it should not require\n    // the gesture to be in progress.\n    const isRoughlyClick = () => {\n        return Math.hypot(lastX - startX, lastY - startY) < clickThreshold;\n    };\n    let startedDragging = false;\n    addEventListener('pointerdown', (event) => {\n        if (event.defaultPrevented || !isDraggableElement(event.target)) {\n            return;\n        }\n        if (event.isPrimary) {\n            startedDragging = false;\n            lastX = event.clientX;\n            lastY = event.clientY;\n            startX = event.clientX;\n            startY = event.clientY;\n            capturedPointerId = null;\n            pointerDown = true;\n        }\n    }, { passive: true });\n    const onGestureEnd = (_event) => {\n        // If the pointerup/pointercancel event was for a pointer not being tracked,\n        if (!pointerDown) {\n            return;\n        }\n        if (capturedPointerId !== null) {\n            dragElement.releasePointerCapture(capturedPointerId);\n            capturedPointerId = null;\n        }\n        options.onDragEnd({\n            roughlyClick: isRoughlyClick(),\n            endTimestamp: performance.now(),\n            displacement: math_1.Vec2.of(lastX - startX, lastY - startY),\n        });\n        pointerDown = false;\n        startedDragging = false;\n    };\n    addEventListener('pointermove', (event) => {\n        if (!event.isPrimary || !pointerDown) {\n            return undefined;\n        }\n        // Mouse event and no buttons pressed? Cancel the event.\n        // This can happen if the event was canceled by a focus change (e.g. by opening a\n        // right-click menu).\n        if (event.pointerType === 'mouse' && event.buttons === 0) {\n            onGestureEnd(event);\n            return undefined;\n        }\n        // Only capture after motion -- capturing early prevents click events in Chrome.\n        if (capturedPointerId === null && !isRoughlyClick()) {\n            dragElement.setPointerCapture(event.pointerId);\n            capturedPointerId = event.pointerId;\n        }\n        const x = event.clientX;\n        const y = event.clientY;\n        const dx = x - lastX;\n        const dy = y - lastY;\n        const isClick = Math.abs(x - startX) <= clickThreshold && Math.abs(y - startY) <= clickThreshold;\n        if (!isClick || startedDragging) {\n            options.onDrag(dx, dy, math_1.Vec2.of(x - startX, y - startY));\n            lastX = x;\n            lastY = y;\n            startedDragging = true;\n        }\n    });\n    addEventListener('pointerleave', (event) => {\n        // Capture the pointer if it exits the container while dragging.\n        if (capturedPointerId === null && pointerDown && event.isPrimary) {\n            dragElement.setPointerCapture(event.pointerId);\n            capturedPointerId = event.pointerId;\n        }\n    });\n    addEventListener('pointerup', onGestureEnd);\n    addEventListener('pointercancel', onGestureEnd);\n    return {\n        removeListeners: () => {\n            for (const removeListenerCallback of removeEventListenerCallbacks) {\n                removeListenerCallback();\n            }\n        },\n    };\n};\nexports[\"default\"] = makeDraggable;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/toolbar/utils/makeDraggable.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/toolbar/widgets/ActionButtonWidget.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/toolbar/widgets/ActionButtonWidget.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar _ActionButtonWidget_autoDisableInReadOnlyEditors, _ActionButtonWidget_helpText;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst BaseWidget_1 = __importDefault(__webpack_require__(/*! ./BaseWidget */ \"./node_modules/js-draw/dist/cjs/toolbar/widgets/BaseWidget.js\"));\nclass ActionButtonWidget extends BaseWidget_1.default {\n    constructor(editor, id, makeIcon, title, clickAction, localizationTable, mustBeToplevel = false, autoDisableInReadOnlyEditors = true) {\n        super(editor, id, localizationTable);\n        this.makeIcon = makeIcon;\n        this.title = title;\n        this.clickAction = clickAction;\n        this.mustBeToplevel = mustBeToplevel;\n        _ActionButtonWidget_autoDisableInReadOnlyEditors.set(this, void 0);\n        _ActionButtonWidget_helpText.set(this, undefined);\n        __classPrivateFieldSet(this, _ActionButtonWidget_autoDisableInReadOnlyEditors, autoDisableInReadOnlyEditors, \"f\");\n    }\n    /**\n     * Sets the text shown in a help overlay for this button.\n     *\n     * See {@link getHelpText}.\n     */\n    setHelpText(helpText) {\n        __classPrivateFieldSet(this, _ActionButtonWidget_helpText, helpText, \"f\");\n    }\n    getHelpText() {\n        return __classPrivateFieldGet(this, _ActionButtonWidget_helpText, \"f\");\n    }\n    shouldAutoDisableInReadOnlyEditor() {\n        return __classPrivateFieldGet(this, _ActionButtonWidget_autoDisableInReadOnlyEditors, \"f\");\n    }\n    handleClick() {\n        this.clickAction();\n    }\n    getTitle() {\n        return this.title;\n    }\n    createIcon() {\n        return this.makeIcon();\n    }\n    fillDropdown(_dropdown) {\n        return false;\n    }\n    mustBeInToplevelMenu() {\n        return this.mustBeToplevel;\n    }\n}\n_ActionButtonWidget_autoDisableInReadOnlyEditors = new WeakMap(), _ActionButtonWidget_helpText = new WeakMap();\nexports[\"default\"] = ActionButtonWidget;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/toolbar/widgets/ActionButtonWidget.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/toolbar/widgets/BaseToolWidget.js":
/*!*************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/toolbar/widgets/BaseToolWidget.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst BaseWidget_1 = __importDefault(__webpack_require__(/*! ./BaseWidget */ \"./node_modules/js-draw/dist/cjs/toolbar/widgets/BaseWidget.js\"));\nconst constants_1 = __webpack_require__(/*! ../constants */ \"./node_modules/js-draw/dist/cjs/toolbar/constants.js\");\nconst isToolWidgetFocused = () => {\n    const currentFocus = [...document.querySelectorAll('*:focus')];\n    return (currentFocus.length &&\n        currentFocus.some((elem) => elem.classList.contains(`${constants_1.toolbarCSSPrefix}button`)));\n};\nclass BaseToolWidget extends BaseWidget_1.default {\n    constructor(editor, targetTool, id, localizationTable) {\n        super(editor, id, localizationTable);\n        this.targetTool = targetTool;\n        this.targetTool.enabledValue().onUpdateAndNow((enabled) => {\n            if (enabled) {\n                this.setSelected(true);\n                // Transfer focus to the current button, only if another toolbar button is\n                // focused.\n                // This prevents pressing \"space\" from triggering a different action when\n                // the current is selected.\n                if (isToolWidgetFocused()) {\n                    this.focus();\n                }\n            }\n            else {\n                this.setSelected(false);\n                this.setDropdownVisible(false);\n            }\n        });\n    }\n    shouldAutoDisableInReadOnlyEditor() {\n        return !this.targetTool.canReceiveInputInReadOnlyEditor();\n    }\n    handleClick() {\n        if (this.hasDropdown) {\n            if (!this.targetTool.isEnabled()) {\n                this.targetTool.setEnabled(true);\n                this.activateDropdown();\n            }\n            else {\n                this.setDropdownVisible(!this.isDropdownVisible());\n            }\n        }\n        else {\n            this.targetTool.setEnabled(!this.targetTool.isEnabled());\n        }\n    }\n    onKeyPress(event) {\n        if (this.isSelected() && event.code === 'Space' && this.hasDropdown) {\n            this.handleClick();\n            return true;\n        }\n        return false;\n    }\n    addTo(parent) {\n        const result = super.addTo(parent);\n        this.setSelected(this.targetTool.isEnabled());\n        return result;\n    }\n}\nexports[\"default\"] = BaseToolWidget;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/toolbar/widgets/BaseToolWidget.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/toolbar/widgets/BaseWidget.js":
/*!*********************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/toolbar/widgets/BaseWidget.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar _BaseWidget_instances, _a, _BaseWidget_hasDropdown, _BaseWidget_disabledDueToReadOnlyEditor, _BaseWidget_tags, _BaseWidget_removeEditorListeners, _BaseWidget_addEditorListeners;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ToolbarWidgetTag = void 0;\nconst ToolbarShortcutHandler_1 = __importDefault(__webpack_require__(/*! ../../tools/ToolbarShortcutHandler */ \"./node_modules/js-draw/dist/cjs/tools/ToolbarShortcutHandler.js\"));\nconst inputEvents_1 = __webpack_require__(/*! ../../inputEvents */ \"./node_modules/js-draw/dist/cjs/inputEvents.js\");\nconst constants_1 = __webpack_require__(/*! ../constants */ \"./node_modules/js-draw/dist/cjs/toolbar/constants.js\");\nconst DropdownLayoutManager_1 = __importDefault(__webpack_require__(/*! ./layout/DropdownLayoutManager */ \"./node_modules/js-draw/dist/cjs/toolbar/widgets/layout/DropdownLayoutManager.js\"));\nconst addLongPressOrHoverCssClasses_1 = __importDefault(__webpack_require__(/*! ../../util/addLongPressOrHoverCssClasses */ \"./node_modules/js-draw/dist/cjs/util/addLongPressOrHoverCssClasses.js\"));\nconst HelpDisplay_1 = __importDefault(__webpack_require__(/*! ../utils/HelpDisplay */ \"./node_modules/js-draw/dist/cjs/toolbar/utils/HelpDisplay.js\"));\nconst assertions_1 = __webpack_require__(/*! ../../util/assertions */ \"./node_modules/js-draw/dist/cjs/util/assertions.js\");\n/**\n * A set of labels that allow toolbar themes to treat buttons differently.\n */\nvar ToolbarWidgetTag;\n(function (ToolbarWidgetTag) {\n    ToolbarWidgetTag[\"Save\"] = \"save\";\n    ToolbarWidgetTag[\"Exit\"] = \"exit\";\n    ToolbarWidgetTag[\"Undo\"] = \"undo\";\n    ToolbarWidgetTag[\"Redo\"] = \"redo\";\n})(ToolbarWidgetTag || (exports.ToolbarWidgetTag = ToolbarWidgetTag = {}));\n/**\n * The `abstract` base class for items that can be shown in a `js-draw` toolbar. See also {@link AbstractToolbar.addWidget}.\n *\n * See [the custom tool example](https://github.com/personalizedrefrigerator/js-draw/blob/main/docs/examples/example-custom-tools/example.ts)\n * for how to create a custom toolbar widget for a tool.\n *\n * For custom action buttons, {@link AbstractToolbar.addActionButton} may be sufficient for most use cases.\n */\nclass BaseWidget {\n    constructor(editor, id, localizationTable) {\n        _BaseWidget_instances.add(this);\n        this.editor = editor;\n        this.id = id;\n        this.dropdown = null;\n        _BaseWidget_hasDropdown.set(this, void 0);\n        // True iff this widget is disabled.\n        this.disabled = false;\n        // True iff this widget is currently disabled because the editor is read only\n        _BaseWidget_disabledDueToReadOnlyEditor.set(this, false);\n        _BaseWidget_tags.set(this, []);\n        // Maps subWidget IDs to subWidgets.\n        this.subWidgets = {};\n        this.toplevel = true;\n        _BaseWidget_removeEditorListeners.set(this, null);\n        this.localizationTable = localizationTable ?? editor.localization;\n        // Default layout manager\n        const defaultLayoutManager = new DropdownLayoutManager_1.default((text) => this.editor.announceForAccessibility(text), this.localizationTable);\n        defaultLayoutManager.connectToEditorNotifier(editor.notifier);\n        this.layoutManager = defaultLayoutManager;\n        this.icon = null;\n        this.container = document.createElement('div');\n        this.container.classList.add(`${constants_1.toolbarCSSPrefix}toolContainer`, `${constants_1.toolbarCSSPrefix}toolButtonContainer`, `${constants_1.toolbarCSSPrefix}internalWidgetId--${id.replace(/[^a-zA-Z0-9_]/g, '-')}`);\n        this.dropdownContent = document.createElement('div');\n        __classPrivateFieldSet(this, _BaseWidget_hasDropdown, false, \"f\");\n        this.button = document.createElement('div');\n        this.button.classList.add(`${constants_1.toolbarCSSPrefix}button`);\n        this.label = document.createElement('label');\n        this.button.setAttribute('role', 'button');\n        this.button.tabIndex = 0;\n        // Disable the context menu. This allows long-press gestures to trigger the button's\n        // tooltip instead.\n        this.button.oncontextmenu = (event) => {\n            event.preventDefault();\n        };\n        (0, addLongPressOrHoverCssClasses_1.default)(this.button);\n    }\n    /**\n     * Should return a constant true or false value. If true (the default),\n     * this widget must be automatically disabled when its editor is read-only.\n     */\n    shouldAutoDisableInReadOnlyEditor() {\n        return true;\n    }\n    getId() {\n        return this.id;\n    }\n    /**\n     * Note: Tags should be set *before* a tool widget is added to a toolbar.\n     *\n     *\n     * Associates tags with this widget that can be used by toolbar themes\n     * to customize the layout/appearance of this button. Prefer tags in\n     * the `ToolbarWidgetTag` enum, where possible.\n     *\n     * In addition to being readable from the {@link getTags} method, tags are\n     * added to a button's main container as CSS classes with the `toolwidget-tag--` prefix.\n     *\n     * For example, the `undo` tag would result in `toolwidget-tag--undo`\n     * being added to the button's container's class list.\n     *\n     */\n    setTags(tags) {\n        const toClassName = (tag) => {\n            return `toolwidget-tag--${tag}`;\n        };\n        // Remove CSS classes associated with old tags\n        for (const tag of __classPrivateFieldGet(this, _BaseWidget_tags, \"f\")) {\n            this.container.classList.remove(toClassName(tag));\n        }\n        __classPrivateFieldSet(this, _BaseWidget_tags, [...tags], \"f\");\n        // Add new CSS classes\n        for (const tag of __classPrivateFieldGet(this, _BaseWidget_tags, \"f\")) {\n            this.container.classList.add(toClassName(tag));\n        }\n    }\n    getTags() {\n        return [...__classPrivateFieldGet(this, _BaseWidget_tags, \"f\")];\n    }\n    /**\n     * Returns the ID of this widget in `container`. Adds a suffix to this' ID\n     * if an item in `container` already has this' ID.\n     *\n     * For example, if `this` has ID `foo` and if\n     * `container = { 'foo': somethingNotThis, 'foo-1': somethingElseNotThis }`, this method\n     * returns `foo-2` because elements with IDs `foo` and `foo-1` are already present in\n     * `container`.\n     *\n     * If `this` is already in `container`, returns the id given to `this` in the container.\n     */\n    getUniqueIdIn(container) {\n        let id = this.getId();\n        let idCounter = 0;\n        while (id in container && container[id] !== this) {\n            id = this.getId() + '-' + idCounter.toString();\n            idCounter++;\n        }\n        return id;\n    }\n    // Add content to the widget's associated dropdown menu.\n    // Returns true if such a menu should be created, false otherwise.\n    fillDropdown(dropdown, helpDisplay) {\n        if (Object.keys(this.subWidgets).length === 0) {\n            return false;\n        }\n        for (const widgetId in this.subWidgets) {\n            const widget = this.subWidgets[widgetId];\n            const widgetElement = widget.addTo(dropdown);\n            widget.setIsToplevel(false);\n            // Add help information\n            const helpText = widget.getHelpText();\n            if (helpText) {\n                helpDisplay?.registerTextHelpForElement(widgetElement, helpText);\n            }\n        }\n        return true;\n    }\n    /**\n     * Should return a 1-2 sentence description of the widget.\n     *\n     * At present, this is only used if this widget has an associated dropdown.\n     */\n    getHelpText() {\n        return undefined;\n    }\n    /** @deprecated Renamed to `setUpButtonEventListeners`. */\n    setupActionBtnClickListener(button) {\n        return this.setUpButtonEventListeners(button);\n    }\n    setUpButtonEventListeners(button) {\n        const clickTriggers = { Enter: true, ' ': true };\n        button.onkeydown = (evt) => {\n            let handled = false;\n            if (evt.key in clickTriggers) {\n                if (!this.disabled) {\n                    this.handleClick();\n                    handled = true;\n                }\n            }\n            // If we didn't do anything with the event, send it to the editor.\n            if (!handled) {\n                const editorEvent = (0, inputEvents_1.keyPressEventFromHTMLEvent)(evt);\n                handled = this.editor.toolController.dispatchInputEvent(editorEvent);\n            }\n            if (handled) {\n                evt.preventDefault();\n            }\n        };\n        button.onkeyup = (htmlEvent) => {\n            if (htmlEvent.key in clickTriggers) {\n                return;\n            }\n            const event = (0, inputEvents_1.keyUpEventFromHTMLEvent)(htmlEvent);\n            const handled = this.editor.toolController.dispatchInputEvent(event);\n            if (handled) {\n                htmlEvent.preventDefault();\n            }\n        };\n        button.onclick = () => {\n            if (!this.disabled) {\n                this.handleClick();\n            }\n        };\n        // Prevent double-click zoom on some devices.\n        button.ondblclick = (event) => {\n            event.preventDefault();\n        };\n    }\n    // Add a listener that is triggered when a key is pressed.\n    // Listeners will fire regardless of whether this widget is selected and require that\n    // {@link Editor.toolController} to have an enabled {@link ToolbarShortcutHandler} tool.\n    onKeyPress(_event) {\n        return false;\n    }\n    get hasDropdown() {\n        return __classPrivateFieldGet(this, _BaseWidget_hasDropdown, \"f\");\n    }\n    // Add a widget to this' dropdown. Must be called before this.addTo.\n    addSubWidget(widget) {\n        // Generate a unique ID for the widget.\n        const id = widget.getUniqueIdIn(this.subWidgets);\n        this.subWidgets[id] = widget;\n    }\n    setLayoutManager(manager) {\n        if (manager === this.layoutManager) {\n            return;\n        }\n        this.layoutManager = manager;\n        if (this.container.parentElement) {\n            // Trigger a re-creation of this' content\n            this.addTo(this.container.parentElement);\n        }\n    }\n    /**\n     * Adds this to `parent`.\n     * Returns the element that was just added to `parent`.\n     * @internal\n     */\n    addTo(parent) {\n        // Update title and icon\n        this.icon = null;\n        this.updateIcon();\n        this.label.innerText = this.getTitle();\n        const longLabelCSSClass = 'long-label';\n        if (this.label.innerText.length > 7) {\n            this.label.classList.add(longLabelCSSClass);\n        }\n        else {\n            this.label.classList.remove(longLabelCSSClass);\n        }\n        // Click functionality\n        this.setUpButtonEventListeners(this.button);\n        // Clear anything already in this.container.\n        this.container.replaceChildren();\n        this.button.replaceChildren(this.icon, this.label);\n        this.container.appendChild(this.button);\n        const helpDisplay = new HelpDisplay_1.default((content) => this.editor.createHTMLOverlay(content), this.editor);\n        const helpText = this.getHelpText();\n        if (helpText) {\n            helpDisplay.registerTextHelpForElement(this.dropdownContent, [this.getTitle(), helpText].join('\\n\\n'));\n        }\n        // Clear the dropdownContainer in case this element is being moved to another\n        // parent.\n        this.dropdownContent.replaceChildren();\n        __classPrivateFieldSet(this, _BaseWidget_hasDropdown, this.fillDropdown(this.dropdownContent, helpDisplay), \"f\");\n        if (__classPrivateFieldGet(this, _BaseWidget_hasDropdown, \"f\")) {\n            this.button.classList.add('has-dropdown');\n            // We're re-creating the dropdown.\n            this.dropdown?.destroy();\n            this.dropdownIcon = this.createDropdownIcon();\n            this.button.appendChild(this.dropdownIcon);\n            this.dropdown = this.layoutManager.createToolMenu({\n                target: this.button,\n                getTitle: () => this.getTitle(),\n                isToplevel: () => this.toplevel,\n            });\n            this.dropdown.visible.onUpdate((visible) => {\n                if (visible) {\n                    this.container.classList.add('dropdownVisible');\n                }\n                else {\n                    this.container.classList.remove('dropdownVisible');\n                }\n                // Auto-focus this component's button when the dropdown hides --\n                // this ensures that keyboard focus goes to a reasonable location when\n                // the user closes a menu.\n                if (!visible) {\n                    this.focus();\n                }\n            });\n            if (helpDisplay.hasHelpText()) {\n                this.dropdown.appendChild(helpDisplay.createToggleButton());\n            }\n            this.dropdown.appendChild(this.dropdownContent);\n        }\n        this.setDropdownVisible(false);\n        if (this.container.parentElement) {\n            this.container.remove();\n        }\n        __classPrivateFieldGet(this, _BaseWidget_instances, \"m\", _BaseWidget_addEditorListeners).call(this);\n        parent.appendChild(this.container);\n        return this.container;\n    }\n    /**\n     * Remove this. This allows the widget to be added to a toolbar again\n     * in the future using `addTo`.\n     */\n    remove() {\n        this.container.remove();\n        __classPrivateFieldGet(this, _BaseWidget_removeEditorListeners, \"f\")?.call(this);\n    }\n    focus() {\n        this.button.focus();\n    }\n    /**\n     * @internal\n     */\n    addCSSClassToContainer(className) {\n        this.container.classList.add(className);\n    }\n    removeCSSClassFromContainer(className) {\n        this.container.classList.remove(className);\n    }\n    updateIcon() {\n        let newIcon = this.createIcon();\n        if (!newIcon) {\n            newIcon = document.createElement('div');\n            this.container.classList.add('no-icon');\n        }\n        else {\n            this.container.classList.remove('no-icon');\n        }\n        this.icon?.replaceWith(newIcon);\n        this.icon = newIcon;\n        this.icon.classList.add(`${constants_1.toolbarCSSPrefix}icon`);\n    }\n    setDisabled(disabled) {\n        this.disabled = disabled;\n        __classPrivateFieldSet(this, _BaseWidget_disabledDueToReadOnlyEditor, false, \"f\");\n        if (this.disabled) {\n            this.button.classList.add('disabled');\n            this.button.setAttribute('aria-disabled', 'true');\n        }\n        else {\n            this.button.classList.remove('disabled');\n            this.button.removeAttribute('aria-disabled');\n        }\n    }\n    setSelected(selected) {\n        const currentlySelected = this.isSelected();\n        if (currentlySelected === selected) {\n            return;\n        }\n        // Ensure that accessibility tools check and read the value of\n        // aria-checked.\n        // TODO: Ensure that 'role' is set to 'switch' by default for selectable\n        //       buttons.\n        this.button.setAttribute('role', 'switch');\n        if (selected) {\n            this.container.classList.add('selected');\n            this.button.setAttribute('aria-checked', 'true');\n        }\n        else {\n            this.container.classList.remove('selected');\n            this.button.setAttribute('aria-checked', 'false');\n        }\n    }\n    setDropdownVisible(visible) {\n        if (visible) {\n            this.dropdown?.requestShow();\n        }\n        else {\n            this.dropdown?.requestHide();\n        }\n    }\n    /**\n     * Only used by some layout managers.\n     * In those layout managers, makes this dropdown visible.\n     */\n    activateDropdown() {\n        this.dropdown?.onActivated();\n    }\n    /**\n     * Returns `true` if this widget must always be in a toplevel menu and not\n     * in a scrolling/overflow menu.\n     *\n     * This method can be overidden to override the default of `true`.\n     */\n    mustBeInToplevelMenu() {\n        return false;\n    }\n    /**\n     * Returns true iff this widget can be in a nontoplevel menu.\n     *\n     * @deprecated Use `!mustBeInToplevelMenu()` instead.\n     */\n    canBeInOverflowMenu() {\n        return !this.mustBeInToplevelMenu();\n    }\n    getButtonWidth() {\n        return this.button.clientWidth;\n    }\n    isHidden() {\n        return this.container.style.display === 'none';\n    }\n    setHidden(hidden) {\n        this.container.style.display = hidden ? 'none' : '';\n    }\n    /** Set whether the widget is contained within another. @internal */\n    setIsToplevel(toplevel) {\n        this.toplevel = toplevel;\n    }\n    /** Returns true if the menu for this widget is open. */\n    isDropdownVisible() {\n        return this.dropdown?.visible?.get() ?? false;\n    }\n    isSelected() {\n        return this.container.classList.contains('selected');\n    }\n    createDropdownIcon() {\n        const icon = this.editor.icons.makeDropdownIcon();\n        icon.classList.add(`${constants_1.toolbarCSSPrefix}showHideDropdownIcon`);\n        return icon;\n    }\n    /**\n     * Serialize state associated with this widget.\n     * Override this method to allow saving/restoring from state on application load.\n     *\n     * Overriders should call `super` and include the output of `super.serializeState` in\n     * the output dictionary.\n     *\n     * Clients should not rely on the output from `saveState` being in any particular\n     * format.\n     */\n    serializeState() {\n        const subwidgetState = {};\n        // Save all subwidget state.\n        for (const subwidgetId in this.subWidgets) {\n            subwidgetState[subwidgetId] = this.subWidgets[subwidgetId].serializeState();\n        }\n        return {\n            subwidgetState,\n        };\n    }\n    /**\n     * Restore widget state from serialized data. See also `saveState`.\n     *\n     * Overriders must call `super`.\n     */\n    deserializeFrom(state) {\n        if (state.subwidgetState) {\n            (0, assertions_1.assertIsObject)(state.subwidgetState);\n            // Deserialize all subwidgets.\n            for (const subwidgetId in state.subwidgetState) {\n                if (subwidgetId in this.subWidgets) {\n                    const serializedSubwidgetState = state.subwidgetState[subwidgetId];\n                    if (serializedSubwidgetState) {\n                        this.subWidgets[subwidgetId].deserializeFrom(serializedSubwidgetState);\n                    }\n                }\n            }\n        }\n    }\n}\n_a = BaseWidget, _BaseWidget_hasDropdown = new WeakMap(), _BaseWidget_disabledDueToReadOnlyEditor = new WeakMap(), _BaseWidget_tags = new WeakMap(), _BaseWidget_removeEditorListeners = new WeakMap(), _BaseWidget_instances = new WeakSet(), _BaseWidget_addEditorListeners = function _BaseWidget_addEditorListeners() {\n    __classPrivateFieldGet(this, _BaseWidget_removeEditorListeners, \"f\")?.call(this);\n    const toolbarShortcutHandlers = this.editor.toolController.getMatchingTools(ToolbarShortcutHandler_1.default);\n    let removeKeyPressListener = null;\n    // If the onKeyPress function has been extended and the editor is configured to send keypress events to\n    // toolbar widgets,\n    if (toolbarShortcutHandlers.length > 0 && this.onKeyPress !== _a.prototype.onKeyPress) {\n        const keyPressListener = (event) => this.onKeyPress(event);\n        const handler = toolbarShortcutHandlers[0];\n        handler.registerListener(keyPressListener);\n        removeKeyPressListener = () => {\n            handler.removeListener(keyPressListener);\n        };\n    }\n    const readOnlyListener = this.editor.isReadOnlyReactiveValue().onUpdateAndNow((readOnly) => {\n        if (readOnly && this.shouldAutoDisableInReadOnlyEditor() && !this.disabled) {\n            this.setDisabled(true);\n            __classPrivateFieldSet(this, _BaseWidget_disabledDueToReadOnlyEditor, true, \"f\");\n            if (__classPrivateFieldGet(this, _BaseWidget_hasDropdown, \"f\")) {\n                this.dropdown?.requestHide();\n            }\n        }\n        else if (!readOnly && __classPrivateFieldGet(this, _BaseWidget_disabledDueToReadOnlyEditor, \"f\")) {\n            __classPrivateFieldSet(this, _BaseWidget_disabledDueToReadOnlyEditor, false, \"f\");\n            this.setDisabled(false);\n        }\n    });\n    __classPrivateFieldSet(this, _BaseWidget_removeEditorListeners, () => {\n        readOnlyListener.remove();\n        removeKeyPressListener?.();\n        __classPrivateFieldSet(this, _BaseWidget_removeEditorListeners, null, \"f\");\n    }, \"f\");\n};\nexports[\"default\"] = BaseWidget;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/toolbar/widgets/BaseWidget.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/toolbar/widgets/DocumentPropertiesWidget.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/toolbar/widgets/DocumentPropertiesWidget.js ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Erase_1 = __importDefault(__webpack_require__(/*! ../../commands/Erase */ \"./node_modules/js-draw/dist/cjs/commands/Erase.js\"));\nconst uniteCommands_1 = __importDefault(__webpack_require__(/*! ../../commands/uniteCommands */ \"./node_modules/js-draw/dist/cjs/commands/uniteCommands.js\"));\nconst BackgroundComponent_1 = __importStar(__webpack_require__(/*! ../../components/BackgroundComponent */ \"./node_modules/js-draw/dist/cjs/components/BackgroundComponent.js\"));\nconst EditorImage_1 = __webpack_require__(/*! ../../image/EditorImage */ \"./node_modules/js-draw/dist/cjs/image/EditorImage.js\");\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\nconst types_1 = __webpack_require__(/*! ../../types */ \"./node_modules/js-draw/dist/cjs/types.js\");\nconst constants_1 = __webpack_require__(/*! ../constants */ \"./node_modules/js-draw/dist/cjs/toolbar/constants.js\");\nconst makeColorInput_1 = __importDefault(__webpack_require__(/*! ./components/makeColorInput */ \"./node_modules/js-draw/dist/cjs/toolbar/widgets/components/makeColorInput.js\"));\nconst BaseWidget_1 = __importDefault(__webpack_require__(/*! ./BaseWidget */ \"./node_modules/js-draw/dist/cjs/toolbar/widgets/BaseWidget.js\"));\nclass DocumentPropertiesWidget extends BaseWidget_1.default {\n    constructor(editor, localizationTable) {\n        super(editor, 'document-properties-widget', localizationTable);\n        this.updateDropdownContent = () => { };\n        this.dropdownUpdateQueued = false;\n        // Make it possible to open the dropdown, even if this widget isn't selected.\n        this.container.classList.add('dropdownShowable');\n        this.editor.notifier.on(types_1.EditorEventType.UndoRedoStackUpdated, () => {\n            this.queueDropdownUpdate();\n        });\n        this.editor.image.notifier.on(EditorImage_1.EditorImageEventType.ExportViewportChanged, () => {\n            this.queueDropdownUpdate();\n        });\n    }\n    getTitle() {\n        return this.localizationTable.documentProperties;\n    }\n    createIcon() {\n        return this.editor.icons.makeConfigureDocumentIcon();\n    }\n    handleClick() {\n        this.setDropdownVisible(!this.isDropdownVisible());\n        this.queueDropdownUpdate();\n    }\n    queueDropdownUpdate() {\n        if (!this.dropdownUpdateQueued) {\n            requestAnimationFrame(() => this.updateDropdown());\n            this.dropdownUpdateQueued = true;\n        }\n    }\n    updateDropdown() {\n        this.dropdownUpdateQueued = false;\n        if (this.isDropdownVisible()) {\n            this.updateDropdownContent();\n        }\n    }\n    setBackgroundColor(color) {\n        this.editor.dispatch(this.editor.setBackgroundColor(color));\n    }\n    getBackgroundColor() {\n        return this.editor.estimateBackgroundColor();\n    }\n    removeBackgroundComponents() {\n        const previousBackgrounds = [];\n        for (const component of this.editor.image.getBackgroundComponents()) {\n            if (component instanceof BackgroundComponent_1.default) {\n                previousBackgrounds.push(component);\n            }\n        }\n        return new Erase_1.default(previousBackgrounds);\n    }\n    /** Replace existing background components with a background of the given type. */\n    setBackgroundType(backgroundType) {\n        const prevBackgroundColor = this.editor.estimateBackgroundColor();\n        const newBackground = new BackgroundComponent_1.default(backgroundType, prevBackgroundColor);\n        const addBackgroundCommand = this.editor.image.addElement(newBackground);\n        return (0, uniteCommands_1.default)([this.removeBackgroundComponents(), addBackgroundCommand]);\n    }\n    /** Returns the type of the topmost background component */\n    getBackgroundType() {\n        const backgroundComponents = this.editor.image.getBackgroundComponents();\n        for (let i = backgroundComponents.length - 1; i >= 0; i--) {\n            const component = backgroundComponents[i];\n            if (component instanceof BackgroundComponent_1.default) {\n                return component.getBackgroundType();\n            }\n        }\n        return BackgroundComponent_1.BackgroundType.None;\n    }\n    updateImportExportRectSize(size) {\n        const filterDimension = (dim) => {\n            if (dim !== undefined && (!isFinite(dim) || dim <= 0)) {\n                dim = 100;\n            }\n            return dim;\n        };\n        const width = filterDimension(size.width);\n        const height = filterDimension(size.height);\n        const currentRect = this.editor.getImportExportRect();\n        const newRect = new math_1.Rect2(currentRect.x, currentRect.y, width ?? currentRect.w, height ?? currentRect.h);\n        this.editor.dispatch(this.editor.image.setImportExportRect(newRect));\n        this.editor.queueRerender();\n    }\n    getHelpText() {\n        return this.localizationTable.pageDropdown__baseHelpText;\n    }\n    fillDropdown(dropdown, helpDisplay) {\n        const container = document.createElement('div');\n        container.classList.add(`${constants_1.toolbarCSSPrefix}spacedList`, `${constants_1.toolbarCSSPrefix}nonbutton-controls-main-list`, `${constants_1.toolbarCSSPrefix}document-properties-widget`);\n        // Background color input\n        const makeBackgroundColorInput = () => {\n            const backgroundColorRow = document.createElement('div');\n            const backgroundColorLabel = document.createElement('label');\n            backgroundColorLabel.innerText = this.localizationTable.backgroundColor;\n            const { input: colorInput, container: backgroundColorInputContainer, setValue: setBgColorInputValue, registerWithHelpTextDisplay: registerHelpForInputs, } = (0, makeColorInput_1.default)(this.editor, (color) => {\n                if (!color.eq(this.getBackgroundColor())) {\n                    this.setBackgroundColor(color);\n                }\n            });\n            colorInput.id = `${constants_1.toolbarCSSPrefix}docPropertiesColorInput-${DocumentPropertiesWidget.idCounter++}`;\n            backgroundColorLabel.htmlFor = colorInput.id;\n            backgroundColorRow.replaceChildren(backgroundColorLabel, backgroundColorInputContainer);\n            const registerWithHelp = (helpDisplay) => {\n                if (!helpDisplay) {\n                    return;\n                }\n                helpDisplay?.registerTextHelpForElement(backgroundColorRow, this.localizationTable.pageDropdown__backgroundColorHelpText);\n                registerHelpForInputs(helpDisplay);\n            };\n            return { setBgColorInputValue, backgroundColorRow, registerWithHelp };\n        };\n        const { backgroundColorRow, setBgColorInputValue, registerWithHelp: registerBackgroundRowWithHelp, } = makeBackgroundColorInput();\n        const makeCheckboxRow = (labelText, onChange) => {\n            const rowContainer = document.createElement('div');\n            const labelElement = document.createElement('label');\n            const checkboxElement = document.createElement('input');\n            checkboxElement.id = `${constants_1.toolbarCSSPrefix}docPropertiesCheckbox-${DocumentPropertiesWidget.idCounter++}`;\n            labelElement.htmlFor = checkboxElement.id;\n            checkboxElement.type = 'checkbox';\n            labelElement.innerText = labelText;\n            checkboxElement.oninput = () => {\n                onChange(checkboxElement.checked);\n            };\n            rowContainer.replaceChildren(labelElement, checkboxElement);\n            return { container: rowContainer, checkbox: checkboxElement };\n        };\n        // Background style selector\n        const { container: useGridRow, checkbox: useGridCheckbox } = makeCheckboxRow(this.localizationTable.useGridOption, (checked) => {\n            const prevBackgroundType = this.getBackgroundType();\n            const wasGrid = prevBackgroundType === BackgroundComponent_1.BackgroundType.Grid;\n            if (wasGrid === checked) {\n                // Already the requested background type.\n                return;\n            }\n            let newBackgroundType = BackgroundComponent_1.BackgroundType.SolidColor;\n            if (checked) {\n                newBackgroundType = BackgroundComponent_1.BackgroundType.Grid;\n            }\n            this.editor.dispatch(this.setBackgroundType(newBackgroundType));\n        });\n        // Adds a width/height input\n        const addDimensionRow = (labelContent, onChange) => {\n            const row = document.createElement('div');\n            const label = document.createElement('label');\n            const input = document.createElement('input');\n            label.innerText = labelContent;\n            input.type = 'number';\n            input.min = '0';\n            input.id = `${constants_1.toolbarCSSPrefix}docPropertiesDimensionRow-${DocumentPropertiesWidget.idCounter++}`;\n            label.htmlFor = input.id;\n            input.style.flexGrow = '2';\n            input.style.width = '25px';\n            input.oninput = () => {\n                onChange(parseFloat(input.value));\n            };\n            row.classList.add('js-draw-size-input-row');\n            row.replaceChildren(label, input);\n            return {\n                setValue: (value) => {\n                    // Slightly improve the case where the user tries to change the\n                    // first digit of a dimension like 600.\n                    //\n                    // As changing the value also gives the image zero size (which is unsupported,\n                    // .setValue is called immediately). We work around this by trying to select\n                    // the added/changed digits.\n                    //\n                    // See https://github.com/personalizedrefrigerator/js-draw/issues/58.\n                    if (document.activeElement === input && input.value.match(/^0*$/)) {\n                        // We need to switch to type=\"text\" and back to type=\"number\" because\n                        // number inputs don't support selection.\n                        //\n                        // See https://stackoverflow.com/q/22381837\n                        const originalValue = input.value;\n                        input.type = 'text';\n                        input.value = value.toString();\n                        // Select the added digits\n                        const lengthToSelect = Math.max(1, input.value.length - originalValue.length);\n                        input.setSelectionRange(0, lengthToSelect);\n                        input.type = 'number';\n                    }\n                    else {\n                        input.value = value.toString();\n                    }\n                },\n                setIsAutomaticSize: (automatic) => {\n                    input.disabled = automatic;\n                    const automaticSizeClass = 'size-input-row--automatic-size';\n                    if (automatic) {\n                        row.classList.add(automaticSizeClass);\n                    }\n                    else {\n                        row.classList.remove(automaticSizeClass);\n                    }\n                },\n                element: row,\n            };\n        };\n        const imageWidthRow = addDimensionRow(this.localizationTable.imageWidthOption, (value) => {\n            this.updateImportExportRectSize({ width: value });\n        });\n        const imageHeightRow = addDimensionRow(this.localizationTable.imageHeightOption, (value) => {\n            this.updateImportExportRectSize({ height: value });\n        });\n        // The autoresize checkbox\n        const { container: auroresizeRow, checkbox: autoresizeCheckbox } = makeCheckboxRow(this.localizationTable.enableAutoresizeOption, (checked) => {\n            const image = this.editor.image;\n            this.editor.dispatch(image.setAutoresizeEnabled(checked));\n        });\n        // The \"About...\" button\n        const aboutButton = document.createElement('button');\n        aboutButton.classList.add('about-button');\n        aboutButton.innerText = this.localizationTable.about;\n        aboutButton.onclick = () => {\n            this.editor.showAboutDialog();\n        };\n        // Add help text\n        registerBackgroundRowWithHelp(helpDisplay);\n        helpDisplay?.registerTextHelpForElement(useGridRow, this.localizationTable.pageDropdown__gridCheckboxHelpText);\n        helpDisplay?.registerTextHelpForElement(auroresizeRow, this.localizationTable.pageDropdown__autoresizeCheckboxHelpText);\n        helpDisplay?.registerTextHelpForElement(aboutButton, this.localizationTable.pageDropdown__aboutButtonHelpText);\n        this.updateDropdownContent = () => {\n            setBgColorInputValue(this.getBackgroundColor());\n            const autoresize = this.editor.image.getAutoresizeEnabled();\n            const importExportRect = this.editor.getImportExportRect();\n            imageWidthRow.setValue(importExportRect.width);\n            imageHeightRow.setValue(importExportRect.height);\n            autoresizeCheckbox.checked = autoresize;\n            imageWidthRow.setIsAutomaticSize(autoresize);\n            imageHeightRow.setIsAutomaticSize(autoresize);\n            useGridCheckbox.checked = this.getBackgroundType() === BackgroundComponent_1.BackgroundType.Grid;\n        };\n        this.updateDropdownContent();\n        container.replaceChildren(backgroundColorRow, useGridRow, imageWidthRow.element, imageHeightRow.element, auroresizeRow, aboutButton);\n        dropdown.replaceChildren(container);\n        return true;\n    }\n}\nDocumentPropertiesWidget.idCounter = 0;\nexports[\"default\"] = DocumentPropertiesWidget;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/toolbar/widgets/DocumentPropertiesWidget.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/toolbar/widgets/EraserToolWidget.js":
/*!***************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/toolbar/widgets/EraserToolWidget.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Eraser_1 = __webpack_require__(/*! ../../tools/Eraser */ \"./node_modules/js-draw/dist/cjs/tools/Eraser.js\");\nconst types_1 = __webpack_require__(/*! ../../types */ \"./node_modules/js-draw/dist/cjs/types.js\");\nconst constants_1 = __webpack_require__(/*! ../constants */ \"./node_modules/js-draw/dist/cjs/toolbar/constants.js\");\nconst BaseToolWidget_1 = __importDefault(__webpack_require__(/*! ./BaseToolWidget */ \"./node_modules/js-draw/dist/cjs/toolbar/widgets/BaseToolWidget.js\"));\nconst makeThicknessSlider_1 = __importDefault(__webpack_require__(/*! ./components/makeThicknessSlider */ \"./node_modules/js-draw/dist/cjs/toolbar/widgets/components/makeThicknessSlider.js\"));\nclass EraserToolWidget extends BaseToolWidget_1.default {\n    constructor(editor, tool, localizationTable) {\n        super(editor, tool, 'eraser-tool-widget', localizationTable);\n        this.tool = tool;\n        this.updateInputs = () => { };\n        this.editor.notifier.on(types_1.EditorEventType.ToolUpdated, (toolEvt) => {\n            if (toolEvt.kind === types_1.EditorEventType.ToolUpdated && toolEvt.tool === this.tool) {\n                this.updateInputs();\n                this.updateIcon();\n            }\n        });\n    }\n    getHelpText() {\n        return this.localizationTable.eraserDropdown__baseHelpText;\n    }\n    getTitle() {\n        return this.localizationTable.eraser;\n    }\n    makeIconForType(mode) {\n        return this.editor.icons.makeEraserIcon(this.tool.getThickness(), mode);\n    }\n    createIcon() {\n        return this.makeIconForType(this.tool.getModeValue().get());\n    }\n    makeEraserTypeSelector(helpDisplay) {\n        const container = document.createElement('div');\n        const labelElement = document.createElement('label');\n        const checkboxElement = document.createElement('input');\n        checkboxElement.id = `${constants_1.toolbarCSSPrefix}eraserToolWidget-${EraserToolWidget.idCounter++}`;\n        labelElement.htmlFor = checkboxElement.id;\n        labelElement.innerText = this.localizationTable.fullStrokeEraser;\n        checkboxElement.type = 'checkbox';\n        checkboxElement.oninput = () => {\n            this.tool\n                .getModeValue()\n                .set(checkboxElement.checked ? Eraser_1.EraserMode.FullStroke : Eraser_1.EraserMode.PartialStroke);\n        };\n        const updateValue = () => {\n            checkboxElement.checked = this.tool.getModeValue().get() === Eraser_1.EraserMode.FullStroke;\n        };\n        container.replaceChildren(labelElement, checkboxElement);\n        helpDisplay?.registerTextHelpForElement(container, this.localizationTable.eraserDropdown__fullStrokeEraserHelpText);\n        return {\n            addTo: (parent) => {\n                parent.appendChild(container);\n            },\n            updateValue,\n        };\n    }\n    fillDropdown(dropdown, helpDisplay) {\n        const container = document.createElement('div');\n        container.classList.add(`${constants_1.toolbarCSSPrefix}spacedList`, `${constants_1.toolbarCSSPrefix}nonbutton-controls-main-list`);\n        const thicknessSlider = (0, makeThicknessSlider_1.default)(this.editor, (thickness) => {\n            this.tool.setThickness(thickness);\n        });\n        thicknessSlider.setBounds(10, 55);\n        helpDisplay?.registerTextHelpForElement(thicknessSlider.container, this.localizationTable.eraserDropdown__thicknessHelpText);\n        const modeSelector = this.makeEraserTypeSelector(helpDisplay);\n        this.updateInputs = () => {\n            thicknessSlider.setValue(this.tool.getThickness());\n            modeSelector.updateValue();\n        };\n        this.updateInputs();\n        container.replaceChildren(thicknessSlider.container);\n        modeSelector.addTo(container);\n        dropdown.replaceChildren(container);\n        return true;\n    }\n    serializeState() {\n        return {\n            ...super.serializeState(),\n            thickness: this.tool.getThickness(),\n            mode: this.tool.getModeValue().get(),\n        };\n    }\n    deserializeFrom(state) {\n        super.deserializeFrom(state);\n        if (state.thickness) {\n            const parsedThickness = parseFloat(state.thickness);\n            if (typeof parsedThickness !== 'number' || !isFinite(parsedThickness)) {\n                throw new Error(`Deserializing property ${parsedThickness} is not a number or is not finite.`);\n            }\n            this.tool.setThickness(parsedThickness);\n        }\n        if (state.mode) {\n            const mode = state.mode;\n            if (Object.values(Eraser_1.EraserMode).includes(mode)) {\n                this.tool.getModeValue().set(mode);\n            }\n        }\n    }\n}\nEraserToolWidget.idCounter = 0;\nexports[\"default\"] = EraserToolWidget;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/toolbar/widgets/EraserToolWidget.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/toolbar/widgets/ExitActionWidget.js":
/*!***************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/toolbar/widgets/ExitActionWidget.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst ActionButtonWidget_1 = __importDefault(__webpack_require__(/*! ./ActionButtonWidget */ \"./node_modules/js-draw/dist/cjs/toolbar/widgets/ActionButtonWidget.js\"));\nconst BaseWidget_1 = __webpack_require__(/*! ./BaseWidget */ \"./node_modules/js-draw/dist/cjs/toolbar/widgets/BaseWidget.js\");\nconst keybindings_1 = __webpack_require__(/*! ./keybindings */ \"./node_modules/js-draw/dist/cjs/toolbar/widgets/keybindings.js\");\nclass ExitActionWidget extends ActionButtonWidget_1.default {\n    constructor(editor, localization, saveCallback, labelOverride = {}) {\n        super(editor, 'exit-button', \n        // Creates an icon\n        () => {\n            return labelOverride.icon ?? editor.icons.makeCloseIcon();\n        }, labelOverride.label ?? localization.exit, saveCallback);\n        this.setTags([BaseWidget_1.ToolbarWidgetTag.Exit]);\n    }\n    shouldAutoDisableInReadOnlyEditor() {\n        return false;\n    }\n    onKeyPress(event) {\n        if (this.editor.shortcuts.matchesShortcut(keybindings_1.exitKeyboardShortcut, event)) {\n            this.clickAction();\n            return true;\n        }\n        return super.onKeyPress(event);\n    }\n    mustBeInToplevelMenu() {\n        return true;\n    }\n}\nexports[\"default\"] = ExitActionWidget;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/toolbar/widgets/ExitActionWidget.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/toolbar/widgets/HandToolWidget.js":
/*!*************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/toolbar/widgets/HandToolWidget.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\nconst PanZoom_1 = __importStar(__webpack_require__(/*! ../../tools/PanZoom */ \"./node_modules/js-draw/dist/cjs/tools/PanZoom.js\"));\nconst types_1 = __webpack_require__(/*! ../../types */ \"./node_modules/js-draw/dist/cjs/types.js\");\nconst Viewport_1 = __importDefault(__webpack_require__(/*! ../../Viewport */ \"./node_modules/js-draw/dist/cjs/Viewport.js\"));\nconst constants_1 = __webpack_require__(/*! ../constants */ \"./node_modules/js-draw/dist/cjs/toolbar/constants.js\");\nconst BaseToolWidget_1 = __importDefault(__webpack_require__(/*! ./BaseToolWidget */ \"./node_modules/js-draw/dist/cjs/toolbar/widgets/BaseToolWidget.js\"));\nconst BaseWidget_1 = __importDefault(__webpack_require__(/*! ./BaseWidget */ \"./node_modules/js-draw/dist/cjs/toolbar/widgets/BaseWidget.js\"));\nconst makeSeparator_1 = __importDefault(__webpack_require__(/*! ./components/makeSeparator */ \"./node_modules/js-draw/dist/cjs/toolbar/widgets/components/makeSeparator.js\"));\nconst makeZoomControl = (localizationTable, editor, helpDisplay) => {\n    const zoomLevelRow = document.createElement('div');\n    const increaseButton = document.createElement('button');\n    const decreaseButton = document.createElement('button');\n    const resetViewButton = document.createElement('button');\n    const zoomLevelDisplay = document.createElement('span');\n    increaseButton.innerText = '+';\n    decreaseButton.innerText = '-';\n    resetViewButton.innerText = localizationTable.resetView;\n    zoomLevelRow.replaceChildren(zoomLevelDisplay, increaseButton, decreaseButton, resetViewButton);\n    zoomLevelRow.classList.add(`${constants_1.toolbarCSSPrefix}zoomLevelEditor`);\n    zoomLevelDisplay.classList.add('zoomDisplay');\n    let lastZoom;\n    const updateZoomDisplay = () => {\n        let zoomLevel = editor.viewport.getScaleFactor() * 100;\n        if (zoomLevel > 0.1) {\n            zoomLevel = Math.round(zoomLevel * 10) / 10;\n        }\n        else {\n            zoomLevel = Math.round(zoomLevel * 1000) / 1000;\n        }\n        if (zoomLevel !== lastZoom) {\n            zoomLevelDisplay.textContent = localizationTable.zoomLevel(zoomLevel);\n            lastZoom = zoomLevel;\n        }\n    };\n    updateZoomDisplay();\n    editor.notifier.on(types_1.EditorEventType.ViewportChanged, (event) => {\n        if (event.kind === types_1.EditorEventType.ViewportChanged) {\n            updateZoomDisplay();\n            // Can't reset if already reset.\n            resetViewButton.disabled = event.newTransform.eq(math_1.Mat33.identity);\n        }\n    });\n    const zoomBy = (factor) => {\n        const screenCenter = editor.viewport.visibleRect.center;\n        const transformUpdate = math_1.Mat33.scaling2D(factor, screenCenter);\n        editor.dispatch(Viewport_1.default.transformBy(transformUpdate), false);\n    };\n    increaseButton.onclick = () => {\n        zoomBy(5.0 / 4);\n    };\n    decreaseButton.onclick = () => {\n        zoomBy(4.0 / 5);\n    };\n    resetViewButton.onclick = () => {\n        const addToHistory = false;\n        editor.dispatch(Viewport_1.default.transformBy(editor.viewport.canvasToScreenTransform.inverse()), addToHistory);\n    };\n    helpDisplay?.registerTextHelpForElement(increaseButton, localizationTable.handDropdown__zoomInHelpText);\n    helpDisplay?.registerTextHelpForElement(decreaseButton, localizationTable.handDropdown__zoomOutHelpText);\n    helpDisplay?.registerTextHelpForElement(resetViewButton, localizationTable.handDropdown__resetViewHelpText);\n    helpDisplay?.registerTextHelpForElement(zoomLevelDisplay, localizationTable.handDropdown__zoomDisplayHelpText);\n    return zoomLevelRow;\n};\nclass HandModeWidget extends BaseWidget_1.default {\n    constructor(editor, tool, flag, makeIcon, title, helpText, localizationTable) {\n        super(editor, `pan-mode-${flag}`, localizationTable);\n        this.tool = tool;\n        this.flag = flag;\n        this.makeIcon = makeIcon;\n        this.title = title;\n        this.helpText = helpText;\n        editor.notifier.on(types_1.EditorEventType.ToolUpdated, (toolEvt) => {\n            if (toolEvt.kind === types_1.EditorEventType.ToolUpdated && toolEvt.tool === tool) {\n                const allEnabled = !!(tool.getMode() & PanZoom_1.PanZoomMode.SinglePointerGestures);\n                this.setSelected(!!(tool.getMode() & flag) || allEnabled);\n                // Unless this widget toggles all single pointer gestures, toggling while\n                // single pointer gestures are enabled should have no effect\n                this.setDisabled(allEnabled && flag !== PanZoom_1.PanZoomMode.SinglePointerGestures);\n            }\n        });\n        this.setSelected(false);\n    }\n    shouldAutoDisableInReadOnlyEditor() {\n        return false;\n    }\n    setModeFlag(enabled) {\n        this.tool.setModeEnabled(this.flag, enabled);\n    }\n    handleClick() {\n        this.setModeFlag(!this.isSelected());\n    }\n    getTitle() {\n        return this.title;\n    }\n    createIcon() {\n        return this.makeIcon();\n    }\n    fillDropdown(_dropdown) {\n        return false;\n    }\n    getHelpText() {\n        return this.helpText;\n    }\n}\n/** This toolbar widget allows controlling the editor's {@link PanZoom} tool(s). */\nclass HandToolWidget extends BaseToolWidget_1.default {\n    constructor(editor, \n    // Can either be the primary pan/zoom tool (in the primary tools list) or\n    // the override pan/zoom tool.\n    // If the override pan/zoom tool, the primary will be gotten from the editor's\n    // tool controller.\n    // If the primary, the override will be gotten from the editor's tool controller.\n    tool, localizationTable) {\n        const isGivenToolPrimary = editor.toolController.getPrimaryTools().includes(tool);\n        const primaryTool = (isGivenToolPrimary ? tool : HandToolWidget.getPrimaryHandTool(editor.toolController)) ??\n            tool;\n        super(editor, primaryTool, 'hand-tool-widget', localizationTable);\n        this.overridePanZoomTool =\n            (isGivenToolPrimary ? HandToolWidget.getOverrideHandTool(editor.toolController) : tool) ??\n                tool;\n        // Only allow toggling a hand tool if we're using the primary hand tool and not the override\n        // hand tool for this button.\n        this.allowTogglingBaseTool = primaryTool !== null;\n        // Allow showing/hiding the dropdown, even if `overridePanZoomTool` isn't enabled.\n        if (!this.allowTogglingBaseTool) {\n            this.container.classList.add('dropdownShowable');\n        }\n        // Controls for the overriding hand tool.\n        const touchPanningWidget = new HandModeWidget(editor, this.overridePanZoomTool, PanZoom_1.PanZoomMode.OneFingerTouchGestures, () => this.editor.icons.makeTouchPanningIcon(), localizationTable.touchPanning, localizationTable.handDropdown__touchPanningHelpText, localizationTable);\n        const rotationLockWidget = new HandModeWidget(editor, this.overridePanZoomTool, PanZoom_1.PanZoomMode.RotationLocked, () => this.editor.icons.makeRotationLockIcon(), localizationTable.lockRotation, localizationTable.handDropdown__lockRotationHelpText, localizationTable);\n        this.addSubWidget(touchPanningWidget);\n        this.addSubWidget(rotationLockWidget);\n    }\n    static getPrimaryHandTool(toolController) {\n        const primaryPanZoomToolList = toolController\n            .getPrimaryTools()\n            .filter((tool) => tool instanceof PanZoom_1.default);\n        const primaryPanZoomTool = primaryPanZoomToolList[0];\n        return primaryPanZoomTool;\n    }\n    static getOverrideHandTool(toolController) {\n        const panZoomToolList = toolController.getMatchingTools(PanZoom_1.default);\n        const panZoomTool = panZoomToolList[0];\n        return panZoomTool;\n    }\n    shouldAutoDisableInReadOnlyEditor() {\n        return false;\n    }\n    getTitle() {\n        return this.localizationTable.handTool;\n    }\n    createIcon() {\n        return this.editor.icons.makeHandToolIcon();\n    }\n    handleClick() {\n        if (this.allowTogglingBaseTool) {\n            super.handleClick();\n        }\n        else {\n            this.setDropdownVisible(!this.isDropdownVisible());\n        }\n    }\n    getHelpText() {\n        return this.localizationTable.handDropdown__baseHelpText;\n    }\n    fillDropdown(dropdown, helpDisplay) {\n        super.fillDropdown(dropdown, helpDisplay);\n        // The container for all actions that come after the toolbar buttons.\n        const nonbuttonActionContainer = document.createElement('div');\n        nonbuttonActionContainer.classList.add(`${constants_1.toolbarCSSPrefix}nonbutton-controls-main-list`);\n        (0, makeSeparator_1.default)().addTo(nonbuttonActionContainer);\n        const zoomControl = makeZoomControl(this.localizationTable, this.editor, helpDisplay);\n        nonbuttonActionContainer.appendChild(zoomControl);\n        dropdown.appendChild(nonbuttonActionContainer);\n        return true;\n    }\n    setSelected(selected) {\n        if (this.allowTogglingBaseTool) {\n            super.setSelected(selected);\n        }\n    }\n    serializeState() {\n        const toolMode = this.overridePanZoomTool.getMode();\n        return {\n            ...super.serializeState(),\n            touchPanning: toolMode & PanZoom_1.PanZoomMode.OneFingerTouchGestures,\n            rotationLocked: toolMode & PanZoom_1.PanZoomMode.RotationLocked,\n        };\n    }\n    deserializeFrom(state) {\n        if (state.touchPanning !== undefined) {\n            this.overridePanZoomTool.setModeEnabled(PanZoom_1.PanZoomMode.OneFingerTouchGestures, !!state.touchPanning);\n        }\n        if (state.rotationLocked !== undefined) {\n            this.overridePanZoomTool.setModeEnabled(PanZoom_1.PanZoomMode.RotationLocked, !!state.rotationLocked);\n        }\n        super.deserializeFrom(state);\n    }\n}\nexports[\"default\"] = HandToolWidget;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/toolbar/widgets/HandToolWidget.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/toolbar/widgets/InsertImageWidget/ImageWrapper.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/toolbar/widgets/InsertImageWidget/ImageWrapper.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ImageWrapper = void 0;\n/** Handles filtering and other operations on an image. */\nclass ImageWrapper {\n    constructor(imageBase64Url, preview, onUrlUpdate) {\n        this.imageBase64Url = imageBase64Url;\n        this.preview = preview;\n        this.onUrlUpdate = onUrlUpdate;\n        this.originalSrc = imageBase64Url;\n        preview.src = imageBase64Url;\n    }\n    updateImageData(base64DataUrl) {\n        this.preview.src = base64DataUrl;\n        this.imageBase64Url = base64DataUrl;\n        this.onUrlUpdate();\n    }\n    decreaseSize(resizeFactor = 3 / 4) {\n        const canvas = document.createElement('canvas');\n        canvas.width = this.preview.naturalWidth * resizeFactor;\n        canvas.height = this.preview.naturalHeight * resizeFactor;\n        const ctx = canvas.getContext('2d');\n        ctx?.drawImage(this.preview, 0, 0, canvas.width, canvas.height);\n        // JPEG can be much smaller than PNG for the same image size. Prefer it if\n        // the image is already a JPEG.\n        const format = this.originalSrc?.startsWith('data:image/jpeg;') ? 'image/jpeg' : 'image/png';\n        this.updateImageData(canvas.toDataURL(format));\n    }\n    reset() {\n        this.updateImageData(this.originalSrc);\n    }\n    isChanged() {\n        return this.imageBase64Url !== this.originalSrc;\n    }\n    // Returns true if the current image is large enough to display a \"decrease size\"\n    // option.\n    isLarge() {\n        const largeImageThreshold = 0.12 * 1024 * 1024; // 0.12 MiB\n        return this.getBase64Url().length > largeImageThreshold;\n    }\n    getBase64Url() {\n        return this.imageBase64Url;\n    }\n    getAltText() {\n        return this.altText;\n    }\n    setAltText(text) {\n        this.altText = text;\n        this.preview.alt = text;\n    }\n    static fromSrcAndPreview(initialBase64Src, preview, onUrlUpdate) {\n        return new ImageWrapper(initialBase64Src, preview, onUrlUpdate);\n    }\n    static fromRenderable(renderable, onUrlUpdate) {\n        const preview = new Image();\n        preview.src = renderable.base64Url;\n        const result = new ImageWrapper(renderable.base64Url, preview, onUrlUpdate);\n        const altText = renderable.label ?? renderable.image.getAttribute('alt');\n        if (altText) {\n            result.setAltText(altText);\n        }\n        return { wrapper: result, preview };\n    }\n}\nexports.ImageWrapper = ImageWrapper;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/toolbar/widgets/InsertImageWidget/ImageWrapper.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/toolbar/widgets/InsertImageWidget/InsertImageWidget.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/toolbar/widgets/InsertImageWidget/InsertImageWidget.js ***!
  \**********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst ImageComponent_1 = __importDefault(__webpack_require__(/*! ../../../components/ImageComponent */ \"./node_modules/js-draw/dist/cjs/components/ImageComponent.js\"));\nconst Erase_1 = __importDefault(__webpack_require__(/*! ../../../commands/Erase */ \"./node_modules/js-draw/dist/cjs/commands/Erase.js\"));\nconst EditorImage_1 = __importDefault(__webpack_require__(/*! ../../../image/EditorImage */ \"./node_modules/js-draw/dist/cjs/image/EditorImage.js\"));\nconst uniteCommands_1 = __importDefault(__webpack_require__(/*! ../../../commands/uniteCommands */ \"./node_modules/js-draw/dist/cjs/commands/uniteCommands.js\"));\nconst SelectionTool_1 = __importDefault(__webpack_require__(/*! ../../../tools/SelectionTool/SelectionTool */ \"./node_modules/js-draw/dist/cjs/tools/SelectionTool/SelectionTool.js\"));\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\nconst BaseWidget_1 = __importDefault(__webpack_require__(/*! ../BaseWidget */ \"./node_modules/js-draw/dist/cjs/toolbar/widgets/BaseWidget.js\"));\nconst types_1 = __webpack_require__(/*! ../../../types */ \"./node_modules/js-draw/dist/cjs/types.js\");\nconst constants_1 = __webpack_require__(/*! ../../constants */ \"./node_modules/js-draw/dist/cjs/toolbar/constants.js\");\nconst makeFileInput_1 = __importDefault(__webpack_require__(/*! ../components/makeFileInput */ \"./node_modules/js-draw/dist/cjs/toolbar/widgets/components/makeFileInput.js\"));\nconst ReactiveValue_1 = __webpack_require__(/*! ../../../util/ReactiveValue */ \"./node_modules/js-draw/dist/cjs/util/ReactiveValue.js\");\nconst bytesToSizeString_1 = __importDefault(__webpack_require__(/*! ../../../util/bytesToSizeString */ \"./node_modules/js-draw/dist/cjs/util/bytesToSizeString.js\"));\nconst ImageWrapper_1 = __webpack_require__(/*! ./ImageWrapper */ \"./node_modules/js-draw/dist/cjs/toolbar/widgets/InsertImageWidget/ImageWrapper.js\");\nconst makeSnappedList_1 = __importDefault(__webpack_require__(/*! ../components/makeSnappedList */ \"./node_modules/js-draw/dist/cjs/toolbar/widgets/components/makeSnappedList.js\"));\nconst fileToImages_1 = __importDefault(__webpack_require__(/*! ./fileToImages */ \"./node_modules/js-draw/dist/cjs/toolbar/widgets/InsertImageWidget/fileToImages.js\"));\n/**\n * Provides a widget that allows inserting or modifying raster images.\n *\n * It's possible to customize the file picker used by this widget through {@link EditorSettings.image}.\n *\n * @example\n * ```ts,runnable\n * import { Editor, makeEdgeToolbar, InsertImageWidget } from 'js-draw';\n *\n * const editor = new Editor(document.body);\n * const toolbar = makeEdgeToolbar(editor);\n *\n * toolbar.addWidget(new InsertImageWidget(editor));\n * ```\n */\nclass InsertImageWidget extends BaseWidget_1.default {\n    constructor(editor, localization) {\n        localization ??= editor.localization;\n        super(editor, 'insert-image-widget', localization);\n        // Make the dropdown showable\n        this.container.classList.add('dropdownShowable');\n        editor.notifier.on(types_1.EditorEventType.SelectionUpdated, (event) => {\n            if (event.kind === types_1.EditorEventType.SelectionUpdated && this.isDropdownVisible()) {\n                this.updateInputs();\n            }\n        });\n        this.images = ReactiveValue_1.MutableReactiveValue.fromInitialValue([]);\n        this.images.onUpdateAndNow(() => {\n            this.onImageDataUpdate();\n        });\n    }\n    getTitle() {\n        return this.localizationTable.image;\n    }\n    createIcon() {\n        return this.editor.icons.makeInsertImageIcon();\n    }\n    setDropdownVisible(visible) {\n        super.setDropdownVisible(visible);\n        // Update the dropdown just before showing.\n        if (this.isDropdownVisible()) {\n            this.updateInputs();\n        }\n        else {\n            // Allow any previously-selected files to be freed.\n            this.selectedFiles?.set([]);\n        }\n    }\n    handleClick() {\n        this.setDropdownVisible(!this.isDropdownVisible());\n    }\n    fillDropdown(dropdown) {\n        const container = document.createElement('div');\n        container.classList.add('insert-image-widget-dropdown-content', `${constants_1.toolbarCSSPrefix}spacedList`, `${constants_1.toolbarCSSPrefix}nonbutton-controls-main-list`);\n        const { container: chooseImageRow, selectedFiles } = (0, makeFileInput_1.default)(this.localizationTable.chooseFile, this.editor, {\n            accepts: 'image/*',\n            allowMultiSelect: true,\n            customPickerAction: this.editor.getCurrentSettings().image?.showImagePicker,\n        });\n        const altTextRow = document.createElement('div');\n        this.imagesPreview = (0, makeSnappedList_1.default)(this.images);\n        this.statusView = document.createElement('div');\n        const actionButtonRow = document.createElement('div');\n        actionButtonRow.classList.add('action-button-row');\n        this.statusView.classList.add('insert-image-image-status-view');\n        this.submitButton = document.createElement('button');\n        this.selectedFiles = selectedFiles;\n        this.imageAltTextInput = document.createElement('input');\n        // Label the alt text input\n        const imageAltTextLabel = document.createElement('label');\n        const altTextInputId = `insert-image-alt-text-input-${InsertImageWidget.nextInputId++}`;\n        this.imageAltTextInput.setAttribute('id', altTextInputId);\n        imageAltTextLabel.htmlFor = altTextInputId;\n        imageAltTextLabel.innerText = this.localizationTable.inputAltText;\n        this.imageAltTextInput.type = 'text';\n        this.imageAltTextInput.placeholder = this.localizationTable.describeTheImage;\n        this.statusView.setAttribute('aria-live', 'polite');\n        this.submitButton.innerText = this.localizationTable.submit;\n        this.imagesPreview.visibleItem.onUpdateAndNow(() => this.onImageDataUpdate());\n        this.imageAltTextInput.oninput = () => {\n            const currentImage = this.imagesPreview.visibleItem.get();\n            if (currentImage) {\n                currentImage.setAltText(this.imageAltTextInput.value);\n                this.submitButton.style.display = '';\n            }\n        };\n        this.selectedFiles.onUpdateAndNow(async (files) => {\n            if (files.length === 0) {\n                this.images.set([]);\n                return;\n            }\n            const previews = (await Promise.all(files.map(async (imageFile) => {\n                let renderableImages;\n                try {\n                    renderableImages = await (0, fileToImages_1.default)(imageFile);\n                }\n                catch (error) {\n                    console.error('Image load error', error);\n                    const errorMessage = this.localizationTable.imageLoadError(error);\n                    this.statusView.innerText = errorMessage;\n                    return [];\n                }\n                return renderableImages.map((image) => {\n                    const { wrapper, preview } = ImageWrapper_1.ImageWrapper.fromRenderable(image, () => this.onImageDataUpdate());\n                    return {\n                        data: wrapper,\n                        element: preview,\n                    };\n                });\n            }))).flat();\n            this.images.set(previews);\n        });\n        altTextRow.replaceChildren(imageAltTextLabel, this.imageAltTextInput);\n        actionButtonRow.replaceChildren(this.submitButton);\n        container.replaceChildren(chooseImageRow, altTextRow, this.imagesPreview.container, this.statusView, actionButtonRow);\n        dropdown.replaceChildren(container);\n        return true;\n    }\n    onImageDataUpdate() {\n        if (!this.imagesPreview)\n            return;\n        const currentImage = this.imagesPreview.visibleItem.get();\n        const base64Data = currentImage?.getBase64Url();\n        this.imageAltTextInput.value = currentImage?.getAltText() ?? '';\n        if (base64Data) {\n            this.submitButton.disabled = false;\n            this.submitButton.style.display = '';\n            this.updateImageSizeDisplay();\n        }\n        else {\n            this.submitButton.disabled = true;\n            this.submitButton.style.display = 'none';\n            this.statusView.innerText = '';\n            this.submitButton.disabled = true;\n        }\n        if (this.images.get().length <= 1) {\n            this.submitButton.innerText = this.localizationTable.submit;\n        }\n        else {\n            this.submitButton.innerText = this.localizationTable.addAll;\n        }\n    }\n    hideDialog() {\n        this.setDropdownVisible(false);\n    }\n    updateImageSizeDisplay() {\n        const currentImage = this.imagesPreview.visibleItem.get();\n        const imageData = currentImage?.getBase64Url() ?? '';\n        const { size, units } = (0, bytesToSizeString_1.default)(imageData.length);\n        const sizeText = document.createElement('span');\n        sizeText.innerText = this.localizationTable.imageSize(Math.round(size), units);\n        // Add a button to allow decreasing the size of large images.\n        const decreaseSizeButton = document.createElement('button');\n        decreaseSizeButton.innerText = this.localizationTable.decreaseImageSize;\n        decreaseSizeButton.onclick = () => {\n            currentImage?.decreaseSize();\n        };\n        const resetSizeButton = document.createElement('button');\n        resetSizeButton.innerText = this.localizationTable.resetImage;\n        resetSizeButton.onclick = () => {\n            currentImage?.reset();\n        };\n        this.statusView.replaceChildren(sizeText);\n        if (currentImage?.isLarge()) {\n            this.statusView.appendChild(decreaseSizeButton);\n        }\n        else if (currentImage?.isChanged()) {\n            this.statusView.appendChild(resetSizeButton);\n        }\n        else {\n            const hasLargeOrChangedImages = this.images\n                .get()\n                .some((image) => image.data?.isChanged() || image.data?.isLarge());\n            if (hasLargeOrChangedImages) {\n                // Still show the button -- prevents the layout from readjusting while\n                // scrolling through the image list\n                decreaseSizeButton.disabled = true;\n                this.statusView.appendChild(decreaseSizeButton);\n            }\n        }\n    }\n    updateInputs() {\n        const resetInputs = () => {\n            this.selectedFiles?.set([]);\n            this.imageAltTextInput.value = '';\n            this.submitButton.disabled = true;\n            this.statusView.innerText = '';\n            this.submitButton.style.display = '';\n        };\n        resetInputs();\n        const selectionTools = this.editor.toolController.getMatchingTools(SelectionTool_1.default);\n        const selectedObjects = selectionTools.map((tool) => tool.getSelectedObjects()).flat();\n        // Check: Is there a selected image that can be edited?\n        let editingImage = null;\n        if (selectedObjects.length === 1 && selectedObjects[0] instanceof ImageComponent_1.default) {\n            editingImage = selectedObjects[0];\n            const image = new Image();\n            const imageWrapper = ImageWrapper_1.ImageWrapper.fromSrcAndPreview(editingImage.getURL(), image, () => this.onImageDataUpdate());\n            imageWrapper.setAltText(editingImage.getAltText() ?? '');\n            this.images.set([{ data: imageWrapper, element: image }]);\n        }\n        else if (selectedObjects.length > 0) {\n            // If not, clear the selection.\n            selectionTools.forEach((tool) => tool.clearSelection());\n        }\n        // Show the submit button only when there is data to submit.\n        this.submitButton.style.display = 'none';\n        this.submitButton.onclick = async () => {\n            const newComponents = [];\n            let transform = math_1.Mat33.identity;\n            let fullBBox = null;\n            for (const { data: imageWrapper } of this.images.get()) {\n                if (!imageWrapper) {\n                    continue;\n                }\n                const image = new Image();\n                image.src = imageWrapper.getBase64Url();\n                const altText = imageWrapper.getAltText();\n                if (altText) {\n                    image.setAttribute('alt', altText);\n                }\n                let component;\n                try {\n                    component = await ImageComponent_1.default.fromImage(image, transform);\n                }\n                catch (error) {\n                    console.error('Error loading image', error);\n                    this.statusView.innerText = this.localizationTable.imageLoadError(error);\n                    return;\n                }\n                const componentBBox = component.getBBox();\n                if (componentBBox.area === 0) {\n                    this.statusView.innerText = this.localizationTable.errorImageHasZeroSize;\n                    return;\n                }\n                newComponents.push(component);\n                fullBBox ??= componentBBox;\n                fullBBox.union(componentBBox);\n                // Update the transform for the next item.\n                const shift = math_1.Vec2.of(0, componentBBox.height);\n                transform = transform.rightMul(math_1.Mat33.translation(shift));\n            }\n            if (newComponents.length) {\n                if (!fullBBox) {\n                    throw new Error('Logic error: Full bounding box must be calculated when components are to be added.');\n                }\n                this.hideDialog();\n                if (editingImage) {\n                    const eraseCommand = new Erase_1.default([editingImage]);\n                    // Try to preserve the original width\n                    const originalTransform = editingImage.getTransformation();\n                    // || 1: Prevent division by zero\n                    const originalWidth = editingImage.getBBox().width || 1;\n                    const newWidth = fullBBox.transformedBoundingBox(originalTransform).width || 1;\n                    const widthAdjustTransform = math_1.Mat33.scaling2D(originalWidth / newWidth);\n                    const commands = [];\n                    for (const component of newComponents) {\n                        commands.push(EditorImage_1.default.addElement(component), component.transformBy(originalTransform.rightMul(widthAdjustTransform)), component.setZIndex(editingImage.getZIndex()));\n                    }\n                    this.editor.dispatch((0, uniteCommands_1.default)([...commands, eraseCommand]));\n                    selectionTools[0]?.setSelection(newComponents);\n                }\n                else {\n                    await this.editor.addAndCenterComponents(newComponents);\n                }\n            }\n        };\n    }\n}\nInsertImageWidget.nextInputId = 0;\nexports[\"default\"] = InsertImageWidget;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/toolbar/widgets/InsertImageWidget/InsertImageWidget.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/toolbar/widgets/InsertImageWidget/fileToImages.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/toolbar/widgets/InsertImageWidget/fileToImages.js ***!
  \*****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst fileToBase64Url_1 = __importDefault(__webpack_require__(/*! ../../../util/fileToBase64Url */ \"./node_modules/js-draw/dist/cjs/util/fileToBase64Url.js\"));\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\nconst fileToImages = async (imageFile) => {\n    const result = [];\n    const imageElement = new Image();\n    const base64Url = await (0, fileToBase64Url_1.default)(imageFile);\n    if (base64Url) {\n        result.push({\n            image: imageElement,\n            base64Url: base64Url,\n            transform: math_1.Mat33.identity,\n        });\n    }\n    return result;\n};\nexports[\"default\"] = fileToImages;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/toolbar/widgets/InsertImageWidget/fileToImages.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/toolbar/widgets/OverflowWidget.js":
/*!*************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/toolbar/widgets/OverflowWidget.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst BaseWidget_1 = __importDefault(__webpack_require__(/*! ./BaseWidget */ \"./node_modules/js-draw/dist/cjs/toolbar/widgets/BaseWidget.js\"));\nclass OverflowWidget extends BaseWidget_1.default {\n    constructor(editor, localizationTable) {\n        super(editor, 'overflow-widget', localizationTable);\n        this.overflowChildren = [];\n        this.container.classList.add('toolbar-overflow-widget');\n        // Make the dropdown openable\n        this.container.classList.add('dropdownShowable');\n        this.overflowContainer ??= document.createElement('div');\n    }\n    shouldAutoDisableInReadOnlyEditor() {\n        return false;\n    }\n    getTitle() {\n        return this.localizationTable.toggleOverflow;\n    }\n    createIcon() {\n        return this.editor.icons.makeOverflowIcon();\n    }\n    handleClick() {\n        this.setDropdownVisible(!this.isDropdownVisible());\n    }\n    fillDropdown(dropdown) {\n        this.overflowContainer ??= document.createElement('div');\n        if (this.overflowContainer.parentElement) {\n            this.overflowContainer.remove();\n        }\n        this.overflowContainer.classList.add('toolbar-overflow-widget-overflow-list');\n        dropdown.appendChild(this.overflowContainer);\n        return true;\n    }\n    /**\n     * Removes all `BaseWidget`s from this and returns them.\n     */\n    clearChildren() {\n        this.overflowContainer.replaceChildren();\n        this.container.classList.remove('horizontal');\n        const overflowChildren = this.overflowChildren;\n        this.overflowChildren = [];\n        return overflowChildren;\n    }\n    getChildWidgets() {\n        return [...this.overflowChildren];\n    }\n    hasAsChild(widget) {\n        for (const otherWidget of this.overflowChildren) {\n            if (widget === otherWidget) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Adds `widget` to this.\n     * `widget`'s previous parent is still responsible\n     * for serializing/deserializing its state.\n     */\n    addToOverflow(widget) {\n        this.overflowChildren.push(widget);\n        widget.addTo(this.overflowContainer);\n        widget.setIsToplevel(false);\n        // Switch to a horizontal layout if enough children\n        if (this.overflowChildren.length > 2) {\n            this.container.classList.add('horizontal');\n        }\n    }\n    // This always returns false.\n    // Don't try to move the overflow menu to itself.\n    canBeInOverflowMenu() {\n        return false;\n    }\n}\nexports[\"default\"] = OverflowWidget;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/toolbar/widgets/OverflowWidget.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/toolbar/widgets/PenToolWidget.js":
/*!************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/toolbar/widgets/PenToolWidget.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst ArrowBuilder_1 = __webpack_require__(/*! ../../components/builders/ArrowBuilder */ \"./node_modules/js-draw/dist/cjs/components/builders/ArrowBuilder.js\");\nconst FreehandLineBuilder_1 = __webpack_require__(/*! ../../components/builders/FreehandLineBuilder */ \"./node_modules/js-draw/dist/cjs/components/builders/FreehandLineBuilder.js\");\nconst PressureSensitiveFreehandLineBuilder_1 = __webpack_require__(/*! ../../components/builders/PressureSensitiveFreehandLineBuilder */ \"./node_modules/js-draw/dist/cjs/components/builders/PressureSensitiveFreehandLineBuilder.js\");\nconst LineBuilder_1 = __webpack_require__(/*! ../../components/builders/LineBuilder */ \"./node_modules/js-draw/dist/cjs/components/builders/LineBuilder.js\");\nconst RectangleBuilder_1 = __webpack_require__(/*! ../../components/builders/RectangleBuilder */ \"./node_modules/js-draw/dist/cjs/components/builders/RectangleBuilder.js\");\nconst CircleBuilder_1 = __webpack_require__(/*! ../../components/builders/CircleBuilder */ \"./node_modules/js-draw/dist/cjs/components/builders/CircleBuilder.js\");\nconst types_1 = __webpack_require__(/*! ../../types */ \"./node_modules/js-draw/dist/cjs/types.js\");\nconst makeColorInput_1 = __importDefault(__webpack_require__(/*! ./components/makeColorInput */ \"./node_modules/js-draw/dist/cjs/toolbar/widgets/components/makeColorInput.js\"));\nconst BaseToolWidget_1 = __importDefault(__webpack_require__(/*! ./BaseToolWidget */ \"./node_modules/js-draw/dist/cjs/toolbar/widgets/BaseToolWidget.js\"));\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\nconst keybindings_1 = __webpack_require__(/*! ./keybindings */ \"./node_modules/js-draw/dist/cjs/toolbar/widgets/keybindings.js\");\nconst constants_1 = __webpack_require__(/*! ../constants */ \"./node_modules/js-draw/dist/cjs/toolbar/constants.js\");\nconst makeThicknessSlider_1 = __importDefault(__webpack_require__(/*! ./components/makeThicknessSlider */ \"./node_modules/js-draw/dist/cjs/toolbar/widgets/components/makeThicknessSlider.js\"));\nconst makeGridSelector_1 = __importDefault(__webpack_require__(/*! ./components/makeGridSelector */ \"./node_modules/js-draw/dist/cjs/toolbar/widgets/components/makeGridSelector.js\"));\nconst PolylineBuilder_1 = __webpack_require__(/*! ../../components/builders/PolylineBuilder */ \"./node_modules/js-draw/dist/cjs/components/builders/PolylineBuilder.js\");\n/**\n * This toolbar widget allows a user to control a single {@link Pen} tool.\n *\n * See also {@link AbstractToolbar.addDefaultToolWidgets}.\n */\nclass PenToolWidget extends BaseToolWidget_1.default {\n    constructor(editor, tool, localization) {\n        super(editor, tool, 'pen', localization);\n        this.tool = tool;\n        this.updateInputs = () => { };\n        // Pen types that correspond to\n        this.shapelikeIDs = ['pressure-sensitive-pen', 'freehand-pen'];\n        // Additional client-specified pens.\n        const additionalPens = editor.getCurrentSettings().pens?.additionalPenTypes ?? [];\n        const filterPens = editor.getCurrentSettings().pens?.filterPenTypes ?? (() => true);\n        // Default pen types\n        this.penTypes = [\n            // Non-shape pens\n            {\n                name: this.localizationTable.flatTipPen,\n                id: 'pressure-sensitive-pen',\n                factory: PressureSensitiveFreehandLineBuilder_1.makePressureSensitiveFreehandLineBuilder,\n            },\n            {\n                name: this.localizationTable.roundedTipPen,\n                id: 'freehand-pen',\n                factory: FreehandLineBuilder_1.makeFreehandLineBuilder,\n            },\n            {\n                name: this.localizationTable.roundedTipPen2,\n                id: 'polyline-pen',\n                factory: PolylineBuilder_1.makePolylineBuilder,\n            },\n            ...additionalPens.filter((pen) => !pen.isShapeBuilder),\n            // Shape pens\n            {\n                name: this.localizationTable.arrowPen,\n                id: 'arrow',\n                isShapeBuilder: true,\n                factory: ArrowBuilder_1.makeArrowBuilder,\n            },\n            {\n                name: this.localizationTable.linePen,\n                id: 'line',\n                isShapeBuilder: true,\n                factory: LineBuilder_1.makeLineBuilder,\n            },\n            {\n                name: this.localizationTable.filledRectanglePen,\n                id: 'filled-rectangle',\n                isShapeBuilder: true,\n                factory: RectangleBuilder_1.makeFilledRectangleBuilder,\n            },\n            {\n                name: this.localizationTable.outlinedRectanglePen,\n                id: 'outlined-rectangle',\n                isShapeBuilder: true,\n                factory: RectangleBuilder_1.makeOutlinedRectangleBuilder,\n            },\n            {\n                name: this.localizationTable.outlinedCirclePen,\n                id: 'outlined-circle',\n                isShapeBuilder: true,\n                factory: CircleBuilder_1.makeOutlinedCircleBuilder,\n            },\n            ...additionalPens.filter((pen) => pen.isShapeBuilder),\n        ].filter(filterPens);\n        this.editor.notifier.on(types_1.EditorEventType.ToolUpdated, (toolEvt) => {\n            if (toolEvt.kind !== types_1.EditorEventType.ToolUpdated) {\n                throw new Error('Invalid event type!');\n            }\n            // The button icon may depend on tool properties.\n            if (toolEvt.tool === this.tool) {\n                this.updateIcon();\n                this.updateInputs();\n            }\n        });\n    }\n    getTitle() {\n        return this.targetTool.description;\n    }\n    // Return the index of this tool's stroke factory in the list of\n    // all stroke factories.\n    //\n    // Returns -1 if the stroke factory is not in the list of all stroke factories.\n    getCurrentPenTypeIdx() {\n        const currentFactory = this.tool.getStrokeFactory();\n        for (let i = 0; i < this.penTypes.length; i++) {\n            if (this.penTypes[i].factory === currentFactory) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    getCurrentPenType() {\n        for (const penType of this.penTypes) {\n            if (penType.factory === this.tool.getStrokeFactory()) {\n                return penType;\n            }\n        }\n        return null;\n    }\n    createIconForRecord(record) {\n        const style = {\n            ...this.tool.getStyleValue().get(),\n        };\n        if (record?.factory) {\n            style.factory = record.factory;\n        }\n        const strokeFactory = record?.factory;\n        if (!strokeFactory ||\n            strokeFactory === FreehandLineBuilder_1.makeFreehandLineBuilder ||\n            strokeFactory === PressureSensitiveFreehandLineBuilder_1.makePressureSensitiveFreehandLineBuilder ||\n            strokeFactory === PolylineBuilder_1.makePolylineBuilder) {\n            return this.editor.icons.makePenIcon(style);\n        }\n        else {\n            return this.editor.icons.makeIconFromFactory(style);\n        }\n    }\n    createIcon() {\n        return this.createIconForRecord(this.getCurrentPenType());\n    }\n    // Creates a widget that allows selecting different pen types\n    createPenTypeSelector(helpOverlay) {\n        const allChoices = this.penTypes.map((penType, index) => {\n            return {\n                id: index,\n                makeIcon: () => this.createIconForRecord(penType),\n                title: penType.name,\n                isShapeBuilder: penType.isShapeBuilder ?? false,\n            };\n        });\n        const penItems = allChoices.filter((choice) => !choice.isShapeBuilder);\n        const penSelector = (0, makeGridSelector_1.default)(this.localizationTable.selectPenType, this.getCurrentPenTypeIdx(), penItems);\n        const shapeItems = allChoices.filter((choice) => choice.isShapeBuilder);\n        const shapeSelector = (0, makeGridSelector_1.default)(this.localizationTable.selectShape, this.getCurrentPenTypeIdx(), shapeItems);\n        const onSelectorUpdate = (newPenTypeIndex) => {\n            this.tool.setStrokeFactory(this.penTypes[newPenTypeIndex].factory);\n        };\n        penSelector.value.onUpdate(onSelectorUpdate);\n        shapeSelector.value.onUpdate(onSelectorUpdate);\n        helpOverlay?.registerTextHelpForElements([penSelector.getRootElement(), shapeSelector.getRootElement()], this.localizationTable.penDropdown__penTypeHelpText);\n        return {\n            setValue: (penTypeIndex) => {\n                penSelector.value.set(penTypeIndex);\n                shapeSelector.value.set(penTypeIndex);\n            },\n            updateIcons: () => {\n                penSelector.updateIcons();\n                shapeSelector.updateIcons();\n            },\n            addTo: (parent) => {\n                if (penItems.length) {\n                    penSelector.addTo(parent);\n                }\n                if (shapeItems.length) {\n                    shapeSelector.addTo(parent);\n                }\n            },\n        };\n    }\n    createStrokeCorrectionOptions(helpOverlay) {\n        const container = document.createElement('div');\n        container.classList.add('action-button-row', `${constants_1.toolbarCSSPrefix}-pen-tool-toggle-buttons`);\n        const addToggleButton = (labelText, icon) => {\n            const button = document.createElement('button');\n            button.classList.add(`${constants_1.toolbarCSSPrefix}-toggle-button`);\n            const iconElement = icon.cloneNode(true);\n            iconElement.classList.add('icon');\n            const label = document.createElement('span');\n            label.innerText = labelText;\n            button.replaceChildren(iconElement, label);\n            button.setAttribute('role', 'switch');\n            container.appendChild(button);\n            let checked = false;\n            let onChangeListener = (_checked) => { };\n            const result = {\n                setChecked(newChecked) {\n                    checked = newChecked;\n                    button.setAttribute('aria-checked', `${checked}`);\n                    onChangeListener(checked);\n                },\n                setOnInputListener(listener) {\n                    onChangeListener = listener;\n                },\n                addHelpText(text) {\n                    helpOverlay?.registerTextHelpForElement(button, text);\n                },\n            };\n            button.onclick = () => {\n                result.setChecked(!checked);\n            };\n            return result;\n        };\n        const stabilizationOption = addToggleButton(this.localizationTable.inputStabilization, this.editor.icons.makeStrokeSmoothingIcon());\n        stabilizationOption.setOnInputListener((enabled) => {\n            this.tool.setHasStabilization(enabled);\n        });\n        const autocorrectOption = addToggleButton(this.localizationTable.strokeAutocorrect, this.editor.icons.makeShapeAutocorrectIcon());\n        autocorrectOption.setOnInputListener((enabled) => {\n            this.tool.setStrokeAutocorrectEnabled(enabled);\n        });\n        // Help text\n        autocorrectOption.addHelpText(this.localizationTable.penDropdown__autocorrectHelpText);\n        stabilizationOption.addHelpText(this.localizationTable.penDropdown__stabilizationHelpText);\n        return {\n            update: () => {\n                stabilizationOption.setChecked(!!this.tool.getInputMapper());\n                autocorrectOption.setChecked(this.tool.getStrokeAutocorrectionEnabled());\n            },\n            addTo: (parent) => {\n                parent.appendChild(container);\n            },\n        };\n    }\n    getHelpText() {\n        return this.localizationTable.penDropdown__baseHelpText;\n    }\n    fillDropdown(dropdown, helpDisplay) {\n        const container = document.createElement('div');\n        container.classList.add(`${constants_1.toolbarCSSPrefix}spacedList`, `${constants_1.toolbarCSSPrefix}nonbutton-controls-main-list`);\n        // Thickness: Value of the input is squared to allow for finer control/larger values.\n        const { container: thicknessRow, setValue: setThickness } = (0, makeThicknessSlider_1.default)(this.editor, (thickness) => {\n            this.tool.setThickness(thickness);\n        });\n        const colorRow = document.createElement('div');\n        const colorLabel = document.createElement('label');\n        const colorInputControl = (0, makeColorInput_1.default)(this.editor, (color) => {\n            this.tool.setColor(color);\n        });\n        const { input: colorInput, container: colorInputContainer } = colorInputControl;\n        colorInput.id = `${constants_1.toolbarCSSPrefix}colorInput${PenToolWidget.idCounter++}`;\n        colorLabel.innerText = this.localizationTable.colorLabel;\n        colorLabel.setAttribute('for', colorInput.id);\n        colorRow.appendChild(colorLabel);\n        colorRow.appendChild(colorInputContainer);\n        // Autocorrect and stabilization options\n        const toggleButtonRow = this.createStrokeCorrectionOptions(helpDisplay);\n        const penTypeSelect = this.createPenTypeSelector(helpDisplay);\n        // Add help text for color and thickness last, as these are likely to be\n        // features users are least interested in.\n        helpDisplay?.registerTextHelpForElement(colorRow, this.localizationTable.penDropdown__colorHelpText);\n        if (helpDisplay) {\n            colorInputControl.registerWithHelpTextDisplay(helpDisplay);\n        }\n        helpDisplay?.registerTextHelpForElement(thicknessRow, this.localizationTable.penDropdown__thicknessHelpText);\n        this.updateInputs = () => {\n            colorInputControl.setValue(this.tool.getColor());\n            setThickness(this.tool.getThickness());\n            penTypeSelect.updateIcons();\n            // Update the selected stroke factory.\n            penTypeSelect.setValue(this.getCurrentPenTypeIdx());\n            toggleButtonRow.update();\n        };\n        this.updateInputs();\n        container.replaceChildren(colorRow, thicknessRow);\n        penTypeSelect.addTo(container);\n        dropdown.replaceChildren(container);\n        // Add the toggle button row *outside* of the main content (use different\n        // spacing with respect to the sides of the container).\n        toggleButtonRow.addTo(dropdown);\n        return true;\n    }\n    onKeyPress(event) {\n        if (!this.isSelected()) {\n            return false;\n        }\n        for (let i = 0; i < keybindings_1.selectStrokeTypeKeyboardShortcutIds.length; i++) {\n            const shortcut = keybindings_1.selectStrokeTypeKeyboardShortcutIds[i];\n            if (this.editor.shortcuts.matchesShortcut(shortcut, event)) {\n                const penTypeIdx = i;\n                if (penTypeIdx < this.penTypes.length) {\n                    this.tool.setStrokeFactory(this.penTypes[penTypeIdx].factory);\n                    return true;\n                }\n            }\n        }\n        // Run any default actions registered by the parent class.\n        if (super.onKeyPress(event)) {\n            return true;\n        }\n        return false;\n    }\n    serializeState() {\n        return {\n            ...super.serializeState(),\n            color: this.tool.getColor().toHexString(),\n            thickness: this.tool.getThickness(),\n            strokeFactoryId: this.getCurrentPenType()?.id,\n            inputStabilization: !!this.tool.getInputMapper(),\n            strokeAutocorrect: this.tool.getStrokeAutocorrectionEnabled(),\n        };\n    }\n    deserializeFrom(state) {\n        super.deserializeFrom(state);\n        const verifyPropertyType = (propertyName, expectedType) => {\n            const actualType = typeof state[propertyName];\n            if (actualType !== expectedType) {\n                throw new Error(`Deserializing property ${propertyName}: Invalid type. Expected ${expectedType},` +\n                    ` was ${actualType}.`);\n            }\n        };\n        if (state.color) {\n            verifyPropertyType('color', 'string');\n            this.tool.setColor(math_1.Color4.fromHex(state.color));\n        }\n        if (state.thickness) {\n            verifyPropertyType('thickness', 'number');\n            this.tool.setThickness(state.thickness);\n        }\n        if (state.strokeFactoryId) {\n            verifyPropertyType('strokeFactoryId', 'string');\n            const factoryId = state.strokeFactoryId;\n            for (const penType of this.penTypes) {\n                if (factoryId === penType.id) {\n                    this.tool.setStrokeFactory(penType.factory);\n                    break;\n                }\n            }\n        }\n        if (state.inputStabilization !== undefined) {\n            this.tool.setHasStabilization(!!state.inputStabilization);\n        }\n        if (state.strokeAutocorrect !== undefined) {\n            this.tool.setStrokeAutocorrectEnabled(!!state.strokeAutocorrect);\n        }\n    }\n}\n// A counter variable that ensures different HTML elements are given unique names/ids.\nPenToolWidget.idCounter = 0;\nexports[\"default\"] = PenToolWidget;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/toolbar/widgets/PenToolWidget.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/toolbar/widgets/SaveActionWidget.js":
/*!***************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/toolbar/widgets/SaveActionWidget.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst ActionButtonWidget_1 = __importDefault(__webpack_require__(/*! ./ActionButtonWidget */ \"./node_modules/js-draw/dist/cjs/toolbar/widgets/ActionButtonWidget.js\"));\nconst BaseWidget_1 = __webpack_require__(/*! ./BaseWidget */ \"./node_modules/js-draw/dist/cjs/toolbar/widgets/BaseWidget.js\");\nconst keybindings_1 = __webpack_require__(/*! ./keybindings */ \"./node_modules/js-draw/dist/cjs/toolbar/widgets/keybindings.js\");\nclass SaveActionWidget extends ActionButtonWidget_1.default {\n    constructor(editor, localization, saveCallback, labelOverride = {}) {\n        super(editor, 'save-button', \n        // Creates an icon\n        () => {\n            return labelOverride.icon ?? editor.icons.makeSaveIcon();\n        }, labelOverride.label ?? localization.save, saveCallback);\n        this.setTags([BaseWidget_1.ToolbarWidgetTag.Save]);\n    }\n    shouldAutoDisableInReadOnlyEditor() {\n        return false;\n    }\n    onKeyPress(event) {\n        if (this.editor.shortcuts.matchesShortcut(keybindings_1.saveKeyboardShortcut, event)) {\n            this.clickAction();\n            return true;\n        }\n        // Run any default actions registered by the parent class.\n        return super.onKeyPress(event);\n    }\n    mustBeInToplevelMenu() {\n        return true;\n    }\n}\nexports[\"default\"] = SaveActionWidget;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/toolbar/widgets/SaveActionWidget.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/toolbar/widgets/SelectionToolWidget.js":
/*!******************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/toolbar/widgets/SelectionToolWidget.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\nconst RestylableComponent_1 = __webpack_require__(/*! ../../components/RestylableComponent */ \"./node_modules/js-draw/dist/cjs/components/RestylableComponent.js\");\nconst uniteCommands_1 = __importDefault(__webpack_require__(/*! ../../commands/uniteCommands */ \"./node_modules/js-draw/dist/cjs/commands/uniteCommands.js\"));\nconst types_1 = __webpack_require__(/*! ../../types */ \"./node_modules/js-draw/dist/cjs/types.js\");\nconst makeColorInput_1 = __importDefault(__webpack_require__(/*! ./components/makeColorInput */ \"./node_modules/js-draw/dist/cjs/toolbar/widgets/components/makeColorInput.js\"));\nconst ActionButtonWidget_1 = __importDefault(__webpack_require__(/*! ./ActionButtonWidget */ \"./node_modules/js-draw/dist/cjs/toolbar/widgets/ActionButtonWidget.js\"));\nconst BaseToolWidget_1 = __importDefault(__webpack_require__(/*! ./BaseToolWidget */ \"./node_modules/js-draw/dist/cjs/toolbar/widgets/BaseToolWidget.js\"));\nconst keybindings_1 = __webpack_require__(/*! ./keybindings */ \"./node_modules/js-draw/dist/cjs/toolbar/widgets/keybindings.js\");\nconst makeSeparator_1 = __importDefault(__webpack_require__(/*! ./components/makeSeparator */ \"./node_modules/js-draw/dist/cjs/toolbar/widgets/components/makeSeparator.js\"));\nconst constants_1 = __webpack_require__(/*! ../constants */ \"./node_modules/js-draw/dist/cjs/toolbar/constants.js\");\nconst makeFormatMenu = (editor, selectionTool, localizationTable) => {\n    const container = document.createElement('div');\n    container.classList.add('selection-format-menu', `${constants_1.toolbarCSSPrefix}spacedList`, `${constants_1.toolbarCSSPrefix}indentedList`);\n    const colorRow = document.createElement('div');\n    const colorLabel = document.createElement('label');\n    const colorInputControl = (0, makeColorInput_1.default)(editor, (color) => {\n        const selection = selectionTool.getSelection();\n        if (selection) {\n            const updateStyleCommands = [];\n            for (const elem of selection.getSelectedObjects()) {\n                if ((0, RestylableComponent_1.isRestylableComponent)(elem)) {\n                    updateStyleCommands.push(elem.updateStyle({ color }));\n                }\n            }\n            const unitedCommand = (0, uniteCommands_1.default)(updateStyleCommands);\n            editor.dispatch(unitedCommand);\n        }\n    });\n    const { input: colorInput, container: colorInputContainer } = colorInputControl;\n    colorLabel.innerText = localizationTable.colorLabel;\n    const update = () => {\n        const selection = selectionTool.getSelection();\n        if (selection && selection.getSelectedItemCount() > 0) {\n            colorInput.disabled = false;\n            container.classList.remove('disabled');\n            const colors = [];\n            for (const elem of selection.getSelectedObjects()) {\n                if ((0, RestylableComponent_1.isRestylableComponent)(elem)) {\n                    const color = elem.getStyle().color;\n                    if (color) {\n                        colors.push(color);\n                    }\n                }\n            }\n            colorInputControl.setValue(math_1.Color4.average(colors));\n        }\n        else {\n            colorInput.disabled = true;\n            container.classList.add('disabled');\n            colorInputControl.setValue(math_1.Color4.transparent);\n        }\n    };\n    colorRow.replaceChildren(colorLabel, colorInputContainer);\n    container.replaceChildren(colorRow);\n    return {\n        addTo: (parent) => {\n            parent.appendChild(container);\n        },\n        update,\n        registerHelpText: (helpDisplay) => {\n            helpDisplay.registerTextHelpForElement(colorRow, localizationTable.selectionDropdown__changeColorHelpText);\n            colorInputControl.registerWithHelpTextDisplay(helpDisplay);\n        },\n    };\n};\nclass SelectionToolWidget extends BaseToolWidget_1.default {\n    constructor(editor, tool, localization) {\n        super(editor, tool, 'selection-tool-widget', localization);\n        this.tool = tool;\n        this.updateFormatMenu = () => { };\n        const resizeButton = new ActionButtonWidget_1.default(editor, 'resize-btn', () => editor.icons.makeResizeImageToSelectionIcon(), this.localizationTable.resizeImageToSelection, () => {\n            this.resizeImageToSelection();\n        }, localization);\n        resizeButton.setHelpText(this.localizationTable.selectionDropdown__resizeToHelpText);\n        const deleteButton = new ActionButtonWidget_1.default(editor, 'delete-btn', () => editor.icons.makeDeleteSelectionIcon(), this.localizationTable.deleteSelection, () => {\n            const selection = this.tool.getSelection();\n            this.editor.dispatch(selection.deleteSelectedObjects());\n            this.tool.clearSelection();\n        }, localization);\n        deleteButton.setHelpText(this.localizationTable.selectionDropdown__deleteHelpText);\n        const duplicateButton = new ActionButtonWidget_1.default(editor, 'duplicate-btn', () => editor.icons.makeDuplicateSelectionIcon(), this.localizationTable.duplicateSelection, async () => {\n            const selection = this.tool.getSelection();\n            this.editor.dispatch(await selection.duplicateSelectedObjects());\n            this.setDropdownVisible(false);\n        }, localization);\n        duplicateButton.setHelpText(this.localizationTable.selectionDropdown__duplicateHelpText);\n        this.addSubWidget(resizeButton);\n        this.addSubWidget(deleteButton);\n        this.addSubWidget(duplicateButton);\n        const updateDisabled = (disabled) => {\n            resizeButton.setDisabled(disabled);\n            deleteButton.setDisabled(disabled);\n            duplicateButton.setDisabled(disabled);\n        };\n        updateDisabled(true);\n        // Enable/disable actions based on whether items are selected\n        this.editor.notifier.on(types_1.EditorEventType.ToolUpdated, (toolEvt) => {\n            if (toolEvt.kind !== types_1.EditorEventType.ToolUpdated) {\n                throw new Error('Invalid event type!');\n            }\n            if (toolEvt.tool === this.tool) {\n                const selection = this.tool.getSelection();\n                const hasSelection = selection && selection.getSelectedItemCount() > 0;\n                updateDisabled(!hasSelection);\n                this.updateFormatMenu();\n            }\n        });\n    }\n    resizeImageToSelection() {\n        const selection = this.tool.getSelection();\n        if (selection) {\n            this.editor.dispatch(this.editor.setImportExportRect(selection.region));\n        }\n    }\n    onKeyPress(event) {\n        const shortcuts = this.editor.shortcuts;\n        // Resize image to selection:\n        // Other keys are handled directly by the selection tool.\n        if (shortcuts.matchesShortcut(keybindings_1.resizeImageToSelectionKeyboardShortcut, event)) {\n            this.resizeImageToSelection();\n            return true;\n        }\n        // If we didn't handle the event, allow the superclass to handle it.\n        if (super.onKeyPress(event)) {\n            return true;\n        }\n        return false;\n    }\n    getTitle() {\n        return this.localizationTable.select;\n    }\n    createIcon() {\n        return this.editor.icons.makeSelectionIcon();\n    }\n    getHelpText() {\n        return this.localizationTable.selectionDropdown__baseHelpText;\n    }\n    fillDropdown(dropdown, helpDisplay) {\n        super.fillDropdown(dropdown, helpDisplay);\n        const controlsContainer = document.createElement('div');\n        controlsContainer.classList.add(`${constants_1.toolbarCSSPrefix}nonbutton-controls-main-list`);\n        dropdown.appendChild(controlsContainer);\n        (0, makeSeparator_1.default)(this.localizationTable.reformatSelection).addTo(controlsContainer);\n        const formatMenu = makeFormatMenu(this.editor, this.tool, this.localizationTable);\n        formatMenu.addTo(controlsContainer);\n        this.updateFormatMenu = () => formatMenu.update();\n        if (helpDisplay) {\n            formatMenu.registerHelpText(helpDisplay);\n        }\n        formatMenu.update();\n        return true;\n    }\n}\nexports[\"default\"] = SelectionToolWidget;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/toolbar/widgets/SelectionToolWidget.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/toolbar/widgets/TextToolWidget.js":
/*!*************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/toolbar/widgets/TextToolWidget.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\nconst types_1 = __webpack_require__(/*! ../../types */ \"./node_modules/js-draw/dist/cjs/types.js\");\nconst constants_1 = __webpack_require__(/*! ../constants */ \"./node_modules/js-draw/dist/cjs/toolbar/constants.js\");\nconst makeColorInput_1 = __importDefault(__webpack_require__(/*! ./components/makeColorInput */ \"./node_modules/js-draw/dist/cjs/toolbar/widgets/components/makeColorInput.js\"));\nconst BaseToolWidget_1 = __importDefault(__webpack_require__(/*! ./BaseToolWidget */ \"./node_modules/js-draw/dist/cjs/toolbar/widgets/BaseToolWidget.js\"));\nclass TextToolWidget extends BaseToolWidget_1.default {\n    constructor(editor, tool, localization) {\n        super(editor, tool, 'text-tool-widget', localization);\n        this.tool = tool;\n        this.updateDropdownInputs = null;\n        editor.notifier.on(types_1.EditorEventType.ToolUpdated, (evt) => {\n            if (evt.kind === types_1.EditorEventType.ToolUpdated && evt.tool === tool) {\n                this.updateIcon();\n                this.updateDropdownInputs?.();\n            }\n        });\n    }\n    getTitle() {\n        return this.targetTool.description;\n    }\n    createIcon() {\n        const textStyle = this.tool.getTextStyle();\n        return this.editor.icons.makeTextIcon(textStyle);\n    }\n    fillDropdown(dropdown) {\n        const container = document.createElement('div');\n        container.classList.add(`${constants_1.toolbarCSSPrefix}spacedList`, `${constants_1.toolbarCSSPrefix}nonbutton-controls-main-list`);\n        const fontRow = document.createElement('div');\n        const colorRow = document.createElement('div');\n        const sizeRow = document.createElement('div');\n        const fontInput = document.createElement('select');\n        const fontLabel = document.createElement('label');\n        const sizeInput = document.createElement('input');\n        const sizeLabel = document.createElement('label');\n        const { input: colorInput, container: colorInputContainer, setValue: setColorInputValue, } = (0, makeColorInput_1.default)(this.editor, (color) => {\n            this.tool.setColor(color);\n        });\n        const colorLabel = document.createElement('label');\n        const fontsInInput = new Set();\n        const addFontToInput = (fontName) => {\n            const option = document.createElement('option');\n            option.value = fontName;\n            option.textContent = fontName;\n            fontInput.appendChild(option);\n            fontsInInput.add(fontName);\n        };\n        sizeInput.setAttribute('type', 'number');\n        sizeInput.min = '1';\n        sizeInput.max = '128';\n        fontLabel.innerText = this.localizationTable.fontLabel;\n        colorLabel.innerText = this.localizationTable.colorLabel;\n        sizeLabel.innerText = this.localizationTable.textSize;\n        colorInput.id = `${constants_1.toolbarCSSPrefix}-text-color-input-${TextToolWidget.idCounter++}`;\n        colorLabel.setAttribute('for', colorInput.id);\n        sizeInput.id = `${constants_1.toolbarCSSPrefix}-text-size-input-${TextToolWidget.idCounter++}`;\n        sizeLabel.setAttribute('for', sizeInput.id);\n        const defaultFonts = this.editor.getCurrentSettings().text?.fonts ?? [];\n        for (const font of defaultFonts) {\n            addFontToInput(font);\n        }\n        fontInput.classList.add('font-selector');\n        fontInput.id = `${constants_1.toolbarCSSPrefix}-text-font-input-${TextToolWidget.idCounter++}`;\n        fontLabel.setAttribute('for', fontInput.id);\n        fontInput.onchange = () => {\n            this.tool.setFontFamily(fontInput.value);\n        };\n        sizeInput.onchange = () => {\n            const size = parseInt(sizeInput.value);\n            if (!isNaN(size) && size > 0) {\n                this.tool.setFontSize(size);\n            }\n        };\n        colorRow.appendChild(colorLabel);\n        colorRow.appendChild(colorInputContainer);\n        fontRow.appendChild(fontLabel);\n        fontRow.appendChild(fontInput);\n        sizeRow.appendChild(sizeLabel);\n        sizeRow.appendChild(sizeInput);\n        this.updateDropdownInputs = () => {\n            const style = this.tool.getTextStyle();\n            setColorInputValue(style.renderingStyle.fill);\n            if (!fontsInInput.has(style.fontFamily)) {\n                addFontToInput(style.fontFamily);\n            }\n            fontInput.value = style.fontFamily;\n            sizeInput.value = `${style.size}`;\n        };\n        this.updateDropdownInputs();\n        container.replaceChildren(colorRow, sizeRow, fontRow);\n        dropdown.appendChild(container);\n        return true;\n    }\n    serializeState() {\n        const textStyle = this.tool.getTextStyle();\n        return {\n            ...super.serializeState(),\n            fontFamily: textStyle.fontFamily,\n            textSize: textStyle.size,\n            color: textStyle.renderingStyle.fill.toHexString(),\n        };\n    }\n    deserializeFrom(state) {\n        if (state.fontFamily && typeof state.fontFamily === 'string') {\n            this.tool.setFontFamily(state.fontFamily);\n        }\n        if (state.color && typeof state.color === 'string') {\n            this.tool.setColor(math_1.Color4.fromHex(state.color));\n        }\n        if (state.textSize && typeof state.textSize === 'number') {\n            this.tool.setFontSize(state.textSize);\n        }\n        super.deserializeFrom(state);\n    }\n}\nTextToolWidget.idCounter = 0;\nexports[\"default\"] = TextToolWidget;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/toolbar/widgets/TextToolWidget.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/toolbar/widgets/components/makeColorInput.js":
/*!************************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/toolbar/widgets/components/makeColorInput.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.makeColorInput = void 0;\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\nconst PipetteTool_1 = __importDefault(__webpack_require__(/*! ../../../tools/PipetteTool */ \"./node_modules/js-draw/dist/cjs/tools/PipetteTool.js\"));\nconst types_1 = __webpack_require__(/*! ../../../types */ \"./node_modules/js-draw/dist/cjs/types.js\");\n// Returns [ color input, input container, callback to change the color value ].\nconst makeColorInput = (editor, onColorChange) => {\n    const container = document.createElement('span');\n    const inputWrapper = document.createElement('span');\n    const colorInput = document.createElement('input');\n    colorInput.type = 'button';\n    colorInput.classList.add('coloris_input');\n    container.classList.add('color-input-container');\n    inputWrapper.classList.add('color-input-wrapper');\n    inputWrapper.appendChild(colorInput);\n    container.appendChild(inputWrapper);\n    const pipetteController = addPipetteTool(editor, container, (color) => {\n        colorInput.value = color.toHexString();\n        onInputEnd();\n        // Update the color preview, if it exists (may be managed by Coloris).\n        const parentElem = colorInput.parentElement;\n        if (parentElem && parentElem.classList.contains('clr-field')) {\n            parentElem.style.color = colorInput.value;\n        }\n    });\n    let currentColor;\n    const handleColorInput = () => {\n        currentColor = math_1.Color4.fromHex(colorInput.value);\n    };\n    // Only change the pen color when we finish sending input (this limits the number of\n    // editor events triggered and accessibility announcements).\n    const onInputEnd = () => {\n        handleColorInput();\n        if (currentColor) {\n            editor.announceForAccessibility(editor.localization.colorChangedAnnouncement(currentColor.toHexString()));\n            onColorChange(currentColor);\n            editor.notifier.dispatch(types_1.EditorEventType.ColorPickerColorSelected, {\n                kind: types_1.EditorEventType.ColorPickerColorSelected,\n                color: currentColor,\n            });\n        }\n    };\n    colorInput.oninput = handleColorInput;\n    let isOpen = false;\n    colorInput.addEventListener('open', () => {\n        isOpen = true;\n        editor.notifier.dispatch(types_1.EditorEventType.ColorPickerToggled, {\n            kind: types_1.EditorEventType.ColorPickerToggled,\n            open: true,\n        });\n        pipetteController.cancel();\n        container.classList.add('picker-open');\n        // Focus the Coloris color picker, if it exists.\n        // Don't focus the text input within the color picker, however,\n        // as this displays a keyboard on mobile devices.\n        const colorPickerElem = document.querySelector('#clr-picker #clr-hue-slider');\n        colorPickerElem?.focus();\n    });\n    const onClose = () => {\n        isOpen = false;\n        editor.notifier.dispatch(types_1.EditorEventType.ColorPickerToggled, {\n            kind: types_1.EditorEventType.ColorPickerToggled,\n            open: false,\n        });\n        onInputEnd();\n        // Restore focus to the input that opened the color picker\n        colorInput.focus();\n        container.classList.remove('picker-open');\n    };\n    colorInput.addEventListener('close', () => {\n        onClose();\n    });\n    const setColorInputValue = (color) => {\n        if (typeof color === 'object') {\n            color = color.toHexString();\n        }\n        colorInput.value = color;\n        // Fire all color event listeners. See\n        // https://github.com/mdbassit/Coloris#manually-updating-the-thumbnail\n        colorInput.dispatchEvent(new Event('input', { bubbles: true }));\n    };\n    return {\n        input: colorInput,\n        container,\n        setValue: setColorInputValue,\n        closePicker: () => {\n            if (isOpen) {\n                onInputEnd();\n            }\n        },\n        registerWithHelpTextDisplay: (helpDisplay) => {\n            helpDisplay.registerTextHelpForElement(inputWrapper, editor.localization.colorPickerToggleHelpText);\n            pipetteController.registerWithHelpTextDisplay(helpDisplay);\n        },\n    };\n};\nexports.makeColorInput = makeColorInput;\nconst addPipetteTool = (editor, container, onColorChange) => {\n    const pipetteButton = document.createElement('button');\n    pipetteButton.classList.add('pipetteButton');\n    pipetteButton.title = editor.localization.pickColorFromScreen;\n    pipetteButton.setAttribute('alt', pipetteButton.title);\n    const pickColorLabel = document.createElement('span');\n    pickColorLabel.classList.add('pickColorInstructions');\n    pickColorLabel.innerText = editor.localization.clickToPickColorAnnouncement;\n    const updatePipetteButtonContent = (color) => {\n        pipetteButton.replaceChildren(editor.icons.makePipetteIcon(color), pickColorLabel);\n    };\n    updatePipetteButtonContent();\n    const pipetteTool = editor.toolController.getMatchingTools(PipetteTool_1.default)[0];\n    const endColorSelectMode = () => {\n        pipetteTool?.clearColorListener();\n        updatePipetteButtonContent();\n        pipetteButton.classList.remove('active');\n    };\n    const pipetteColorSelect = (color) => {\n        endColorSelectMode();\n        if (color) {\n            onColorChange(color);\n        }\n    };\n    const pipetteColorPreview = (color) => {\n        if (color) {\n            updatePipetteButtonContent(color);\n        }\n        else {\n            updatePipetteButtonContent();\n        }\n    };\n    pipetteButton.onclick = () => {\n        // If already picking, cancel it.\n        if (pipetteButton.classList.contains('active')) {\n            endColorSelectMode();\n            editor.announceForAccessibility(editor.localization.colorSelectionCanceledAnnouncement);\n            return;\n        }\n        pipetteTool?.setColorListener(pipetteColorPreview, pipetteColorSelect);\n        if (pipetteTool) {\n            pipetteButton.classList.add('active');\n            editor.announceForAccessibility(editor.localization.clickToPickColorAnnouncement);\n        }\n    };\n    container.appendChild(pipetteButton);\n    return {\n        // Cancel a pipette color selection if one is in progress.\n        cancel: () => {\n            endColorSelectMode();\n        },\n        registerWithHelpTextDisplay: (helpDisplay) => {\n            helpDisplay.registerTextHelpForElement(pipetteButton, editor.localization.colorPickerPipetteHelpText);\n        },\n    };\n};\nexports[\"default\"] = exports.makeColorInput;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/toolbar/widgets/components/makeColorInput.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/toolbar/widgets/components/makeFileInput.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/toolbar/widgets/components/makeFileInput.js ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst ReactiveValue_1 = __importDefault(__webpack_require__(/*! ../../../util/ReactiveValue */ \"./node_modules/js-draw/dist/cjs/util/ReactiveValue.js\"));\nlet idCounter = 0;\n/**\n * Creates a stylized file input. This file input can either use the system file picker, or a custom\n * one specified by `customPickerAction`.\n */\nconst makeFileInput = (labelText, context, { accepts = '*', allowMultiSelect = false, customPickerAction } = {}) => {\n    const container = document.createElement('div');\n    const label = document.createElement('label');\n    const input = document.createElement('input');\n    const descriptionBox = document.createElement('div');\n    descriptionBox.classList.add('toolbar--file-input-description');\n    const descriptionText = document.createElement('span');\n    container.classList.add('toolbar--file-input-container');\n    label.appendChild(document.createTextNode(labelText));\n    input.accept = accepts;\n    input.type = customPickerAction ? 'button' : 'file';\n    input.classList.add('file-input');\n    input.multiple = allowMultiSelect;\n    // Associate the label with the input\n    const inputId = `js-draw-file-input-${idCounter++}`;\n    input.setAttribute('id', inputId);\n    label.htmlFor = inputId;\n    const icon = context.icons.makeUploadFileIcon();\n    icon.classList.add('icon');\n    descriptionBox.replaceChildren(icon, descriptionText);\n    label.appendChild(descriptionBox);\n    container.replaceChildren(label, input);\n    const selectedFiles = ReactiveValue_1.default.fromInitialValue([]);\n    let loading = false;\n    let cancelLoading = null;\n    const updateStatusText = () => {\n        const files = selectedFiles.get();\n        if (loading) {\n            descriptionText.textContent = context.localization.fileInput__loading;\n            if (cancelLoading) {\n                const cancelText = document.createElement('b');\n                cancelText.textContent = context.localization.cancel;\n                cancelText.classList.add('cancel-button');\n                descriptionText.appendChild(cancelText);\n            }\n            icon.style.display = 'none';\n        }\n        else if (files.length > 0) {\n            const fileNames = files.map((file) => file.name);\n            const maxNames = 5;\n            if (fileNames.length <= maxNames) {\n                descriptionText.textContent = fileNames.join('\\n');\n            }\n            else {\n                const fileNamesToShow = fileNames.slice(0, maxNames - 1);\n                descriptionText.textContent = [\n                    ...fileNamesToShow,\n                    context.localization.fileInput__andNMoreFiles(fileNames.length - fileNamesToShow.length),\n                ].join('\\n');\n            }\n            // Only show the icon when there are files\n            icon.style.display = 'none';\n        }\n        else {\n            // Show the icon\n            icon.style.display = '';\n            const text = context.localization.dragAndDropHereOrBrowse;\n            // Split into regions surrounded by {{curly braces}} and regions that are\n            // not.\n            // When given a regular expression, `.split` outputs an array. For example,\n            //    \"a test __of__ split\".split(/__(.*)__/)\n            // results in\n            //    ['a test ', 'of', ' split'].\n            const segments = text.split(/[{]{2}(.*)[}]{2}/g);\n            descriptionText.replaceChildren();\n            for (let i = 0; i < segments.length; i++) {\n                // Inside a {{pair of curly braces}}?\n                if (i % 2 === 1) {\n                    const boldedText = document.createElement('b');\n                    boldedText.textContent = segments[i];\n                    descriptionText.appendChild(boldedText);\n                }\n                else {\n                    descriptionText.appendChild(document.createTextNode(segments[i]));\n                }\n            }\n        }\n    };\n    const addFileEventListeners = () => {\n        // Support dropping files\n        label.addEventListener('dragover', (event) => {\n            event.preventDefault();\n            label.classList.add('drag-target');\n        });\n        label.addEventListener('dragenter', (event) => {\n            event.preventDefault();\n            label.classList.add('drag-target');\n        });\n        label.addEventListener('dragleave', (event) => {\n            event.preventDefault();\n            // Ensure the event wasn't targeting a child.\n            // See https://stackoverflow.com/a/54271161 and\n            //     https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/relatedTarget\n            const enteringElement = event.relatedTarget;\n            if (!enteringElement || !label.contains(enteringElement)) {\n                label.classList.remove('drag-target');\n            }\n        });\n        // See https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API/File_drag_and_drop#process_the_drop\n        label.addEventListener('drop', (event) => {\n            event.preventDefault();\n            label.classList.remove('drag-target');\n            const fileList = [];\n            if (event.dataTransfer) {\n                fileList.push(...event.dataTransfer.files);\n            }\n            selectedFiles.set(fileList);\n        });\n        input.addEventListener('change', () => {\n            const fileList = input.files ?? [];\n            selectedFiles.set([...fileList]);\n        });\n    };\n    addFileEventListeners();\n    // Support for custom file pickers\n    if (customPickerAction) {\n        const promptForFiles = async () => {\n            if (loading) {\n                cancelLoading?.();\n                return;\n            }\n            container.classList.add('-loading');\n            loading = true;\n            updateStatusText();\n            try {\n                const data = await customPickerAction({\n                    setOnCancelCallback: (onCancel) => {\n                        if (!loading) {\n                            throw new Error(\"Task already completed. Can't register cancel handler.\");\n                        }\n                        cancelLoading = () => {\n                            cancelLoading = null;\n                            updateStatusText();\n                            onCancel();\n                        };\n                        updateStatusText();\n                    },\n                });\n                if (data) {\n                    selectedFiles.set(data);\n                }\n            }\n            finally {\n                container.classList.remove('-loading');\n                loading = false;\n                updateStatusText();\n            }\n        };\n        input.onclick = promptForFiles;\n    }\n    selectedFiles.onUpdate((files) => {\n        if (files.length === 0 && input.files && input.files.length > 0) {\n            input.value = '';\n        }\n        cancelLoading?.();\n    });\n    // Update the status text and hide/show the icon.\n    selectedFiles.onUpdateAndNow(updateStatusText);\n    return {\n        container,\n        input,\n        selectedFiles,\n        addTo: (parent) => {\n            parent.appendChild(container);\n        },\n    };\n};\nexports[\"default\"] = makeFileInput;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/toolbar/widgets/components/makeFileInput.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/toolbar/widgets/components/makeGridSelector.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/toolbar/widgets/components/makeGridSelector.js ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst ReactiveValue_1 = __webpack_require__(/*! ../../../util/ReactiveValue */ \"./node_modules/js-draw/dist/cjs/util/ReactiveValue.js\");\nconst stopPropagationOfScrollingWheelEvents_1 = __importDefault(__webpack_require__(/*! ../../../util/stopPropagationOfScrollingWheelEvents */ \"./node_modules/js-draw/dist/cjs/util/stopPropagationOfScrollingWheelEvents.js\"));\nconst addLongPressOrHoverCssClasses_1 = __importDefault(__webpack_require__(/*! ../../../util/addLongPressOrHoverCssClasses */ \"./node_modules/js-draw/dist/cjs/util/addLongPressOrHoverCssClasses.js\"));\nconst constants_1 = __webpack_require__(/*! ../../constants */ \"./node_modules/js-draw/dist/cjs/toolbar/constants.js\");\nlet idCounter = 0;\n/**\n * Creates a widget that allows users to select one of serveral items from a list.\n *\n * `ChoiceIdType` should be `string`, a `number`, or an `enum` (or similar).\n *\n * If this input is set to an ID that is not in `choices`, no item is selected.\n */\nconst makeGridSelector = (\n// Text before the grid selector used as a label\nlabelText, defaultId, choices) => {\n    const outerContainer = document.createElement('div');\n    outerContainer.classList.add(`${constants_1.toolbarCSSPrefix}grid-selector`);\n    const selectedValue = ReactiveValue_1.MutableReactiveValue.fromInitialValue(defaultId);\n    const menuContainer = document.createElement('div');\n    menuContainer.setAttribute('role', 'menu');\n    menuContainer.id = `${constants_1.toolbarCSSPrefix}-grid-select-id-${idCounter++}`;\n    (0, stopPropagationOfScrollingWheelEvents_1.default)(menuContainer);\n    const label = document.createElement('label');\n    label.textContent = labelText;\n    label.htmlFor = menuContainer.id;\n    outerContainer.appendChild(label);\n    // All buttons in a radiogroup need the same name attribute.\n    let radiogroupName = `${constants_1.toolbarCSSPrefix}-grid-selector-${idCounter++}`;\n    const createChoiceButton = (record) => {\n        const buttonContainer = document.createElement('div');\n        buttonContainer.classList.add('choice-button');\n        const button = document.createElement('input');\n        button.type = 'radio';\n        button.id = `${constants_1.toolbarCSSPrefix}-grid-select-button-${idCounter++}`;\n        // Some toolbars only show the label on hover. Having long press or hover\n        // CSS classes are helpful here.\n        (0, addLongPressOrHoverCssClasses_1.default)(buttonContainer);\n        // Clicking any part of labelContainer triggers the radio button.\n        const labelContainer = document.createElement('label');\n        const rebuildLabel = () => {\n            labelContainer.setAttribute('title', record.title);\n            const labelText = document.createElement('span');\n            labelText.classList.add('button-label-text');\n            const icon = record.makeIcon();\n            icon.classList.add('icon');\n            // The title of the record\n            labelText.innerText = record.title;\n            labelContainer.htmlFor = button.id;\n            labelContainer.replaceChildren(icon, labelText);\n        };\n        rebuildLabel();\n        // Mark the button as belonging to the current group (causes\n        // other buttons in the same group to automatically uncheck\n        // when this button is checked).\n        const updateButtonRadiogroupName = () => {\n            button.name = radiogroupName;\n        };\n        updateButtonRadiogroupName();\n        const updateButtonCSS = () => {\n            if (button.checked) {\n                buttonContainer.classList.add('checked');\n            }\n            else {\n                buttonContainer.classList.remove('checked');\n            }\n        };\n        button.oninput = () => {\n            // Setting the selected value fires an event that causes the value\n            // of this button to be set.\n            if (button.checked) {\n                selectedValue.set(record.id);\n            }\n            updateButtonCSS();\n        };\n        button.onfocus = () => {\n            if (buttonContainer.querySelector(':focus-visible')) {\n                buttonContainer.classList.add('focus-visible');\n            }\n        };\n        button.onblur = () => {\n            buttonContainer.classList.remove('focus-visible');\n        };\n        // Prevent the right-click menu from being shown on long-press\n        // (important for some toolbars that use long-press gestures to\n        // show grid selector labels).\n        buttonContainer.oncontextmenu = (event) => {\n            event.preventDefault();\n        };\n        buttonContainer.replaceChildren(button, labelContainer);\n        menuContainer.appendChild(buttonContainer);\n        // Set whether the current button is checked\n        const setChecked = (checked) => {\n            button.checked = checked;\n            updateButtonCSS();\n        };\n        setChecked(false);\n        // Updates the factory's icon based on the current style of the tool.\n        const updateIcon = () => {\n            rebuildLabel();\n        };\n        return {\n            choiceRecord: record,\n            setChecked,\n            updateIcon,\n            updateButtonRadiogroupName,\n        };\n    };\n    const buttons = [];\n    for (const choice of choices) {\n        buttons.push(createChoiceButton(choice));\n    }\n    // invariant: buttons.length = choices.length\n    // However, it is still possible that selectedValue does not correspond\n    // to a choice in `choices`. This is acceptable.\n    outerContainer.appendChild(menuContainer);\n    selectedValue.onUpdateAndNow((choiceId) => {\n        for (let i = 0; i < buttons.length; i++) {\n            buttons[i].setChecked(buttons[i].choiceRecord.id === choiceId);\n        }\n    });\n    const result = {\n        value: selectedValue,\n        _radiogroupName: radiogroupName,\n        linkWith: (other) => {\n            result._radiogroupName = other._radiogroupName;\n            radiogroupName = other._radiogroupName;\n            for (const button of buttons) {\n                button.updateButtonRadiogroupName();\n            }\n        },\n        updateIcons: () => {\n            buttons.forEach((button) => button.updateIcon());\n        },\n        getRootElement() {\n            return outerContainer;\n        },\n        addTo: (parent) => {\n            parent.appendChild(outerContainer);\n        },\n    };\n    return result;\n};\nexports[\"default\"] = makeGridSelector;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/toolbar/widgets/components/makeGridSelector.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/toolbar/widgets/components/makeSeparator.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/toolbar/widgets/components/makeSeparator.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * Creates a separator element that renders a line and, optionally, a header.\n */\nconst makeSeparator = (header = '') => {\n    const container = document.createElement('div');\n    container.classList.add('tool-dropdown-separator');\n    container.innerText = header;\n    return {\n        addTo: (parent) => {\n            parent.appendChild(container);\n        },\n    };\n};\nexports[\"default\"] = makeSeparator;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/toolbar/widgets/components/makeSeparator.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/toolbar/widgets/components/makeSnappedList.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/toolbar/widgets/components/makeSnappedList.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst stopPropagationOfScrollingWheelEvents_1 = __importDefault(__webpack_require__(/*! ../../../util/stopPropagationOfScrollingWheelEvents */ \"./node_modules/js-draw/dist/cjs/util/stopPropagationOfScrollingWheelEvents.js\"));\nconst ReactiveValue_1 = __webpack_require__(/*! ../../../util/ReactiveValue */ \"./node_modules/js-draw/dist/cjs/util/ReactiveValue.js\");\n/**\n * Creates a list that snaps to each item and reports the selected item.\n */\nconst makeSnappedList = (itemsValue) => {\n    const container = document.createElement('div');\n    container.classList.add('toolbar-snapped-scroll-list');\n    const scroller = document.createElement('div');\n    scroller.classList.add('scroller');\n    const visibleIndex = ReactiveValue_1.MutableReactiveValue.fromInitialValue(0);\n    let observer = null;\n    const makePageMarkers = () => {\n        const markerContainer = document.createElement('div');\n        markerContainer.classList.add('page-markers');\n        // Keyboard focus should go to the main scrolling list.\n        // TODO: Does it make sense for the page marker list to be focusable?\n        markerContainer.setAttribute('tabindex', '-1');\n        const markers = [];\n        const pairedItems = ReactiveValue_1.ReactiveValue.union([\n            visibleIndex,\n            itemsValue,\n        ]);\n        pairedItems.onUpdateAndNow(([currentVisibleIndex, items]) => {\n            let addedOrRemovedMarkers = false;\n            // Items may have been removed from the list of pages. Make the markers reflect that.\n            while (items.length < markers.length) {\n                markers.pop();\n                addedOrRemovedMarkers = true;\n            }\n            let activeMarker;\n            for (let i = 0; i < items.length; i++) {\n                let marker;\n                if (i >= markers.length) {\n                    marker = document.createElement('div');\n                    // Use a separate content element to increase the clickable size of\n                    // the marker.\n                    const content = document.createElement('div');\n                    content.classList.add('content');\n                    marker.replaceChildren(content);\n                    markers.push(marker);\n                    addedOrRemovedMarkers = true;\n                }\n                else {\n                    marker = markers[i];\n                }\n                marker.classList.add('marker');\n                if (i === currentVisibleIndex) {\n                    marker.classList.add('-active');\n                    activeMarker = marker;\n                }\n                else {\n                    marker.classList.remove('-active');\n                }\n                const markerIndex = i;\n                marker.onclick = () => {\n                    wrappedItems\n                        .get()[markerIndex]?.element?.scrollIntoView({ block: 'nearest', behavior: 'smooth' });\n                };\n            }\n            // Only call .replaceChildren when necessary -- doing so on every change would\n            // break transitions.\n            if (addedOrRemovedMarkers) {\n                markerContainer.replaceChildren(...markers);\n            }\n            // Handles the case where there are many markers and the current is offscreen\n            if (activeMarker && markerContainer.scrollHeight > container.clientHeight) {\n                activeMarker.scrollIntoView({ block: 'nearest' });\n            }\n            if (markers.length === 1) {\n                markerContainer.classList.add('-one-element');\n            }\n            else {\n                markerContainer.classList.remove('-one-element');\n            }\n        });\n        return markerContainer;\n    };\n    const createObserver = () => {\n        observer = new IntersectionObserver((entries) => {\n            for (const entry of entries) {\n                if (entry.isIntersecting && entry.intersectionRatio > 0.7) {\n                    const indexString = entry.target.getAttribute('data-item-index');\n                    if (indexString === null)\n                        throw new Error('Could not find attribute data-item-index');\n                    const index = Number(indexString);\n                    visibleIndex.set(index);\n                    break;\n                }\n            }\n        }, {\n            // Element to use as the boudning box with which to intersect.\n            // See https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API\n            root: scroller,\n            // Fraction of an element that must be visible to trigger the callback:\n            threshold: 0.9,\n        });\n    };\n    const destroyObserver = () => {\n        if (observer) {\n            observer.disconnect();\n            visibleIndex.set(0);\n            observer = null;\n        }\n    };\n    const wrappedItems = ReactiveValue_1.ReactiveValue.map(itemsValue, (items) => {\n        return items.map((item, index) => {\n            const wrapper = document.createElement('div');\n            if (item.element.parentElement)\n                item.element.remove();\n            wrapper.appendChild(item.element);\n            wrapper.classList.add('item');\n            wrapper.setAttribute('data-item-index', `${index}`);\n            return {\n                element: wrapper,\n                data: item.data,\n            };\n        });\n    });\n    const lastItems = [];\n    wrappedItems.onUpdateAndNow((items) => {\n        visibleIndex.set(-1);\n        for (const item of lastItems) {\n            observer?.unobserve(item.element);\n        }\n        scroller.replaceChildren();\n        // An observer is only necessary if there are multiple items to scroll through.\n        if (items.length > 1) {\n            createObserver();\n        }\n        else {\n            destroyObserver();\n        }\n        // Different styling is applied when empty\n        if (items.length === 0) {\n            container.classList.add('-empty');\n        }\n        else {\n            container.classList.remove('-empty');\n        }\n        for (const item of items) {\n            scroller.appendChild(item.element);\n        }\n        visibleIndex.set(0);\n        if (observer) {\n            for (const item of items) {\n                observer.observe(item.element);\n            }\n        }\n    });\n    const visibleItem = ReactiveValue_1.ReactiveValue.map(visibleIndex, (index) => {\n        const values = itemsValue.get();\n        if (0 <= index && index < values.length) {\n            return values[index].data;\n        }\n        return null;\n    });\n    // makeSnappedList is generally shown within the toolbar. This allows users to\n    // scroll it with a touchpad.\n    (0, stopPropagationOfScrollingWheelEvents_1.default)(scroller);\n    container.replaceChildren(makePageMarkers(), scroller);\n    return {\n        container,\n        visibleItem,\n    };\n};\nexports[\"default\"] = makeSnappedList;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/toolbar/widgets/components/makeSnappedList.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/toolbar/widgets/components/makeThicknessSlider.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/toolbar/widgets/components/makeThicknessSlider.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\nconst constants_1 = __webpack_require__(/*! ../../constants */ \"./node_modules/js-draw/dist/cjs/toolbar/constants.js\");\nlet idCounter = 0;\nconst makeThicknessSlider = (context, onChange) => {\n    const container = document.createElement('div');\n    const thicknessLabel = document.createElement('label');\n    const thicknessInput = document.createElement('input');\n    container.classList.add(`${constants_1.toolbarCSSPrefix}thicknessSliderContainer`);\n    // Give inputs IDs so we can label them with a <label for=...>Label text</label>\n    thicknessInput.id = `${constants_1.toolbarCSSPrefix}thicknessInput${idCounter++}`;\n    thicknessLabel.innerText = context.localization.thicknessLabel;\n    thicknessLabel.setAttribute('for', thicknessInput.id);\n    // Use a logarithmic scale for thicknessInput (finer control over thinner strokewidths.)\n    const inverseThicknessInputFn = (t) => Math.log10(t);\n    const thicknessInputFn = (t) => 10 ** t;\n    thicknessInput.type = 'range';\n    thicknessInput.oninput = () => {\n        onChange(thicknessInputFn(parseFloat(thicknessInput.value)));\n    };\n    container.appendChild(thicknessLabel);\n    container.appendChild(thicknessInput);\n    const setBounds = (min, max) => {\n        const round = (value, roundUp) => {\n            const roundFn = roundUp ? Math.ceil : Math.floor;\n            return roundFn(value * 100) / 100;\n        };\n        const sliderMin = round(inverseThicknessInputFn(min), false);\n        const sliderMax = round(inverseThicknessInputFn(max), true);\n        thicknessInput.min = `${sliderMin}`;\n        thicknessInput.max = `${sliderMax}`;\n        thicknessInput.step = `${(0, math_1.toRoundedString)((sliderMax - sliderMin) / 20)}`;\n    };\n    setBounds(2, 262);\n    return {\n        container,\n        addTo: (parent) => {\n            parent.appendChild(container);\n        },\n        setBounds,\n        setValue: (thickness) => {\n            thicknessInput.value = inverseThicknessInputFn(thickness).toString();\n        },\n    };\n};\nexports[\"default\"] = makeThicknessSlider;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/toolbar/widgets/components/makeThicknessSlider.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/toolbar/widgets/keybindings.js":
/*!**********************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/toolbar/widgets/keybindings.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.exitKeyboardShortcut = exports.saveKeyboardShortcut = exports.selectStrokeTypeKeyboardShortcutIds = exports.resizeImageToSelectionKeyboardShortcut = void 0;\nconst KeyboardShortcutManager_1 = __importDefault(__webpack_require__(/*! ../../shortcuts/KeyboardShortcutManager */ \"./node_modules/js-draw/dist/cjs/shortcuts/KeyboardShortcutManager.js\"));\n// Selection\nexports.resizeImageToSelectionKeyboardShortcut = 'jsdraw.toolbar.SelectionTool.resizeImageToSelection';\nKeyboardShortcutManager_1.default.registerDefaultKeyboardShortcut(exports.resizeImageToSelectionKeyboardShortcut, ['ctrlOrMeta+r'], 'Resize image to selection');\n// Pen tool\nexports.selectStrokeTypeKeyboardShortcutIds = [1, 2, 3, 4, 5, 6, 7, 8, 9].map((id) => `jsdraw.toolbar.PenTool.select-pen-${id}`);\nfor (let i = 0; i < exports.selectStrokeTypeKeyboardShortcutIds.length; i++) {\n    const id = exports.selectStrokeTypeKeyboardShortcutIds[i];\n    KeyboardShortcutManager_1.default.registerDefaultKeyboardShortcut(id, [`CtrlOrMeta+Digit${i + 1}`], 'Select pen style ' + (i + 1));\n}\n// Save\nexports.saveKeyboardShortcut = 'jsdraw.toolbar.SaveActionWidget.save';\nKeyboardShortcutManager_1.default.registerDefaultKeyboardShortcut(exports.saveKeyboardShortcut, ['ctrlOrMeta+KeyS'], 'Save');\n// Exit\nexports.exitKeyboardShortcut = 'jsdraw.toolbar.ExitActionWidget.exit';\nKeyboardShortcutManager_1.default.registerDefaultKeyboardShortcut(exports.exitKeyboardShortcut, ['Alt+KeyQ'], 'Exit');\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/toolbar/widgets/keybindings.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/toolbar/widgets/layout/DropdownLayoutManager.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/toolbar/widgets/layout/DropdownLayoutManager.js ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst types_1 = __webpack_require__(/*! ../../../types */ \"./node_modules/js-draw/dist/cjs/types.js\");\nconst EventDispatcher_1 = __importDefault(__webpack_require__(/*! ../../../EventDispatcher */ \"./node_modules/js-draw/dist/cjs/EventDispatcher.js\"));\nconst constants_1 = __webpack_require__(/*! ../../constants */ \"./node_modules/js-draw/dist/cjs/toolbar/constants.js\");\nconst ReactiveValue_1 = __webpack_require__(/*! ../../../util/ReactiveValue */ \"./node_modules/js-draw/dist/cjs/util/ReactiveValue.js\");\nvar DropdownEventType;\n(function (DropdownEventType) {\n    DropdownEventType[DropdownEventType[\"DropdownShown\"] = 0] = \"DropdownShown\";\n    DropdownEventType[DropdownEventType[\"DropdownHidden\"] = 1] = \"DropdownHidden\";\n})(DropdownEventType || (DropdownEventType = {}));\nclass Dropdown {\n    constructor(parent, notifier, onDestroy) {\n        this.parent = parent;\n        this.notifier = notifier;\n        this.onDestroy = onDestroy;\n        this.dropdownToggleListener = null;\n        this.hideDropdownTimeout = null;\n        this.visible = ReactiveValue_1.ReactiveValue.fromInitialValue(false);\n        this.dropdownContainer = document.createElement('div');\n        this.dropdownContainer.classList.add(`${constants_1.toolbarCSSPrefix}dropdown`);\n        this.dropdownContainer.classList.add('hidden');\n        parent.target.insertAdjacentElement('afterend', this.dropdownContainer);\n        // When another dropdown is shown,\n        this.dropdownToggleListener = this.notifier.on(DropdownEventType.DropdownShown, (evt) => {\n            if (evt.dropdown !== this &&\n                // Don't hide if a submenu was shown (it might be a submenu of\n                // the current menu).\n                evt.fromToplevelDropdown) {\n                this.setVisible(false);\n            }\n        });\n    }\n    onActivated() {\n        // Do nothing.\n    }\n    repositionDropdown() {\n        const dropdownBBox = this.dropdownContainer.getBoundingClientRect();\n        const screenWidth = document.scrollingElement?.clientWidth ?? document.body.clientHeight;\n        const screenHeight = document.scrollingElement?.clientHeight ?? document.body.clientHeight;\n        let translateX = undefined;\n        let translateY = undefined;\n        if (dropdownBBox.left > screenWidth / 2) {\n            const targetElem = this.parent.target;\n            translateX = `calc(${targetElem.clientWidth + 'px'} - 100%)`;\n        }\n        // Shift the dropdown if it's off the screen, but only if doing so moves it on to the screen\n        // (prevents dropdowns from going almost completely offscreen on small screens).\n        if (dropdownBBox.bottom > screenHeight && dropdownBBox.top - dropdownBBox.height > 0) {\n            const targetElem = this.parent.target;\n            translateY = `calc(-${targetElem.clientHeight}px - 100%)`;\n        }\n        // Use .translate so as not to conflict with CSS animating the\n        // transform property.\n        if (translateX || translateY) {\n            this.dropdownContainer.style.translate = `${translateX ?? '0'} ${translateY ?? '0'}`;\n        }\n        else {\n            this.dropdownContainer.style.translate = '';\n        }\n    }\n    setVisible(visible) {\n        const currentlyVisible = this.visible.get();\n        if (currentlyVisible === visible) {\n            return;\n        }\n        // If waiting to hide the dropdown, cancel it.\n        if (this.hideDropdownTimeout) {\n            clearTimeout(this.hideDropdownTimeout);\n            this.hideDropdownTimeout = null;\n            this.dropdownContainer.classList.remove('hiding');\n            this.repositionDropdown();\n        }\n        const animationDuration = 150; // ms\n        this.visible.set(visible);\n        if (visible) {\n            this.dropdownContainer.classList.remove('hidden');\n            this.notifier.dispatch(DropdownEventType.DropdownShown, {\n                dropdown: this,\n                fromToplevelDropdown: this.parent.isToplevel(),\n            });\n            this.repositionDropdown();\n        }\n        else {\n            this.notifier.dispatch(DropdownEventType.DropdownHidden, {\n                dropdown: this,\n                fromToplevelDropdown: this.parent.isToplevel(),\n            });\n            this.dropdownContainer.classList.add('hiding');\n            // Hide the dropdown *slightly* before the animation finishes. This\n            // prevents flickering in some browsers.\n            const hideDelay = animationDuration * 0.95;\n            this.hideDropdownTimeout = setTimeout(() => {\n                this.dropdownContainer.classList.add('hidden');\n                this.dropdownContainer.classList.remove('hiding');\n                this.repositionDropdown();\n            }, hideDelay);\n        }\n        // Animate\n        const animationName = `var(--dropdown-${visible ? 'show' : 'hide'}-animation)`;\n        this.dropdownContainer.style.animation = `${animationDuration}ms ease ${animationName}`;\n    }\n    requestShow() {\n        this.setVisible(true);\n    }\n    requestHide() {\n        this.setVisible(false);\n    }\n    appendChild(item) {\n        this.dropdownContainer.appendChild(item);\n    }\n    clearChildren() {\n        this.dropdownContainer.replaceChildren();\n    }\n    destroy() {\n        this.setVisible(false);\n        this.dropdownContainer.remove();\n        this.dropdownToggleListener?.remove();\n        // Allow children to be added to other parents\n        this.clearChildren();\n        this.onDestroy();\n    }\n}\nclass DropdownLayoutManager {\n    constructor(announceForAccessibility, localization) {\n        this.localization = localization;\n        this.dropdowns = new Set();\n        this.listeners = [];\n        this.connectedNotifiers = [];\n        this.notifier = new EventDispatcher_1.default();\n        this.notifier.on(DropdownEventType.DropdownShown, ({ dropdown, fromToplevelDropdown }) => {\n            if (!dropdown)\n                return;\n            announceForAccessibility(this.localization.dropdownShown(dropdown.parent.getTitle()));\n            // Share the event with other connected notifiers\n            this.connectedNotifiers.forEach((notifier) => {\n                notifier.dispatch(types_1.EditorEventType.ToolbarDropdownShown, {\n                    kind: types_1.EditorEventType.ToolbarDropdownShown,\n                    fromToplevelDropdown,\n                    layoutManager: this,\n                });\n            });\n        });\n        this.notifier.on(DropdownEventType.DropdownHidden, ({ dropdown }) => {\n            if (!dropdown)\n                return;\n            announceForAccessibility(this.localization.dropdownHidden(dropdown.parent.getTitle()));\n        });\n    }\n    connectToEditorNotifier(notifier) {\n        this.connectedNotifiers.push(notifier);\n        this.refreshListeners();\n    }\n    /** Creates a dropdown within `parent`. */\n    createToolMenu(parent) {\n        const dropdown = new Dropdown(parent, this.notifier, () => {\n            this.dropdowns.delete(dropdown);\n            this.refreshListeners();\n        });\n        this.dropdowns.add(dropdown);\n        this.refreshListeners();\n        return dropdown;\n    }\n    /**\n     * Adds/removes listeners based on whether we have any managed dropdowns.\n     *\n     * We attempt to clean up all resources when `dropdowns.size == 0`, at which\n     * point, an instance of this could be safely garbage collected.\n     */\n    refreshListeners() {\n        const clearListeners = () => {\n            // Remove all listeners & resources that won't be garbage collected.\n            this.listeners.forEach((l) => l.remove());\n            this.listeners = [];\n        };\n        if (this.dropdowns.size === 0) {\n            clearListeners();\n        }\n        else if (this.listeners.length !== this.connectedNotifiers.length) {\n            clearListeners();\n            this.listeners = this.connectedNotifiers.map((notifier) => {\n                return notifier.on(types_1.EditorEventType.ToolbarDropdownShown, (evt) => {\n                    if (evt.kind !== types_1.EditorEventType.ToolbarDropdownShown ||\n                        // Don't forward to ourselves events that we originally triggered.\n                        evt.layoutManager === this) {\n                        return;\n                    }\n                    this.notifier.dispatch(DropdownEventType.DropdownShown, {\n                        fromToplevelDropdown: evt.fromToplevelDropdown,\n                    });\n                });\n            });\n        }\n    }\n}\nexports[\"default\"] = DropdownLayoutManager;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/toolbar/widgets/layout/DropdownLayoutManager.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/toolbar/widgets/layout/EdgeToolbarLayoutManager.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/toolbar/widgets/layout/EdgeToolbarLayoutManager.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst ReactiveValue_1 = __webpack_require__(/*! ../../../util/ReactiveValue */ \"./node_modules/js-draw/dist/cjs/util/ReactiveValue.js\");\nclass EdgeToolbarLayoutManager {\n    // @internal\n    constructor(setSidebarContent, sidebarTitle, sidebarVisibility, announceForAccessibility, localization) {\n        this.setSidebarContent = setSidebarContent;\n        this.sidebarTitle = sidebarTitle;\n        this.sidebarVisibility = sidebarVisibility;\n        this.announceForAccessibility = announceForAccessibility;\n        this.localization = localization;\n        this.visibleWidgetContent = ReactiveValue_1.ReactiveValue.fromInitialValue(null);\n    }\n    /** Creates a dropdown within `parent`. */\n    createToolMenu(parent) {\n        const contentElem = document.createElement('div');\n        let result = null;\n        const visible = ReactiveValue_1.ReactiveValue.fromCallback(() => {\n            return this.visibleWidgetContent.get() === result && this.sidebarVisibility.get();\n        }, [this.visibleWidgetContent, this.sidebarVisibility]);\n        result = {\n            visible,\n            requestShow: () => {\n                this.setSidebarContent(contentElem);\n                this.sidebarTitle.set(parent.getTitle());\n                // Set visibleWidgetContent first -- this causes the previously visible (if any)\n                // item to not be sent a shown event.\n                this.visibleWidgetContent.set(result);\n                this.sidebarVisibility.set(true);\n                this.announceForAccessibility(this.localization.dropdownShown(parent.getTitle()));\n            },\n            onActivated: () => {\n                // TODO: Only request show when in sidebar mode\n                //result?.requestShow();\n            },\n            requestHide: () => {\n                if (visible.get()) {\n                    this.sidebarVisibility.set(false);\n                }\n            },\n            appendChild: (item) => {\n                contentElem.appendChild(item);\n            },\n            clearChildren: () => {\n                contentElem.replaceChildren();\n            },\n            destroy: () => {\n                result?.requestHide();\n                if (contentElem.parentElement) {\n                    contentElem.remove();\n                }\n                if (this.visibleWidgetContent.get() === result) {\n                    this.visibleWidgetContent.set(null);\n                }\n            },\n        };\n        return result;\n    }\n}\nexports[\"default\"] = EdgeToolbarLayoutManager;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/toolbar/widgets/layout/EdgeToolbarLayoutManager.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/toolbar/widgets/lib.js":
/*!**************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/toolbar/widgets/lib.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DocumentPropertiesWidget = exports.InsertImageWidget = exports.EraserToolWidget = exports.SelectionToolWidget = exports.HandToolWidget = exports.TextToolWidget = exports.PenToolWidget = exports.ToolbarWidgetTag = exports.BaseWidget = exports.BaseToolWidget = exports.ActionButtonWidget = void 0;\nvar ActionButtonWidget_1 = __webpack_require__(/*! ./ActionButtonWidget */ \"./node_modules/js-draw/dist/cjs/toolbar/widgets/ActionButtonWidget.js\");\nObject.defineProperty(exports, \"ActionButtonWidget\", ({ enumerable: true, get: function () { return __importDefault(ActionButtonWidget_1).default; } }));\nvar BaseToolWidget_1 = __webpack_require__(/*! ./BaseToolWidget */ \"./node_modules/js-draw/dist/cjs/toolbar/widgets/BaseToolWidget.js\");\nObject.defineProperty(exports, \"BaseToolWidget\", ({ enumerable: true, get: function () { return __importDefault(BaseToolWidget_1).default; } }));\nvar BaseWidget_1 = __webpack_require__(/*! ./BaseWidget */ \"./node_modules/js-draw/dist/cjs/toolbar/widgets/BaseWidget.js\");\nObject.defineProperty(exports, \"BaseWidget\", ({ enumerable: true, get: function () { return __importDefault(BaseWidget_1).default; } }));\nObject.defineProperty(exports, \"ToolbarWidgetTag\", ({ enumerable: true, get: function () { return BaseWidget_1.ToolbarWidgetTag; } }));\nvar PenToolWidget_1 = __webpack_require__(/*! ./PenToolWidget */ \"./node_modules/js-draw/dist/cjs/toolbar/widgets/PenToolWidget.js\");\nObject.defineProperty(exports, \"PenToolWidget\", ({ enumerable: true, get: function () { return __importDefault(PenToolWidget_1).default; } }));\nvar TextToolWidget_1 = __webpack_require__(/*! ./TextToolWidget */ \"./node_modules/js-draw/dist/cjs/toolbar/widgets/TextToolWidget.js\");\nObject.defineProperty(exports, \"TextToolWidget\", ({ enumerable: true, get: function () { return __importDefault(TextToolWidget_1).default; } }));\nvar HandToolWidget_1 = __webpack_require__(/*! ./HandToolWidget */ \"./node_modules/js-draw/dist/cjs/toolbar/widgets/HandToolWidget.js\");\nObject.defineProperty(exports, \"HandToolWidget\", ({ enumerable: true, get: function () { return __importDefault(HandToolWidget_1).default; } }));\nvar SelectionToolWidget_1 = __webpack_require__(/*! ./SelectionToolWidget */ \"./node_modules/js-draw/dist/cjs/toolbar/widgets/SelectionToolWidget.js\");\nObject.defineProperty(exports, \"SelectionToolWidget\", ({ enumerable: true, get: function () { return __importDefault(SelectionToolWidget_1).default; } }));\nvar EraserToolWidget_1 = __webpack_require__(/*! ./EraserToolWidget */ \"./node_modules/js-draw/dist/cjs/toolbar/widgets/EraserToolWidget.js\");\nObject.defineProperty(exports, \"EraserToolWidget\", ({ enumerable: true, get: function () { return __importDefault(EraserToolWidget_1).default; } }));\nvar InsertImageWidget_1 = __webpack_require__(/*! ./InsertImageWidget/InsertImageWidget */ \"./node_modules/js-draw/dist/cjs/toolbar/widgets/InsertImageWidget/InsertImageWidget.js\");\nObject.defineProperty(exports, \"InsertImageWidget\", ({ enumerable: true, get: function () { return __importDefault(InsertImageWidget_1).default; } }));\nvar DocumentPropertiesWidget_1 = __webpack_require__(/*! ./DocumentPropertiesWidget */ \"./node_modules/js-draw/dist/cjs/toolbar/widgets/DocumentPropertiesWidget.js\");\nObject.defineProperty(exports, \"DocumentPropertiesWidget\", ({ enumerable: true, get: function () { return __importDefault(DocumentPropertiesWidget_1).default; } }));\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/toolbar/widgets/lib.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/tools/BaseTool.js":
/*!*********************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/tools/BaseTool.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _BaseTool_enabled, _BaseTool_group, _BaseTool_inputMapper, _BaseTool_readOnlyEditorChangeListener;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst types_1 = __webpack_require__(/*! ../types */ \"./node_modules/js-draw/dist/cjs/types.js\");\nconst inputEvents_1 = __webpack_require__(/*! ../inputEvents */ \"./node_modules/js-draw/dist/cjs/inputEvents.js\");\nconst ReactiveValue_1 = __webpack_require__(/*! ../util/ReactiveValue */ \"./node_modules/js-draw/dist/cjs/util/ReactiveValue.js\");\nclass BaseTool {\n    constructor(notifier, description) {\n        this.notifier = notifier;\n        this.description = description;\n        _BaseTool_enabled.set(this, void 0);\n        _BaseTool_group.set(this, null);\n        _BaseTool_inputMapper.set(this, null);\n        _BaseTool_readOnlyEditorChangeListener.set(this, null);\n        __classPrivateFieldSet(this, _BaseTool_enabled, ReactiveValue_1.ReactiveValue.fromInitialValue(true), \"f\");\n        __classPrivateFieldGet(this, _BaseTool_enabled, \"f\").onUpdate((enabled) => {\n            // Ensure that at most one tool in the group is enabled.\n            if (enabled) {\n                __classPrivateFieldGet(this, _BaseTool_group, \"f\")?.notifyEnabled(this);\n                this.notifier.dispatch(types_1.EditorEventType.ToolEnabled, {\n                    kind: types_1.EditorEventType.ToolEnabled,\n                    tool: this,\n                });\n            }\n            else {\n                this.notifier.dispatch(types_1.EditorEventType.ToolDisabled, {\n                    kind: types_1.EditorEventType.ToolDisabled,\n                    tool: this,\n                });\n            }\n        });\n    }\n    /** Override this to allow this tool to be enabled in a read-only editor */\n    canReceiveInputInReadOnlyEditor() {\n        return false;\n    }\n    setInputMapper(mapper) {\n        __classPrivateFieldSet(this, _BaseTool_inputMapper, mapper, \"f\");\n        if (mapper) {\n            mapper.setEmitListener((event) => this.dispatchEventToCallback(event));\n        }\n    }\n    getInputMapper() {\n        return __classPrivateFieldGet(this, _BaseTool_inputMapper, \"f\");\n    }\n    dispatchEventToCallback(event) {\n        let exhaustivenessCheck;\n        switch (event.kind) {\n            case inputEvents_1.InputEvtType.PointerDownEvt:\n                return this.onPointerDown(event);\n            case inputEvents_1.InputEvtType.PointerMoveEvt:\n                this.onPointerMove(event);\n                break;\n            case inputEvents_1.InputEvtType.PointerUpEvt:\n                return this.onPointerUp(event) ?? false;\n            case inputEvents_1.InputEvtType.GestureCancelEvt:\n                this.onGestureCancel(event);\n                break;\n            case inputEvents_1.InputEvtType.WheelEvt:\n                return this.onWheel(event);\n            case inputEvents_1.InputEvtType.KeyPressEvent:\n                return this.onKeyPress(event);\n            case inputEvents_1.InputEvtType.KeyUpEvent:\n                return this.onKeyUp(event);\n            case inputEvents_1.InputEvtType.CopyEvent:\n                return this.onCopy(event);\n            case inputEvents_1.InputEvtType.PasteEvent:\n                return this.onPaste(event);\n            case inputEvents_1.InputEvtType.ContextMenu:\n                return this.onContextMenu(event);\n            default:\n                exhaustivenessCheck = event;\n                return exhaustivenessCheck;\n        }\n        return true;\n    }\n    // @internal\n    onEvent(event) {\n        if (__classPrivateFieldGet(this, _BaseTool_inputMapper, \"f\")) {\n            return __classPrivateFieldGet(this, _BaseTool_inputMapper, \"f\").onEvent(event);\n        }\n        return this.dispatchEventToCallback(event);\n    }\n    /**\n     * Returns true iff the tool handled the event and thus should receive additional\n     * events.\n     */\n    onPointerDown(_event) {\n        return false;\n    }\n    onPointerMove(_event) { }\n    /**\n     * Returns true iff there are additional pointers down and the tool should\n     * remain active to handle the additional events.\n     *\n     * For most purposes, this should return `false` or nothing.\n     */\n    onPointerUp(_event) { }\n    onGestureCancel(_event) { }\n    onWheel(_event) {\n        return false;\n    }\n    onCopy(_event) {\n        return false;\n    }\n    onPaste(_event) {\n        return false;\n    }\n    onKeyPress(_event) {\n        return false;\n    }\n    onKeyUp(_event) {\n        return false;\n    }\n    onContextMenu(_event) {\n        return false;\n    }\n    /**\n     * Return true if, while this tool is active, `_event` can be delivered to\n     * another tool that is higher priority than this.\n     * @internal May be renamed\n     */\n    eventCanBeDeliveredToNonActiveTool(_event) {\n        return true;\n    }\n    setEnabled(enabled) {\n        __classPrivateFieldGet(this, _BaseTool_enabled, \"f\").set(enabled);\n    }\n    isEnabled() {\n        return __classPrivateFieldGet(this, _BaseTool_enabled, \"f\").get();\n    }\n    /**\n     * Returns a {@link ReactiveValue} that updates based on whether this tool is\n     * enabled.\n     *\n     * @example\n     * ```ts\n     * const tool = new SomeTool();\n     *\n     * // Watch for changes in enabled status\n     * tool.enabledValue().onUpdate(enabled => doSomething(enabled));\n     * ```\n     */\n    enabledValue() {\n        return __classPrivateFieldGet(this, _BaseTool_enabled, \"f\");\n    }\n    // Connect this tool to a set of other tools, ensuring that at most one\n    // of the tools in the group is enabled.\n    setToolGroup(group) {\n        if (this.isEnabled()) {\n            group.notifyEnabled(this);\n        }\n        __classPrivateFieldSet(this, _BaseTool_group, group, \"f\");\n    }\n    getToolGroup() {\n        if (__classPrivateFieldGet(this, _BaseTool_group, \"f\")) {\n            return __classPrivateFieldGet(this, _BaseTool_group, \"f\");\n        }\n        return null;\n    }\n    // Called when the tool is removed/when the editor is destroyed.\n    // Subclasses that override this method **must call super.onDestroy()**.\n    onDestroy() {\n        __classPrivateFieldGet(this, _BaseTool_readOnlyEditorChangeListener, \"f\")?.remove();\n        __classPrivateFieldSet(this, _BaseTool_readOnlyEditorChangeListener, null, \"f\");\n        __classPrivateFieldSet(this, _BaseTool_group, null, \"f\");\n    }\n}\n_BaseTool_enabled = new WeakMap(), _BaseTool_group = new WeakMap(), _BaseTool_inputMapper = new WeakMap(), _BaseTool_readOnlyEditorChangeListener = new WeakMap();\nexports[\"default\"] = BaseTool;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/tools/BaseTool.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/tools/Eraser.js":
/*!*******************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/tools/Eraser.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EraserMode = void 0;\nconst types_1 = __webpack_require__(/*! ../types */ \"./node_modules/js-draw/dist/cjs/types.js\");\nconst BaseTool_1 = __importDefault(__webpack_require__(/*! ./BaseTool */ \"./node_modules/js-draw/dist/cjs/tools/BaseTool.js\"));\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\nconst Erase_1 = __importDefault(__webpack_require__(/*! ../commands/Erase */ \"./node_modules/js-draw/dist/cjs/commands/Erase.js\"));\nconst Pointer_1 = __webpack_require__(/*! ../Pointer */ \"./node_modules/js-draw/dist/cjs/Pointer.js\");\nconst keybindings_1 = __webpack_require__(/*! ./keybindings */ \"./node_modules/js-draw/dist/cjs/tools/keybindings.js\");\nconst ReactiveValue_1 = __webpack_require__(/*! ../util/ReactiveValue */ \"./node_modules/js-draw/dist/cjs/util/ReactiveValue.js\");\nconst EditorImage_1 = __importDefault(__webpack_require__(/*! ../image/EditorImage */ \"./node_modules/js-draw/dist/cjs/image/EditorImage.js\"));\nconst uniteCommands_1 = __importDefault(__webpack_require__(/*! ../commands/uniteCommands */ \"./node_modules/js-draw/dist/cjs/commands/uniteCommands.js\"));\nconst RenderablePathSpec_1 = __webpack_require__(/*! ../rendering/RenderablePathSpec */ \"./node_modules/js-draw/dist/cjs/rendering/RenderablePathSpec.js\");\nvar EraserMode;\n(function (EraserMode) {\n    EraserMode[\"PartialStroke\"] = \"partial-stroke\";\n    EraserMode[\"FullStroke\"] = \"full-stroke\";\n})(EraserMode || (exports.EraserMode = EraserMode = {}));\n/** Handles switching from other primary tools to the eraser and back */\nclass EraserSwitcher extends BaseTool_1.default {\n    constructor(editor, eraser) {\n        super(editor.notifier, editor.localization.changeTool);\n        this.editor = editor;\n        this.eraser = eraser;\n    }\n    onPointerDown(event) {\n        if (event.allPointers.length === 1 && event.current.device === Pointer_1.PointerDevice.Eraser) {\n            const toolController = this.editor.toolController;\n            const enabledPrimaryTools = toolController\n                .getPrimaryTools()\n                .filter((tool) => tool.isEnabled());\n            if (enabledPrimaryTools.length) {\n                this.previousEnabledTool = enabledPrimaryTools[0];\n            }\n            else {\n                this.previousEnabledTool = null;\n            }\n            this.previousEraserEnabledState = this.eraser.isEnabled();\n            this.eraser.setEnabled(true);\n            if (this.eraser.onPointerDown(event)) {\n                return true;\n            }\n            else {\n                this.restoreOriginalTool();\n            }\n        }\n        return false;\n    }\n    onPointerMove(event) {\n        this.eraser.onPointerMove(event);\n    }\n    restoreOriginalTool() {\n        this.eraser.setEnabled(this.previousEraserEnabledState);\n        if (this.previousEnabledTool) {\n            this.previousEnabledTool.setEnabled(true);\n        }\n    }\n    onPointerUp(event) {\n        this.eraser.onPointerUp(event);\n        this.restoreOriginalTool();\n    }\n    onGestureCancel(event) {\n        this.eraser.onGestureCancel(event);\n        this.restoreOriginalTool();\n    }\n}\n/**\n * A tool that allows a user to erase parts of an image.\n */\nclass Eraser extends BaseTool_1.default {\n    constructor(editor, description, options) {\n        super(editor.notifier, description);\n        this.editor = editor;\n        this.lastPoint = null;\n        this.isFirstEraseEvt = true;\n        this.toAdd = new Set();\n        // Commands that each remove one element\n        this.eraseCommands = [];\n        this.addCommands = [];\n        this.thickness = options?.thickness ?? 10;\n        this.thicknessValue = ReactiveValue_1.ReactiveValue.fromInitialValue(this.thickness);\n        this.thicknessValue.onUpdate((value) => {\n            this.thickness = value;\n            this.editor.notifier.dispatch(types_1.EditorEventType.ToolUpdated, {\n                kind: types_1.EditorEventType.ToolUpdated,\n                tool: this,\n            });\n        });\n        this.modeValue = ReactiveValue_1.ReactiveValue.fromInitialValue(options?.mode ?? EraserMode.FullStroke);\n        this.modeValue.onUpdate((_value) => {\n            this.editor.notifier.dispatch(types_1.EditorEventType.ToolUpdated, {\n                kind: types_1.EditorEventType.ToolUpdated,\n                tool: this,\n            });\n        });\n    }\n    /**\n     * @returns a tool that briefly enables the eraser when a physical eraser is used.\n     * This tool should be added to the tool list after the primary tools.\n     */\n    makeEraserSwitcherTool() {\n        return new EraserSwitcher(this.editor, this);\n    }\n    clearPreview() {\n        this.editor.clearWetInk();\n    }\n    getSizeOnCanvas() {\n        return this.thickness / this.editor.viewport.getScaleFactor();\n    }\n    drawPreviewAt(point) {\n        this.clearPreview();\n        const size = this.getSizeOnCanvas();\n        const renderer = this.editor.display.getWetInkRenderer();\n        const rect = this.getEraserRect(point);\n        const rect2 = this.getEraserRect(this.lastPoint ?? point);\n        const fill = {\n            fill: math_1.Color4.transparent,\n            stroke: { width: size / 10, color: math_1.Color4.gray },\n        };\n        renderer.drawPath((0, RenderablePathSpec_1.pathToRenderable)(math_1.Path.fromConvexHullOf([...rect.corners, ...rect2.corners]), fill));\n    }\n    /**\n     * @returns the eraser rectangle in canvas coordinates.\n     *\n     * For now, all erasers are rectangles or points.\n     */\n    getEraserRect(centerPoint) {\n        const size = this.getSizeOnCanvas();\n        const halfSize = math_1.Vec2.of(size / 2, size / 2);\n        return math_1.Rect2.fromCorners(centerPoint.minus(halfSize), centerPoint.plus(halfSize));\n    }\n    /** Erases in a line from the last point to the current. */\n    eraseTo(currentPoint) {\n        if (!this.isFirstEraseEvt && currentPoint.distanceTo(this.lastPoint) === 0) {\n            return;\n        }\n        this.isFirstEraseEvt = false;\n        // Currently only objects within eraserRect or that intersect a straight line\n        // from the center of the current rect to the previous are erased. TODO: Erase\n        // all objects as if there were pointerMove events between the two points.\n        const eraserRect = this.getEraserRect(currentPoint);\n        const line = new math_1.LineSegment2(this.lastPoint, currentPoint);\n        const region = math_1.Rect2.union(line.bbox, eraserRect);\n        const intersectingElems = this.editor.image\n            .getElementsIntersectingRegion(region)\n            .filter((component) => {\n            return component.intersects(line) || component.intersectsRect(eraserRect);\n        });\n        // Only erase components that could be selected (and thus interacted with)\n        // by the user.\n        const eraseableElems = intersectingElems.filter((elem) => elem.isSelectable());\n        if (this.modeValue.get() === EraserMode.FullStroke) {\n            // Remove any intersecting elements.\n            this.toRemove.push(...eraseableElems);\n            // Create new Erase commands for the now-to-be-erased elements and apply them.\n            const newPartialCommands = eraseableElems.map((elem) => new Erase_1.default([elem]));\n            newPartialCommands.forEach((cmd) => cmd.apply(this.editor));\n            this.eraseCommands.push(...newPartialCommands);\n        }\n        else {\n            const toErase = [];\n            const toAdd = [];\n            for (const targetElem of eraseableElems) {\n                toErase.push(targetElem);\n                // Completely delete items that can't be divided.\n                if (!targetElem.withRegionErased) {\n                    continue;\n                }\n                // Completely delete items that are completely or almost completely\n                // contained within the eraser.\n                const grownRect = eraserRect.grownBy(eraserRect.maxDimension / 3);\n                if (grownRect.containsRect(targetElem.getExactBBox())) {\n                    continue;\n                }\n                // Join the current and previous rectangles so that points between events are also\n                // erased.\n                const erasePath = math_1.Path.fromConvexHullOf([\n                    ...eraserRect.corners,\n                    ...this.getEraserRect(this.lastPoint ?? currentPoint).corners,\n                ].map((p) => this.editor.viewport.roundPoint(p)));\n                toAdd.push(...targetElem.withRegionErased(erasePath, this.editor.viewport));\n            }\n            const eraseCommand = new Erase_1.default(toErase);\n            const newAddCommands = toAdd.map((elem) => EditorImage_1.default.addElement(elem));\n            eraseCommand.apply(this.editor);\n            newAddCommands.forEach((command) => command.apply(this.editor));\n            const finalToErase = [];\n            for (const item of toErase) {\n                if (this.toAdd.has(item)) {\n                    this.toAdd.delete(item);\n                }\n                else {\n                    finalToErase.push(item);\n                }\n            }\n            this.toRemove.push(...finalToErase);\n            for (const item of toAdd) {\n                this.toAdd.add(item);\n            }\n            this.eraseCommands.push(new Erase_1.default(finalToErase));\n            this.addCommands.push(...newAddCommands);\n        }\n        this.drawPreviewAt(currentPoint);\n        this.lastPoint = currentPoint;\n    }\n    onPointerDown(event) {\n        if (event.allPointers.length === 1 || event.current.device === Pointer_1.PointerDevice.Eraser) {\n            this.lastPoint = event.current.canvasPos;\n            this.toRemove = [];\n            this.toAdd.clear();\n            this.isFirstEraseEvt = true;\n            this.drawPreviewAt(event.current.canvasPos);\n            return true;\n        }\n        return false;\n    }\n    onPointerMove(event) {\n        const currentPoint = event.current.canvasPos;\n        this.eraseTo(currentPoint);\n    }\n    onPointerUp(event) {\n        this.eraseTo(event.current.canvasPos);\n        const commands = [];\n        if (this.addCommands.length > 0) {\n            this.addCommands.forEach((cmd) => cmd.unapply(this.editor));\n            // Remove items from toAdd that are also present in toRemove -- adding, then\n            // removing these does nothing, and can break undo/redo.\n            for (const item of this.toAdd) {\n                if (this.toRemove.includes(item)) {\n                    this.toAdd.delete(item);\n                    this.toRemove = this.toRemove.filter((other) => other !== item);\n                }\n            }\n            for (const item of this.toRemove) {\n                if (this.toAdd.has(item)) {\n                    this.toAdd.delete(item);\n                    this.toRemove = this.toRemove.filter((other) => other !== item);\n                }\n            }\n            commands.push(...[...this.toAdd].map((a) => EditorImage_1.default.addElement(a)));\n            this.addCommands = [];\n        }\n        if (this.eraseCommands.length > 0) {\n            // Undo commands for each individual component and unite into a single command.\n            this.eraseCommands.forEach((cmd) => cmd.unapply(this.editor));\n            this.eraseCommands = [];\n            const command = new Erase_1.default(this.toRemove);\n            commands.push(command);\n        }\n        if (commands.length === 1) {\n            this.editor.dispatch(commands[0]); // dispatch: Makes undo-able.\n        }\n        else {\n            this.editor.dispatch((0, uniteCommands_1.default)(commands));\n        }\n        this.clearPreview();\n    }\n    onGestureCancel(_event) {\n        this.addCommands.forEach((cmd) => cmd.unapply(this.editor));\n        this.eraseCommands.forEach((cmd) => cmd.unapply(this.editor));\n        this.eraseCommands = [];\n        this.addCommands = [];\n        this.clearPreview();\n    }\n    onKeyPress(event) {\n        const shortcuts = this.editor.shortcuts;\n        let newThickness;\n        if (shortcuts.matchesShortcut(keybindings_1.decreaseSizeKeyboardShortcutId, event)) {\n            newThickness = (this.getThickness() * 2) / 3;\n        }\n        else if (shortcuts.matchesShortcut(keybindings_1.increaseSizeKeyboardShortcutId, event)) {\n            newThickness = (this.getThickness() * 3) / 2;\n        }\n        if (newThickness !== undefined) {\n            newThickness = Math.min(Math.max(1, newThickness), 200);\n            this.setThickness(newThickness);\n            return true;\n        }\n        return false;\n    }\n    /** Returns the side-length of the tip of this eraser. */\n    getThickness() {\n        return this.thickness;\n    }\n    /** Sets the side-length of this' tip. */\n    setThickness(thickness) {\n        this.thicknessValue.set(thickness);\n    }\n    /**\n     * Returns a {@link MutableReactiveValue} that can be used to watch\n     * this tool's thickness.\n     */\n    getThicknessValue() {\n        return this.thicknessValue;\n    }\n    /** @returns An object that allows switching between a full stroke and a partial stroke eraser. */\n    getModeValue() {\n        return this.modeValue;\n    }\n}\nexports[\"default\"] = Eraser;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/tools/Eraser.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/tools/FindTool.js":
/*!*********************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/tools/FindTool.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n// Displays a find dialog that allows the user to search for and focus text.\n//\n// @packageDocumentation\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst TextComponent_1 = __importDefault(__webpack_require__(/*! ../components/TextComponent */ \"./node_modules/js-draw/dist/cjs/components/TextComponent.js\"));\nconst ImageComponent_1 = __importDefault(__webpack_require__(/*! ../components/ImageComponent */ \"./node_modules/js-draw/dist/cjs/components/ImageComponent.js\"));\nconst BaseTool_1 = __importDefault(__webpack_require__(/*! ./BaseTool */ \"./node_modules/js-draw/dist/cjs/tools/BaseTool.js\"));\nconst keybindings_1 = __webpack_require__(/*! ./keybindings */ \"./node_modules/js-draw/dist/cjs/tools/keybindings.js\");\nconst cssPrefix = 'find-tool';\nclass FindTool extends BaseTool_1.default {\n    constructor(editor) {\n        super(editor.notifier, editor.localization.findLabel);\n        this.editor = editor;\n        this.currentMatchIdx = 0;\n        this.overlay = document.createElement('div');\n        this.fillOverlay();\n        editor.createHTMLOverlay(this.overlay);\n        this.overlay.style.display = 'none';\n        this.overlay.classList.add(`${cssPrefix}-overlay`);\n    }\n    canReceiveInputInReadOnlyEditor() {\n        return true;\n    }\n    getMatches(searchFor) {\n        const lowerSearchFor = searchFor.toLocaleLowerCase();\n        const matchingComponents = this.editor.image.getAllElements().filter((component) => {\n            let text = '';\n            if (component instanceof TextComponent_1.default) {\n                text = component.getText();\n            }\n            else if (component instanceof ImageComponent_1.default) {\n                text = component.getAltText() ?? '';\n            }\n            else {\n                return false;\n            }\n            const hasLowercaseMatch = text.toLocaleLowerCase().indexOf(lowerSearchFor) !== -1;\n            const hasSameCaseMatch = text.indexOf(searchFor) !== -1;\n            return hasLowercaseMatch || hasSameCaseMatch;\n        });\n        return matchingComponents.map((match) => match.getBBox());\n    }\n    focusCurrentMatch() {\n        const matches = this.getMatches(this.searchInput.value);\n        let matchIdx = this.currentMatchIdx % matches.length;\n        if (matchIdx < 0) {\n            matchIdx = matches.length + matchIdx;\n        }\n        if (matchIdx < matches.length) {\n            const undoable = false;\n            void this.editor.dispatch(this.editor.viewport.zoomTo(matches[matchIdx], true, true), undoable);\n            this.editor.announceForAccessibility(this.editor.localization.focusedFoundText(matchIdx + 1, matches.length));\n        }\n    }\n    toNextMatch() {\n        this.currentMatchIdx++;\n        this.focusCurrentMatch();\n    }\n    toPrevMatch() {\n        this.currentMatchIdx--;\n        this.focusCurrentMatch();\n    }\n    fillOverlay() {\n        const label = document.createElement('label');\n        this.searchInput = document.createElement('input');\n        const nextBtn = document.createElement('button');\n        const closeBtn = document.createElement('button');\n        // Math.random() ensures that the ID is unique (to allow us to refer to it\n        // with an htmlFor).\n        this.searchInput.setAttribute('id', `${cssPrefix}-searchInput-${Math.random()}`);\n        label.htmlFor = this.searchInput.getAttribute('id');\n        label.innerText = this.editor.localization.findLabel;\n        nextBtn.innerText = this.editor.localization.toNextMatch;\n        closeBtn.innerText = this.editor.localization.closeDialog;\n        this.searchInput.onkeydown = (ev) => {\n            if (ev.key === 'Enter') {\n                if (ev.shiftKey) {\n                    this.toPrevMatch();\n                }\n                else {\n                    this.toNextMatch();\n                }\n            }\n            else if (ev.key === 'Escape') {\n                this.setVisible(false);\n            }\n            else if (this.editor.shortcuts.matchesShortcut(keybindings_1.toggleFindVisibleShortcutId, ev)) {\n                ev.preventDefault();\n                this.toggleVisible();\n            }\n        };\n        nextBtn.onclick = () => {\n            this.toNextMatch();\n        };\n        closeBtn.onclick = () => {\n            this.setVisible(false);\n        };\n        this.overlay.replaceChildren(label, this.searchInput, nextBtn, closeBtn);\n    }\n    isVisible() {\n        return this.overlay.style.display !== 'none';\n    }\n    setVisible(visible) {\n        if (visible !== this.isVisible()) {\n            this.overlay.style.display = visible ? 'block' : 'none';\n            if (visible) {\n                this.searchInput.focus();\n                this.editor.announceForAccessibility(this.editor.localization.findDialogShown);\n            }\n            else {\n                this.editor.focus();\n                this.editor.announceForAccessibility(this.editor.localization.findDialogHidden);\n            }\n        }\n    }\n    toggleVisible() {\n        this.setVisible(!this.isVisible());\n    }\n    onKeyPress(event) {\n        if (this.editor.shortcuts.matchesShortcut(keybindings_1.toggleFindVisibleShortcutId, event)) {\n            this.toggleVisible();\n            return true;\n        }\n        return false;\n    }\n    setEnabled(enabled) {\n        super.setEnabled(enabled);\n        if (this.isEnabled()) {\n            this.setVisible(false);\n        }\n    }\n}\nexports[\"default\"] = FindTool;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/tools/FindTool.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/tools/InputFilter/ContextMenuRecognizer.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/tools/InputFilter/ContextMenuRecognizer.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst inputEvents_1 = __webpack_require__(/*! ../../inputEvents */ \"./node_modules/js-draw/dist/cjs/inputEvents.js\");\nconst InputMapper_1 = __importDefault(__webpack_require__(/*! ./InputMapper */ \"./node_modules/js-draw/dist/cjs/tools/InputFilter/InputMapper.js\"));\nconst StationaryPenDetector_1 = __importStar(__webpack_require__(/*! ../util/StationaryPenDetector */ \"./node_modules/js-draw/dist/cjs/tools/util/StationaryPenDetector.js\"));\nconst Pointer_1 = __webpack_require__(/*! ../../Pointer */ \"./node_modules/js-draw/dist/cjs/Pointer.js\");\nclass ContextMenuRecognizer extends InputMapper_1.default {\n    constructor() {\n        super();\n        this.canShowContextMenu = false;\n        this.stationaryDetector = null;\n        this.clickTolerance = 12;\n    }\n    /**\n     * In general, only certain events (i.e. touchscreens) are expected to be able to\n     * create long-press menus. This method checks whether `event` was generated by\n     * one such device.\n     */\n    canMakeLongPressMenuEvent(event) {\n        const allowedDevices = [Pointer_1.PointerDevice.Touch];\n        return event.allPointers.length === 1 && allowedDevices.includes(event.current.device);\n    }\n    onEvent(event) {\n        const sendContextMenuEvent = () => {\n            if (!(0, inputEvents_1.isPointerEvt)(event))\n                return false;\n            if (this.canShowContextMenu) {\n                const eventHandled = this.emit({\n                    kind: inputEvents_1.InputEvtType.ContextMenu,\n                    screenPos: event.current.screenPos,\n                    canvasPos: event.current.canvasPos,\n                });\n                if (eventHandled) {\n                    this.emit({\n                        kind: inputEvents_1.InputEvtType.GestureCancelEvt,\n                    });\n                    return true;\n                }\n            }\n            return false;\n        };\n        if (event.kind === inputEvents_1.InputEvtType.PointerDownEvt) {\n            if (event.allPointers.length === 1) {\n                this.canShowContextMenu = true;\n                this.contextMenuTriggerPointer = event.current;\n                this.contextMenuStartPoint = event.current.screenPos;\n                if (this.canMakeLongPressMenuEvent(event)) {\n                    this.stationaryDetector = new StationaryPenDetector_1.default(event.current, StationaryPenDetector_1.defaultStationaryDetectionConfig, sendContextMenuEvent);\n                }\n            }\n            else {\n                this.canShowContextMenu = false;\n            }\n        }\n        else if (event.kind === inputEvents_1.InputEvtType.PointerMoveEvt) {\n            if (this.canShowContextMenu) {\n                this.stationaryDetector?.onPointerMove(event.current);\n                // Only clicks/stationary long presses can create context menu events.\n                const deltaPosition = event.current.screenPos.minus(this.contextMenuStartPoint);\n                const threshold = this.clickTolerance;\n                if (deltaPosition.length() > threshold) {\n                    this.canShowContextMenu = false;\n                }\n            }\n        }\n        else if (event.kind === inputEvents_1.InputEvtType.PointerUpEvt) {\n            this.stationaryDetector?.destroy();\n            if (this.contextMenuTriggerPointer?.id === event.current.id &&\n                this.contextMenuTriggerPointer.device === Pointer_1.PointerDevice.RightButtonMouse &&\n                sendContextMenuEvent()) {\n                return true;\n            }\n        }\n        return this.emit(event);\n    }\n}\nexports[\"default\"] = ContextMenuRecognizer;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/tools/InputFilter/ContextMenuRecognizer.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/tools/InputFilter/InputMapper.js":
/*!************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/tools/InputFilter/InputMapper.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _InputMapper_listener;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * Accepts input events and emits input events.\n */\nclass InputMapper {\n    constructor() {\n        _InputMapper_listener.set(this, null);\n    }\n    // @internal\n    setEmitListener(listener) {\n        if (listener && typeof listener === 'object') {\n            __classPrivateFieldSet(this, _InputMapper_listener, (event) => {\n                return listener.onEvent(event) ?? false;\n            }, \"f\");\n        }\n        else {\n            __classPrivateFieldSet(this, _InputMapper_listener, listener, \"f\");\n        }\n    }\n    emit(event) {\n        return __classPrivateFieldGet(this, _InputMapper_listener, \"f\")?.call(this, event) ?? false;\n    }\n}\n_InputMapper_listener = new WeakMap();\nexports[\"default\"] = InputMapper;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/tools/InputFilter/InputMapper.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/tools/InputFilter/InputPipeline.js":
/*!**************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/tools/InputFilter/InputPipeline.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar _InputPipeline_head, _InputPipeline_tail;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst InputMapper_1 = __importDefault(__webpack_require__(/*! ./InputMapper */ \"./node_modules/js-draw/dist/cjs/tools/InputFilter/InputMapper.js\"));\n/**\n * The composition of multiple `InputMapper`s.\n */\nclass InputPipeline extends InputMapper_1.default {\n    constructor() {\n        super(...arguments);\n        _InputPipeline_head.set(this, null);\n        _InputPipeline_tail.set(this, null);\n    }\n    onEvent(event) {\n        if (__classPrivateFieldGet(this, _InputPipeline_head, \"f\") === null) {\n            return this.emit(event);\n        }\n        else {\n            return __classPrivateFieldGet(this, _InputPipeline_head, \"f\").onEvent(event);\n        }\n    }\n    /**\n     * Adds a new `InputMapper` to the *tail* of this pipeline.\n     * Note that an instance of an `InputMapper` can only be used in a single\n     * pipeline.\n     */\n    addToTail(mapper) {\n        if (!__classPrivateFieldGet(this, _InputPipeline_tail, \"f\")) {\n            __classPrivateFieldSet(this, _InputPipeline_head, mapper, \"f\");\n            __classPrivateFieldSet(this, _InputPipeline_tail, __classPrivateFieldGet(this, _InputPipeline_head, \"f\"), \"f\");\n        }\n        else {\n            __classPrivateFieldGet(this, _InputPipeline_tail, \"f\").setEmitListener(mapper);\n            __classPrivateFieldSet(this, _InputPipeline_tail, mapper, \"f\");\n        }\n        __classPrivateFieldGet(this, _InputPipeline_tail, \"f\").setEmitListener((event) => this.emit(event));\n    }\n}\n_InputPipeline_head = new WeakMap(), _InputPipeline_tail = new WeakMap();\nexports[\"default\"] = InputPipeline;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/tools/InputFilter/InputPipeline.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/tools/InputFilter/InputStabilizer.js":
/*!****************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/tools/InputFilter/InputStabilizer.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst inputEvents_1 = __webpack_require__(/*! ../../inputEvents */ \"./node_modules/js-draw/dist/cjs/inputEvents.js\");\nconst InputMapper_1 = __importDefault(__webpack_require__(/*! ./InputMapper */ \"./node_modules/js-draw/dist/cjs/tools/InputFilter/InputMapper.js\"));\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\nconst untilNextAnimationFrame_1 = __importDefault(__webpack_require__(/*! ../../util/untilNextAnimationFrame */ \"./node_modules/js-draw/dist/cjs/util/untilNextAnimationFrame.js\"));\nvar StabilizerType;\n(function (StabilizerType) {\n    StabilizerType[StabilizerType[\"IntertialStabilizer\"] = 0] = \"IntertialStabilizer\";\n})(StabilizerType || (StabilizerType = {}));\nconst defaultOptions = {\n    kind: StabilizerType.IntertialStabilizer,\n    mass: 0.4, // kg\n    springConstant: 100.0, // N/m\n    frictionCoefficient: 0.28,\n    maxPointDist: 10, // screen units\n    inertiaFraction: 0.75,\n    minSimilarityToFinalize: 0.0,\n    velocityDecayFactor: 0.1,\n};\n// Stabilizes input for a single cursor\nclass StylusInputStabilizer {\n    constructor(\n    // The initial starting point of the pointer.\n    start, \n    // Emits a pointer motion event, returns true if the event was handled.\n    updatePointer, options) {\n        this.updatePointer = updatePointer;\n        this.options = options;\n        this.runLoop = true;\n        this.lastUpdateTime = 0;\n        this.velocity = math_1.Vec2.zero;\n        this.strokePoint = start;\n        this.targetPoint = start;\n        this.targetInterval = 10; // ms\n        void this.loop();\n    }\n    async loop() {\n        this.lastUpdateTime = performance.now();\n        while (this.runLoop) {\n            this.update(false);\n            await (0, untilNextAnimationFrame_1.default)();\n        }\n    }\n    setTarget(point) {\n        this.targetPoint = point;\n    }\n    getNextVelocity(deltaTimeMs) {\n        const toTarget = this.targetPoint.minus(this.strokePoint);\n        const springForce = toTarget.times(this.options.springConstant);\n        const gravityAccel = 10;\n        const normalForceMagnitude = this.options.mass * gravityAccel;\n        const frictionForce = this.velocity\n            .normalizedOrZero()\n            .times(-this.options.frictionCoefficient * normalForceMagnitude);\n        const acceleration = springForce.plus(frictionForce).times(1 / this.options.mass);\n        const decayFactor = this.options.velocityDecayFactor;\n        const springVelocity = this.velocity\n            .times(1 - decayFactor)\n            .plus(acceleration.times(deltaTimeMs / 1000));\n        // An alternate velocity that goes directly towards the target.\n        const toTargetVelocity = toTarget.normalizedOrZero().times(springVelocity.length());\n        return toTargetVelocity.lerp(springVelocity, this.options.inertiaFraction);\n    }\n    update(force) {\n        const nowTime = performance.now();\n        const deltaTime = nowTime - this.lastUpdateTime;\n        const reachedTarget = this.strokePoint.eq(this.targetPoint);\n        if (deltaTime > this.targetInterval || force) {\n            if (!reachedTarget) {\n                let velocity;\n                let deltaX;\n                let parts = 1;\n                do {\n                    velocity = this.getNextVelocity(deltaTime / parts);\n                    deltaX = velocity.times(deltaTime / 1000);\n                    parts++;\n                } while (deltaX.magnitude() > this.options.maxPointDist && parts < 10);\n                for (let i = 0; i < parts; i++) {\n                    this.velocity = this.getNextVelocity(deltaTime / parts);\n                    deltaX = this.velocity.times(deltaTime / 1000);\n                    this.strokePoint = this.strokePoint.plus(deltaX);\n                    // Allows the last updatePointer to be returned.\n                    if (i < parts - 1) {\n                        this.updatePointer(this.strokePoint, nowTime);\n                    }\n                }\n            }\n            // Even if we have reached the target, ensure that lastUpdateTime is updated\n            // (prevent large deltaTime).\n            this.lastUpdateTime = nowTime;\n            if (force || !reachedTarget) {\n                return this.updatePointer(this.strokePoint, nowTime);\n            }\n        }\n        return false;\n    }\n    /** Finalizes the current stroke. */\n    finish() {\n        this.runLoop = false;\n        const toTarget = this.targetPoint.minus(this.strokePoint);\n        if (this.velocity.dot(toTarget) > this.options.minSimilarityToFinalize) {\n            // Connect the stroke to its end point\n            this.updatePointer(this.targetPoint, performance.now());\n        }\n    }\n    cancel() {\n        this.runLoop = false;\n    }\n}\nclass InputStabilizer extends InputMapper_1.default {\n    constructor(viewport, options = defaultOptions) {\n        super();\n        this.viewport = viewport;\n        this.options = options;\n        this.stabilizer = null;\n        this.lastPointerEvent = null;\n    }\n    mapPointerEvent(event) {\n        // Don't store the last pointer event for use with pressure/button data --\n        // this information can be very different for a pointerup event.\n        if ((0, inputEvents_1.isPointerEvt)(event) && event.kind !== inputEvents_1.InputEvtType.PointerUpEvt) {\n            this.lastPointerEvent = event;\n        }\n        // Only apply smoothing if there is a single pointer.\n        if (event.kind === inputEvents_1.InputEvtType.GestureCancelEvt ||\n            event.allPointers.length > 1 ||\n            this.stabilizer === null) {\n            return this.emit(event);\n        }\n        this.stabilizer.setTarget(event.current.screenPos);\n        if (event.kind === inputEvents_1.InputEvtType.PointerMoveEvt) {\n            return this.stabilizer.update(true);\n        }\n        else if (event.kind === inputEvents_1.InputEvtType.PointerUpEvt) {\n            this.stabilizer.finish();\n            return this.emit(event);\n        }\n        else {\n            return this.emit(event);\n        }\n    }\n    // Assumes that there is exactly one pointer that is currently down.\n    emitPointerMove(screenPoint, timeStamp) {\n        if (!this.lastPointerEvent) {\n            return false;\n        }\n        const pointer = this.lastPointerEvent.current\n            .withScreenPosition(screenPoint, this.viewport)\n            .withTimestamp(timeStamp);\n        const event = {\n            kind: inputEvents_1.InputEvtType.PointerMoveEvt,\n            current: pointer,\n            allPointers: [pointer],\n        };\n        const handled = this.emit(event);\n        return handled;\n    }\n    onEvent(event) {\n        if ((0, inputEvents_1.isPointerEvt)(event) || event.kind === inputEvents_1.InputEvtType.GestureCancelEvt) {\n            if (event.kind === inputEvents_1.InputEvtType.PointerDownEvt) {\n                if (this.stabilizer === null) {\n                    this.stabilizer = new StylusInputStabilizer(event.current.screenPos, (screenPoint, timeStamp) => this.emitPointerMove(screenPoint, timeStamp), this.options);\n                }\n                else if (event.allPointers.length > 1) {\n                    // Do not attempt to stabilize multiple pointers.\n                    this.stabilizer.cancel();\n                    this.stabilizer = null;\n                }\n            }\n            const handled = this.mapPointerEvent(event);\n            if (event.kind === inputEvents_1.InputEvtType.PointerUpEvt ||\n                event.kind === inputEvents_1.InputEvtType.GestureCancelEvt) {\n                this.stabilizer?.cancel();\n                this.stabilizer = null;\n            }\n            return handled;\n        }\n        return this.emit(event);\n    }\n    static fromEditor(editor) {\n        return new InputStabilizer(editor.viewport);\n    }\n}\nexports[\"default\"] = InputStabilizer;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/tools/InputFilter/InputStabilizer.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/tools/InputFilter/StrokeKeyboardControl.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/tools/InputFilter/StrokeKeyboardControl.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst inputEvents_1 = __webpack_require__(/*! ../../inputEvents */ \"./node_modules/js-draw/dist/cjs/inputEvents.js\");\nconst InputMapper_1 = __importDefault(__webpack_require__(/*! ./InputMapper */ \"./node_modules/js-draw/dist/cjs/tools/InputFilter/InputMapper.js\"));\nconst keybindings_1 = __webpack_require__(/*! ../keybindings */ \"./node_modules/js-draw/dist/cjs/tools/keybindings.js\");\n/**\n * Provides keyboard shortcuts that provide some amount of control over\n * drawing (e.g. snap to grid, plane lock).\n */\nclass StrokeKeyboardControl extends InputMapper_1.default {\n    constructor(shortcuts, viewport) {\n        super();\n        this.shortcuts = shortcuts;\n        this.viewport = viewport;\n        this.snapToGridEnabled = false;\n        this.angleLockEnabled = false;\n        // The point at which the last pointerDown event happened (or null if\n        // no such event has occurred).\n        this.startPointCanvas = null;\n    }\n    // Snap the given pointer to the nearer of the x/y axes.\n    xyAxesSnap(pointer) {\n        if (!this.startPointCanvas) {\n            return pointer;\n        }\n        // Convert this.startPointCanvas here because the viewport might change\n        // while drawing a stroke.\n        const screenPos = this.viewport.canvasToScreen(this.startPointCanvas);\n        return pointer.lockedToXYAxesScreen(screenPos, this.viewport);\n    }\n    mapPointerEvent(event) {\n        const mapPointer = (pointer) => {\n            // Only map if there's exactly one pointer.\n            if (event.allPointers.length > 1) {\n                return pointer;\n            }\n            if (this.snapToGridEnabled) {\n                return pointer.snappedToGrid(this.viewport);\n            }\n            if (this.angleLockEnabled && this.startPointCanvas) {\n                return this.xyAxesSnap(pointer);\n            }\n            return pointer;\n        };\n        return {\n            kind: event.kind,\n            current: mapPointer(event.current),\n            allPointers: event.allPointers.map(mapPointer),\n        };\n    }\n    onEvent(event) {\n        const shortcuts = this.shortcuts;\n        if (event.kind === inputEvents_1.InputEvtType.PointerDownEvt ||\n            event.kind === inputEvents_1.InputEvtType.PointerMoveEvt ||\n            event.kind === inputEvents_1.InputEvtType.PointerUpEvt) {\n            if (event.kind === inputEvents_1.InputEvtType.PointerDownEvt) {\n                this.startPointCanvas = event.current.canvasPos;\n            }\n            event = this.mapPointerEvent(event);\n        }\n        let handled = this.emit(event);\n        if (\n        // Always check keyUpEvents (in case we handled the corresponding keyDown event)\n        event.kind === inputEvents_1.InputEvtType.KeyUpEvent ||\n            // Only handle key press events if another tool isn't handling it. We don't want\n            // snap to grid/angle lock to conflict with selection/another tool's shortcuts.\n            (!handled && event.kind === inputEvents_1.InputEvtType.KeyPressEvent)) {\n            const isKeyPress = event.kind === inputEvents_1.InputEvtType.KeyPressEvent;\n            if (shortcuts.matchesShortcut(keybindings_1.snapToGridKeyboardShortcutId, event)) {\n                this.snapToGridEnabled = isKeyPress;\n                handled = true;\n            }\n            if (shortcuts.matchesShortcut(keybindings_1.lineLockKeyboardShortcutId, event)) {\n                this.angleLockEnabled = isKeyPress;\n                handled = true;\n            }\n        }\n        return handled;\n    }\n    static fromEditor(editor) {\n        return new StrokeKeyboardControl(editor.shortcuts, editor.viewport);\n    }\n}\nexports[\"default\"] = StrokeKeyboardControl;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/tools/InputFilter/StrokeKeyboardControl.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/tools/PanZoom.js":
/*!********************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/tools/PanZoom.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PanZoomMode = void 0;\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\nconst Pointer_1 = __webpack_require__(/*! ../Pointer */ \"./node_modules/js-draw/dist/cjs/Pointer.js\");\nconst types_1 = __webpack_require__(/*! ../types */ \"./node_modules/js-draw/dist/cjs/types.js\");\nconst untilNextAnimationFrame_1 = __importDefault(__webpack_require__(/*! ../util/untilNextAnimationFrame */ \"./node_modules/js-draw/dist/cjs/util/untilNextAnimationFrame.js\"));\nconst Viewport_1 = __webpack_require__(/*! ../Viewport */ \"./node_modules/js-draw/dist/cjs/Viewport.js\");\nconst BaseTool_1 = __importDefault(__webpack_require__(/*! ./BaseTool */ \"./node_modules/js-draw/dist/cjs/tools/BaseTool.js\"));\nconst keybindings_1 = __webpack_require__(/*! ./keybindings */ \"./node_modules/js-draw/dist/cjs/tools/keybindings.js\");\nvar PanZoomMode;\n(function (PanZoomMode) {\n    /** Touch gestures with a single pointer. Ignores non-touch gestures. */\n    PanZoomMode[PanZoomMode[\"OneFingerTouchGestures\"] = 1] = \"OneFingerTouchGestures\";\n    /** Touch gestures with exactly two pointers. Ignores non-touch gestures. */\n    PanZoomMode[PanZoomMode[\"TwoFingerTouchGestures\"] = 2] = \"TwoFingerTouchGestures\";\n    PanZoomMode[PanZoomMode[\"RightClickDrags\"] = 4] = \"RightClickDrags\";\n    /** Single-pointer gestures of *any* type (including touch). */\n    PanZoomMode[PanZoomMode[\"SinglePointerGestures\"] = 8] = \"SinglePointerGestures\";\n    /** Keyboard navigation (e.g. LeftArrow to move left). */\n    PanZoomMode[PanZoomMode[\"Keyboard\"] = 16] = \"Keyboard\";\n    /** If provided, prevents **this** tool from rotating the viewport (other tools may still do so). */\n    PanZoomMode[PanZoomMode[\"RotationLocked\"] = 32] = \"RotationLocked\";\n})(PanZoomMode || (exports.PanZoomMode = PanZoomMode = {}));\nclass InertialScroller {\n    constructor(initialVelocity, scrollBy, onComplete) {\n        this.initialVelocity = initialVelocity;\n        this.scrollBy = scrollBy;\n        this.onComplete = onComplete;\n        this.running = false;\n        this.start();\n    }\n    async start() {\n        if (this.running) {\n            return;\n        }\n        this.currentVelocity = this.initialVelocity;\n        let lastTime = performance.now();\n        this.running = true;\n        const maxSpeed = 5000; // units/s\n        const minSpeed = 200; // units/s\n        if (this.currentVelocity.magnitude() > maxSpeed) {\n            this.currentVelocity = this.currentVelocity.normalized().times(maxSpeed);\n        }\n        while (this.running && this.currentVelocity.magnitude() > minSpeed) {\n            const nowTime = performance.now();\n            const dt = (nowTime - lastTime) / 1000;\n            this.currentVelocity = this.currentVelocity.times(Math.pow(1 / 8, dt));\n            this.scrollBy(this.currentVelocity.times(dt));\n            await (0, untilNextAnimationFrame_1.default)();\n            lastTime = nowTime;\n        }\n        if (this.running) {\n            this.stop();\n        }\n    }\n    getCurrentVelocity() {\n        if (!this.running) {\n            return null;\n        }\n        return this.currentVelocity;\n    }\n    stop() {\n        if (this.running) {\n            this.running = false;\n            this.onComplete();\n        }\n    }\n}\n/**\n * This tool moves the viewport in response to touchpad, touchscreen, mouse, and keyboard events.\n *\n * Which events are handled, and which are skipped, are determined by the tool's `mode`. For example,\n * a `PanZoom` tool with `mode = PanZoomMode.TwoFingerTouchGestures|PanZoomMode.RightClickDrags` would\n * respond to right-click drag events and two-finger touch gestures.\n *\n * @see {@link setModeEnabled}\n */\nclass PanZoom extends BaseTool_1.default {\n    constructor(editor, mode, description) {\n        super(editor.notifier, description);\n        this.editor = editor;\n        this.mode = mode;\n        this.transform = null;\n        // Constants\n        // initialRotationSnapAngle is larger than afterRotationStartSnapAngle to\n        // make it more difficult to start rotating (and easier to continue rotating).\n        this.initialRotationSnapAngle = 0.22; // radians\n        this.afterRotationStartSnapAngle = 0.07; // radians\n        this.pinchZoomStartThreshold = 1.08; // scale factor\n        // Last timestamp at which a pointerdown event was received\n        this.lastPointerDownTimestamp = 0;\n        this.initialTouchAngle = 0;\n        this.initialViewportRotation = 0;\n        this.initialViewportScale = 0;\n        // Set to `true` only when scaling has started (if two fingers are down and have moved\n        // far enough).\n        this.isScaling = false;\n        this.isRotating = false;\n        this.inertialScroller = null;\n        this.velocity = null;\n    }\n    // The pan/zoom tool can be used in a read-only editor.\n    canReceiveInputInReadOnlyEditor() {\n        return true;\n    }\n    // Returns information about the pointers in a gesture\n    computePinchData(p1, p2) {\n        // Swap the pointers to ensure consistent ordering.\n        if (p1.id < p2.id) {\n            const tmp = p1;\n            p1 = p2;\n            p2 = tmp;\n        }\n        const screenBetween = p2.screenPos.minus(p1.screenPos);\n        const angle = screenBetween.angle();\n        const dist = screenBetween.magnitude();\n        const canvasCenter = p2.canvasPos.plus(p1.canvasPos).times(0.5);\n        const screenCenter = p2.screenPos.plus(p1.screenPos).times(0.5);\n        return { canvasCenter, screenCenter, angle, dist };\n    }\n    allPointersAreOfType(pointers, kind) {\n        return pointers.every((pointer) => pointer.device === kind);\n    }\n    onPointerDown({ allPointers: pointers, current: currentPointer, }) {\n        let handlingGesture = false;\n        const inertialScrollerVelocity = this.inertialScroller?.getCurrentVelocity() ?? math_1.Vec2.zero;\n        this.inertialScroller?.stop();\n        this.velocity = inertialScrollerVelocity;\n        this.lastPointerDownTimestamp = currentPointer.timeStamp;\n        const allAreTouch = this.allPointersAreOfType(pointers, Pointer_1.PointerDevice.Touch);\n        const isRightClick = this.allPointersAreOfType(pointers, Pointer_1.PointerDevice.RightButtonMouse);\n        if (allAreTouch && pointers.length === 2 && this.mode & PanZoomMode.TwoFingerTouchGestures) {\n            const { screenCenter, angle, dist } = this.computePinchData(pointers[0], pointers[1]);\n            this.lastTouchDist = dist;\n            this.startTouchDist = dist;\n            this.lastScreenCenter = screenCenter;\n            this.initialTouchAngle = angle;\n            this.initialViewportRotation = this.editor.viewport.getRotationAngle();\n            this.initialViewportScale = this.editor.viewport.getScaleFactor();\n            this.isScaling = false;\n            // We're initially rotated if `initialViewportRotation` isn't near a multiple of pi/2.\n            // In other words, if sin(2 initialViewportRotation) is near zero.\n            this.isRotating = Math.abs(Math.sin(this.initialViewportRotation * 2)) > 1e-3;\n            handlingGesture = true;\n        }\n        else if (pointers.length === 1 &&\n            ((this.mode & PanZoomMode.OneFingerTouchGestures && allAreTouch) ||\n                (isRightClick && this.mode & PanZoomMode.RightClickDrags) ||\n                this.mode & PanZoomMode.SinglePointerGestures)) {\n            this.lastScreenCenter = pointers[0].screenPos;\n            this.isScaling = false;\n            handlingGesture = true;\n        }\n        if (handlingGesture) {\n            this.lastTimestamp = performance.now();\n            this.transform ??= Viewport_1.Viewport.transformBy(math_1.Mat33.identity);\n            this.editor.display.setDraftMode(true);\n        }\n        return handlingGesture;\n    }\n    updateVelocity(currentCenter) {\n        const deltaPos = currentCenter.minus(this.lastScreenCenter);\n        let deltaTime = (performance.now() - this.lastTimestamp) / 1000;\n        // Ignore duplicate events, unless there has been enough time between them.\n        if (deltaPos.magnitude() === 0 && deltaTime < 0.1) {\n            return;\n        }\n        // We divide by deltaTime. Don't divide by zero.\n        if (deltaTime === 0) {\n            return;\n        }\n        // Don't divide by almost zero, either\n        deltaTime = Math.max(deltaTime, 0.01);\n        const currentVelocity = deltaPos.times(1 / deltaTime);\n        let smoothedVelocity = currentVelocity;\n        if (this.velocity) {\n            smoothedVelocity = this.velocity.lerp(currentVelocity, 0.5);\n        }\n        this.velocity = smoothedVelocity;\n    }\n    // Returns the change in position of the center of the given group of pointers.\n    // Assumes this.lastScreenCenter has been set appropriately.\n    getCenterDelta(screenCenter) {\n        // Use transformVec3 to avoid translating the delta\n        const delta = this.editor.viewport.screenToCanvasTransform.transformVec3(screenCenter.minus(this.lastScreenCenter));\n        return delta;\n    }\n    //  Snaps `angle` to common desired rotations. For example, if `touchAngle` corresponds\n    // to a viewport rotation of 90.1 degrees, this function returns a rotation delta that,\n    // when applied to the viewport, rotates the viewport to 90.0 degrees.\n    //\n    // Returns a snapped rotation delta that, when applied to the viewport, rotates the viewport,\n    // from its position on the last touchDown event, by `touchAngle - initialTouchAngle`.\n    toSnappedRotationDelta(touchAngle) {\n        const deltaAngle = touchAngle - this.initialTouchAngle;\n        let fullRotation = deltaAngle + this.initialViewportRotation;\n        const snapToMultipleOf = Math.PI / 2;\n        const roundedFullRotation = Math.round(fullRotation / snapToMultipleOf) * snapToMultipleOf;\n        // The maximum angle for which we snap the given angle to a multiple of\n        // `snapToMultipleOf`.\n        // Use a smaller snap angle if already rotated (to avoid pinch zoom gestures from\n        // starting rotation).\n        const maxSnapAngle = this.isRotating\n            ? this.afterRotationStartSnapAngle\n            : this.initialRotationSnapAngle;\n        // Snap the rotation\n        if (Math.abs(fullRotation - roundedFullRotation) < maxSnapAngle) {\n            fullRotation = roundedFullRotation;\n            // Work around a rotation/matrix multiply bug.\n            // (See commit after 4abe27ff8e7913155828f98dee77b09c57c51d30).\n            // TODO: Fix the underlying issue and remove this.\n            if (fullRotation !== 0) {\n                fullRotation += 0.0001;\n            }\n        }\n        return fullRotation - this.editor.viewport.getRotationAngle();\n    }\n    /**\n     * Given a scale update, `scaleFactor`, returns a new scale factor snapped\n     * to a power of two (if within some tolerance of that scale).\n     */\n    toSnappedScaleFactor(touchDist) {\n        // scaleFactor is applied to the current transformation of the viewport.\n        const newScale = (this.initialViewportScale * touchDist) / this.startTouchDist;\n        const currentScale = this.editor.viewport.getScaleFactor();\n        const logNewScale = Math.log(newScale) / Math.log(10);\n        const roundedLogNewScale = Math.round(logNewScale);\n        const logTolerance = 0.04;\n        if (Math.abs(roundedLogNewScale - logNewScale) < logTolerance) {\n            return Math.pow(10, roundedLogNewScale) / currentScale;\n        }\n        return touchDist / this.lastTouchDist;\n    }\n    handleTwoFingerMove(allPointers) {\n        const { screenCenter, canvasCenter, angle, dist } = this.computePinchData(allPointers[0], allPointers[1]);\n        const delta = this.getCenterDelta(screenCenter);\n        let deltaRotation;\n        if (this.isRotationLocked()) {\n            deltaRotation = 0;\n        }\n        else {\n            deltaRotation = this.toSnappedRotationDelta(angle);\n        }\n        // If any rotation, make a note of this (affects rotation snap\n        // angles).\n        if (Math.abs(deltaRotation) > 1e-8) {\n            this.isRotating = true;\n        }\n        this.updateVelocity(screenCenter);\n        if (!this.isScaling) {\n            const initialScaleFactor = dist / this.startTouchDist;\n            // Only start scaling if scaling done so far exceeds some threshold.\n            const upperBound = this.pinchZoomStartThreshold;\n            const lowerBound = 1 / this.pinchZoomStartThreshold;\n            if (initialScaleFactor > upperBound || initialScaleFactor < lowerBound) {\n                this.isScaling = true;\n            }\n        }\n        let scaleFactor = 1;\n        if (this.isScaling) {\n            scaleFactor = this.toSnappedScaleFactor(dist);\n            // Don't set lastDist until we start scaling --\n            this.lastTouchDist = dist;\n        }\n        const transformUpdate = math_1.Mat33.translation(delta)\n            .rightMul(math_1.Mat33.scaling2D(scaleFactor, canvasCenter))\n            .rightMul(math_1.Mat33.zRotation(deltaRotation, canvasCenter));\n        this.lastScreenCenter = screenCenter;\n        this.transform = Viewport_1.Viewport.transformBy(this.transform.transform.rightMul(transformUpdate));\n        return transformUpdate;\n    }\n    handleOneFingerMove(pointer) {\n        const delta = this.getCenterDelta(pointer.screenPos);\n        const transformUpdate = math_1.Mat33.translation(delta);\n        this.transform = Viewport_1.Viewport.transformBy(this.transform.transform.rightMul(transformUpdate));\n        this.updateVelocity(pointer.screenPos);\n        this.lastScreenCenter = pointer.screenPos;\n        return transformUpdate;\n    }\n    onPointerMove({ allPointers }) {\n        this.transform ??= Viewport_1.Viewport.transformBy(math_1.Mat33.identity);\n        let transformUpdate = math_1.Mat33.identity;\n        if (allPointers.length === 2) {\n            transformUpdate = this.handleTwoFingerMove(allPointers);\n        }\n        else if (allPointers.length === 1) {\n            transformUpdate = this.handleOneFingerMove(allPointers[0]);\n        }\n        Viewport_1.Viewport.transformBy(transformUpdate).apply(this.editor);\n        this.lastTimestamp = performance.now();\n    }\n    onPointerUp(event) {\n        const onComplete = () => {\n            if (this.transform) {\n                this.transform.unapply(this.editor);\n                this.editor.dispatch(this.transform, false);\n            }\n            this.editor.display.setDraftMode(false);\n            this.transform = null;\n            this.velocity = math_1.Vec2.zero;\n        };\n        const minInertialScrollDt = 30;\n        const shouldInertialScroll = event.current.device === Pointer_1.PointerDevice.Touch &&\n            event.allPointers.length === 1 &&\n            this.velocity !== null &&\n            event.current.timeStamp - this.lastPointerDownTimestamp > minInertialScrollDt;\n        if (shouldInertialScroll && this.velocity !== null) {\n            const oldVelocity = this.velocity;\n            // If the user drags the screen, then stops, then lifts the pointer,\n            // we want the final velocity to reflect the stop at the end (so the velocity\n            // should be near zero). Handle this:\n            this.updateVelocity(event.current.screenPos);\n            // Work around an input issue. Some devices that disable the touchscreen when a stylus\n            // comes near the screen fire a touch-end event at the position of the stylus when a\n            // touch gesture is canceled. Because the stylus is often far away from the last touch,\n            // this causes a great displacement between the second-to-last (from the touchscreen) and\n            // last (from the pen that is now near the screen) events. Only allow velocity to decrease\n            // to work around this:\n            if (oldVelocity.magnitude() < this.velocity.magnitude()) {\n                this.velocity = oldVelocity;\n            }\n            // Cancel any ongoing inertial scrolling.\n            this.inertialScroller?.stop();\n            this.inertialScroller = new InertialScroller(this.velocity, (scrollDelta) => {\n                if (!this.transform) {\n                    return;\n                }\n                const canvasDelta = this.editor.viewport.screenToCanvasTransform.transformVec3(scrollDelta);\n                // Scroll by scrollDelta\n                this.transform.unapply(this.editor);\n                this.transform = Viewport_1.Viewport.transformBy(this.transform.transform.rightMul(math_1.Mat33.translation(canvasDelta)));\n                this.transform.apply(this.editor);\n            }, onComplete);\n        }\n        else {\n            onComplete();\n        }\n    }\n    onGestureCancel() {\n        this.inertialScroller?.stop();\n        this.velocity = math_1.Vec2.zero;\n        this.transform?.unapply(this.editor);\n        this.editor.display.setDraftMode(false);\n        this.transform = null;\n    }\n    // Applies [transformUpdate] to the editor. This stacks on top of the\n    // current transformation, if it exists.\n    updateTransform(transformUpdate, announce = false) {\n        let newTransform = transformUpdate;\n        if (this.transform) {\n            newTransform = this.transform.transform.rightMul(transformUpdate);\n        }\n        this.transform?.unapply(this.editor);\n        this.transform = Viewport_1.Viewport.transformBy(newTransform);\n        this.transform.apply(this.editor);\n        if (announce) {\n            this.editor.announceForAccessibility(this.transform.description(this.editor, this.editor.localization));\n        }\n    }\n    /**\n     * Updates the current transform and clears it. Use this method for events that are not part of\n     * a larger gesture (i.e. have no start and end event). For example, this would be used for `onwheel`\n     * events, but not for `onpointer` events.\n     */\n    applyAndFinalizeTransform(transformUpdate) {\n        this.updateTransform(transformUpdate, true);\n        this.transform = null;\n    }\n    onWheel({ delta, screenPos }) {\n        this.inertialScroller?.stop();\n        // Reset the transformation -- wheel events are individual events, so we don't\n        // need to unapply/reapply.\n        this.transform = Viewport_1.Viewport.transformBy(math_1.Mat33.identity);\n        const canvasPos = this.editor.viewport.screenToCanvas(screenPos);\n        const toCanvas = this.editor.viewport.screenToCanvasTransform;\n        // Transform without including translation\n        const translation = toCanvas.transformVec3(math_1.Vec3.of(-delta.x, -delta.y, 0));\n        let pinchAmount = delta.z;\n        // Clamp the magnitude of pinchAmount\n        pinchAmount = Math.atan(pinchAmount / 2) * 2;\n        const pinchZoomScaleFactor = 1.04;\n        const transformUpdate = math_1.Mat33.scaling2D(Math.max(0.4, Math.min(Math.pow(pinchZoomScaleFactor, -pinchAmount), 4)), canvasPos).rightMul(math_1.Mat33.translation(translation));\n        this.applyAndFinalizeTransform(transformUpdate);\n        return true;\n    }\n    onKeyPress(event) {\n        this.inertialScroller?.stop();\n        if (!(this.mode & PanZoomMode.Keyboard)) {\n            return false;\n        }\n        // No need to keep the same the transform for keyboard events.\n        this.transform = Viewport_1.Viewport.transformBy(math_1.Mat33.identity);\n        let translation = math_1.Vec2.zero;\n        let scale = 1;\n        let rotation = 0;\n        // Keyboard shortcut handling\n        const shortcucts = this.editor.shortcuts;\n        if (shortcucts.matchesShortcut(keybindings_1.moveLeftKeyboardShortcutId, event)) {\n            translation = math_1.Vec2.of(-1, 0);\n        }\n        else if (shortcucts.matchesShortcut(keybindings_1.moveRightKeyboardShortcutId, event)) {\n            translation = math_1.Vec2.of(1, 0);\n        }\n        else if (shortcucts.matchesShortcut(keybindings_1.moveUpKeyboardShortcutId, event)) {\n            translation = math_1.Vec2.of(0, -1);\n        }\n        else if (shortcucts.matchesShortcut(keybindings_1.moveDownKeyboardShortcutId, event)) {\n            translation = math_1.Vec2.of(0, 1);\n        }\n        else if (shortcucts.matchesShortcut(keybindings_1.zoomInKeyboardShortcutId, event)) {\n            scale = 1 / 2;\n        }\n        else if (shortcucts.matchesShortcut(keybindings_1.zoomOutKeyboardShortcutId, event)) {\n            scale = 2;\n        }\n        else if (shortcucts.matchesShortcut(keybindings_1.rotateClockwiseKeyboardShortcutId, event)) {\n            rotation = 1;\n        }\n        else if (shortcucts.matchesShortcut(keybindings_1.rotateCounterClockwiseKeyboardShortcutId, event)) {\n            rotation = -1;\n        }\n        else {\n            return false;\n        }\n        // For each keypress,\n        translation = translation.times(30); // Move at most 30 units\n        rotation *= Math.PI / 8; // Rotate at least a sixteenth of a rotation\n        // Transform the canvas, not the viewport:\n        translation = translation.times(-1);\n        rotation = rotation * -1;\n        scale = 1 / scale;\n        // Work around an issue that seems to be related to rotation matrices losing precision on inversion.\n        // TODO: Figure out why and implement a better solution.\n        if (rotation !== 0) {\n            rotation += 0.0001;\n        }\n        if (this.isRotationLocked()) {\n            rotation = 0;\n        }\n        const toCanvas = this.editor.viewport.screenToCanvasTransform;\n        // Transform without translating (treat toCanvas as a linear instead of\n        // an affine transformation).\n        translation = toCanvas.transformVec3(translation);\n        // Rotate/scale about the center of the canvas\n        const transformCenter = this.editor.viewport.visibleRect.center;\n        const transformUpdate = math_1.Mat33.scaling2D(scale, transformCenter)\n            .rightMul(math_1.Mat33.zRotation(rotation, transformCenter))\n            .rightMul(math_1.Mat33.translation(translation));\n        this.applyAndFinalizeTransform(transformUpdate);\n        return true;\n    }\n    isRotationLocked() {\n        return !!(this.mode & PanZoomMode.RotationLocked);\n    }\n    /**\n     * Changes the types of gestures used by this pan/zoom tool.\n     *\n     * @see {@link PanZoomMode} {@link setMode}\n     *\n     * @example\n     * ```ts,runnable\n     * import { Editor, PanZoomTool, PanZoomMode } from 'js-draw';\n     *\n     * const editor = new Editor(document.body);\n     *\n     * // By default, there are multiple PanZoom tools that handle different events.\n     * // This gets all PanZoomTools.\n     * const panZoomToolList = editor.toolController.getMatchingTools(PanZoomTool);\n     *\n     * // The first PanZoomTool is the highest priority -- by default,\n     * // this tool is responsible for handling multi-finger touch gestures.\n     * //\n     * // Lower-priority PanZoomTools handle one-finger touch gestures and\n     * // key-presses.\n     * const panZoomTool = panZoomToolList[0];\n     *\n     * // Lock rotation for multi-finger touch gestures.\n     * panZoomTool.setModeEnabled(PanZoomMode.RotationLocked, true);\n     * ```\n     */\n    setModeEnabled(mode, enabled) {\n        let newMode = this.mode;\n        if (enabled) {\n            newMode |= mode;\n        }\n        else {\n            newMode &= ~mode;\n        }\n        this.setMode(newMode);\n    }\n    /**\n     * Sets all modes for this tool using a bitmask.\n     *\n     * @see {@link setModeEnabled}\n     *\n     * @example\n     * ```ts\n     * tool.setMode(PanZoomMode.RotationLocked|PanZoomMode.TwoFingerTouchGestures);\n     * ```\n     */\n    setMode(mode) {\n        if (mode !== this.mode) {\n            this.mode = mode;\n            this.editor.notifier.dispatch(types_1.EditorEventType.ToolUpdated, {\n                kind: types_1.EditorEventType.ToolUpdated,\n                tool: this,\n            });\n        }\n    }\n    /**\n     * Returns a bitmask indicating the currently-enabled modes.\n     * @see {@link setModeEnabled}\n     */\n    getMode() {\n        return this.mode;\n    }\n}\nexports[\"default\"] = PanZoom;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/tools/PanZoom.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/tools/PasteHandler.js":
/*!*************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/tools/PasteHandler.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst TextComponent_1 = __importDefault(__webpack_require__(/*! ../components/TextComponent */ \"./node_modules/js-draw/dist/cjs/components/TextComponent.js\"));\nconst SVGLoader_1 = __importDefault(__webpack_require__(/*! ../SVGLoader/SVGLoader */ \"./node_modules/js-draw/dist/cjs/SVGLoader/SVGLoader.js\"));\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\nconst BaseTool_1 = __importDefault(__webpack_require__(/*! ./BaseTool */ \"./node_modules/js-draw/dist/cjs/tools/BaseTool.js\"));\nconst TextTool_1 = __importDefault(__webpack_require__(/*! ./TextTool */ \"./node_modules/js-draw/dist/cjs/tools/TextTool.js\"));\nconst ImageComponent_1 = __importDefault(__webpack_require__(/*! ../components/ImageComponent */ \"./node_modules/js-draw/dist/cjs/components/ImageComponent.js\"));\n/**\n * A tool that handles paste events (e.g. as triggered by ctrl+V).\n *\n * @example\n * While `ToolController` has a `PasteHandler` in its default list of tools,\n * if a non-default set is being used, `PasteHandler` can be added as follows:\n * ```ts\n * const toolController = editor.toolController;\n * toolController.addTool(new PasteHandler(editor));\n * ```\n */\nclass PasteHandler extends BaseTool_1.default {\n    constructor(editor) {\n        super(editor.notifier, editor.localization.pasteHandler);\n        this.editor = editor;\n    }\n    // @internal\n    onPaste(event, onComplete) {\n        const mime = event.mime.toLowerCase();\n        const svgData = (() => {\n            if (mime === 'image/svg+xml') {\n                return event.data;\n            }\n            // In some environments, it isn't possible to write non-text data to the\n            // clipboard. To support these cases, auto-detect text/plain SVG data.\n            if (mime === 'text/plain') {\n                const trimmedData = event.data.trim();\n                if (trimmedData.startsWith('<svg') && trimmedData.endsWith('</svg>')) {\n                    return trimmedData;\n                }\n            }\n            if (mime !== 'text/html') {\n                return false;\n            }\n            // text/html is sometimes handlable SVG data. Use a hueristic\n            // to determine if this is the case:\n            // We use [^] and not . so that newlines are included.\n            const match = event.data.match(/^[^]{0,200}<svg.*/i); // [^]{0,200} <- Allow for metadata near start\n            if (!match) {\n                return false;\n            }\n            // Extract the SVG element from the pasted data\n            let svgEnd = event.data.toLowerCase().lastIndexOf('</svg>');\n            if (svgEnd === -1)\n                svgEnd = event.data.length;\n            return event.data.substring(event.data.search(/<svg/i), svgEnd);\n        })();\n        if (svgData) {\n            void this.doSVGPaste(svgData).then(onComplete);\n            return true;\n        }\n        else if (mime === 'text/plain') {\n            void this.doTextPaste(event.data).then(onComplete);\n            return true;\n        }\n        else if (mime === 'image/png' || mime === 'image/jpeg') {\n            void this.doImagePaste(event.data).then(onComplete);\n            return true;\n        }\n        return false;\n    }\n    async addComponentsFromPaste(components) {\n        await this.editor.addAndCenterComponents(components, true, this.editor.localization.pasted(components.length));\n    }\n    async doSVGPaste(data) {\n        this.editor.showLoadingWarning(0);\n        try {\n            const loader = SVGLoader_1.default.fromString(data, true);\n            const components = [];\n            await loader.start((component) => {\n                components.push(component);\n            }, (_countProcessed, _totalToProcess) => null);\n            await this.addComponentsFromPaste(components);\n        }\n        finally {\n            this.editor.hideLoadingWarning();\n        }\n    }\n    async doTextPaste(text) {\n        const textTools = this.editor.toolController.getMatchingTools(TextTool_1.default);\n        textTools.sort((a, b) => {\n            if (!a.isEnabled() && b.isEnabled()) {\n                return -1;\n            }\n            if (!b.isEnabled() && a.isEnabled()) {\n                return 1;\n            }\n            return 0;\n        });\n        const defaultTextStyle = {\n            size: 12,\n            fontFamily: 'sans',\n            renderingStyle: { fill: math_1.Color4.red },\n        };\n        const pastedTextStyle = textTools[0]?.getTextStyle() ?? defaultTextStyle;\n        // Don't paste text that would be invisible.\n        if (text.trim() === '') {\n            return;\n        }\n        const lines = text.split('\\n');\n        await this.addComponentsFromPaste([\n            TextComponent_1.default.fromLines(lines, math_1.Mat33.identity, pastedTextStyle),\n        ]);\n    }\n    async doImagePaste(dataURL) {\n        const image = new Image();\n        image.src = dataURL;\n        const component = await ImageComponent_1.default.fromImage(image, math_1.Mat33.identity);\n        await this.addComponentsFromPaste([component]);\n    }\n}\nexports[\"default\"] = PasteHandler;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/tools/PasteHandler.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/tools/Pen.js":
/*!****************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/tools/Pen.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\nconst EditorImage_1 = __importDefault(__webpack_require__(/*! ../image/EditorImage */ \"./node_modules/js-draw/dist/cjs/image/EditorImage.js\"));\nconst Pointer_1 = __webpack_require__(/*! ../Pointer */ \"./node_modules/js-draw/dist/cjs/Pointer.js\");\nconst FreehandLineBuilder_1 = __webpack_require__(/*! ../components/builders/FreehandLineBuilder */ \"./node_modules/js-draw/dist/cjs/components/builders/FreehandLineBuilder.js\");\nconst types_1 = __webpack_require__(/*! ../types */ \"./node_modules/js-draw/dist/cjs/types.js\");\nconst BaseTool_1 = __importDefault(__webpack_require__(/*! ./BaseTool */ \"./node_modules/js-draw/dist/cjs/tools/BaseTool.js\"));\nconst keybindings_1 = __webpack_require__(/*! ./keybindings */ \"./node_modules/js-draw/dist/cjs/tools/keybindings.js\");\nconst keybindings_2 = __webpack_require__(/*! ./keybindings */ \"./node_modules/js-draw/dist/cjs/tools/keybindings.js\");\nconst InputStabilizer_1 = __importDefault(__webpack_require__(/*! ./InputFilter/InputStabilizer */ \"./node_modules/js-draw/dist/cjs/tools/InputFilter/InputStabilizer.js\"));\nconst ReactiveValue_1 = __webpack_require__(/*! ../util/ReactiveValue */ \"./node_modules/js-draw/dist/cjs/util/ReactiveValue.js\");\nconst StationaryPenDetector_1 = __importStar(__webpack_require__(/*! ./util/StationaryPenDetector */ \"./node_modules/js-draw/dist/cjs/tools/util/StationaryPenDetector.js\"));\n/**\n * A tool that allows drawing shapes and freehand lines.\n *\n * To change the type of shape drawn by the pen (e.g. to switch to the rectangle\n * pen type), see {@link setStrokeFactory}.\n */\nclass Pen extends BaseTool_1.default {\n    constructor(editor, description, style) {\n        super(editor.notifier, description);\n        this.editor = editor;\n        this.builder = null;\n        this.lastPoint = null;\n        this.startPoint = null;\n        this.currentDeviceType = null;\n        this.currentPointerId = null;\n        this.shapeAutocompletionEnabled = false;\n        this.autocorrectedShape = null;\n        this.lastAutocorrectedShape = null;\n        this.removedAutocorrectedShapeTime = 0;\n        this.stationaryDetector = null;\n        this.styleValue = ReactiveValue_1.ReactiveValue.fromInitialValue({\n            factory: FreehandLineBuilder_1.makeFreehandLineBuilder,\n            color: math_1.Color4.blue,\n            thickness: 4,\n            ...style,\n        });\n        this.styleValue.onUpdateAndNow((newValue) => {\n            this.style = newValue;\n            this.noteUpdated();\n        });\n    }\n    getPressureMultiplier() {\n        const thickness = this.style.thickness;\n        return (1 / this.editor.viewport.getScaleFactor()) * thickness;\n    }\n    // Converts a `pointer` to a `StrokeDataPoint`.\n    toStrokePoint(pointer) {\n        const minPressure = 0.3;\n        let pressure = Math.max(pointer.pressure ?? 1.0, minPressure);\n        if (!isFinite(pressure)) {\n            console.warn('Non-finite pressure!', pointer);\n            pressure = minPressure;\n        }\n        console.assert(isFinite(pointer.canvasPos.length()), 'Non-finite canvas position!');\n        console.assert(isFinite(pointer.screenPos.length()), 'Non-finite screen position!');\n        console.assert(isFinite(pointer.timeStamp), 'Non-finite timeStamp on pointer!');\n        const pos = pointer.canvasPos;\n        return {\n            pos,\n            width: pressure * this.getPressureMultiplier(),\n            color: this.style.color,\n            time: pointer.timeStamp,\n        };\n    }\n    // Displays the stroke that is currently being built with the display's `wetInkRenderer`.\n    previewStroke() {\n        this.editor.clearWetInk();\n        const wetInkRenderer = this.editor.display.getWetInkRenderer();\n        if (this.autocorrectedShape) {\n            const visibleRect = this.editor.viewport.visibleRect;\n            this.autocorrectedShape.render(wetInkRenderer, visibleRect);\n        }\n        else {\n            this.builder?.preview(wetInkRenderer);\n        }\n    }\n    // Throws if no stroke builder exists.\n    addPointToStroke(point) {\n        if (!this.builder) {\n            throw new Error('No stroke is currently being generated.');\n        }\n        this.builder.addPoint(point);\n        this.lastPoint = point;\n        this.previewStroke();\n    }\n    onPointerDown(event) {\n        // Avoid canceling an existing stroke\n        if (this.builder && !this.eventCanCancelStroke(event)) {\n            return true;\n        }\n        const { current, allPointers } = event;\n        const isEraser = current.device === Pointer_1.PointerDevice.Eraser;\n        const isPen = current.device === Pointer_1.PointerDevice.Pen;\n        // Always start strokes if the current device is a pen. This is useful in the case\n        // where an accidental touch gesture from a user's hand is ongoing. This gesture\n        // should not prevent the user from drawing.\n        if ((allPointers.length === 1 && !isEraser) || isPen) {\n            this.startPoint = this.toStrokePoint(current);\n            this.builder = this.style.factory(this.startPoint, this.editor.viewport);\n            this.currentDeviceType = current.device;\n            this.currentPointerId = current.id;\n            if (this.shapeAutocompletionEnabled) {\n                this.stationaryDetector = new StationaryPenDetector_1.default(current, StationaryPenDetector_1.defaultStationaryDetectionConfig, (pointer) => this.autocorrectShape(pointer));\n            }\n            else {\n                this.stationaryDetector = null;\n            }\n            this.lastAutocorrectedShape = null;\n            this.removedAutocorrectedShapeTime = 0;\n            return true;\n        }\n        return false;\n    }\n    eventCanCancelStroke(event) {\n        // If there has been a delay since the last input event,\n        // it's always okay to cancel\n        const lastInputTime = this.lastPoint?.time ?? 0;\n        if (event.current.timeStamp - lastInputTime > 1000) {\n            return true;\n        }\n        const isPenStroke = this.currentDeviceType === Pointer_1.PointerDevice.Pen;\n        const isTouchEvent = event.current.device === Pointer_1.PointerDevice.Touch;\n        // Don't allow pen strokes to be cancelled by touch events.\n        if (isPenStroke && isTouchEvent) {\n            return false;\n        }\n        return true;\n    }\n    eventCanBeDeliveredToNonActiveTool(event) {\n        return this.eventCanCancelStroke(event);\n    }\n    onPointerMove({ current }) {\n        if (!this.builder)\n            return;\n        if (current.device !== this.currentDeviceType)\n            return;\n        if (current.id !== this.currentPointerId)\n            return;\n        const isStationary = this.stationaryDetector?.onPointerMove(current);\n        if (!isStationary) {\n            this.addPointToStroke(this.toStrokePoint(current));\n            if (this.autocorrectedShape) {\n                this.removedAutocorrectedShapeTime = performance.now();\n                this.autocorrectedShape = null;\n                this.editor.announceForAccessibility(this.editor.localization.autocorrectionCanceled);\n            }\n        }\n    }\n    onPointerUp({ current }) {\n        if (!this.builder)\n            return false;\n        if (current.id !== this.currentPointerId) {\n            // this.builder still exists, so we're handling events from another\n            // device type.\n            return true;\n        }\n        this.stationaryDetector?.onPointerUp(current);\n        // onPointerUp events can have zero pressure. Use the last pressure instead.\n        const currentPoint = this.toStrokePoint(current);\n        const strokePoint = {\n            ...currentPoint,\n            width: this.lastPoint?.width ?? currentPoint.width,\n        };\n        this.addPointToStroke(strokePoint);\n        this.finalizeStroke();\n        return false;\n    }\n    onGestureCancel() {\n        this.builder = null;\n        this.editor.clearWetInk();\n        this.stationaryDetector?.destroy();\n        this.stationaryDetector = null;\n    }\n    removedAutocorrectedShapeRecently() {\n        return this.removedAutocorrectedShapeTime > performance.now() - 320;\n    }\n    async autocorrectShape(_lastPointer) {\n        if (!this.builder || !this.builder.autocorrectShape)\n            return;\n        if (!this.shapeAutocompletionEnabled)\n            return;\n        // If already corrected, do nothing\n        if (this.autocorrectedShape)\n            return;\n        // Activate stroke fitting\n        const correctedShape = await this.builder.autocorrectShape();\n        if (!this.builder || !correctedShape) {\n            return;\n        }\n        // Don't complete to empty shapes.\n        const bboxArea = correctedShape.getBBox().area;\n        if (bboxArea === 0 || !isFinite(bboxArea)) {\n            return;\n        }\n        const shapeDescription = correctedShape.description(this.editor.localization);\n        this.editor.announceForAccessibility(this.editor.localization.autocorrectedTo(shapeDescription));\n        this.autocorrectedShape = correctedShape;\n        this.lastAutocorrectedShape = correctedShape;\n        this.previewStroke();\n    }\n    finalizeStroke() {\n        if (this.builder) {\n            // If autocorrectedShape was cleared recently enough, it was\n            // probably by mistake. Reset it.\n            if (this.lastAutocorrectedShape && this.removedAutocorrectedShapeRecently()) {\n                this.autocorrectedShape = this.lastAutocorrectedShape;\n            }\n            const stroke = this.autocorrectedShape ?? this.builder.build();\n            this.previewStroke();\n            if (stroke.getBBox().area > 0) {\n                if (stroke === this.autocorrectedShape) {\n                    this.editor.announceForAccessibility(this.editor.localization.autocorrectedTo(stroke.description(this.editor.localization)));\n                }\n                const canFlatten = true;\n                const action = EditorImage_1.default.addElement(stroke, canFlatten);\n                this.editor.dispatch(action);\n            }\n            else {\n                console.warn('Pen: Not adding empty stroke', stroke, 'to the canvas.');\n            }\n        }\n        this.builder = null;\n        this.lastPoint = null;\n        this.autocorrectedShape = null;\n        this.lastAutocorrectedShape = null;\n        this.editor.clearWetInk();\n        this.stationaryDetector?.destroy();\n        this.stationaryDetector = null;\n    }\n    noteUpdated() {\n        this.editor.notifier.dispatch(types_1.EditorEventType.ToolUpdated, {\n            kind: types_1.EditorEventType.ToolUpdated,\n            tool: this,\n        });\n    }\n    setColor(color) {\n        if (color.toHexString() !== this.style.color.toHexString()) {\n            this.styleValue.set({\n                ...this.style,\n                color,\n            });\n        }\n    }\n    setThickness(thickness) {\n        if (thickness !== this.style.thickness) {\n            this.styleValue.set({\n                ...this.style,\n                thickness,\n            });\n        }\n    }\n    /**\n     * Changes the type of stroke created by the pen. The given `factory` can be one of the built-in\n     * stroke factories (e.g. {@link makeFreehandLineBuilder}) or a custom stroke factory.\n     *\n     * Example:\n     * [[include:doc-pages/inline-examples/changing-pen-types.md]]\n     */\n    setStrokeFactory(factory) {\n        if (factory !== this.style.factory) {\n            this.styleValue.set({\n                ...this.style,\n                factory,\n            });\n        }\n    }\n    setHasStabilization(hasStabilization) {\n        const hasInputMapper = !!this.getInputMapper();\n        // TODO: Currently, this assumes that there is no other input mapper.\n        if (hasStabilization === hasInputMapper) {\n            return;\n        }\n        if (hasInputMapper) {\n            this.setInputMapper(null);\n        }\n        else {\n            this.setInputMapper(new InputStabilizer_1.default(this.editor.viewport));\n        }\n        this.noteUpdated();\n    }\n    setStrokeAutocorrectEnabled(enabled) {\n        if (enabled !== this.shapeAutocompletionEnabled) {\n            this.shapeAutocompletionEnabled = enabled;\n            this.noteUpdated();\n        }\n    }\n    getStrokeAutocorrectionEnabled() {\n        return this.shapeAutocompletionEnabled;\n    }\n    getThickness() {\n        return this.style.thickness;\n    }\n    getColor() {\n        return this.style.color;\n    }\n    getStrokeFactory() {\n        return this.style.factory;\n    }\n    getStyleValue() {\n        return this.styleValue;\n    }\n    onKeyPress(event) {\n        const shortcuts = this.editor.shortcuts;\n        // Ctrl+Z: End the stroke so that it can be undone/redone.\n        const isCtrlZ = shortcuts.matchesShortcut(keybindings_1.undoKeyboardShortcutId, event);\n        if (this.builder && isCtrlZ) {\n            this.finalizeStroke();\n            // Return false: Allow other listeners to handle the event (e.g.\n            // undo/redo).\n            return false;\n        }\n        let newThickness;\n        if (shortcuts.matchesShortcut(keybindings_2.decreaseSizeKeyboardShortcutId, event)) {\n            newThickness = (this.getThickness() * 2) / 3;\n        }\n        else if (shortcuts.matchesShortcut(keybindings_2.increaseSizeKeyboardShortcutId, event)) {\n            newThickness = (this.getThickness() * 3) / 2;\n        }\n        if (newThickness !== undefined) {\n            newThickness = Math.min(Math.max(1, newThickness), 256);\n            this.setThickness(newThickness);\n            return true;\n        }\n        return false;\n    }\n}\nexports[\"default\"] = Pen;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/tools/Pen.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/tools/PipetteTool.js":
/*!************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/tools/PipetteTool.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n// @internal @packageDocumentation\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst BaseTool_1 = __importDefault(__webpack_require__(/*! ./BaseTool */ \"./node_modules/js-draw/dist/cjs/tools/BaseTool.js\"));\n/**\n * A tool used internally to pick colors from the canvas.\n *\n * When color selection is in progress, the `pipette--color-selection-in-progress` class\n * is added to the root element. This can be used by themes.\n *\n * @internal\n */\nclass PipetteTool extends BaseTool_1.default {\n    constructor(editor, description) {\n        super(editor.notifier, description);\n        this.editor = editor;\n        this.colorPreviewListener = null;\n        this.colorSelectListener = null;\n        this.enabledValue().onUpdateAndNow(() => {\n            this.updateSelectingStatus();\n        });\n    }\n    canReceiveInputInReadOnlyEditor() {\n        return true;\n    }\n    // Ensures that the root editor element correctly reflects whether color selection\n    // is in progress.\n    updateSelectingStatus() {\n        const className = 'pipette--color-selection-in-progress';\n        if (this.isEnabled() && this.colorSelectListener && this.colorPreviewListener) {\n            this.editor.getRootElement().classList.add(className);\n        }\n        else {\n            this.editor.getRootElement().classList.remove(className);\n        }\n    }\n    setColorListener(colorPreviewListener, \n    // Called when the gesture ends -- when the user has selected a color.\n    colorSelectListener) {\n        this.colorPreviewListener = colorPreviewListener;\n        this.colorSelectListener = colorSelectListener;\n        this.updateSelectingStatus();\n    }\n    clearColorListener() {\n        this.colorPreviewListener = null;\n        this.colorSelectListener = null;\n        this.updateSelectingStatus();\n    }\n    onPointerDown({ current, allPointers }) {\n        if (this.colorPreviewListener && allPointers.length === 1) {\n            this.colorPreviewListener(this.editor.display.getColorAt(current.screenPos));\n            return true;\n        }\n        return false;\n    }\n    onPointerMove({ current }) {\n        this.colorPreviewListener?.(this.editor.display.getColorAt(current.screenPos));\n    }\n    onPointerUp({ current }) {\n        this.colorSelectListener?.(this.editor.display.getColorAt(current.screenPos));\n    }\n    onGestureCancel() {\n        this.colorSelectListener?.(null);\n    }\n}\nexports[\"default\"] = PipetteTool;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/tools/PipetteTool.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/tools/ScrollbarTool.js":
/*!**************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/tools/ScrollbarTool.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\nconst types_1 = __webpack_require__(/*! ../types */ \"./node_modules/js-draw/dist/cjs/types.js\");\nconst BaseTool_1 = __importDefault(__webpack_require__(/*! ./BaseTool */ \"./node_modules/js-draw/dist/cjs/tools/BaseTool.js\"));\n/**\n * This tool, when enabled, renders scrollbars reflecting the current position\n * of the view relative to the import/export area of the image.\n *\n * **Note**: These scrollbars are currently not draggable. This may change in\n * a future release.\n */\nclass ScrollbarTool extends BaseTool_1.default {\n    constructor(editor) {\n        super(editor.notifier, 'scrollbar');\n        this.editor = editor;\n        this.fadeOutTimeout = null;\n        this.scrollbarOverlay = document.createElement('div');\n        this.scrollbarOverlay.classList.add('ScrollbarTool-overlay');\n        this.verticalScrollbar = document.createElement('div');\n        this.verticalScrollbar.classList.add('vertical-scrollbar');\n        this.horizontalScrollbar = document.createElement('div');\n        this.horizontalScrollbar.classList.add('horizontal-scrollbar');\n        this.scrollbarOverlay.replaceChildren(this.verticalScrollbar, this.horizontalScrollbar);\n        let overlay = null;\n        let viewportListener = null;\n        this.enabledValue().onUpdateAndNow((enabled) => {\n            overlay?.remove();\n            viewportListener?.remove();\n            viewportListener = null;\n            overlay = null;\n            if (enabled) {\n                viewportListener = editor.notifier.on(types_1.EditorEventType.ViewportChanged, (_event) => {\n                    this.updateScrollbars();\n                });\n                this.updateScrollbars();\n                overlay = editor.createHTMLOverlay(this.scrollbarOverlay);\n            }\n        });\n    }\n    updateScrollbars() {\n        const viewport = this.editor.viewport;\n        const screenSize = viewport.getScreenRectSize();\n        const screenRect = new math_1.Rect2(0, 0, screenSize.x, screenSize.y);\n        const imageRect = this.editor\n            .getImportExportRect()\n            // The scrollbars are positioned in screen coordinates, so the exportRect also needs\n            // to be in screen coordinates\n            .transformedBoundingBox(viewport.canvasToScreenTransform)\n            // If the screenRect is outside of the exportRect, expand the image rectangle\n            .union(screenRect);\n        const scrollbarWidth = (screenRect.width / imageRect.width) * screenSize.x;\n        const scrollbarHeight = (screenRect.height / imageRect.height) * screenSize.y;\n        const scrollbarX = ((screenRect.x - imageRect.x) / imageRect.width) * screenSize.x;\n        const scrollbarY = ((screenRect.y - imageRect.y) / imageRect.height) * screenSize.y;\n        this.horizontalScrollbar.style.width = `${scrollbarWidth}px`;\n        this.verticalScrollbar.style.height = `${scrollbarHeight}px`;\n        this.horizontalScrollbar.style.marginLeft = `${scrollbarX}px`;\n        this.verticalScrollbar.style.marginTop = `${scrollbarY}px`;\n        // Style the scrollbars differently when there's no scroll (all content visible)\n        const handleNoScrollStyling = (scrollbar, size, fillSize) => {\n            const fillsWindowClass = 'represents-no-scroll';\n            if (Math.abs(size - fillSize) < 1e-8) {\n                scrollbar.classList.add(fillsWindowClass);\n            }\n            else {\n                scrollbar.classList.remove(fillsWindowClass);\n            }\n        };\n        handleNoScrollStyling(this.horizontalScrollbar, scrollbarWidth, screenSize.x);\n        handleNoScrollStyling(this.verticalScrollbar, scrollbarHeight, screenSize.y);\n        // Fade out after a delay.\n        if (this.fadeOutTimeout !== null) {\n            clearTimeout(this.fadeOutTimeout);\n        }\n        const fadeOutDelay = 3000;\n        this.fadeOutTimeout = setTimeout(() => {\n            this.scrollbarOverlay.classList.remove('just-updated');\n        }, fadeOutDelay);\n        this.scrollbarOverlay.classList.add('just-updated');\n    }\n}\nexports[\"default\"] = ScrollbarTool;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/tools/ScrollbarTool.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/tools/SelectionTool/SelectAllShortcutHandler.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/tools/SelectionTool/SelectAllShortcutHandler.js ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst BaseTool_1 = __importDefault(__webpack_require__(/*! ../BaseTool */ \"./node_modules/js-draw/dist/cjs/tools/BaseTool.js\"));\nconst keybindings_1 = __webpack_require__(/*! ../keybindings */ \"./node_modules/js-draw/dist/cjs/tools/keybindings.js\");\nconst SelectionTool_1 = __importDefault(__webpack_require__(/*! ./SelectionTool */ \"./node_modules/js-draw/dist/cjs/tools/SelectionTool/SelectionTool.js\"));\n// Handles ctrl+a: Select all\nclass SelectAllShortcutHandler extends BaseTool_1.default {\n    constructor(editor) {\n        super(editor.notifier, editor.localization.selectAllTool);\n        this.editor = editor;\n    }\n    canReceiveInputInReadOnlyEditor() {\n        return true;\n    }\n    // @internal\n    onKeyPress(event) {\n        if (this.editor.shortcuts.matchesShortcut(keybindings_1.selectAllKeyboardShortcut, event)) {\n            const selectionTools = this.editor.toolController.getMatchingTools(SelectionTool_1.default);\n            if (selectionTools.length > 0) {\n                const selectionTool = selectionTools[0];\n                selectionTool.setEnabled(true);\n                selectionTool.setSelection(this.editor.image.getAllElements());\n                return true;\n            }\n        }\n        return false;\n    }\n}\nexports[\"default\"] = SelectAllShortcutHandler;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/tools/SelectionTool/SelectAllShortcutHandler.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/tools/SelectionTool/Selection.js":
/*!************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/tools/SelectionTool/Selection.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * @internal\n * @packageDocumentation\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar _a;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst SerializableCommand_1 = __importDefault(__webpack_require__(/*! ../../commands/SerializableCommand */ \"./node_modules/js-draw/dist/cjs/commands/SerializableCommand.js\"));\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\nconst SelectionHandle_1 = __importStar(__webpack_require__(/*! ./SelectionHandle */ \"./node_modules/js-draw/dist/cjs/tools/SelectionTool/SelectionHandle.js\"));\nconst SelectionTool_1 = __webpack_require__(/*! ./SelectionTool */ \"./node_modules/js-draw/dist/cjs/tools/SelectionTool/SelectionTool.js\");\nconst Viewport_1 = __importDefault(__webpack_require__(/*! ../../Viewport */ \"./node_modules/js-draw/dist/cjs/Viewport.js\"));\nconst Erase_1 = __importDefault(__webpack_require__(/*! ../../commands/Erase */ \"./node_modules/js-draw/dist/cjs/commands/Erase.js\"));\nconst Duplicate_1 = __importDefault(__webpack_require__(/*! ../../commands/Duplicate */ \"./node_modules/js-draw/dist/cjs/commands/Duplicate.js\"));\nconst TransformMode_1 = __webpack_require__(/*! ./TransformMode */ \"./node_modules/js-draw/dist/cjs/tools/SelectionTool/TransformMode.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"./node_modules/js-draw/dist/cjs/tools/SelectionTool/types.js\");\nconst EditorImage_1 = __importDefault(__webpack_require__(/*! ../../image/EditorImage */ \"./node_modules/js-draw/dist/cjs/image/EditorImage.js\"));\nconst uniteCommands_1 = __importDefault(__webpack_require__(/*! ../../commands/uniteCommands */ \"./node_modules/js-draw/dist/cjs/commands/uniteCommands.js\"));\nconst SelectionMenuShortcut_1 = __importDefault(__webpack_require__(/*! ./SelectionMenuShortcut */ \"./node_modules/js-draw/dist/cjs/tools/SelectionTool/SelectionMenuShortcut.js\"));\nconst updateChunkSize = 100;\nconst maxPreviewElemCount = 500;\n// @internal\nclass Selection {\n    constructor(startPoint, editor, showContextMenu) {\n        this.editor = editor;\n        // The last-computed bounding box of selected content\n        // @see getTightBoundingBox\n        this.selectionTightBoundingBox = null;\n        this.transform = math_1.Mat33.identity;\n        // invariant: sorted by increasing z-index\n        this.selectedElems = [];\n        this.hasParent = true;\n        // Maps IDs to whether we removed the component from the image\n        this.removedFromImage = {};\n        this.activeHandle = null;\n        this.backgroundDragging = false;\n        this.selectionDuplicatedAnimationTimeout = null;\n        this.originalRegion = new math_1.Rect2(startPoint.x, startPoint.y, 0, 0);\n        this.transformers = {\n            drag: new TransformMode_1.DragTransformer(editor, this),\n            resize: new TransformMode_1.ResizeTransformer(editor, this),\n            rotate: new TransformMode_1.RotateTransformer(editor, this),\n        };\n        // We need two containers for some CSS to apply (the outer container\n        // needs zero height, the inner needs to prevent the selection background\n        // from being visible outside of the editor).\n        this.outerContainer = document.createElement('div');\n        this.outerContainer.classList.add(`${SelectionTool_1.cssPrefix}selection-outer-container`);\n        this.innerContainer = document.createElement('div');\n        this.innerContainer.classList.add(`${SelectionTool_1.cssPrefix}selection-inner-container`);\n        this.backgroundElem = document.createElement('div');\n        this.backgroundElem.classList.add(`${SelectionTool_1.cssPrefix}selection-background`);\n        this.innerContainer.appendChild(this.backgroundElem);\n        this.outerContainer.appendChild(this.innerContainer);\n        const makeResizeHandle = (mode, side) => {\n            const modeToAction = {\n                [types_1.ResizeMode.Both]: SelectionHandle_1.HandleAction.ResizeXY,\n                [types_1.ResizeMode.HorizontalOnly]: SelectionHandle_1.HandleAction.ResizeX,\n                [types_1.ResizeMode.VerticalOnly]: SelectionHandle_1.HandleAction.ResizeY,\n            };\n            return new SelectionHandle_1.default({\n                action: modeToAction[mode],\n                side,\n            }, this, this.editor.viewport, (startPoint) => this.transformers.resize.onDragStart(startPoint, mode), (currentPoint) => this.transformers.resize.onDragUpdate(currentPoint), () => this.transformers.resize.onDragEnd());\n        };\n        const resizeHorizontalHandles = [\n            makeResizeHandle(types_1.ResizeMode.HorizontalOnly, math_1.Vec2.of(0, 0.5)),\n            makeResizeHandle(types_1.ResizeMode.HorizontalOnly, math_1.Vec2.of(1, 0.5)),\n        ];\n        const resizeVerticalHandle = makeResizeHandle(types_1.ResizeMode.VerticalOnly, math_1.Vec2.of(0.5, 1));\n        const resizeBothHandle = makeResizeHandle(types_1.ResizeMode.Both, math_1.Vec2.of(1, 1));\n        const rotationHandle = new SelectionHandle_1.default({\n            action: SelectionHandle_1.HandleAction.Rotate,\n            side: math_1.Vec2.of(0.5, 0),\n            icon: this.editor.icons.makeRotateIcon(),\n        }, this, this.editor.viewport, (startPoint) => this.transformers.rotate.onDragStart(startPoint), (currentPoint) => this.transformers.rotate.onDragUpdate(currentPoint), () => this.transformers.rotate.onDragEnd());\n        const menuToggleButton = new SelectionMenuShortcut_1.default(this, this.editor.viewport, this.editor.icons.makeOverflowIcon(), showContextMenu, this.editor.localization);\n        this.childwidgets = [\n            menuToggleButton,\n            resizeBothHandle,\n            ...resizeHorizontalHandles,\n            resizeVerticalHandle,\n            rotationHandle,\n        ];\n        for (const widget of this.childwidgets) {\n            widget.addTo(this.backgroundElem);\n        }\n        this.updateUI();\n    }\n    // @internal Intended for unit tests\n    getBackgroundElem() {\n        return this.backgroundElem;\n    }\n    getTransform() {\n        return this.transform;\n    }\n    get preTransformRegion() {\n        return this.originalRegion;\n    }\n    // The **canvas** region.\n    get region() {\n        // TODO: This currently assumes that the region rotates about its center.\n        // This may not be true.\n        const rotationMatrix = math_1.Mat33.zRotation(this.regionRotation, this.originalRegion.center);\n        const scaleAndTranslateMat = this.transform.rightMul(rotationMatrix.inverse());\n        return this.originalRegion.transformedBoundingBox(scaleAndTranslateMat);\n    }\n    /**\n     * Computes and returns the bounding box of the selection without\n     * any additional padding. Computes directly from the elements that are selected.\n     * @internal\n     */\n    computeTightBoundingBox() {\n        const bbox = this.selectedElems.reduce((accumulator, elem) => {\n            return (accumulator ?? elem.getBBox()).union(elem.getBBox());\n        }, null);\n        return bbox ?? math_1.Rect2.empty;\n    }\n    get regionRotation() {\n        return this.transform.transformVec3(math_1.Vec2.unitX).angle();\n    }\n    get preTransformedScreenRegion() {\n        const toScreen = (vec) => this.editor.viewport.canvasToScreen(vec);\n        return math_1.Rect2.fromCorners(toScreen(this.preTransformRegion.topLeft), toScreen(this.preTransformRegion.bottomRight));\n    }\n    get preTransformedScreenRegionRotation() {\n        return this.editor.viewport.getRotationAngle();\n    }\n    getScreenRegion() {\n        const toScreen = this.editor.viewport.canvasToScreenTransform;\n        const scaleFactor = this.editor.viewport.getScaleFactor();\n        const screenCenter = toScreen.transformVec2(this.region.center);\n        return new math_1.Rect2(screenCenter.x, screenCenter.y, scaleFactor * this.region.width, scaleFactor * this.region.height).translatedBy(this.region.size.times(-scaleFactor / 2));\n    }\n    get screenRegionRotation() {\n        return this.regionRotation + this.editor.viewport.getRotationAngle();\n    }\n    // Applies, previews, but doesn't finalize the given transformation.\n    setTransform(transform, preview = true) {\n        this.transform = transform;\n        if (preview && this.hasParent) {\n            this.previewTransformCmds();\n        }\n    }\n    getDeltaZIndexToMoveSelectionToTop() {\n        if (this.selectedElems.length === 0) {\n            return 0;\n        }\n        const selectedBottommostZIndex = this.selectedElems[0].getZIndex();\n        const visibleObjects = this.editor.image.getElementsIntersectingRegion(this.region);\n        const topMostVisibleZIndex = visibleObjects[visibleObjects.length - 1]?.getZIndex() ?? selectedBottommostZIndex;\n        const deltaZIndex = topMostVisibleZIndex + 1 - selectedBottommostZIndex;\n        return deltaZIndex;\n    }\n    // Applies the current transformation to the selection\n    finalizeTransform() {\n        const fullTransform = this.transform;\n        const selectedElems = this.selectedElems;\n        // Reset for the next drag\n        this.originalRegion = this.originalRegion.transformedBoundingBox(this.transform);\n        this.transform = math_1.Mat33.identity;\n        this.scrollTo();\n        let transformPromise = undefined;\n        // Make the commands undo-able.\n        // Don't check for non-empty transforms because this breaks changing the\n        // z-index of the just-transformed commands.\n        if (this.selectedElems.length > 0) {\n            const deltaZIndex = this.getDeltaZIndexToMoveSelectionToTop();\n            transformPromise = this.editor.dispatch(new _a.ApplyTransformationCommand(this, selectedElems, fullTransform, deltaZIndex));\n        }\n        return transformPromise;\n    }\n    /** Sends all selected elements to the bottom of the visible image. */\n    sendToBack() {\n        const visibleObjects = this.editor.image.getElementsIntersectingRegion(this.editor.viewport.visibleRect);\n        // VisibleObjects and selectedElems should both be sorted by z-index\n        const lowestVisibleZIndex = visibleObjects[0]?.getZIndex() ?? 0;\n        const highestSelectedZIndex = this.selectedElems[this.selectedElems.length - 1]?.getZIndex() ?? 0;\n        const targetHighestZIndex = lowestVisibleZIndex - 1;\n        const deltaZIndex = targetHighestZIndex - highestSelectedZIndex;\n        if (deltaZIndex !== 0) {\n            const commands = this.selectedElems.map((elem) => {\n                return elem.setZIndex(elem.getZIndex() + deltaZIndex);\n            });\n            return (0, uniteCommands_1.default)(commands, updateChunkSize);\n        }\n        return null;\n    }\n    // Preview the effects of the current transformation on the selection\n    previewTransformCmds() {\n        if (this.selectedElems.length === 0) {\n            return;\n        }\n        // Don't render what we're moving if it's likely to be slow.\n        if (this.selectedElems.length > maxPreviewElemCount) {\n            this.updateUI();\n            return;\n        }\n        const wetInkRenderer = this.editor.display.getWetInkRenderer();\n        wetInkRenderer.clear();\n        wetInkRenderer.pushTransform(this.transform);\n        const viewportVisibleRect = this.editor.viewport.visibleRect.union(this.region);\n        const visibleRect = viewportVisibleRect.transformedBoundingBox(this.transform.inverse());\n        for (const elem of this.selectedElems) {\n            elem.render(wetInkRenderer, visibleRect);\n        }\n        wetInkRenderer.popTransform();\n        this.updateUI();\n    }\n    // Find the objects corresponding to this in the document,\n    // select them.\n    // Returns false iff nothing was selected.\n    resolveToObjects() {\n        let singleItemSelectionMode = false;\n        this.transform = math_1.Mat33.identity;\n        // Grow the rectangle, if necessary\n        if (this.region.w === 0 || this.region.h === 0) {\n            const padding = this.editor.viewport.visibleRect.maxDimension / 200;\n            this.originalRegion = math_1.Rect2.bboxOf(this.region.corners, padding);\n            // Only select one item if the rectangle was very small.\n            singleItemSelectionMode = true;\n        }\n        this.selectedElems = this.editor.image\n            .getElementsIntersectingRegion(this.region)\n            .filter((elem) => {\n            return elem.intersectsRect(this.region) && elem.isSelectable();\n        });\n        if (singleItemSelectionMode && this.selectedElems.length > 0) {\n            this.selectedElems = [this.selectedElems[this.selectedElems.length - 1]];\n        }\n        // Find the bounding box of all selected elements.\n        if (!this.recomputeRegion()) {\n            return false;\n        }\n        this.updateUI();\n        return true;\n    }\n    // Recompute this' region from the selected elements.\n    // Returns false if the selection is empty.\n    recomputeRegion() {\n        const newRegion = this.computeTightBoundingBox();\n        this.selectionTightBoundingBox = newRegion;\n        if (!newRegion) {\n            this.cancelSelection();\n            return false;\n        }\n        this.originalRegion = newRegion;\n        this.padRegion();\n        return true;\n    }\n    // Applies padding to the current region if it is too small.\n    // @internal\n    padRegion() {\n        const sourceRegion = this.selectionTightBoundingBox ?? this.originalRegion;\n        const minSize = this.getMinCanvasSize();\n        if (sourceRegion.w < minSize || sourceRegion.h < minSize) {\n            // Add padding\n            const padding = minSize / 2;\n            this.originalRegion = math_1.Rect2.bboxOf(sourceRegion.corners, padding);\n            this.updateUI();\n        }\n    }\n    getMinCanvasSize() {\n        const canvasHandleSize = SelectionHandle_1.handleSize / this.editor.viewport.getScaleFactor();\n        return canvasHandleSize * 2;\n    }\n    getSelectedItemCount() {\n        return this.selectedElems.length;\n    }\n    // @internal\n    updateUI() {\n        // Don't update old selections.\n        if (!this.hasParent) {\n            return;\n        }\n        const screenRegion = this.getScreenRegion();\n        // marginLeft, marginTop: Display relative to the top left of the selection overlay.\n        // left, top don't work for this.\n        this.backgroundElem.style.marginLeft = `${screenRegion.topLeft.x}px`;\n        this.backgroundElem.style.marginTop = `${screenRegion.topLeft.y}px`;\n        this.backgroundElem.style.width = `${screenRegion.width}px`;\n        this.backgroundElem.style.height = `${screenRegion.height}px`;\n        const rotationDeg = (this.screenRegionRotation * 180) / Math.PI;\n        this.backgroundElem.style.transform = `rotate(${rotationDeg}deg)`;\n        this.backgroundElem.style.transformOrigin = 'center';\n        // If closer to perpendicular, apply different CSS\n        const perpendicularClassName = `${SelectionTool_1.cssPrefix}rotated-near-perpendicular`;\n        if (Math.abs(Math.sin(this.screenRegionRotation)) > 0.5) {\n            this.innerContainer.classList.add(perpendicularClassName);\n        }\n        else {\n            this.innerContainer.classList.remove(perpendicularClassName);\n        }\n        // Hide handles when empty\n        if (screenRegion.width === 0 && screenRegion.height === 0) {\n            this.innerContainer.classList.add('-empty');\n        }\n        else {\n            this.innerContainer.classList.remove('-empty');\n        }\n        for (const widget of this.childwidgets) {\n            widget.updatePosition(this.getScreenRegion());\n        }\n    }\n    // Add/remove the contents of this seleciton from the editor.\n    // Used to prevent previewed content from looking like duplicate content\n    // while dragging.\n    //\n    // Does nothing if a large number of elements are selected (and so modifying\n    // the editor image is likely to be slow.)\n    //\n    // If removed from the image, selected elements are drawn as wet ink.\n    //\n    // [inImage] should be `true` if the selected elements should be added to the\n    // main image, `false` if they should be removed.\n    addRemoveSelectionFromImage(inImage) {\n        // Don't hide elements if doing so will be slow.\n        if (!inImage && this.selectedElems.length > maxPreviewElemCount) {\n            return;\n        }\n        for (const elem of this.selectedElems) {\n            const parent = this.editor.image.findParent(elem);\n            if (!inImage && parent) {\n                this.removedFromImage[elem.getId()] = true;\n                parent.remove();\n            }\n            // If we're making things visible and the selected object wasn't previously\n            // visible,\n            else if (!parent && this.removedFromImage[elem.getId()]) {\n                EditorImage_1.default.addElement(elem).apply(this.editor);\n                this.removedFromImage[elem.getId()] = false;\n                delete this.removedFromImage[elem.getId()];\n            }\n        }\n        // Don't await queueRerender. If we're running in a test, the re-render might never\n        // happen.\n        this.editor.queueRerender().then(() => {\n            if (!inImage) {\n                this.previewTransformCmds();\n            }\n            else {\n                // Clear renderings of any in-progress transformations\n                const wetInkRenderer = this.editor.display.getWetInkRenderer();\n                wetInkRenderer.clear();\n            }\n        });\n    }\n    removeDeletedElemsFromSelection() {\n        // Remove any deleted elements from the selection.\n        this.selectedElems = this.selectedElems.filter((elem) => {\n            const hasParent = !!this.editor.image.findParent(elem);\n            // If we removed the element and haven't added it back yet, don't remove it\n            // from the selection.\n            const weRemoved = this.removedFromImage[elem.getId()];\n            return hasParent || weRemoved;\n        });\n    }\n    onDragStart(pointer) {\n        // Clear the HTML selection (prevent HTML drag and drop being triggered by this drag)\n        document.getSelection()?.removeAllRanges();\n        this.activeHandle = null;\n        let result = false;\n        this.backgroundDragging = false;\n        if (this.region.containsPoint(pointer.canvasPos)) {\n            this.backgroundDragging = true;\n            result = true;\n        }\n        for (const widget of this.childwidgets) {\n            if (widget.containsPoint(pointer.canvasPos)) {\n                this.activeHandle = widget;\n                this.backgroundDragging = false;\n                result = true;\n            }\n        }\n        if (result) {\n            this.removeDeletedElemsFromSelection();\n            this.addRemoveSelectionFromImage(false);\n        }\n        if (this.activeHandle) {\n            this.activeHandle.handleDragStart(pointer);\n        }\n        if (this.backgroundDragging) {\n            this.transformers.drag.onDragStart(pointer.canvasPos);\n        }\n        return result;\n    }\n    onDragUpdate(pointer) {\n        if (this.backgroundDragging) {\n            this.transformers.drag.onDragUpdate(pointer.canvasPos);\n        }\n        if (this.activeHandle) {\n            this.activeHandle.handleDragUpdate(pointer);\n        }\n    }\n    onDragEnd() {\n        if (this.backgroundDragging) {\n            this.transformers.drag.onDragEnd();\n        }\n        else if (this.activeHandle) {\n            this.activeHandle.handleDragEnd();\n        }\n        this.addRemoveSelectionFromImage(true);\n        this.backgroundDragging = false;\n        this.activeHandle = null;\n        this.updateUI();\n    }\n    onDragCancel() {\n        this.backgroundDragging = false;\n        this.activeHandle = null;\n        this.setTransform(math_1.Mat33.identity);\n        this.addRemoveSelectionFromImage(true);\n        this.updateUI();\n    }\n    // Scroll the viewport to this. Does not zoom\n    scrollTo() {\n        if (this.selectedElems.length === 0) {\n            return false;\n        }\n        const screenSize = this.editor.viewport.getScreenRectSize();\n        const screenRect = new math_1.Rect2(0, 0, screenSize.x, screenSize.y);\n        const selectionScreenRegion = this.getScreenRegion();\n        if (!screenRect.containsPoint(selectionScreenRegion.center)) {\n            const targetPointScreen = selectionScreenRegion.center;\n            const closestPointScreen = screenRect.getClosestPointOnBoundaryTo(targetPointScreen);\n            const closestPointCanvas = this.editor.viewport.screenToCanvas(closestPointScreen);\n            const targetPointCanvas = this.region.center;\n            const delta = closestPointCanvas.minus(targetPointCanvas);\n            this.editor.dispatchNoAnnounce(Viewport_1.default.transformBy(math_1.Mat33.translation(delta.times(0.5))), false);\n            this.editor.queueRerender().then(() => {\n                this.previewTransformCmds();\n            });\n            return true;\n        }\n        return false;\n    }\n    deleteSelectedObjects() {\n        if (this.backgroundDragging || this.activeHandle) {\n            this.onDragEnd();\n        }\n        return new Erase_1.default(this.selectedElems);\n    }\n    runSelectionDuplicatedAnimation() {\n        if (this.selectionDuplicatedAnimationTimeout) {\n            clearTimeout(this.selectionDuplicatedAnimationTimeout);\n        }\n        const animationDuration = 400; // ms\n        this.backgroundElem.style.animation = `${animationDuration}ms ease selection-duplicated-animation`;\n        this.selectionDuplicatedAnimationTimeout = setTimeout(() => {\n            this.backgroundElem.style.animation = '';\n            this.selectionDuplicatedAnimationTimeout = null;\n        }, animationDuration);\n    }\n    async duplicateSelectedObjects() {\n        const wasTransforming = this.backgroundDragging || this.activeHandle;\n        let tmpApplyCommand = null;\n        if (!wasTransforming) {\n            this.runSelectionDuplicatedAnimation();\n        }\n        let command;\n        if (wasTransforming) {\n            // Don't update the selection's focus when redoing/undoing\n            const selectionToUpdate = null;\n            const deltaZIndex = this.getDeltaZIndexToMoveSelectionToTop();\n            tmpApplyCommand = new _a.ApplyTransformationCommand(selectionToUpdate, this.selectedElems, this.transform, deltaZIndex);\n            // Transform to ensure that the duplicates are in the correct location\n            await tmpApplyCommand.apply(this.editor);\n            // Show items again\n            this.addRemoveSelectionFromImage(true);\n            // With the transformation applied, create the duplicates\n            command = (0, uniteCommands_1.default)(this.selectedElems.map((elem) => {\n                return EditorImage_1.default.addElement(elem.clone());\n            }));\n            // Move the selected objects back to the correct location.\n            await tmpApplyCommand?.unapply(this.editor);\n            this.addRemoveSelectionFromImage(false);\n            this.previewTransformCmds();\n            this.updateUI();\n        }\n        else {\n            command = new Duplicate_1.default(this.selectedElems);\n        }\n        return command;\n    }\n    setHandlesVisible(showHandles) {\n        if (!showHandles) {\n            this.innerContainer.classList.add('-hide-handles');\n        }\n        else {\n            this.innerContainer.classList.remove('-hide-handles');\n        }\n    }\n    addTo(elem) {\n        if (this.outerContainer.parentElement) {\n            this.outerContainer.remove();\n        }\n        elem.appendChild(this.outerContainer);\n        this.hasParent = true;\n    }\n    setToPoint(point) {\n        this.originalRegion = this.originalRegion.grownToPoint(point);\n        this.selectionTightBoundingBox = null;\n        this.updateUI();\n    }\n    cancelSelection() {\n        if (this.outerContainer.parentElement) {\n            this.outerContainer.remove();\n        }\n        this.originalRegion = math_1.Rect2.empty;\n        this.selectionTightBoundingBox = null;\n        this.hasParent = false;\n    }\n    setSelectedObjects(objects, bbox) {\n        this.addRemoveSelectionFromImage(true);\n        this.originalRegion = bbox;\n        this.selectionTightBoundingBox = bbox;\n        this.selectedElems = objects.filter((object) => object.isSelectable());\n        // Enforce increasing z-index invariant\n        this.selectedElems.sort((a, b) => a.getZIndex() - b.getZIndex());\n        this.padRegion();\n        this.updateUI();\n    }\n    getSelectedObjects() {\n        return [...this.selectedElems];\n    }\n}\n_a = Selection;\n(() => {\n    SerializableCommand_1.default.register('selection-tool-transform', (json, _editor) => {\n        // The selection box is lost when serializing/deserializing. No need to store box rotation\n        const fullTransform = new math_1.Mat33(...json.transform);\n        const elemIds = json.elems ?? [];\n        const deltaZIndex = parseInt(json.deltaZIndex ?? 0);\n        return new _a.ApplyTransformationCommand(null, elemIds, fullTransform, deltaZIndex);\n    });\n})();\nSelection.ApplyTransformationCommand = class extends SerializableCommand_1.default {\n    constructor(selection, \n    // If a `string[]`, selectedElems is a list of element IDs.\n    selectedElems, \n    // Full transformation used to transform elements.\n    fullTransform, deltaZIndex) {\n        super('selection-tool-transform');\n        this.selection = selection;\n        this.fullTransform = fullTransform;\n        this.deltaZIndex = deltaZIndex;\n        const isIDList = (arr) => {\n            return typeof arr[0] === 'string';\n        };\n        // If a list of element IDs,\n        if (isIDList(selectedElems)) {\n            this.selectedElemIds = selectedElems;\n        }\n        else {\n            this.selectedElemIds = selectedElems.map((elem) => elem.getId());\n            this.transformCommands = selectedElems.map((elem) => {\n                return elem.setZIndexAndTransformBy(this.fullTransform, elem.getZIndex() + deltaZIndex);\n            });\n        }\n    }\n    resolveToElems(editor, isUndoing) {\n        if (this.transformCommands) {\n            return;\n        }\n        this.transformCommands = this.selectedElemIds\n            .map((id) => {\n            const elem = editor.image.lookupElement(id);\n            if (!elem) {\n                // There may be valid reasons for an element lookup to fail:\n                // For example, if the element was deleted remotely and the remote deletion\n                // hasn't been undone.\n                console.warn(`Unable to find element with ID, ${id}.`);\n                return null;\n            }\n            let originalZIndex = elem.getZIndex();\n            let targetZIndex = elem.getZIndex() + this.deltaZIndex;\n            // If the command has already been applied, the element should currently\n            // have the target z-index.\n            if (isUndoing) {\n                targetZIndex = elem.getZIndex();\n                originalZIndex = elem.getZIndex() - this.deltaZIndex;\n            }\n            return elem.setZIndexAndTransformBy(this.fullTransform, targetZIndex, originalZIndex);\n        })\n            .filter(\n        // Remove all null commands\n        (command) => command !== null);\n    }\n    async apply(editor) {\n        this.resolveToElems(editor, false);\n        this.selection?.setTransform(this.fullTransform, false);\n        this.selection?.updateUI();\n        await editor.asyncApplyCommands(this.transformCommands, updateChunkSize);\n        this.selection?.setTransform(math_1.Mat33.identity, false);\n        this.selection?.recomputeRegion();\n        this.selection?.updateUI();\n    }\n    async unapply(editor) {\n        this.resolveToElems(editor, true);\n        this.selection?.setTransform(this.fullTransform.inverse(), false);\n        this.selection?.updateUI();\n        await editor.asyncUnapplyCommands(this.transformCommands, updateChunkSize, true);\n        this.selection?.setTransform(math_1.Mat33.identity, false);\n        this.selection?.recomputeRegion();\n        this.selection?.updateUI();\n    }\n    serializeToJSON() {\n        return {\n            elems: this.selectedElemIds,\n            transform: this.fullTransform.toArray(),\n            deltaZIndex: this.deltaZIndex,\n        };\n    }\n    description(_editor, localizationTable) {\n        return localizationTable.transformedElements(this.selectedElemIds.length);\n    }\n};\nexports[\"default\"] = Selection;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/tools/SelectionTool/Selection.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/tools/SelectionTool/SelectionHandle.js":
/*!******************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/tools/SelectionTool/SelectionHandle.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.handleSize = exports.HandleAction = void 0;\nconst assertions_1 = __webpack_require__(/*! ../../util/assertions */ \"./node_modules/js-draw/dist/cjs/util/assertions.js\");\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\nconst SelectionTool_1 = __webpack_require__(/*! ./SelectionTool */ \"./node_modules/js-draw/dist/cjs/tools/SelectionTool/SelectionTool.js\");\nvar HandleShape;\n(function (HandleShape) {\n    HandleShape[HandleShape[\"Circle\"] = 0] = \"Circle\";\n    HandleShape[HandleShape[\"Square\"] = 1] = \"Square\";\n})(HandleShape || (HandleShape = {}));\nvar HandleAction;\n(function (HandleAction) {\n    HandleAction[\"ResizeXY\"] = \"resize-xy\";\n    HandleAction[\"Rotate\"] = \"rotate\";\n    HandleAction[\"ResizeX\"] = \"resize-x\";\n    HandleAction[\"ResizeY\"] = \"resize-y\";\n})(HandleAction || (exports.HandleAction = HandleAction = {}));\n// The *interactable* handle size. The visual size will be slightly smaller.\nexports.handleSize = 30;\nclass SelectionHandle {\n    constructor(presentation, parent, viewport, onDragStart, onDragUpdate, onDragEnd) {\n        this.presentation = presentation;\n        this.parent = parent;\n        this.viewport = viewport;\n        this.onDragStart = onDragStart;\n        this.onDragUpdate = onDragUpdate;\n        this.onDragEnd = onDragEnd;\n        this.dragLastPos = null;\n        this.element = document.createElement('div');\n        this.element.classList.add(`${SelectionTool_1.cssPrefix}handle`, `${SelectionTool_1.cssPrefix}${presentation.action}`);\n        // Create a slightly smaller content/background element.\n        const visibleContent = document.createElement('div');\n        visibleContent.classList.add(`${SelectionTool_1.cssPrefix}content`);\n        this.element.appendChild(visibleContent);\n        this.parentSide = presentation.side;\n        const icon = presentation.icon;\n        if (icon) {\n            visibleContent.appendChild(icon);\n            icon.classList.add('icon');\n        }\n        if (presentation.action === HandleAction.Rotate) {\n            this.shape = HandleShape.Circle;\n        }\n        else {\n            this.shape = HandleShape.Square;\n        }\n        switch (this.shape) {\n            case HandleShape.Circle:\n                this.element.classList.add(`${SelectionTool_1.cssPrefix}circle`);\n                break;\n            case HandleShape.Square:\n                this.element.classList.add(`${SelectionTool_1.cssPrefix}square`);\n                break;\n            default:\n                (0, assertions_1.assertUnreachable)(this.shape);\n        }\n        this.updatePosition();\n    }\n    /**\n     * Adds this to `container`, where `conatiner` should be the background/selection\n     * element visible on the screen.\n     */\n    addTo(container) {\n        container.appendChild(this.element);\n    }\n    /**\n     * Removes this element from its container. Should only be called\n     * after {@link addTo}.\n     */\n    remove() {\n        this.element.remove();\n    }\n    /**\n     * Returns this handle's bounding box relative to the top left of the\n     * selection box.\n     */\n    getBBoxParentCoords() {\n        const parentRect = this.parent.getScreenRegion();\n        const size = math_1.Vec2.of(exports.handleSize, exports.handleSize);\n        const topLeft = parentRect.size\n            .scale(this.parentSide)\n            // Center\n            .minus(size.times(1 / 2));\n        return new math_1.Rect2(topLeft.x, topLeft.y, size.x, size.y);\n    }\n    /** @returns this handle's bounding box relative to the canvas. */\n    getBBoxCanvasCoords() {\n        const parentRect = this.parent.region;\n        const size = math_1.Vec2.of(exports.handleSize, exports.handleSize).times(1 / this.viewport.getScaleFactor());\n        const topLeftFromParent = parentRect.size.scale(this.parentSide).minus(size.times(0.5));\n        return new math_1.Rect2(topLeftFromParent.x, topLeftFromParent.y, size.x, size.y).translatedBy(parentRect.topLeft);\n    }\n    /**\n     * Moves the HTML representation of this to the location matching its internal representation.\n     */\n    updatePosition() {\n        const bbox = this.getBBoxParentCoords();\n        // Position within the selection box.\n        this.element.style.marginLeft = `${bbox.topLeft.x}px`;\n        this.element.style.marginTop = `${bbox.topLeft.y}px`;\n        this.element.style.width = `${bbox.w}px`;\n        this.element.style.height = `${bbox.h}px`;\n    }\n    /** @returns true iff `point` (in editor **canvas** coordinates) is in this. */\n    containsPoint(point) {\n        const bbox = this.getBBoxCanvasCoords();\n        const delta = point.minus(bbox.center);\n        // Should have same x and y radius\n        const radius = bbox.size.x / 2;\n        let result;\n        if (this.shape === HandleShape.Circle) {\n            result = delta.magnitude() <= radius;\n        }\n        else {\n            result = Math.abs(delta.x) <= radius && Math.abs(delta.y) <= radius;\n        }\n        return result;\n    }\n    handleDragStart(pointer) {\n        this.onDragStart(pointer.canvasPos);\n        this.dragLastPos = pointer.canvasPos;\n        return true;\n    }\n    handleDragUpdate(pointer) {\n        if (!this.dragLastPos) {\n            return;\n        }\n        this.onDragUpdate(pointer.canvasPos);\n    }\n    handleDragEnd() {\n        if (!this.dragLastPos) {\n            return;\n        }\n        return this.onDragEnd();\n    }\n    setSnapToGrid(snap) {\n        this.snapToGrid = snap;\n    }\n    isSnappingToGrid() {\n        return this.snapToGrid;\n    }\n}\nexports[\"default\"] = SelectionHandle;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/tools/SelectionTool/SelectionHandle.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/tools/SelectionTool/SelectionMenuShortcut.js":
/*!************************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/tools/SelectionTool/SelectionMenuShortcut.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\nconst SelectionTool_1 = __webpack_require__(/*! ./SelectionTool */ \"./node_modules/js-draw/dist/cjs/tools/SelectionTool/SelectionTool.js\");\nconst verticalOffset = 40;\nclass SelectionMenuShortcut {\n    constructor(parent, viewport, icon, showContextMenu, localization) {\n        this.parent = parent;\n        this.viewport = viewport;\n        this.icon = icon;\n        this.localization = localization;\n        this.lastDragPointer = null;\n        this.element = document.createElement('div');\n        this.element.classList.add(`${SelectionTool_1.cssPrefix}handle`, `${SelectionTool_1.cssPrefix}selection-menu`);\n        this.element.style.setProperty('--vertical-offset', `${verticalOffset}px`);\n        this.onClick = () => {\n            this.button?.focus({ preventScroll: true });\n            const anchor = this.getBBoxCanvasCoords().center;\n            showContextMenu(anchor);\n        };\n        this.initUI();\n        this.updatePosition();\n    }\n    initUI() {\n        const button = document.createElement('button');\n        this.icon.classList.add('icon');\n        button.replaceChildren(this.icon);\n        button.ariaLabel = this.localization.selectionMenu__show;\n        button.title = button.ariaLabel;\n        this.button = button;\n        // To prevent editor event handlers from conflicting with those for the button,\n        // don't register a [click] handler. An onclick handler can be fired incorrectly\n        // in this case (in Chrome) after onClick is fired in onDragEnd, leading to a double\n        // on-click action.\n        button.onkeydown = (event) => {\n            if (event.key === 'Enter') {\n                // .preventDefault prevents [Enter] from activating the first item in the\n                // selection menu.\n                event.preventDefault();\n                this.onClick();\n            }\n        };\n        this.element.appendChild(button);\n        // Update the bounding box of this in response to the new button.\n        requestAnimationFrame(() => {\n            this.updatePosition();\n        });\n    }\n    addTo(container) {\n        container.appendChild(this.element);\n    }\n    remove() {\n        this.element.remove();\n    }\n    getElementScreenSize() {\n        return math_1.Vec2.of(this.element.clientWidth, this.element.clientHeight);\n    }\n    /** Gets this menu's bounding box relative to the top left of its parent. */\n    getBBoxParentCoords() {\n        const topLeft = math_1.Vec2.of(0, -verticalOffset);\n        const screenSize = this.getElementScreenSize();\n        return new math_1.Rect2(topLeft.x, topLeft.y, screenSize.x, screenSize.y);\n    }\n    getBBoxCanvasCoords() {\n        const parentCanvasRect = this.parent.region;\n        const toCanvasScale = this.viewport.getSizeOfPixelOnCanvas();\n        // Don't apply rotation -- rotation is handled by the selection container\n        const contentCanvasSize = this.getElementScreenSize().times(toCanvasScale);\n        const handleSizeCanvas = verticalOffset / this.viewport.getScaleFactor();\n        const topLeft = math_1.Vec2.of(parentCanvasRect.x, parentCanvasRect.y - handleSizeCanvas);\n        const minSize = math_1.Vec2.of(48, 48).times(toCanvasScale);\n        return new math_1.Rect2(topLeft.x, topLeft.y, contentCanvasSize.x, contentCanvasSize.y).grownToSize(minSize);\n    }\n    updatePosition() {\n        const bbox = this.getBBoxParentCoords();\n        // Position within the selection box.\n        this.element.style.marginLeft = `${bbox.topLeft.x}px`;\n        this.element.style.marginTop = `${bbox.topLeft.y}px`;\n    }\n    containsPoint(canvasPoint) {\n        return this.getBBoxCanvasCoords().containsPoint(canvasPoint);\n    }\n    handleDragStart(pointer) {\n        this.lastDragPointer = pointer;\n        return true;\n    }\n    handleDragUpdate(pointer) {\n        this.lastDragPointer = pointer;\n    }\n    handleDragEnd() {\n        if (this.lastDragPointer && this.containsPoint(this.lastDragPointer.canvasPos)) {\n            this.onClick();\n        }\n        this.lastDragPointer = null;\n    }\n}\nexports[\"default\"] = SelectionMenuShortcut;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/tools/SelectionTool/SelectionMenuShortcut.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/tools/SelectionTool/SelectionTool.js":
/*!****************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/tools/SelectionTool/SelectionTool.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.cssPrefix = void 0;\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\nconst types_1 = __webpack_require__(/*! ../../types */ \"./node_modules/js-draw/dist/cjs/types.js\");\nconst Viewport_1 = __importDefault(__webpack_require__(/*! ../../Viewport */ \"./node_modules/js-draw/dist/cjs/Viewport.js\"));\nconst BaseTool_1 = __importDefault(__webpack_require__(/*! ../BaseTool */ \"./node_modules/js-draw/dist/cjs/tools/BaseTool.js\"));\nconst CanvasRenderer_1 = __importDefault(__webpack_require__(/*! ../../rendering/renderers/CanvasRenderer */ \"./node_modules/js-draw/dist/cjs/rendering/renderers/CanvasRenderer.js\"));\nconst SVGRenderer_1 = __importDefault(__webpack_require__(/*! ../../rendering/renderers/SVGRenderer */ \"./node_modules/js-draw/dist/cjs/rendering/renderers/SVGRenderer.js\"));\nconst Selection_1 = __importDefault(__webpack_require__(/*! ./Selection */ \"./node_modules/js-draw/dist/cjs/tools/SelectionTool/Selection.js\"));\nconst TextComponent_1 = __importDefault(__webpack_require__(/*! ../../components/TextComponent */ \"./node_modules/js-draw/dist/cjs/components/TextComponent.js\"));\nconst keybindings_1 = __webpack_require__(/*! ../keybindings */ \"./node_modules/js-draw/dist/cjs/tools/keybindings.js\");\nconst ToPointerAutoscroller_1 = __importDefault(__webpack_require__(/*! ./ToPointerAutoscroller */ \"./node_modules/js-draw/dist/cjs/tools/SelectionTool/ToPointerAutoscroller.js\"));\nconst showSelectionContextMenu_1 = __importDefault(__webpack_require__(/*! ./util/showSelectionContextMenu */ \"./node_modules/js-draw/dist/cjs/tools/SelectionTool/util/showSelectionContextMenu.js\"));\nexports.cssPrefix = 'selection-tool-';\n// Allows users to select/transform portions of the `EditorImage`.\n// With respect to `extend`ing, `SelectionTool` is not stable.\nclass SelectionTool extends BaseTool_1.default {\n    constructor(editor, description) {\n        super(editor.notifier, description);\n        this.editor = editor;\n        // True if clearing and recreating the selectionBox has been deferred. This is used to prevent the selection\n        // from vanishing on pointerdown events that are intended to form other gestures (e.g. long press) that would\n        // ultimately restore the selection.\n        this.rebuildSelectionScheduled = false;\n        this.startPoint = null; // canvas position\n        this.expandingSelectionBox = false;\n        this.shiftKeyPressed = false;\n        this.snapToGrid = false;\n        this.lastPointer = null;\n        this.showContextMenu = async (canvasAnchor, preferSelectionMenu = true) => {\n            await (0, showSelectionContextMenu_1.default)(this.selectionBox, this.editor, canvasAnchor, preferSelectionMenu, () => this.clearSelection());\n        };\n        this.selectionBoxHandlingEvt = false;\n        this.lastSelectedObjects = [];\n        // Whether the last keypress corresponded to an action that didn't transform the\n        // selection (and thus does not need to be finalized on onKeyUp).\n        this.hasUnfinalizedTransformFromKeyPress = false;\n        this.autoscroller = new ToPointerAutoscroller_1.default(editor.viewport, (scrollBy) => {\n            editor.dispatch(Viewport_1.default.transformBy(math_1.Mat33.translation(scrollBy)), false);\n            // Update the selection box/content to match the new viewport.\n            if (this.lastPointer) {\n                // The viewport has changed -- ensure that the screen and canvas positions\n                // of the pointer are both correct\n                const updatedPointer = this.lastPointer.withScreenPosition(this.lastPointer.screenPos, editor.viewport);\n                this.onMainPointerUpdated(updatedPointer);\n            }\n        });\n        this.handleOverlay = document.createElement('div');\n        editor.createHTMLOverlay(this.handleOverlay);\n        this.handleOverlay.style.display = 'none';\n        this.handleOverlay.classList.add('handleOverlay');\n        editor.notifier.on(types_1.EditorEventType.ViewportChanged, (_data) => {\n            // The selection box could be using the wet ink display if its transformation\n            // hasn't been finalized yet. Clear before updating the UI.\n            this.editor.clearWetInk();\n            // If not currently selecting, ensure that the selection box\n            // is large enough.\n            if (!this.expandingSelectionBox) {\n                this.selectionBox?.padRegion();\n            }\n            this.selectionBox?.updateUI();\n        });\n        this.editor.handleKeyEventsFrom(this.handleOverlay);\n        this.editor.handlePointerEventsFrom(this.handleOverlay);\n    }\n    makeSelectionBox(selectionStartPos) {\n        this.prevSelectionBox = this.selectionBox;\n        this.selectionBox = new Selection_1.default(selectionStartPos, this.editor, this.showContextMenu);\n        if (!this.expandingSelectionBox) {\n            // Remove any previous selection rects\n            this.prevSelectionBox?.cancelSelection();\n        }\n        this.selectionBox.addTo(this.handleOverlay);\n    }\n    snapSelectionToGrid() {\n        if (!this.selectionBox)\n            throw new Error('No selection to snap!');\n        // Snap the top left corner of what we have selected.\n        const topLeftOfBBox = this.selectionBox.computeTightBoundingBox().topLeft;\n        const snappedTopLeft = this.editor.viewport.snapToGrid(topLeftOfBBox);\n        const snapDelta = snappedTopLeft.minus(topLeftOfBBox);\n        const oldTransform = this.selectionBox.getTransform();\n        this.selectionBox.setTransform(oldTransform.rightMul(math_1.Mat33.translation(snapDelta)));\n        this.selectionBox.finalizeTransform();\n    }\n    onContextMenu(event) {\n        const canShowSelectionMenu = this.selectionBox\n            ?.getScreenRegion()\n            ?.containsPoint(event.screenPos);\n        void this.showContextMenu(event.canvasPos, canShowSelectionMenu);\n        return true;\n    }\n    onPointerDown({ allPointers, current }) {\n        const snapToGrid = this.snapToGrid;\n        if (snapToGrid) {\n            current = current.snappedToGrid(this.editor.viewport);\n        }\n        // Don't rely on .isPrimary -- it's buggy in Firefox. See https://github.com/personalizedrefrigerator/js-draw/issues/71\n        if (allPointers.length === 1) {\n            this.startPoint = current.canvasPos;\n            let transforming = false;\n            if (this.selectionBox) {\n                if (snapToGrid) {\n                    this.snapSelectionToGrid();\n                }\n                const dragStartResult = this.selectionBox.onDragStart(current);\n                if (dragStartResult) {\n                    transforming = true;\n                    this.selectionBoxHandlingEvt = true;\n                    this.expandingSelectionBox = false;\n                }\n            }\n            if (!transforming) {\n                // Shift key: Combine the new and old selection boxes at the end of the gesture.\n                this.expandingSelectionBox = this.shiftKeyPressed;\n                this.rebuildSelectionScheduled = true;\n            }\n            else {\n                // Only autoscroll if we're transforming an existing selection\n                this.autoscroller.start();\n            }\n            return true;\n        }\n        return false;\n    }\n    onPointerMove(event) {\n        this.onMainPointerUpdated(event.current);\n    }\n    onMainPointerUpdated(currentPointer) {\n        this.lastPointer = currentPointer;\n        if (this.rebuildSelectionScheduled) {\n            this.rebuildSelectionScheduled = false;\n            this.makeSelectionBox(this.startPoint ?? currentPointer.canvasPos);\n            this.selectionBox?.setHandlesVisible(false);\n        }\n        if (!this.selectionBox)\n            return;\n        this.autoscroller.onPointerMove(currentPointer.screenPos);\n        if (!this.expandingSelectionBox && this.shiftKeyPressed && this.startPoint) {\n            const screenPos = this.editor.viewport.canvasToScreen(this.startPoint);\n            currentPointer = currentPointer.lockedToXYAxesScreen(screenPos, this.editor.viewport);\n        }\n        if (this.snapToGrid) {\n            currentPointer = currentPointer.snappedToGrid(this.editor.viewport);\n        }\n        if (this.selectionBoxHandlingEvt) {\n            this.selectionBox.onDragUpdate(currentPointer);\n        }\n        else {\n            this.selectionBox.setToPoint(currentPointer.canvasPos);\n        }\n    }\n    onPointerUp(event) {\n        this.onMainPointerUpdated(event.current);\n        this.autoscroller.stop();\n        if (!this.selectionBox)\n            return;\n        this.selectionBox.setHandlesVisible(true);\n        // Were we expanding the previous selection?\n        if (this.expandingSelectionBox && this.prevSelectionBox) {\n            // If so, finish expanding.\n            this.expandingSelectionBox = false;\n            this.selectionBox.resolveToObjects();\n            this.setSelection([\n                ...this.selectionBox.getSelectedObjects(),\n                ...this.prevSelectionBox.getSelectedObjects(),\n            ]);\n        }\n        else {\n            if (!this.selectionBoxHandlingEvt) {\n                // Expand/shrink the selection rectangle, if applicable\n                this.selectionBox.resolveToObjects();\n                this.onSelectionUpdated();\n            }\n            else {\n                this.selectionBox.onDragEnd();\n            }\n            this.selectionBoxHandlingEvt = false;\n            this.lastPointer = null;\n        }\n    }\n    onGestureCancel() {\n        this.autoscroller.stop();\n        if (this.selectionBoxHandlingEvt) {\n            this.selectionBox?.onDragCancel();\n        }\n        else if (!this.rebuildSelectionScheduled) {\n            // Revert to the previous selection, if any.\n            this.selectionBox?.cancelSelection();\n            this.selectionBox = this.prevSelectionBox;\n            this.selectionBox?.addTo(this.handleOverlay);\n            this.selectionBox?.recomputeRegion();\n            this.prevSelectionBox = null;\n        }\n        this.rebuildSelectionScheduled = false;\n        this.expandingSelectionBox = false;\n        this.lastPointer = null;\n        this.selectionBoxHandlingEvt = false;\n    }\n    onSelectionUpdated() {\n        const selectedItemCount = this.selectionBox?.getSelectedItemCount() ?? 0;\n        const selectedObjects = this.selectionBox?.getSelectedObjects() ?? [];\n        const hasDifferentSelection = this.lastSelectedObjects.length !== selectedItemCount ||\n            selectedObjects.some((obj, i) => this.lastSelectedObjects[i] !== obj);\n        if (hasDifferentSelection) {\n            this.lastSelectedObjects = selectedObjects;\n            // Note that the selection has changed\n            this.editor.notifier.dispatch(types_1.EditorEventType.ToolUpdated, {\n                kind: types_1.EditorEventType.ToolUpdated,\n                tool: this,\n            });\n            // Only fire the SelectionUpdated event if the selection really updated.\n            this.editor.notifier.dispatch(types_1.EditorEventType.SelectionUpdated, {\n                kind: types_1.EditorEventType.SelectionUpdated,\n                selectedComponents: selectedObjects,\n                tool: this,\n            });\n            if (selectedItemCount > 0) {\n                this.editor.announceForAccessibility(this.editor.localization.selectedElements(selectedItemCount));\n                this.zoomToSelection();\n            }\n        }\n        if (selectedItemCount === 0 && this.selectionBox) {\n            this.selectionBox.cancelSelection();\n            this.prevSelectionBox = this.selectionBox;\n            this.selectionBox = null;\n        }\n    }\n    zoomToSelection() {\n        if (this.selectionBox) {\n            const selectionRect = this.selectionBox.region;\n            this.editor.dispatchNoAnnounce(this.editor.viewport.zoomTo(selectionRect, false), false);\n        }\n    }\n    onKeyPress(event) {\n        const shortcucts = this.editor.shortcuts;\n        if (shortcucts.matchesShortcut(keybindings_1.snapToGridKeyboardShortcutId, event)) {\n            this.snapToGrid = true;\n            return true;\n        }\n        if (this.selectionBox &&\n            (shortcucts.matchesShortcut(keybindings_1.duplicateSelectionShortcut, event) ||\n                shortcucts.matchesShortcut(keybindings_1.sendToBackSelectionShortcut, event))) {\n            // Handle duplication on key up — we don't want to accidentally duplicate\n            // many times.\n            return true;\n        }\n        else if (shortcucts.matchesShortcut(keybindings_1.selectAllKeyboardShortcut, event)) {\n            this.setSelection(this.editor.image.getAllElements());\n            return true;\n        }\n        else if (event.ctrlKey) {\n            // Don't transform the selection with, for example, ctrl+i.\n            // Pass it to another tool, if apliccable.\n            return false;\n        }\n        else if (event.shiftKey || event.key === 'Shift') {\n            this.shiftKeyPressed = true;\n            if (event.key === 'Shift') {\n                return true;\n            }\n        }\n        let rotationSteps = 0;\n        let xTranslateSteps = 0;\n        let yTranslateSteps = 0;\n        let xScaleSteps = 0;\n        let yScaleSteps = 0;\n        if (shortcucts.matchesShortcut(keybindings_1.translateLeftSelectionShortcutId, event)) {\n            xTranslateSteps -= 1;\n        }\n        else if (shortcucts.matchesShortcut(keybindings_1.translateRightSelectionShortcutId, event)) {\n            xTranslateSteps += 1;\n        }\n        else if (shortcucts.matchesShortcut(keybindings_1.translateUpSelectionShortcutId, event)) {\n            yTranslateSteps -= 1;\n        }\n        else if (shortcucts.matchesShortcut(keybindings_1.translateDownSelectionShortcutId, event)) {\n            yTranslateSteps += 1;\n        }\n        else if (shortcucts.matchesShortcut(keybindings_1.rotateClockwiseSelectionShortcutId, event)) {\n            rotationSteps += 1;\n        }\n        else if (shortcucts.matchesShortcut(keybindings_1.rotateCounterClockwiseSelectionShortcutId, event)) {\n            rotationSteps -= 1;\n        }\n        else if (shortcucts.matchesShortcut(keybindings_1.shrinkXSelectionShortcutId, event)) {\n            xScaleSteps -= 1;\n        }\n        else if (shortcucts.matchesShortcut(keybindings_1.stretchXSelectionShortcutId, event)) {\n            xScaleSteps += 1;\n        }\n        else if (shortcucts.matchesShortcut(keybindings_1.shrinkYSelectionShortcutId, event)) {\n            yScaleSteps -= 1;\n        }\n        else if (shortcucts.matchesShortcut(keybindings_1.stretchYSelectionShortcutId, event)) {\n            yScaleSteps += 1;\n        }\n        else if (shortcucts.matchesShortcut(keybindings_1.shrinkXYSelectionShortcutId, event)) {\n            xScaleSteps -= 1;\n            yScaleSteps -= 1;\n        }\n        else if (shortcucts.matchesShortcut(keybindings_1.stretchXYSelectionShortcutId, event)) {\n            xScaleSteps += 1;\n            yScaleSteps += 1;\n        }\n        let handled = xTranslateSteps !== 0 ||\n            yTranslateSteps !== 0 ||\n            rotationSteps !== 0 ||\n            xScaleSteps !== 0 ||\n            yScaleSteps !== 0;\n        if (!this.selectionBox) {\n            handled = false;\n        }\n        else if (handled) {\n            const translateStepSize = 10 * this.editor.viewport.getSizeOfPixelOnCanvas();\n            const rotateStepSize = Math.PI / 8;\n            const scaleStepSize = 5 / 4;\n            const region = this.selectionBox.region;\n            const scaleFactor = math_1.Vec2.of(scaleStepSize ** xScaleSteps, scaleStepSize ** yScaleSteps);\n            const rotationMat = math_1.Mat33.zRotation(rotationSteps * rotateStepSize);\n            const roundedRotationMatrix = rotationMat.mapEntries((component) => Viewport_1.default.roundScaleRatio(component));\n            const regionCenter = this.editor.viewport.roundPoint(region.center);\n            const transform = math_1.Mat33.scaling2D(scaleFactor, this.editor.viewport.roundPoint(region.topLeft))\n                .rightMul(math_1.Mat33.translation(regionCenter)\n                .rightMul(roundedRotationMatrix)\n                .rightMul(math_1.Mat33.translation(regionCenter.times(-1))))\n                .rightMul(math_1.Mat33.translation(this.editor.viewport.roundPoint(math_1.Vec2.of(xTranslateSteps, yTranslateSteps).times(translateStepSize))));\n            const oldTransform = this.selectionBox.getTransform();\n            this.selectionBox.setTransform(oldTransform.rightMul(transform));\n            this.selectionBox.scrollTo();\n            // The transformation needs to be finalized at some point (on key up)\n            this.hasUnfinalizedTransformFromKeyPress = true;\n        }\n        if (this.selectionBox && !handled && (event.key === 'Delete' || event.key === 'Backspace')) {\n            this.editor.dispatch(this.selectionBox.deleteSelectedObjects());\n            this.clearSelection();\n            handled = true;\n        }\n        return handled;\n    }\n    onKeyUp(evt) {\n        const shortcucts = this.editor.shortcuts;\n        if (shortcucts.matchesShortcut(keybindings_1.snapToGridKeyboardShortcutId, evt)) {\n            this.snapToGrid = false;\n            return true;\n        }\n        if (shortcucts.matchesShortcut(keybindings_1.selectAllKeyboardShortcut, evt)) {\n            // Selected all in onKeyDown. Don't finalizeTransform.\n            return true;\n        }\n        if (this.selectionBox && shortcucts.matchesShortcut(keybindings_1.duplicateSelectionShortcut, evt)) {\n            // Finalize duplicating the selection\n            this.selectionBox.duplicateSelectedObjects().then((command) => {\n                this.editor.dispatch(command);\n            });\n            return true;\n        }\n        if (this.selectionBox && shortcucts.matchesShortcut(keybindings_1.sendToBackSelectionShortcut, evt)) {\n            const sendToBackCommand = this.selectionBox.sendToBack();\n            if (sendToBackCommand) {\n                this.editor.dispatch(sendToBackCommand);\n            }\n            return true;\n        }\n        // Here, we check if shiftKey === false because, as of this writing,\n        // evt.shiftKey is an optional property. Being falsey could just mean\n        // that it wasn't set.\n        if (evt.shiftKey === false) {\n            this.shiftKeyPressed = false;\n            // Don't return immediately -- event may be otherwise handled\n        }\n        // Also check for key === 'Shift' (for the case where shiftKey is undefined)\n        if (evt.key === 'Shift') {\n            this.shiftKeyPressed = false;\n            return true;\n        }\n        // If we don't need to finalize the transform\n        if (!this.hasUnfinalizedTransformFromKeyPress) {\n            return true;\n        }\n        if (this.selectionBox) {\n            this.selectionBox.finalizeTransform();\n            this.hasUnfinalizedTransformFromKeyPress = false;\n            return true;\n        }\n        return false;\n    }\n    onCopy(event) {\n        if (!this.selectionBox) {\n            return false;\n        }\n        const selectedElems = this.selectionBox.getSelectedObjects();\n        const bbox = this.selectionBox.region;\n        if (selectedElems.length === 0) {\n            return false;\n        }\n        const exportViewport = new Viewport_1.default(() => { });\n        const selectionScreenSize = this.selectionBox\n            .getScreenRegion()\n            .size.times(this.editor.display.getDevicePixelRatio());\n        // Update the viewport to have screen size roughly equal to the size of the selection box\n        let scaleFactor = selectionScreenSize.maximumEntryMagnitude() / (bbox.size.maximumEntryMagnitude() || 1);\n        // Round to a nearby power of two\n        scaleFactor = Math.pow(2, Math.ceil(Math.log2(scaleFactor)));\n        exportViewport.updateScreenSize(bbox.size.times(scaleFactor));\n        exportViewport.resetTransform(math_1.Mat33.scaling2D(scaleFactor)\n            // Move the selection onto the screen\n            .rightMul(math_1.Mat33.translation(bbox.topLeft.times(-1))));\n        const { element: svgExportElem, renderer: svgRenderer } = SVGRenderer_1.default.fromViewport(exportViewport, { sanitize: true, useViewBoxForPositioning: true });\n        const { element: canvas, renderer: canvasRenderer } = CanvasRenderer_1.default.fromViewport(exportViewport, { maxCanvasDimen: 4096 });\n        const text = [];\n        for (const elem of selectedElems) {\n            elem.render(svgRenderer);\n            elem.render(canvasRenderer);\n            if (elem instanceof TextComponent_1.default) {\n                text.push(elem.getText());\n            }\n        }\n        event.setData('image/svg+xml', svgExportElem.outerHTML);\n        event.setData('text/html', svgExportElem.outerHTML);\n        event.setData('image/png', new Promise((resolve, reject) => {\n            canvas.toBlob((blob) => {\n                if (blob) {\n                    resolve(blob);\n                }\n                else {\n                    reject(new Error('Failed to convert canvas to blob.'));\n                }\n            }, 'image/png');\n        }));\n        if (text.length > 0) {\n            event.setData('text/plain', text.join('\\n'));\n        }\n        return true;\n    }\n    setEnabled(enabled) {\n        const wasEnabled = this.isEnabled();\n        super.setEnabled(enabled);\n        if (wasEnabled === enabled) {\n            return;\n        }\n        // Clear the selection\n        this.selectionBox?.cancelSelection();\n        this.onSelectionUpdated();\n        this.handleOverlay.replaceChildren();\n        this.selectionBox = null;\n        this.shiftKeyPressed = false;\n        this.snapToGrid = false;\n        this.handleOverlay.style.display = enabled ? 'block' : 'none';\n        if (enabled) {\n            this.handleOverlay.tabIndex = 0;\n            this.handleOverlay.setAttribute('aria-label', this.editor.localization.selectionToolKeyboardShortcuts);\n        }\n        else {\n            this.handleOverlay.tabIndex = -1;\n        }\n    }\n    // Get the object responsible for displaying this' selection.\n    // @internal\n    getSelection() {\n        return this.selectionBox;\n    }\n    getSelectedObjects() {\n        return this.selectionBox?.getSelectedObjects() ?? [];\n    }\n    // Select the given `objects`. Any non-selectable objects in `objects` are ignored.\n    setSelection(objects) {\n        // Only select selectable objects.\n        objects = objects.filter((obj) => obj.isSelectable());\n        // Sort by z-index\n        objects.sort((a, b) => a.getZIndex() - b.getZIndex());\n        // Remove duplicates\n        objects = objects.filter((current, idx) => {\n            if (idx > 0) {\n                return current !== objects[idx - 1];\n            }\n            return true;\n        });\n        let bbox = null;\n        for (const object of objects) {\n            if (bbox) {\n                bbox = bbox.union(object.getBBox());\n            }\n            else {\n                bbox = object.getBBox();\n            }\n        }\n        if (!bbox) {\n            return;\n        }\n        this.clearSelection();\n        if (!this.selectionBox) {\n            this.makeSelectionBox(bbox.topLeft);\n        }\n        this.selectionBox.setSelectedObjects(objects, bbox);\n        this.onSelectionUpdated();\n    }\n    clearSelection() {\n        this.handleOverlay.replaceChildren();\n        this.prevSelectionBox = this.selectionBox;\n        this.selectionBox = null;\n        this.onSelectionUpdated();\n    }\n}\nexports[\"default\"] = SelectionTool;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/tools/SelectionTool/SelectionTool.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/tools/SelectionTool/ToPointerAutoscroller.js":
/*!************************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/tools/SelectionTool/ToPointerAutoscroller.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\nconst untilNextAnimationFrame_1 = __importDefault(__webpack_require__(/*! ../../util/untilNextAnimationFrame */ \"./node_modules/js-draw/dist/cjs/util/untilNextAnimationFrame.js\"));\n/**\n * Automatically scrolls the viewport such that the user's pointer is visible.\n */\nclass ToPointerAutoscroller {\n    constructor(viewport, scrollByCanvasDelta) {\n        this.viewport = viewport;\n        this.scrollByCanvasDelta = scrollByCanvasDelta;\n        this.started = false;\n        this.updateLoopId = 0;\n        this.updateLoopRunning = false;\n        this.targetPoint = null;\n        this.scrollRate = 1000; // px/s\n    }\n    getScrollForPoint(screenPoint) {\n        const screenSize = this.viewport.getScreenRectSize();\n        const screenRect = new math_1.Rect2(0, 0, screenSize.x, screenSize.y);\n        // Starts autoscrolling when the cursor is **outside of** this region\n        const marginSize = 44;\n        const autoscrollBoundary = screenRect.grownBy(-marginSize);\n        if (autoscrollBoundary.containsPoint(screenPoint)) {\n            return math_1.Vec2.zero;\n        }\n        const closestEdgePoint = autoscrollBoundary.getClosestPointOnBoundaryTo(screenPoint);\n        const distToEdge = closestEdgePoint.distanceTo(screenPoint);\n        const toEdge = closestEdgePoint.minus(screenPoint);\n        // Go faster for points further away from the boundary.\n        const maximumScaleFactor = 1.25;\n        const scaleFactor = Math.min(distToEdge / marginSize, maximumScaleFactor);\n        return toEdge.normalizedOrZero().times(scaleFactor);\n    }\n    start() {\n        this.started = true;\n    }\n    onPointerMove(pointerScreenPosition) {\n        if (!this.started) {\n            return;\n        }\n        if (this.getScrollForPoint(pointerScreenPosition) === math_1.Vec2.zero) {\n            this.stopUpdateLoop();\n        }\n        else {\n            this.targetPoint = pointerScreenPosition;\n            this.startUpdateLoop();\n        }\n    }\n    stop() {\n        this.targetPoint = null;\n        this.started = false;\n        this.stopUpdateLoop();\n    }\n    startUpdateLoop() {\n        if (this.updateLoopRunning) {\n            return;\n        }\n        (async () => {\n            this.updateLoopId++;\n            const currentUpdateLoopId = this.updateLoopId;\n            let lastUpdateTime = performance.now();\n            while (this.updateLoopId === currentUpdateLoopId && this.targetPoint) {\n                this.updateLoopRunning = true;\n                const currentTime = performance.now();\n                const deltaTimeMs = currentTime - lastUpdateTime;\n                const scrollDirection = this.getScrollForPoint(this.targetPoint);\n                const screenScrollAmount = scrollDirection.times((this.scrollRate * deltaTimeMs) / 1000);\n                this.scrollByCanvasDelta(this.viewport.screenToCanvasTransform.transformVec3(screenScrollAmount));\n                lastUpdateTime = currentTime;\n                await (0, untilNextAnimationFrame_1.default)();\n            }\n            this.updateLoopRunning = false;\n        })();\n    }\n    stopUpdateLoop() {\n        this.updateLoopId++;\n    }\n}\nexports[\"default\"] = ToPointerAutoscroller;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/tools/SelectionTool/ToPointerAutoscroller.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/tools/SelectionTool/TransformMode.js":
/*!****************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/tools/SelectionTool/TransformMode.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RotateTransformer = exports.ResizeTransformer = exports.DragTransformer = void 0;\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\nconst Viewport_1 = __importDefault(__webpack_require__(/*! ../../Viewport */ \"./node_modules/js-draw/dist/cjs/Viewport.js\"));\nconst types_1 = __webpack_require__(/*! ./types */ \"./node_modules/js-draw/dist/cjs/tools/SelectionTool/types.js\");\nclass DragTransformer {\n    constructor(editor, selection) {\n        this.editor = editor;\n        this.selection = selection;\n    }\n    onDragStart(startPoint) {\n        this.selection.setTransform(math_1.Mat33.identity);\n        this.dragStartPoint = startPoint;\n    }\n    onDragUpdate(canvasPos) {\n        const delta = this.editor.viewport.roundPoint(canvasPos.minus(this.dragStartPoint));\n        this.selection.setTransform(math_1.Mat33.translation(delta));\n    }\n    onDragEnd() {\n        return this.selection.finalizeTransform();\n    }\n}\nexports.DragTransformer = DragTransformer;\nclass ResizeTransformer {\n    constructor(editor, selection) {\n        this.editor = editor;\n        this.selection = selection;\n        this.mode = types_1.ResizeMode.Both;\n    }\n    onDragStart(startPoint, mode) {\n        this.selection.setTransform(math_1.Mat33.identity);\n        this.mode = mode;\n        this.dragStartPoint = startPoint;\n        this.computeOriginAndScaleRate();\n    }\n    computeOriginAndScaleRate() {\n        // Store the index of the furthest corner from startPoint. We'll use that\n        // to determine where the transform considers (0, 0) (where we scale from).\n        const selectionRect = this.selection.preTransformRegion;\n        const selectionBoxCorners = selectionRect.corners;\n        let largestDistSquared = 0;\n        for (let i = 0; i < selectionBoxCorners.length; i++) {\n            const currentCorner = selectionBoxCorners[i];\n            const distSquaredToCurrent = this.dragStartPoint.minus(currentCorner).magnitudeSquared();\n            if (distSquaredToCurrent > largestDistSquared) {\n                largestDistSquared = distSquaredToCurrent;\n                this.transformOrigin = currentCorner;\n            }\n        }\n        // Determine whether moving the mouse to the right increases or decreases the width.\n        let widthScaleRate = 1;\n        let heightScaleRate = 1;\n        if (this.transformOrigin.x > selectionRect.center.x) {\n            widthScaleRate = -1;\n        }\n        if (this.transformOrigin.y > selectionRect.center.y) {\n            heightScaleRate = -1;\n        }\n        this.scaleRate = math_1.Vec2.of(widthScaleRate, heightScaleRate);\n    }\n    onDragUpdate(canvasPos) {\n        const canvasDelta = canvasPos.minus(this.dragStartPoint);\n        const origWidth = this.selection.preTransformRegion.width;\n        const origHeight = this.selection.preTransformRegion.height;\n        let scale = math_1.Vec2.of(1, 1);\n        if (this.mode === types_1.ResizeMode.HorizontalOnly) {\n            const newWidth = origWidth + canvasDelta.x * this.scaleRate.x;\n            scale = math_1.Vec2.of(newWidth / origWidth, scale.y);\n        }\n        if (this.mode === types_1.ResizeMode.VerticalOnly) {\n            const newHeight = origHeight + canvasDelta.y * this.scaleRate.y;\n            scale = math_1.Vec2.of(scale.x, newHeight / origHeight);\n        }\n        if (this.mode === types_1.ResizeMode.Both) {\n            const delta = Math.abs(canvasDelta.x) > Math.abs(canvasDelta.y) ? canvasDelta.x : canvasDelta.y;\n            const newWidth = origWidth + delta;\n            scale = math_1.Vec2.of(newWidth / origWidth, newWidth / origWidth);\n        }\n        // Round: If this isn't done, scaling can create numbers with long decimal representations.\n        //    long decimal representations => large file sizes.\n        scale = scale.map((component) => Viewport_1.default.roundScaleRatio(component, 2));\n        if (scale.x !== 0 && scale.y !== 0) {\n            const origin = this.editor.viewport.roundPoint(this.transformOrigin);\n            this.selection.setTransform(math_1.Mat33.scaling2D(scale, origin));\n        }\n    }\n    onDragEnd() {\n        return this.selection.finalizeTransform();\n    }\n}\nexports.ResizeTransformer = ResizeTransformer;\nclass RotateTransformer {\n    constructor(editor, selection) {\n        this.editor = editor;\n        this.selection = selection;\n        this.startAngle = 0;\n        this.targetRotation = 0;\n        this.maximumDistFromStart = 0;\n    }\n    getAngle(canvasPoint) {\n        const selectionCenter = this.selection.preTransformRegion.center;\n        const offset = canvasPoint.minus(selectionCenter);\n        return offset.angle();\n    }\n    roundAngle(angle) {\n        // Round angles to the nearest 16th of a turn\n        const roundingFactor = 16 / 2 / Math.PI;\n        return Math.round(angle * roundingFactor) / roundingFactor;\n    }\n    onDragStart(startPoint) {\n        this.startPoint = startPoint;\n        this.selection.setTransform(math_1.Mat33.identity);\n        this.startAngle = this.getAngle(startPoint);\n        this.targetRotation = 0;\n        // Used to determine whether the user clicked or not.\n        this.maximumDistFromStart = 0;\n        this.startTime = performance.now();\n    }\n    setRotationTo(angle) {\n        // Transform in canvas space\n        const canvasSelCenter = this.editor.viewport.roundPoint(this.selection.preTransformRegion.center);\n        const unrounded = math_1.Mat33.zRotation(angle);\n        const roundedRotationTransform = unrounded.mapEntries((entry) => Viewport_1.default.roundScaleRatio(entry));\n        const fullRoundedTransform = math_1.Mat33.translation(canvasSelCenter)\n            .rightMul(roundedRotationTransform)\n            .rightMul(math_1.Mat33.translation(canvasSelCenter.times(-1)));\n        this.selection.setTransform(fullRoundedTransform);\n    }\n    onDragUpdate(canvasPos) {\n        this.targetRotation = this.roundAngle(this.getAngle(canvasPos) - this.startAngle);\n        this.setRotationTo(this.targetRotation);\n        const distFromStart = canvasPos.minus(this.startPoint).magnitude();\n        if (distFromStart > this.maximumDistFromStart) {\n            this.maximumDistFromStart = distFromStart;\n        }\n    }\n    onDragEnd() {\n        // Anything with motion less than this is considered a click\n        const clickThresholdDist = 10;\n        const clickThresholdTime = 0.4; // s\n        const dragTimeSeconds = (performance.now() - this.startTime) / 1000;\n        if (dragTimeSeconds < clickThresholdTime &&\n            this.maximumDistFromStart < clickThresholdDist &&\n            this.targetRotation === 0) {\n            this.setRotationTo(-Math.PI / 2);\n        }\n        return this.selection.finalizeTransform();\n    }\n}\nexports.RotateTransformer = RotateTransformer;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/tools/SelectionTool/TransformMode.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/tools/SelectionTool/keybindings.js":
/*!**************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/tools/SelectionTool/keybindings.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.stretchXYSelectionShortcutId = exports.shrinkXYSelectionShortcutId = exports.stretchYSelectionShortcutId = exports.shrinkYSelectionShortcutId = exports.stretchXSelectionShortcutId = exports.shrinkXSelectionShortcutId = exports.rotateClockwiseSelectionShortcutId = exports.rotateCounterClockwiseSelectionShortcutId = exports.translateDownSelectionShortcutId = exports.translateUpSelectionShortcutId = exports.translateRightSelectionShortcutId = exports.translateLeftSelectionShortcutId = exports.sendToBackSelectionShortcut = exports.duplicateSelectionShortcut = exports.selectAllKeyboardShortcut = void 0;\nconst KeyboardShortcutManager_1 = __importDefault(__webpack_require__(/*! ../../shortcuts/KeyboardShortcutManager */ \"./node_modules/js-draw/dist/cjs/shortcuts/KeyboardShortcutManager.js\"));\n// Selection\nexports.selectAllKeyboardShortcut = 'jsdraw.tools.SelectionTool.selectAll';\nKeyboardShortcutManager_1.default.registerDefaultKeyboardShortcut(exports.selectAllKeyboardShortcut, ['CtrlOrMeta+KeyA'], 'Select all');\nexports.duplicateSelectionShortcut = 'jsdraw.tools.SelectionTool.duplicateSelection';\nKeyboardShortcutManager_1.default.registerDefaultKeyboardShortcut(exports.duplicateSelectionShortcut, ['CtrlOrMeta+KeyD'], 'Duplicate selection');\nexports.sendToBackSelectionShortcut = 'jsdraw.tools.SelectionTool.sendToBack';\nKeyboardShortcutManager_1.default.registerDefaultKeyboardShortcut(exports.sendToBackSelectionShortcut, ['End'], 'Send to back');\nexports.translateLeftSelectionShortcutId = 'jsdraw.tools.SelectionTool.translateLeft';\nKeyboardShortcutManager_1.default.registerDefaultKeyboardShortcut(exports.translateLeftSelectionShortcutId, ['KeyA', 'KeyH', 'ArrowLeft'], 'Move selection left');\nexports.translateRightSelectionShortcutId = 'jsdraw.tools.SelectionTool.translateRight';\nKeyboardShortcutManager_1.default.registerDefaultKeyboardShortcut(exports.translateRightSelectionShortcutId, ['KeyD', 'KeyL', 'ArrowRight'], 'Move selection right');\nexports.translateUpSelectionShortcutId = 'jsdraw.tools.SelectionTool.translateUp';\nKeyboardShortcutManager_1.default.registerDefaultKeyboardShortcut(exports.translateUpSelectionShortcutId, ['KeyQ', 'KeyK', 'ArrowUp'], 'Move selection up');\nexports.translateDownSelectionShortcutId = 'jsdraw.tools.SelectionTool.translateDown';\nKeyboardShortcutManager_1.default.registerDefaultKeyboardShortcut(exports.translateDownSelectionShortcutId, ['KeyE', 'KeyJ', 'ArrowDown'], 'Move selection down');\nexports.rotateCounterClockwiseSelectionShortcutId = 'jsdraw.tools.SelectionTool.rotateCCW';\nKeyboardShortcutManager_1.default.registerDefaultKeyboardShortcut(exports.rotateCounterClockwiseSelectionShortcutId, ['Shift+KeyR'], 'Rotate selection counter clockwise');\nexports.rotateClockwiseSelectionShortcutId = 'jsdraw.tools.SelectionTool.rotateCW';\nKeyboardShortcutManager_1.default.registerDefaultKeyboardShortcut(exports.rotateClockwiseSelectionShortcutId, ['KeyR'], 'Rotate selection clockwise');\nexports.shrinkXSelectionShortcutId = 'jsdraw.tools.SelectionTool.shrink.x';\nKeyboardShortcutManager_1.default.registerDefaultKeyboardShortcut(exports.shrinkXSelectionShortcutId, ['KeyI'], 'Decrease width');\nexports.stretchXSelectionShortcutId = 'jsdraw.tools.SelectionTool.stretch.x';\nKeyboardShortcutManager_1.default.registerDefaultKeyboardShortcut(exports.stretchXSelectionShortcutId, ['Shift+KeyI'], 'Increase width');\nexports.shrinkYSelectionShortcutId = 'jsdraw.tools.SelectionTool.shrink.y';\nKeyboardShortcutManager_1.default.registerDefaultKeyboardShortcut(exports.shrinkYSelectionShortcutId, ['KeyO'], 'Decrease height');\nexports.stretchYSelectionShortcutId = 'jsdraw.tools.SelectionTool.stretch.y';\nKeyboardShortcutManager_1.default.registerDefaultKeyboardShortcut(exports.stretchYSelectionShortcutId, ['Shift+KeyO'], 'Increase height');\nexports.shrinkXYSelectionShortcutId = 'jsdraw.tools.SelectionTool.shrink.xy';\nKeyboardShortcutManager_1.default.registerDefaultKeyboardShortcut(exports.shrinkXYSelectionShortcutId, ['Comma'], 'Decrease selection size');\nexports.stretchXYSelectionShortcutId = 'jsdraw.tools.SelectionTool.stretch.xy';\nKeyboardShortcutManager_1.default.registerDefaultKeyboardShortcut(exports.stretchXYSelectionShortcutId, ['Period'], 'Increase selection size');\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/tools/SelectionTool/keybindings.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/tools/SelectionTool/types.js":
/*!********************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/tools/SelectionTool/types.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TransformMode = exports.ResizeMode = void 0;\nvar ResizeMode;\n(function (ResizeMode) {\n    ResizeMode[ResizeMode[\"Both\"] = 0] = \"Both\";\n    ResizeMode[ResizeMode[\"HorizontalOnly\"] = 1] = \"HorizontalOnly\";\n    ResizeMode[ResizeMode[\"VerticalOnly\"] = 2] = \"VerticalOnly\";\n})(ResizeMode || (exports.ResizeMode = ResizeMode = {}));\nvar TransformMode;\n(function (TransformMode) {\n    TransformMode[TransformMode[\"Snap\"] = 0] = \"Snap\";\n    TransformMode[TransformMode[\"NoSnap\"] = 1] = \"NoSnap\";\n})(TransformMode || (exports.TransformMode = TransformMode = {}));\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/tools/SelectionTool/types.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/tools/SelectionTool/util/makeClipboardErrorHandlers.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/tools/SelectionTool/util/makeClipboardErrorHandlers.js ***!
  \**********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst makeMessageDialog_1 = __importDefault(__webpack_require__(/*! ../../../dialogs/makeMessageDialog */ \"./node_modules/js-draw/dist/cjs/dialogs/makeMessageDialog.js\"));\nconst ClipboardHandler_1 = __importDefault(__webpack_require__(/*! ../../../util/ClipboardHandler */ \"./node_modules/js-draw/dist/cjs/util/ClipboardHandler.js\"));\nconst makeClipboardErrorHandlers = (editor) => {\n    const makeErrorDialog = (error) => {\n        const dialog = (0, makeMessageDialog_1.default)(editor, {\n            title: editor.localization.copyPasteError__heading,\n            classNames: ['clipboard-error-dialog'],\n        });\n        dialog.appendChild(document.createTextNode(editor.localization.copyPasteError__description));\n        const errorDetailsElement = document.createElement('details');\n        const errorDetailsSummary = document.createElement('summary');\n        errorDetailsSummary.textContent = editor.localization.copyPasteError__errorDetails;\n        errorDetailsElement.appendChild(errorDetailsSummary);\n        errorDetailsElement.appendChild(document.createTextNode(`Error: ${error}`));\n        dialog.appendChild(errorDetailsElement);\n        return dialog;\n    };\n    return {\n        onCopyError(error) {\n            const dialog = makeErrorDialog(error);\n            const textboxLabel = document.createElement('label');\n            textboxLabel.textContent = editor.localization.copyPasteError__copyRetry;\n            const copyTextbox = document.createElement('textarea');\n            textboxLabel.appendChild(copyTextbox);\n            const retryHandler = new ClipboardHandler_1.default(editor);\n            const handleCopy = (event) => {\n                event.preventDefault();\n                // Use .then to ensure that .copy runs within the event handler.\n                // Copy can fail if certain logic is run async.\n                return retryHandler.copy(event).then(() => {\n                    dialog.close();\n                });\n            };\n            copyTextbox.oncopy = handleCopy;\n            copyTextbox.ondragstart = handleCopy;\n            copyTextbox.value = editor.localization.copyPasteError__copyMe;\n            dialog.appendChild(textboxLabel);\n            copyTextbox.select();\n            document.execCommand('copy');\n        },\n        onPasteError(error) {\n            const dialog = makeErrorDialog(error);\n            const textboxLabel = document.createElement('label');\n            textboxLabel.textContent = editor.localization.copyPasteError__pasteRetry;\n            const pasteTextbox = document.createElement('textarea');\n            textboxLabel.appendChild(pasteTextbox);\n            const retryHandler = new ClipboardHandler_1.default(editor);\n            const handlePaste = (event) => {\n                event.preventDefault();\n                // Use .then to ensure that .paste runs within the event handler.\n                // Paste can fail if certain logic is run async.\n                return retryHandler.paste(event).then((pasted) => {\n                    if (pasted) {\n                        dialog.close();\n                    }\n                });\n            };\n            pasteTextbox.onpaste = handlePaste;\n            pasteTextbox.ondrop = handlePaste;\n            dialog.appendChild(textboxLabel);\n            pasteTextbox.focus();\n            document.execCommand('paste');\n        },\n    };\n};\nexports[\"default\"] = makeClipboardErrorHandlers;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/tools/SelectionTool/util/makeClipboardErrorHandlers.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/tools/SelectionTool/util/showSelectionContextMenu.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/tools/SelectionTool/util/showSelectionContextMenu.js ***!
  \********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst createMenuOverlay_1 = __importDefault(__webpack_require__(/*! ../../util/createMenuOverlay */ \"./node_modules/js-draw/dist/cjs/tools/util/createMenuOverlay.js\"));\nconst ClipboardHandler_1 = __importDefault(__webpack_require__(/*! ../../../util/ClipboardHandler */ \"./node_modules/js-draw/dist/cjs/util/ClipboardHandler.js\"));\nconst makeClipboardErrorHandlers_1 = __importDefault(__webpack_require__(/*! ./makeClipboardErrorHandlers */ \"./node_modules/js-draw/dist/cjs/tools/SelectionTool/util/makeClipboardErrorHandlers.js\"));\nconst showSelectionContextMenu = async (selectionBox, editor, canvasAnchor, preferSelectionMenu, clearSelection) => {\n    const localization = editor.localization;\n    const showSelectionMenu = selectionBox?.getSelectedItemCount() && preferSelectionMenu;\n    const noSelectionMenu = [\n        {\n            text: localization.selectionMenu__paste,\n            icon: () => editor.icons.makePasteIcon(),\n            key: () => {\n                const clipboardHandler = new ClipboardHandler_1.default(editor, (0, makeClipboardErrorHandlers_1.default)(editor));\n                void clipboardHandler.paste();\n            },\n        },\n    ];\n    const onActivated = await (0, createMenuOverlay_1.default)(editor, canvasAnchor, showSelectionMenu\n        ? [\n            {\n                text: localization.selectionMenu__duplicate,\n                icon: () => editor.icons.makeDuplicateSelectionIcon(),\n                key: async () => {\n                    await editor.dispatch(await selectionBox.duplicateSelectedObjects());\n                },\n            },\n            {\n                text: localization.selectionMenu__delete,\n                icon: () => editor.icons.makeDeleteSelectionIcon(),\n                key: async () => {\n                    await editor.dispatch(selectionBox.deleteSelectedObjects());\n                    clearSelection();\n                },\n            },\n            {\n                text: localization.selectionMenu__copyToClipboard,\n                icon: () => editor.icons.makeCopyIcon(),\n                key: () => {\n                    const clipboardHandler = new ClipboardHandler_1.default(editor, (0, makeClipboardErrorHandlers_1.default)(editor));\n                    void clipboardHandler.copy();\n                },\n            },\n            ...noSelectionMenu,\n        ]\n        : noSelectionMenu);\n    onActivated?.();\n};\nexports[\"default\"] = showSelectionContextMenu;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/tools/SelectionTool/util/showSelectionContextMenu.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/tools/SoundUITool.js":
/*!************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/tools/SoundUITool.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\nconst BaseTool_1 = __importDefault(__webpack_require__(/*! ./BaseTool */ \"./node_modules/js-draw/dist/cjs/tools/BaseTool.js\"));\nclass SoundFeedback {\n    constructor() {\n        this.closed = false;\n        // No AudioContext? Exit!\n        if (!window.AudioContext) {\n            console.warn('Accessibility sound UI: Unable to open AudioContext.');\n            this.closed = true;\n            return;\n        }\n        this.ctx = new AudioContext();\n        // Color oscillator and gain\n        this.colorOscHue = this.ctx.createOscillator();\n        this.colorOscValue = this.ctx.createOscillator();\n        this.colorOscSaturation = this.ctx.createOscillator();\n        this.colorOscHue.type = 'triangle';\n        this.colorOscSaturation.type = 'sine';\n        this.colorOscValue.type = 'sawtooth';\n        this.valueGain = this.ctx.createGain();\n        this.colorOscValue.connect(this.valueGain);\n        this.valueGain.gain.setValueAtTime(0.18, this.ctx.currentTime);\n        this.colorGain = this.ctx.createGain();\n        this.colorOscHue.connect(this.colorGain);\n        this.valueGain.connect(this.colorGain);\n        this.colorOscSaturation.connect(this.colorGain);\n        this.colorGain.connect(this.ctx.destination);\n        // Boundary oscillator and gain\n        this.boundaryGain = this.ctx.createGain();\n        this.boundaryOsc = this.ctx.createOscillator();\n        this.boundaryOsc.type = 'sawtooth';\n        this.boundaryGain.gain.setValueAtTime(0, this.ctx.currentTime);\n        this.boundaryOsc.connect(this.boundaryGain);\n        this.boundaryGain.connect(this.ctx.destination);\n        // Prepare for the first announcement/feedback.\n        this.colorOscHue.start();\n        this.colorOscSaturation.start();\n        this.colorOscValue.start();\n        this.boundaryOsc.start();\n        this.pause();\n    }\n    pause() {\n        if (this.closed)\n            return;\n        this.colorGain.gain.setValueAtTime(0, this.ctx.currentTime);\n        void this.ctx.suspend();\n    }\n    play() {\n        if (this.closed)\n            return;\n        void this.ctx.resume();\n    }\n    setColor(color) {\n        const hsv = color.asHSV();\n        // Choose frequencies that roughly correspond to hue, saturation, and value.\n        const hueFrequency = -Math.cos(hsv.x / 2) * 220 + 440;\n        const saturationFrequency = hsv.y * 440 + 220;\n        const valueFrequency = (hsv.z + 0.1) * 440;\n        // Sigmoid with maximum 0.25 * alpha.\n        // Louder for greater value.\n        const gain = (0.25 * Math.min(1, color.a)) / (1 + Math.exp(-(hsv.z - 0.5) * 3));\n        this.colorOscHue.frequency.setValueAtTime(hueFrequency, this.ctx.currentTime);\n        this.colorOscSaturation.frequency.setValueAtTime(saturationFrequency, this.ctx.currentTime);\n        this.colorOscValue.frequency.setValueAtTime(valueFrequency, this.ctx.currentTime);\n        this.valueGain.gain.setValueAtTime((1 - hsv.z) * 0.4, this.ctx.currentTime);\n        this.colorGain.gain.setValueAtTime(gain, this.ctx.currentTime);\n    }\n    announceBoundaryCross(boundaryCrossCount) {\n        this.boundaryGain.gain.cancelScheduledValues(this.ctx.currentTime);\n        this.boundaryGain.gain.setValueAtTime(0, this.ctx.currentTime);\n        this.boundaryGain.gain.linearRampToValueAtTime(0.018, this.ctx.currentTime + 0.1);\n        this.boundaryOsc.frequency.setValueAtTime(440 + Math.atan(boundaryCrossCount / 2) * 100, this.ctx.currentTime);\n        this.boundaryGain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.25);\n    }\n    close() {\n        void this.ctx.close();\n        this.closed = true;\n    }\n}\n/**\n * This tool, when enabled, plays a sound representing the color of the portion of the display\n * currently under the cursor. This tool adds a button that can be navigated to with the tab key\n * that enables/disables the tool.\n *\n * This allows the user to explore the content of the display without a working screen.\n */\nclass SoundUITool extends BaseTool_1.default {\n    constructor(editor, description) {\n        super(editor.notifier, description);\n        this.editor = editor;\n        this.soundFeedback = null;\n        // Create a screen-reader-usable method of toggling the tool:\n        this.toggleButtonContainer = document.createElement('div');\n        this.toggleButtonContainer.classList.add('js-draw-sound-ui-toggle');\n        this.toggleButton = document.createElement('button');\n        this.toggleButton.onclick = () => {\n            this.setEnabled(!this.isEnabled());\n        };\n        this.toggleButtonContainer.appendChild(this.toggleButton);\n        this.updateToggleButtonText();\n        editor.createHTMLOverlay(this.toggleButtonContainer);\n    }\n    canReceiveInputInReadOnlyEditor() {\n        return true;\n    }\n    updateToggleButtonText() {\n        const containerEnabledClass = 'sound-ui-tool-enabled';\n        if (this.isEnabled()) {\n            this.toggleButton.innerText = this.editor.localization.disableAccessibilityExploreTool;\n            this.toggleButtonContainer.classList.add(containerEnabledClass);\n        }\n        else {\n            this.toggleButton.innerText = this.editor.localization.enableAccessibilityExploreTool;\n            this.toggleButtonContainer.classList.remove(containerEnabledClass);\n        }\n    }\n    setEnabled(enabled) {\n        super.setEnabled(enabled);\n        if (!this.isEnabled()) {\n            this.soundFeedback?.close();\n            this.soundFeedback = null;\n        }\n        else {\n            this.editor.announceForAccessibility(this.editor.localization.soundExplorerUsageAnnouncement);\n        }\n        this.updateToggleButtonText();\n    }\n    onKeyPress(event) {\n        if (event.code === 'Escape') {\n            this.setEnabled(false);\n            return true;\n        }\n        return false;\n    }\n    onPointerDown({ current, allPointers }) {\n        if (!this.soundFeedback) {\n            this.soundFeedback = new SoundFeedback();\n        }\n        // Allow two-finger gestures to move the screen.\n        if (allPointers.length >= 2) {\n            return false;\n        }\n        // Accept multiple cursors -- some screen readers require multiple (touch) pointers to interact with\n        // an image instead of using the built-in navigation features.\n        this.soundFeedback?.play();\n        this.soundFeedback?.setColor(this.editor.display.getColorAt(current.screenPos) ?? math_1.Color4.black);\n        this.lastPointerPos = current.canvasPos;\n        return true;\n    }\n    onPointerMove({ current }) {\n        this.soundFeedback?.setColor(this.editor.display.getColorAt(current.screenPos) ?? math_1.Color4.black);\n        const pointerMotionLine = new math_1.LineSegment2(this.lastPointerPos, current.canvasPos);\n        const collisions = this.editor.image\n            .getElementsIntersectingRegion(pointerMotionLine.bbox)\n            .filter((component) => component.intersects(pointerMotionLine));\n        this.lastPointerPos = current.canvasPos;\n        if (collisions.length > 0) {\n            this.soundFeedback?.announceBoundaryCross(collisions.length);\n        }\n    }\n    onPointerUp(_event) {\n        this.soundFeedback?.pause();\n    }\n    onGestureCancel() {\n        this.soundFeedback?.pause();\n    }\n}\nexports[\"default\"] = SoundUITool;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/tools/SoundUITool.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/tools/TextTool.js":
/*!*********************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/tools/TextTool.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst TextComponent_1 = __importDefault(__webpack_require__(/*! ../components/TextComponent */ \"./node_modules/js-draw/dist/cjs/components/TextComponent.js\"));\nconst EditorImage_1 = __importDefault(__webpack_require__(/*! ../image/EditorImage */ \"./node_modules/js-draw/dist/cjs/image/EditorImage.js\"));\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\nconst Pointer_1 = __webpack_require__(/*! ../Pointer */ \"./node_modules/js-draw/dist/cjs/Pointer.js\");\nconst types_1 = __webpack_require__(/*! ../types */ \"./node_modules/js-draw/dist/cjs/types.js\");\nconst BaseTool_1 = __importDefault(__webpack_require__(/*! ./BaseTool */ \"./node_modules/js-draw/dist/cjs/tools/BaseTool.js\"));\nconst Erase_1 = __importDefault(__webpack_require__(/*! ../commands/Erase */ \"./node_modules/js-draw/dist/cjs/commands/Erase.js\"));\nconst uniteCommands_1 = __importDefault(__webpack_require__(/*! ../commands/uniteCommands */ \"./node_modules/js-draw/dist/cjs/commands/uniteCommands.js\"));\nconst ReactiveValue_1 = __webpack_require__(/*! ../util/ReactiveValue */ \"./node_modules/js-draw/dist/cjs/util/ReactiveValue.js\");\nconst overlayCSSClass = 'textEditorOverlay';\n/** A tool that allows users to enter and edit text. */\nclass TextTool extends BaseTool_1.default {\n    constructor(editor, description, localizationTable) {\n        super(editor.notifier, description);\n        this.editor = editor;\n        this.localizationTable = localizationTable;\n        this.textInputElem = null;\n        this.textMeasuringCtx = null;\n        this.removeExistingCommand = null;\n        const editorFonts = editor.getCurrentSettings().text?.fonts ?? [];\n        this.textStyleValue = ReactiveValue_1.ReactiveValue.fromInitialValue({\n            size: 32,\n            fontFamily: editorFonts.length > 0 ? editorFonts[0] : 'sans-serif',\n            renderingStyle: {\n                fill: math_1.Color4.purple,\n            },\n        });\n        this.textStyleValue.onUpdateAndNow(() => {\n            this.textStyle = this.textStyleValue.get();\n            this.updateTextInput();\n            this.editor.notifier.dispatch(types_1.EditorEventType.ToolUpdated, {\n                kind: types_1.EditorEventType.ToolUpdated,\n                tool: this,\n            });\n        });\n        this.contentTransform = ReactiveValue_1.ReactiveValue.fromInitialValue(math_1.Mat33.identity);\n        this.textEditOverlay = document.createElement('div');\n        this.textEditOverlay.classList.add(overlayCSSClass);\n        this.editor.addStyleSheet(`\n\t\t\t.${overlayCSSClass} textarea {\n\t\t\t\tbackground-color: rgba(0, 0, 0, 0);\n\n\t\t\t\twhite-space: pre;\n\t\t\t\toverflow: hidden;\n\n\t\t\t\tpadding: 0;\n\t\t\t\tmargin: 0;\n\t\t\t\tborder: none;\n\t\t\t\tpadding: 0;\n\n\t\t\t\tmin-width: 100px;\n\t\t\t\tmin-height: 1.1em;\n\t\t\t}\n\t\t`);\n        this.anchorControl = this.editor.anchorElementToCanvas(this.textEditOverlay, this.contentTransform);\n    }\n    initTextMeasuringCanvas() {\n        this.textMeasuringCtx ??= document.createElement('canvas').getContext('2d');\n    }\n    getTextAscent(text, style) {\n        this.initTextMeasuringCanvas();\n        if (this.textMeasuringCtx) {\n            this.textMeasuringCtx.textBaseline = 'alphabetic';\n            TextComponent_1.default.applyTextStyles(this.textMeasuringCtx, style);\n            const measurement = this.textMeasuringCtx.measureText(text);\n            return measurement.fontBoundingBoxAscent ?? measurement.actualBoundingBoxAscent;\n        }\n        // Estimate\n        return (style.size * 2) / 3;\n    }\n    // Take input from this' textInputElem and add it to the EditorImage.\n    // If [removeInput], the HTML input element is removed. Otherwise, its value\n    // is cleared.\n    flushInput(removeInput = true) {\n        if (!this.textInputElem)\n            return;\n        // Determine the scroll first -- removing the input (and other DOM changes)\n        // also change the scroll.\n        const scrollingRegion = this.textEditOverlay.parentElement;\n        const containerScroll = math_1.Vec2.of(scrollingRegion?.scrollLeft ?? 0, scrollingRegion?.scrollTop ?? 0);\n        const content = this.textInputElem.value.trimEnd();\n        this.textInputElem.value = '';\n        if (removeInput) {\n            // In some browsers, .remove() triggers a .blur event (synchronously).\n            // Clear this.textInputElem before removal\n            const input = this.textInputElem;\n            this.textInputElem = null;\n            input.remove();\n        }\n        if (content !== '') {\n            // When the text is long, it can cause its container to scroll so that the\n            // editing caret is in view.\n            // So that the text added to the document is in the same position as the text\n            // shown in the editor, account for this scroll when computing the transform:\n            const scrollCorrectionScreen = containerScroll.times(-1);\n            // Uses .transformVec3 to avoid also translating the scroll correction (treating\n            // it as a point):\n            const scrollCorrectionCanvas = this.editor.viewport.screenToCanvasTransform.transformVec3(scrollCorrectionScreen);\n            const scrollTransform = math_1.Mat33.translation(scrollCorrectionCanvas);\n            const textComponent = TextComponent_1.default.fromLines(content.split('\\n'), scrollTransform.rightMul(this.contentTransform.get()), this.textStyle);\n            const action = EditorImage_1.default.addElement(textComponent);\n            if (this.removeExistingCommand) {\n                // Unapply so that `removeExistingCommand` can be added to the undo stack.\n                this.removeExistingCommand.unapply(this.editor);\n                this.editor.dispatch((0, uniteCommands_1.default)([this.removeExistingCommand, action]));\n                this.removeExistingCommand = null;\n            }\n            else {\n                this.editor.dispatch(action);\n            }\n        }\n    }\n    updateTextInput() {\n        if (!this.textInputElem) {\n            return;\n        }\n        this.textInputElem.placeholder = this.localizationTable.enterTextToInsert;\n        this.textInputElem.style.fontFamily = this.textStyle.fontFamily;\n        this.textInputElem.style.fontStyle = this.textStyle.fontStyle ?? '';\n        this.textInputElem.style.fontVariant = this.textStyle.fontVariant ?? '';\n        this.textInputElem.style.fontWeight = this.textStyle.fontWeight ?? '';\n        this.textInputElem.style.fontSize = `${this.textStyle.size}px`;\n        this.textInputElem.style.color = this.textStyle.renderingStyle.fill.toHexString();\n        this.textInputElem.style.margin = '0';\n        this.textInputElem.style.width = `${this.textInputElem.scrollWidth}px`;\n        this.textInputElem.style.height = `${this.textInputElem.scrollHeight}px`;\n        // Get the ascent based on the font, using a string of characters\n        // that is tall in most fonts.\n        const tallText = 'Testing!';\n        const ascent = this.getTextAscent(tallText, this.textStyle);\n        const vertAdjust = ascent;\n        this.textInputElem.style.transform = `translate(0, ${-vertAdjust}px)`;\n        this.textInputElem.style.transformOrigin = 'top left';\n        // Match the line height of default rendered text.\n        const lineHeight = Math.floor(this.textStyle.size);\n        this.textInputElem.style.lineHeight = `${lineHeight}px`;\n    }\n    startTextInput(textCanvasPos, initialText) {\n        this.flushInput();\n        this.textInputElem = document.createElement('textarea');\n        this.textInputElem.value = initialText;\n        this.textInputElem.style.display = 'inline-block';\n        const textTargetPosition = this.editor.viewport.roundPoint(textCanvasPos);\n        const textRotation = -this.editor.viewport.getRotationAngle();\n        const textScale = math_1.Vec2.of(1, 1).times(this.editor.viewport.getSizeOfPixelOnCanvas());\n        this.contentTransform.set(\n        // Scale, then rotate, then translate:\n        math_1.Mat33.translation(textTargetPosition)\n            .rightMul(math_1.Mat33.zRotation(textRotation))\n            .rightMul(math_1.Mat33.scaling2D(textScale)));\n        this.updateTextInput();\n        // Update the input size/position/etc. after the placeHolder has had time to appear.\n        setTimeout(() => this.updateTextInput(), 0);\n        this.textInputElem.oninput = () => {\n            if (this.textInputElem) {\n                this.textInputElem.style.width = `${this.textInputElem.scrollWidth}px`;\n                this.textInputElem.style.height = `${this.textInputElem.scrollHeight}px`;\n            }\n        };\n        this.textInputElem.onblur = () => {\n            const input = this.textInputElem;\n            // Delay removing the input -- flushInput may be called within a blur()\n            // event handler\n            const removeInput = false;\n            this.flushInput(removeInput);\n            this.textInputElem = null;\n            if (input) {\n                input.classList.add('-hiding');\n            }\n            setTimeout(() => {\n                input?.remove();\n            }, 0);\n        };\n        this.textInputElem.onkeyup = (evt) => {\n            // In certain input modes, the <enter> key is used to select characters.\n            // When in this mode, prevent <enter> from submitting:\n            if (evt.isComposing)\n                return;\n            if (evt.key === 'Enter' && !evt.shiftKey) {\n                this.flushInput();\n                this.editor.focus();\n            }\n            else if (evt.key === 'Escape') {\n                // Cancel input.\n                this.textInputElem?.remove();\n                this.textInputElem = null;\n                this.editor.focus();\n                this.removeExistingCommand?.unapply(this.editor);\n                this.removeExistingCommand = null;\n            }\n        };\n        this.textEditOverlay.replaceChildren(this.textInputElem);\n        setTimeout(() => this.textInputElem?.focus(), 0);\n    }\n    setEnabled(enabled) {\n        super.setEnabled(enabled);\n        if (!this.isEnabled()) {\n            this.flushInput();\n        }\n        this.textEditOverlay.style.display = enabled ? 'block' : 'none';\n    }\n    onPointerDown({ current, allPointers }) {\n        if (current.device === Pointer_1.PointerDevice.Eraser) {\n            return false;\n        }\n        if (allPointers.length === 1) {\n            // Are we clicking on a text node?\n            const canvasPos = current.canvasPos;\n            const halfTestRegionSize = math_1.Vec2.of(4, 4).times(this.editor.viewport.getSizeOfPixelOnCanvas());\n            const testRegion = math_1.Rect2.fromCorners(canvasPos.minus(halfTestRegionSize), canvasPos.plus(halfTestRegionSize));\n            const targetNodes = this.editor.image.getElementsIntersectingRegion(testRegion);\n            let targetTextNodes = targetNodes.filter((node) => node instanceof TextComponent_1.default);\n            // Don't try to edit text nodes that contain the viewport (this allows us\n            // to zoom in on text nodes and add text on top of them.)\n            const visibleRect = this.editor.viewport.visibleRect;\n            targetTextNodes = targetTextNodes.filter((node) => !node.getBBox().containsRect(visibleRect));\n            // End any TextNodes we're currently editing.\n            this.flushInput();\n            if (targetTextNodes.length > 0) {\n                const targetNode = targetTextNodes[targetTextNodes.length - 1];\n                this.setTextStyle(targetNode.getTextStyle());\n                // Create and temporarily apply removeExistingCommand.\n                this.removeExistingCommand = new Erase_1.default([targetNode]);\n                this.removeExistingCommand.apply(this.editor);\n                this.startTextInput(targetNode.getBaselinePos(), targetNode.getText());\n                this.contentTransform.set(targetNode.getTransform());\n                this.updateTextInput();\n            }\n            else {\n                this.removeExistingCommand = null;\n                this.startTextInput(current.canvasPos, '');\n            }\n            return true;\n        }\n        return false;\n    }\n    onGestureCancel() {\n        this.flushInput();\n        this.editor.focus();\n    }\n    setFontFamily(fontFamily) {\n        if (fontFamily !== this.textStyle.fontFamily) {\n            this.textStyleValue.set({\n                ...this.textStyle,\n                fontFamily: fontFamily,\n            });\n        }\n    }\n    setColor(color) {\n        if (!color.eq(this.textStyle.renderingStyle.fill)) {\n            this.textStyleValue.set({\n                ...this.textStyle,\n                renderingStyle: {\n                    ...this.textStyle.renderingStyle,\n                    fill: color,\n                },\n            });\n        }\n    }\n    setFontSize(size) {\n        if (size !== this.textStyle.size) {\n            this.textStyleValue.set({\n                ...this.textStyle,\n                size,\n            });\n        }\n    }\n    getTextStyle() {\n        return this.textStyle;\n    }\n    getStyleValue() {\n        return this.textStyleValue;\n    }\n    setTextStyle(style) {\n        this.textStyleValue.set(style);\n    }\n    // @internal\n    onDestroy() {\n        super.onDestroy();\n        this.anchorControl.remove();\n    }\n}\nexports[\"default\"] = TextTool;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/tools/TextTool.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/tools/ToolController.js":
/*!***************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/tools/ToolController.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst types_1 = __webpack_require__(/*! ../types */ \"./node_modules/js-draw/dist/cjs/types.js\");\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\nconst PanZoom_1 = __importStar(__webpack_require__(/*! ./PanZoom */ \"./node_modules/js-draw/dist/cjs/tools/PanZoom.js\"));\nconst Pen_1 = __importDefault(__webpack_require__(/*! ./Pen */ \"./node_modules/js-draw/dist/cjs/tools/Pen.js\"));\nconst ToolEnabledGroup_1 = __importDefault(__webpack_require__(/*! ./ToolEnabledGroup */ \"./node_modules/js-draw/dist/cjs/tools/ToolEnabledGroup.js\"));\nconst Eraser_1 = __importDefault(__webpack_require__(/*! ./Eraser */ \"./node_modules/js-draw/dist/cjs/tools/Eraser.js\"));\nconst SelectionTool_1 = __importDefault(__webpack_require__(/*! ./SelectionTool/SelectionTool */ \"./node_modules/js-draw/dist/cjs/tools/SelectionTool/SelectionTool.js\"));\nconst UndoRedoShortcut_1 = __importDefault(__webpack_require__(/*! ./UndoRedoShortcut */ \"./node_modules/js-draw/dist/cjs/tools/UndoRedoShortcut.js\"));\nconst TextTool_1 = __importDefault(__webpack_require__(/*! ./TextTool */ \"./node_modules/js-draw/dist/cjs/tools/TextTool.js\"));\nconst PipetteTool_1 = __importDefault(__webpack_require__(/*! ./PipetteTool */ \"./node_modules/js-draw/dist/cjs/tools/PipetteTool.js\"));\nconst ToolSwitcherShortcut_1 = __importDefault(__webpack_require__(/*! ./ToolSwitcherShortcut */ \"./node_modules/js-draw/dist/cjs/tools/ToolSwitcherShortcut.js\"));\nconst PasteHandler_1 = __importDefault(__webpack_require__(/*! ./PasteHandler */ \"./node_modules/js-draw/dist/cjs/tools/PasteHandler.js\"));\nconst ToolbarShortcutHandler_1 = __importDefault(__webpack_require__(/*! ./ToolbarShortcutHandler */ \"./node_modules/js-draw/dist/cjs/tools/ToolbarShortcutHandler.js\"));\nconst PressureSensitiveFreehandLineBuilder_1 = __webpack_require__(/*! ../components/builders/PressureSensitiveFreehandLineBuilder */ \"./node_modules/js-draw/dist/cjs/components/builders/PressureSensitiveFreehandLineBuilder.js\");\nconst FindTool_1 = __importDefault(__webpack_require__(/*! ./FindTool */ \"./node_modules/js-draw/dist/cjs/tools/FindTool.js\"));\nconst SelectAllShortcutHandler_1 = __importDefault(__webpack_require__(/*! ./SelectionTool/SelectAllShortcutHandler */ \"./node_modules/js-draw/dist/cjs/tools/SelectionTool/SelectAllShortcutHandler.js\"));\nconst SoundUITool_1 = __importDefault(__webpack_require__(/*! ./SoundUITool */ \"./node_modules/js-draw/dist/cjs/tools/SoundUITool.js\"));\nconst inputEvents_1 = __webpack_require__(/*! ../inputEvents */ \"./node_modules/js-draw/dist/cjs/inputEvents.js\");\nconst InputPipeline_1 = __importDefault(__webpack_require__(/*! ./InputFilter/InputPipeline */ \"./node_modules/js-draw/dist/cjs/tools/InputFilter/InputPipeline.js\"));\nconst InputStabilizer_1 = __importDefault(__webpack_require__(/*! ./InputFilter/InputStabilizer */ \"./node_modules/js-draw/dist/cjs/tools/InputFilter/InputStabilizer.js\"));\nconst ScrollbarTool_1 = __importDefault(__webpack_require__(/*! ./ScrollbarTool */ \"./node_modules/js-draw/dist/cjs/tools/ScrollbarTool.js\"));\nclass ToolController {\n    /** @internal */\n    constructor(editor, localization) {\n        this.activeTool = null;\n        this.isEditorReadOnly = editor.isReadOnlyReactiveValue();\n        this.inputPipeline = new InputPipeline_1.default();\n        this.inputPipeline.setEmitListener((event) => this.onEventInternal(event));\n        const primaryToolGroup = new ToolEnabledGroup_1.default();\n        this.primaryToolGroup = primaryToolGroup;\n        const panZoomTool = new PanZoom_1.default(editor, PanZoom_1.PanZoomMode.TwoFingerTouchGestures | PanZoom_1.PanZoomMode.RightClickDrags, localization.touchPanTool);\n        const keyboardPanZoomTool = new PanZoom_1.default(editor, PanZoom_1.PanZoomMode.Keyboard, localization.keyboardPanZoom);\n        const primaryPenTool = new Pen_1.default(editor, localization.penTool(1), {\n            color: math_1.Color4.purple,\n            thickness: 8,\n        });\n        const secondaryPenTool = new Pen_1.default(editor, localization.penTool(2), {\n            color: math_1.Color4.clay,\n            thickness: 4,\n        });\n        // Stabilize the secondary pen tool.\n        secondaryPenTool.setInputMapper(new InputStabilizer_1.default(editor.viewport));\n        const eraser = new Eraser_1.default(editor, localization.eraserTool);\n        const primaryTools = [\n            // Three pens\n            primaryPenTool,\n            secondaryPenTool,\n            // Highlighter-like pen with width=40\n            new Pen_1.default(editor, localization.penTool(3), {\n                color: math_1.Color4.ofRGBA(1, 1, 0, 0.5),\n                thickness: 40,\n                factory: PressureSensitiveFreehandLineBuilder_1.makePressureSensitiveFreehandLineBuilder,\n            }),\n            eraser,\n            new SelectionTool_1.default(editor, localization.selectionTool),\n            new TextTool_1.default(editor, localization.textTool, localization),\n            new PanZoom_1.default(editor, PanZoom_1.PanZoomMode.SinglePointerGestures, localization.anyDevicePanning),\n        ];\n        // Accessibility tools\n        const soundExplorer = new SoundUITool_1.default(editor, localization.soundExplorer);\n        soundExplorer.setEnabled(false);\n        this.tools = [\n            new ScrollbarTool_1.default(editor),\n            new PipetteTool_1.default(editor, localization.pipetteTool),\n            soundExplorer,\n            panZoomTool,\n            ...primaryTools,\n            keyboardPanZoomTool,\n            new UndoRedoShortcut_1.default(editor),\n            new ToolbarShortcutHandler_1.default(editor),\n            new ToolSwitcherShortcut_1.default(editor),\n            eraser.makeEraserSwitcherTool(),\n            new FindTool_1.default(editor),\n            new PasteHandler_1.default(editor),\n            new SelectAllShortcutHandler_1.default(editor),\n        ];\n        primaryTools.forEach((tool) => tool.setToolGroup(primaryToolGroup));\n        panZoomTool.setEnabled(true);\n        primaryPenTool.setEnabled(true);\n        editor.notifier.on(types_1.EditorEventType.ToolEnabled, (event) => {\n            if (event.kind === types_1.EditorEventType.ToolEnabled) {\n                editor.announceForAccessibility(localization.toolEnabledAnnouncement(event.tool.description));\n            }\n        });\n        editor.notifier.on(types_1.EditorEventType.ToolDisabled, (event) => {\n            if (event.kind === types_1.EditorEventType.ToolDisabled) {\n                editor.announceForAccessibility(localization.toolDisabledAnnouncement(event.tool.description));\n            }\n        });\n        this.activeTool = null;\n    }\n    /**\n     * Replaces the current set of tools with `tools`. This should only be done before\n     * the creation of the app's toolbar (if using `AbstractToolbar`).\n     *\n     * If no `primaryToolGroup` is given, an empty one will be created.\n     */\n    setTools(tools, primaryToolGroup) {\n        this.tools = tools;\n        this.primaryToolGroup = primaryToolGroup ?? new ToolEnabledGroup_1.default();\n    }\n    /**\n     * Add a tool that acts like one of the primary tools (only one primary tool can be enabled at a time).\n     *\n     * If the tool is already added to this, the tool is converted to a primary tool.\n     *\n     * This should be called before creating the app's toolbar.\n     */\n    addPrimaryTool(tool) {\n        tool.setToolGroup(this.primaryToolGroup);\n        if (tool.isEnabled()) {\n            this.primaryToolGroup.notifyEnabled(tool);\n        }\n        if (!this.tools.includes(tool)) {\n            this.addTool(tool);\n        }\n    }\n    getPrimaryTools() {\n        return this.tools.filter((tool) => {\n            return tool.getToolGroup() === this.primaryToolGroup;\n        });\n    }\n    /**\n     * Add a tool to the end of this' tool list (the added tool receives events after tools already added to this).\n     * This should be called before creating the app's toolbar.\n     *\n     * If `options.addToFront`, the tool is added to the beginning of this' tool list.\n     *\n     * Does nothing if the tool is already present.\n     */\n    addTool(tool, options) {\n        // Only add if not already present.\n        if (!this.tools.includes(tool)) {\n            if (options?.addToFront) {\n                this.tools.splice(0, 0, tool);\n            }\n            else {\n                this.tools.push(tool);\n            }\n        }\n    }\n    /**\n     * Removes **and destroys** all tools in `tools` from this.\n     */\n    removeAndDestroyTools(tools) {\n        const newTools = [];\n        for (const tool of this.tools) {\n            if (tools.includes(tool)) {\n                if (this.activeTool === tool) {\n                    this.activeTool = null;\n                }\n                tool.onDestroy();\n            }\n            else {\n                newTools.push(tool);\n            }\n        }\n        this.tools = newTools;\n    }\n    insertTools(insertNear, toolsToInsert, mode) {\n        this.tools = this.tools.filter((tool) => !toolsToInsert.includes(tool));\n        const newTools = [];\n        for (const tool of this.tools) {\n            if (mode === 'after') {\n                newTools.push(tool);\n            }\n            if (tool === insertNear) {\n                newTools.push(...toolsToInsert);\n            }\n            if (mode === 'before') {\n                newTools.push(tool);\n            }\n        }\n        this.tools = newTools;\n    }\n    /**\n     * Removes a tool from this' tool list and replaces it with `replaceWith`.\n     *\n     * If any of `toolsToInsert` have already been added to this, the tools are\n     * moved.\n     *\n     * This should be called before creating the editor's toolbar.\n     */\n    insertToolsAfter(insertAfter, toolsToInsert) {\n        this.insertTools(insertAfter, toolsToInsert, 'after');\n    }\n    /** @see {@link insertToolsAfter} */\n    insertToolsBefore(insertBefore, toolsToInsert) {\n        this.insertTools(insertBefore, toolsToInsert, 'before');\n    }\n    // @internal use `dispatchEvent` rather than calling `onEvent` directly.\n    onEventInternal(event) {\n        const isEditorReadOnly = this.isEditorReadOnly.get();\n        const canToolReceiveInput = (tool) => {\n            return tool.isEnabled() && (!isEditorReadOnly || tool.canReceiveInputInReadOnlyEditor());\n        };\n        let handled = false;\n        if (event.kind === inputEvents_1.InputEvtType.PointerDownEvt) {\n            let canOnlySendToActiveTool = false;\n            if (this.activeTool && !this.activeTool.eventCanBeDeliveredToNonActiveTool(event)) {\n                canOnlySendToActiveTool = true;\n            }\n            for (const tool of this.tools) {\n                if (canOnlySendToActiveTool && tool !== this.activeTool) {\n                    continue;\n                }\n                if (canToolReceiveInput(tool) && tool.onEvent(event)) {\n                    if (this.activeTool !== tool) {\n                        this.activeTool?.onEvent({ kind: inputEvents_1.InputEvtType.GestureCancelEvt });\n                    }\n                    this.activeTool = tool;\n                    handled = true;\n                    break;\n                }\n            }\n        }\n        else if (event.kind === inputEvents_1.InputEvtType.PointerUpEvt) {\n            const upResult = this.activeTool?.onEvent(event);\n            const continueHandlingEvents = upResult && event.allPointers.length > 1;\n            // Should the active tool continue handling events (without an additional pointer down?)\n            if (!continueHandlingEvents) {\n                // No -- Remove the current tool\n                this.activeTool = null;\n            }\n            handled = true;\n        }\n        else if (event.kind === inputEvents_1.InputEvtType.PointerMoveEvt) {\n            if (this.activeTool !== null) {\n                this.activeTool.onEvent(event);\n                handled = true;\n            }\n        }\n        else if (event.kind === inputEvents_1.InputEvtType.GestureCancelEvt) {\n            if (this.activeTool !== null) {\n                this.activeTool.onEvent(event);\n                this.activeTool = null;\n            }\n        }\n        else {\n            for (const tool of this.tools) {\n                if (!canToolReceiveInput(tool)) {\n                    continue;\n                }\n                handled = tool.onEvent(event);\n                if (handled) {\n                    break;\n                }\n            }\n        }\n        return handled;\n    }\n    /** Alias for {@link dispatchInputEvent}. */\n    onEvent(event) {\n        return this.dispatchInputEvent(event);\n    }\n    // Returns true if the event was handled.\n    dispatchInputEvent(event) {\n        // Feed the event through the input pipeline\n        return this.inputPipeline.onEvent(event);\n    }\n    /**\n     * Adds a new `InputMapper` to this' input pipeline.\n     *\n     * A `mapper` is really a relation that maps each event to no, one,\n     * or many other events.\n     *\n     * @see {@link InputMapper}.\n     */\n    addInputMapper(mapper) {\n        this.inputPipeline.addToTail(mapper);\n    }\n    getMatchingTools(type) {\n        return this.tools.filter((tool) => tool instanceof type);\n    }\n    // @internal\n    onEditorDestroyed() {\n        for (const tool of this.tools) {\n            tool.onDestroy();\n        }\n    }\n}\nexports[\"default\"] = ToolController;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/tools/ToolController.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/tools/ToolEnabledGroup.js":
/*!*****************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/tools/ToolEnabledGroup.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// Connects a group of tools -- at most one tool in the group can be enabled.\nclass ToolEnabledGroup {\n    constructor() { }\n    notifyEnabled(tool) {\n        if (tool !== this.activeTool) {\n            this.activeTool?.setEnabled(false);\n            this.activeTool = tool;\n        }\n    }\n}\nexports[\"default\"] = ToolEnabledGroup;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/tools/ToolEnabledGroup.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/tools/ToolSwitcherShortcut.js":
/*!*********************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/tools/ToolSwitcherShortcut.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst BaseTool_1 = __importDefault(__webpack_require__(/*! ./BaseTool */ \"./node_modules/js-draw/dist/cjs/tools/BaseTool.js\"));\n/**\n * Handles keyboard events used, by default, to select tools. By default,\n * 1 maps to the first primary tool, 2 to the second primary tool, ... .\n *\n * This is in the default set of {@link ToolController} tools.\n *\n */\nclass ToolSwitcherShortcut extends BaseTool_1.default {\n    constructor(editor) {\n        super(editor.notifier, editor.localization.changeTool);\n        this.editor = editor;\n    }\n    canReceiveInputInReadOnlyEditor() {\n        return true;\n    }\n    // @internal\n    onKeyPress({ key }) {\n        const toolController = this.editor.toolController;\n        const primaryTools = toolController.getPrimaryTools();\n        // Map keys 0-9 to primary tools.\n        const keyMatch = /^[0-9]$/.exec(key);\n        let targetTool;\n        if (keyMatch) {\n            const targetIdx = parseInt(keyMatch[0], 10) - 1;\n            targetTool = primaryTools[targetIdx];\n        }\n        if (targetTool) {\n            targetTool.setEnabled(true);\n            return true;\n        }\n        return false;\n    }\n}\nexports[\"default\"] = ToolSwitcherShortcut;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/tools/ToolSwitcherShortcut.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/tools/ToolbarShortcutHandler.js":
/*!***********************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/tools/ToolbarShortcutHandler.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n// Allows the toolbar to register keyboard events.\n// @packageDocumentation\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst BaseTool_1 = __importDefault(__webpack_require__(/*! ./BaseTool */ \"./node_modules/js-draw/dist/cjs/tools/BaseTool.js\"));\nclass ToolbarShortcutHandler extends BaseTool_1.default {\n    constructor(editor) {\n        super(editor.notifier, editor.localization.changeTool);\n        this.listeners = new Set([]);\n    }\n    registerListener(listener) {\n        this.listeners.add(listener);\n    }\n    removeListener(listener) {\n        this.listeners.delete(listener);\n    }\n    onKeyPress(event) {\n        // TypeScript seems to automatically convert for of loops into for(init;check;update)\n        // loops (even with target set to es6). Thus, we cannot iterate directly through the\n        // set here.\n        // See https://stackoverflow.com/q/48886500\n        const listeners = Array.from(this.listeners.values());\n        for (const listener of listeners) {\n            if (listener(event)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\nexports[\"default\"] = ToolbarShortcutHandler;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/tools/ToolbarShortcutHandler.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/tools/UndoRedoShortcut.js":
/*!*****************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/tools/UndoRedoShortcut.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst BaseTool_1 = __importDefault(__webpack_require__(/*! ./BaseTool */ \"./node_modules/js-draw/dist/cjs/tools/BaseTool.js\"));\nconst keybindings_1 = __webpack_require__(/*! ./keybindings */ \"./node_modules/js-draw/dist/cjs/tools/keybindings.js\");\n// Handles ctrl+Z, ctrl+Shift+Z keyboard shortcuts.\nclass UndoRedoShortcut extends BaseTool_1.default {\n    constructor(editor) {\n        super(editor.notifier, editor.localization.undoRedoTool);\n        this.editor = editor;\n    }\n    // @internal\n    onKeyPress(event) {\n        if (this.editor.shortcuts.matchesShortcut(keybindings_1.undoKeyboardShortcutId, event)) {\n            void this.editor.history.undo();\n            return true;\n        }\n        else if (this.editor.shortcuts.matchesShortcut(keybindings_1.redoKeyboardShortcutId, event)) {\n            void this.editor.history.redo();\n            return true;\n        }\n        return false;\n    }\n}\nexports[\"default\"] = UndoRedoShortcut;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/tools/UndoRedoShortcut.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/tools/keybindings.js":
/*!************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/tools/keybindings.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.zoomOutKeyboardShortcutId = exports.zoomInKeyboardShortcutId = exports.rotateCounterClockwiseKeyboardShortcutId = exports.rotateClockwiseKeyboardShortcutId = exports.moveDownKeyboardShortcutId = exports.moveUpKeyboardShortcutId = exports.moveRightKeyboardShortcutId = exports.moveLeftKeyboardShortcutId = exports.toggleFindVisibleShortcutId = exports.lineLockKeyboardShortcutId = exports.snapToGridKeyboardShortcutId = exports.decreaseSizeKeyboardShortcutId = exports.increaseSizeKeyboardShortcutId = exports.redoKeyboardShortcutId = exports.undoKeyboardShortcutId = void 0;\nconst KeyboardShortcutManager_1 = __importDefault(__webpack_require__(/*! ../shortcuts/KeyboardShortcutManager */ \"./node_modules/js-draw/dist/cjs/shortcuts/KeyboardShortcutManager.js\"));\n// This file contains user-overridable tool-realted keybindings.\n// Undo/redo\nexports.undoKeyboardShortcutId = 'jsdraw.tools.undo';\nexports.redoKeyboardShortcutId = 'jsdaw.tools.redo';\nKeyboardShortcutManager_1.default.registerDefaultKeyboardShortcut(exports.undoKeyboardShortcutId, ['CtrlOrMeta+KeyZ'], 'Undo');\nKeyboardShortcutManager_1.default.registerDefaultKeyboardShortcut(exports.redoKeyboardShortcutId, ['CtrlOrMeta+Shift+KeyZ', 'CtrlOrMeta+KeyY'], 'Redo');\n// Pen/eraser/selection keybindings\nexports.increaseSizeKeyboardShortcutId = 'jsdraw.tools.increaseSize';\nKeyboardShortcutManager_1.default.registerDefaultKeyboardShortcut(exports.increaseSizeKeyboardShortcutId, ['Equal', 'Shift+Equal'], 'Increase pen/eraser size');\nexports.decreaseSizeKeyboardShortcutId = 'jsdraw.tools.decreaseSize';\nKeyboardShortcutManager_1.default.registerDefaultKeyboardShortcut(exports.decreaseSizeKeyboardShortcutId, ['Minus', 'Shift+Minus'], 'Decrease pen/eraser size');\nexports.snapToGridKeyboardShortcutId = 'jsdraw.tools.snapToGrid';\nKeyboardShortcutManager_1.default.registerDefaultKeyboardShortcut(exports.snapToGridKeyboardShortcutId, ['Control', 'Meta'], 'Snap to grid (press and hold)');\nexports.lineLockKeyboardShortcutId = 'jsdraw.tools.lockToLine';\nKeyboardShortcutManager_1.default.registerDefaultKeyboardShortcut(exports.lineLockKeyboardShortcutId, ['Shift'], 'Snap to XY axes (press and hold)');\n// Find tool\nexports.toggleFindVisibleShortcutId = 'js-draw.tools.FindTool.toggleVisible';\nKeyboardShortcutManager_1.default.registerDefaultKeyboardShortcut(exports.toggleFindVisibleShortcutId, ['CtrlOrMeta+KeyF'], 'Shows/hides the find tool');\n// Pan/zoom\nexports.moveLeftKeyboardShortcutId = 'jsdraw.tools.PanZoom.moveLeft';\nKeyboardShortcutManager_1.default.registerDefaultKeyboardShortcut(exports.moveLeftKeyboardShortcutId, ['ArrowLeft', 'KeyH', 'KeyA'], 'Pan left');\nexports.moveRightKeyboardShortcutId = 'jsdraw.tools.PanZoom.moveRight';\nKeyboardShortcutManager_1.default.registerDefaultKeyboardShortcut(exports.moveRightKeyboardShortcutId, ['ArrowRight', 'KeyL', 'KeyD'], 'Pan right');\nexports.moveUpKeyboardShortcutId = 'jsdraw.tools.PanZoom.moveUp';\nKeyboardShortcutManager_1.default.registerDefaultKeyboardShortcut(exports.moveUpKeyboardShortcutId, ['ArrowUp', 'KeyK', 'KeyQ'], 'Pan up');\nexports.moveDownKeyboardShortcutId = 'jsdraw.tools.PanZoom.moveDown';\nKeyboardShortcutManager_1.default.registerDefaultKeyboardShortcut(exports.moveDownKeyboardShortcutId, ['ArrowDown', 'KeyJ', 'KeyE'], 'Pan down');\nexports.rotateClockwiseKeyboardShortcutId = 'jsdraw.tools.PanZoom.rotateViewClockwise';\nKeyboardShortcutManager_1.default.registerDefaultKeyboardShortcut(exports.rotateClockwiseKeyboardShortcutId, ['Shift+KeyR'], 'Rotate viewport clockwise');\nexports.rotateCounterClockwiseKeyboardShortcutId = 'jsdraw.tools.PanZoom.rotateViewCounterClockwise';\nKeyboardShortcutManager_1.default.registerDefaultKeyboardShortcut(exports.rotateCounterClockwiseKeyboardShortcutId, ['KeyR'], 'Rotate viewport counter-clockwise');\nexports.zoomInKeyboardShortcutId = 'jsdraw.tools.PanZoom.zoomIn';\nKeyboardShortcutManager_1.default.registerDefaultKeyboardShortcut(exports.zoomInKeyboardShortcutId, ['KeyW'], 'Zoom in');\nexports.zoomOutKeyboardShortcutId = 'jsdraw.tools.PanZoom.zoomOut';\nKeyboardShortcutManager_1.default.registerDefaultKeyboardShortcut(exports.zoomOutKeyboardShortcutId, ['KeyS'], 'Zoom out');\n// Selection tool\n__exportStar(__webpack_require__(/*! ./SelectionTool/keybindings */ \"./node_modules/js-draw/dist/cjs/tools/SelectionTool/keybindings.js\"), exports);\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/tools/keybindings.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/tools/lib.js":
/*!****************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/tools/lib.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ToolbarShortcutHandler = exports.SoundUITool = exports.PasteHandler = exports.EraserMode = exports.EraserTool = exports.SelectAllShortcutHandler = exports.SelectionTool = exports.TextTool = exports.PenTool = exports.PanZoomMode = exports.PanZoomTool = exports.ToolSwitcherShortcut = exports.UndoRedoShortcut = exports.ToolEnabledGroup = exports.ToolController = exports.BaseTool = exports.InputMapper = void 0;\nvar InputMapper_1 = __webpack_require__(/*! ./InputFilter/InputMapper */ \"./node_modules/js-draw/dist/cjs/tools/InputFilter/InputMapper.js\");\nObject.defineProperty(exports, \"InputMapper\", ({ enumerable: true, get: function () { return __importDefault(InputMapper_1).default; } }));\nvar BaseTool_1 = __webpack_require__(/*! ./BaseTool */ \"./node_modules/js-draw/dist/cjs/tools/BaseTool.js\");\nObject.defineProperty(exports, \"BaseTool\", ({ enumerable: true, get: function () { return __importDefault(BaseTool_1).default; } }));\nvar ToolController_1 = __webpack_require__(/*! ./ToolController */ \"./node_modules/js-draw/dist/cjs/tools/ToolController.js\");\nObject.defineProperty(exports, \"ToolController\", ({ enumerable: true, get: function () { return __importDefault(ToolController_1).default; } }));\nvar ToolEnabledGroup_1 = __webpack_require__(/*! ./ToolEnabledGroup */ \"./node_modules/js-draw/dist/cjs/tools/ToolEnabledGroup.js\");\nObject.defineProperty(exports, \"ToolEnabledGroup\", ({ enumerable: true, get: function () { return __importDefault(ToolEnabledGroup_1).default; } }));\nvar UndoRedoShortcut_1 = __webpack_require__(/*! ./UndoRedoShortcut */ \"./node_modules/js-draw/dist/cjs/tools/UndoRedoShortcut.js\");\nObject.defineProperty(exports, \"UndoRedoShortcut\", ({ enumerable: true, get: function () { return __importDefault(UndoRedoShortcut_1).default; } }));\nvar ToolSwitcherShortcut_1 = __webpack_require__(/*! ./ToolSwitcherShortcut */ \"./node_modules/js-draw/dist/cjs/tools/ToolSwitcherShortcut.js\");\nObject.defineProperty(exports, \"ToolSwitcherShortcut\", ({ enumerable: true, get: function () { return __importDefault(ToolSwitcherShortcut_1).default; } }));\nvar PanZoom_1 = __webpack_require__(/*! ./PanZoom */ \"./node_modules/js-draw/dist/cjs/tools/PanZoom.js\");\nObject.defineProperty(exports, \"PanZoomTool\", ({ enumerable: true, get: function () { return __importDefault(PanZoom_1).default; } }));\nObject.defineProperty(exports, \"PanZoomMode\", ({ enumerable: true, get: function () { return PanZoom_1.PanZoomMode; } }));\nvar Pen_1 = __webpack_require__(/*! ./Pen */ \"./node_modules/js-draw/dist/cjs/tools/Pen.js\");\nObject.defineProperty(exports, \"PenTool\", ({ enumerable: true, get: function () { return __importDefault(Pen_1).default; } }));\nvar TextTool_1 = __webpack_require__(/*! ./TextTool */ \"./node_modules/js-draw/dist/cjs/tools/TextTool.js\");\nObject.defineProperty(exports, \"TextTool\", ({ enumerable: true, get: function () { return __importDefault(TextTool_1).default; } }));\nvar SelectionTool_1 = __webpack_require__(/*! ./SelectionTool/SelectionTool */ \"./node_modules/js-draw/dist/cjs/tools/SelectionTool/SelectionTool.js\");\nObject.defineProperty(exports, \"SelectionTool\", ({ enumerable: true, get: function () { return __importDefault(SelectionTool_1).default; } }));\nvar SelectAllShortcutHandler_1 = __webpack_require__(/*! ./SelectionTool/SelectAllShortcutHandler */ \"./node_modules/js-draw/dist/cjs/tools/SelectionTool/SelectAllShortcutHandler.js\");\nObject.defineProperty(exports, \"SelectAllShortcutHandler\", ({ enumerable: true, get: function () { return __importDefault(SelectAllShortcutHandler_1).default; } }));\nvar Eraser_1 = __webpack_require__(/*! ./Eraser */ \"./node_modules/js-draw/dist/cjs/tools/Eraser.js\");\nObject.defineProperty(exports, \"EraserTool\", ({ enumerable: true, get: function () { return __importDefault(Eraser_1).default; } }));\nObject.defineProperty(exports, \"EraserMode\", ({ enumerable: true, get: function () { return Eraser_1.EraserMode; } }));\nvar PasteHandler_1 = __webpack_require__(/*! ./PasteHandler */ \"./node_modules/js-draw/dist/cjs/tools/PasteHandler.js\");\nObject.defineProperty(exports, \"PasteHandler\", ({ enumerable: true, get: function () { return __importDefault(PasteHandler_1).default; } }));\nvar SoundUITool_1 = __webpack_require__(/*! ./SoundUITool */ \"./node_modules/js-draw/dist/cjs/tools/SoundUITool.js\");\nObject.defineProperty(exports, \"SoundUITool\", ({ enumerable: true, get: function () { return __importDefault(SoundUITool_1).default; } }));\nvar ToolbarShortcutHandler_1 = __webpack_require__(/*! ./ToolbarShortcutHandler */ \"./node_modules/js-draw/dist/cjs/tools/ToolbarShortcutHandler.js\");\nObject.defineProperty(exports, \"ToolbarShortcutHandler\", ({ enumerable: true, get: function () { return __importDefault(ToolbarShortcutHandler_1).default; } }));\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/tools/lib.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/tools/localization.js":
/*!*************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/tools/localization.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.defaultToolLocalization = void 0;\nexports.defaultToolLocalization = {\n    penTool: (penId) => `Pen ${penId}`,\n    selectionTool: 'Selection',\n    selectAllTool: 'Select all shortcut',\n    eraserTool: 'Eraser',\n    touchPanTool: 'Touch panning',\n    twoFingerPanZoomTool: 'Panning and zooming',\n    undoRedoTool: 'Undo/Redo',\n    rightClickDragPanTool: 'Right-click drag',\n    pipetteTool: 'Pick color from screen',\n    keyboardPanZoom: 'Keyboard pan/zoom shortcuts',\n    selectionMenu__show: 'Show selection menu',\n    selectionMenu__copyToClipboard: 'Copy to clipboard',\n    selectionMenu__duplicate: 'Duplicate',\n    selectionMenu__delete: 'Delete',\n    selectionMenu__paste: 'Paste',\n    copyPasteError__heading: 'Copy/paste',\n    copyPasteError__description: 'Something went wrong — this tool may not have clipboard access.',\n    copyPasteError__errorDetails: 'Show error',\n    copyPasteError__pasteRetry: 'To retry, please paste into the input box below:',\n    copyPasteError__copyRetry: 'To retry, please copy the text in the input box below:',\n    copyPasteError__copyMe: 'Copy me!',\n    autocorrectedTo: (strokeDescription) => `Autocorrected to ${strokeDescription}`,\n    autocorrectionCanceled: 'Autocorrect cancelled',\n    textTool: 'Text',\n    enterTextToInsert: 'Text to insert',\n    changeTool: 'Change tool',\n    pasteHandler: 'Copy paste handler',\n    soundExplorer: 'Sound-based image exploration',\n    disableAccessibilityExploreTool: 'Disable sound-based exploration',\n    enableAccessibilityExploreTool: 'Enable sound-based exploration',\n    soundExplorerUsageAnnouncement: 'Sound-based image exploration enabled: Click/drag the screen to play a sound representation of different parts of the image.',\n    findLabel: 'Find',\n    toNextMatch: 'Next',\n    closeDialog: 'Close',\n    findDialogShown: 'Find dialog shown',\n    findDialogHidden: 'Find dialog hidden',\n    focusedFoundText: (matchIdx, totalMatches) => `Viewing match ${matchIdx} of ${totalMatches}`,\n    anyDevicePanning: 'Any device panning',\n    copied: (count) => `Copied ${count} item(s)`,\n    pasted: (count) => `Pasted ${count} item(s)`,\n    toolEnabledAnnouncement: (toolName) => `${toolName} enabled`,\n    toolDisabledAnnouncement: (toolName) => `${toolName} disabled`,\n};\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/tools/localization.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/tools/util/StationaryPenDetector.js":
/*!***************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/tools/util/StationaryPenDetector.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.defaultStationaryDetectionConfig = void 0;\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\nexports.defaultStationaryDetectionConfig = {\n    maxSpeed: 8.5, // screenPx/s\n    maxRadius: 11, // screenPx\n    minTimeSeconds: 0.5, // s\n};\nclass StationaryPenDetector {\n    // Only handles one pen. As such, `startPointer` should be the same device/finger\n    // as `updatedPointer` in `onPointerMove`.\n    //\n    // A new `StationaryPenDetector` should be created for each gesture.\n    constructor(startPointer, config, onStationary) {\n        this.config = config;\n        this.onStationary = onStationary;\n        this.timeout = null;\n        this.stationaryStartPointer = startPointer;\n        this.lastPointer = startPointer;\n        this.averageVelocity = math_1.Vec2.zero;\n        this.setStationaryTimeout(this.config.minTimeSeconds * 1000);\n    }\n    // Returns true if stationary\n    onPointerMove(currentPointer) {\n        if (!this.stationaryStartPointer) {\n            // Destoroyed\n            return;\n        }\n        if (currentPointer.id !== this.stationaryStartPointer.id) {\n            return false;\n        }\n        // dx: \"Δx\" Displacement from last.\n        const dxFromLast = currentPointer.screenPos.minus(this.lastPointer.screenPos);\n        const dxFromStationaryStart = currentPointer.screenPos.minus(this.stationaryStartPointer.screenPos);\n        // dt: Delta time:\n        // /1000: Convert to s.\n        let dtFromLast = (currentPointer.timeStamp - this.lastPointer.timeStamp) / 1000; // s\n        // Don't divide by zero\n        if (dtFromLast === 0) {\n            dtFromLast = 1;\n        }\n        const currentVelocity = dxFromLast.times(1 / dtFromLast); // px/s\n        // Slight smoothing of the velocity to prevent input jitter from affecting the\n        // velocity too significantly.\n        this.averageVelocity = this.averageVelocity.lerp(currentVelocity, 0.5); // px/s\n        const dtFromStart = currentPointer.timeStamp - this.stationaryStartPointer.timeStamp; // ms\n        const movedOutOfRadius = dxFromStationaryStart.length() > this.config.maxRadius;\n        this.hasMovedOutOfRadius ||= movedOutOfRadius;\n        // If not stationary\n        if (movedOutOfRadius ||\n            this.averageVelocity.length() > this.config.maxSpeed ||\n            dtFromStart < this.config.minTimeSeconds) {\n            this.stationaryStartPointer = currentPointer;\n            this.lastPointer = currentPointer;\n            this.setStationaryTimeout(this.config.minTimeSeconds * 1000);\n            return false;\n        }\n        const stationaryTimeoutMs = this.config.minTimeSeconds * 1000 - dtFromStart;\n        this.lastPointer = currentPointer;\n        return stationaryTimeoutMs <= 0;\n    }\n    onPointerUp(pointer) {\n        if (pointer.id !== this.stationaryStartPointer?.id) {\n            this.cancelStationaryTimeout();\n        }\n    }\n    destroy() {\n        this.cancelStationaryTimeout();\n        this.stationaryStartPointer = null;\n    }\n    getHasMovedOutOfRadius() {\n        return this.hasMovedOutOfRadius;\n    }\n    cancelStationaryTimeout() {\n        if (this.timeout !== null) {\n            clearTimeout(this.timeout);\n            this.timeout = null;\n        }\n    }\n    setStationaryTimeout(timeoutMs) {\n        if (this.timeout !== null) {\n            return;\n        }\n        if (timeoutMs <= 0) {\n            this.onStationary(this.lastPointer);\n        }\n        else {\n            this.timeout = setTimeout(() => {\n                this.timeout = null;\n                if (!this.stationaryStartPointer) {\n                    // Destroyed\n                    return;\n                }\n                const timeSinceStationaryStart = performance.now() - this.stationaryStartPointer.timeStamp;\n                const timeRemaining = this.config.minTimeSeconds * 1000 - timeSinceStationaryStart;\n                if (timeRemaining <= 0) {\n                    this.onStationary(this.lastPointer);\n                }\n                else {\n                    this.setStationaryTimeout(timeRemaining);\n                }\n            }, timeoutMs);\n        }\n    }\n}\nexports[\"default\"] = StationaryPenDetector;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/tools/util/StationaryPenDetector.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/tools/util/createMenuOverlay.js":
/*!***********************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/tools/util/createMenuOverlay.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst waitForTimeout_1 = __importDefault(__webpack_require__(/*! ../../util/waitForTimeout */ \"./node_modules/js-draw/dist/cjs/util/waitForTimeout.js\"));\nconst types_1 = __webpack_require__(/*! ../../types */ \"./node_modules/js-draw/dist/cjs/types.js\");\nlet idCounter = 0;\nconst createMenuOverlay = async (editor, canvasAnchor, options) => {\n    const overlay = document.createElement('div');\n    const { remove: removeOverlay } = editor.createHTMLOverlay(overlay);\n    const menuModal = document.createElement('dialog');\n    menuModal.classList.add('editor-popup-menu');\n    const hideMenuTimeout = 240;\n    menuModal.style.setProperty('--hide-menu-animation-timeout', `${hideMenuTimeout}ms`);\n    const updateMenuLocation = () => {\n        const overlayRect = editor.getOutputBBoxInDOM();\n        const anchor = editor.viewport.canvasToScreen(canvasAnchor).plus(overlayRect.topLeft);\n        menuModal.style.setProperty('--anchor-x', `${anchor.x}px`);\n        menuModal.style.setProperty('--anchor-y', `${anchor.y}px`);\n    };\n    updateMenuLocation();\n    const viewportChangeListener = editor.notifier.on(types_1.EditorEventType.ViewportChanged, updateMenuLocation);\n    overlay.appendChild(menuModal);\n    let dismissing = false;\n    const dismissMenu = async () => {\n        if (dismissing)\n            return;\n        dismissing = true;\n        viewportChangeListener.remove();\n        menuModal.classList.add('-hide');\n        await (0, waitForTimeout_1.default)(hideMenuTimeout);\n        menuModal.close();\n    };\n    return new Promise((resolve) => {\n        let resolved = false;\n        let result = null;\n        const resolveWithSelectedResult = () => {\n            if (!resolved) {\n                resolve(result);\n                resolved = true;\n            }\n        };\n        menuModal.onclose = () => {\n            removeOverlay();\n            resolveWithSelectedResult();\n        };\n        const onOptionSelected = (key) => {\n            result = key;\n            void dismissMenu();\n            // To properly handle clipboard events, this needs to be called synchronously\n            // and not after a delay:\n            resolveWithSelectedResult();\n        };\n        editor.handlePointerEventsExceptClicksFrom(menuModal, (eventName, event) => {\n            if (event.target === menuModal && eventName === 'pointerdown') {\n                void dismissMenu();\n                return true;\n            }\n            else if (dismissing) {\n                // Send pointer events to the editor if the dialog is in the process of being\n                // dismissed (e.g. pointermove events just after a pointerdown outside of the\n                // editor).\n                return true;\n            }\n            return false;\n        }, (_eventName, event) => {\n            return event.target === menuModal;\n        });\n        const contentElement = document.createElement('div');\n        contentElement.classList.add('content');\n        contentElement.role = 'menu';\n        const optionElements = [];\n        // Keyboard focus handling as described in\n        // - https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/menu_role and\n        // - https://www.w3.org/WAI/ARIA/apg/patterns/disclosure/examples/disclosure-navigation/\n        contentElement.addEventListener('keydown', (event) => {\n            const focusedIndex = optionElements.findIndex((item) => item === document.activeElement);\n            if (focusedIndex === -1)\n                return;\n            let newFocusedIndex = focusedIndex;\n            if (event.key === 'ArrowDown') {\n                newFocusedIndex++;\n            }\n            else if (event.key === 'ArrowUp') {\n                newFocusedIndex--;\n            }\n            else if (event.key === 'End') {\n                newFocusedIndex = optionElements.length - 1;\n            }\n            else if (event.key === 'Home') {\n                newFocusedIndex = 0;\n            }\n            if (newFocusedIndex < 0) {\n                newFocusedIndex += optionElements.length;\n            }\n            newFocusedIndex %= optionElements.length;\n            if (newFocusedIndex !== focusedIndex) {\n                event.preventDefault();\n                optionElements[newFocusedIndex].focus();\n            }\n        });\n        for (const option of options) {\n            const optionElement = document.createElement('button');\n            optionElement.id = `menu-overlay-option-${idCounter++}`;\n            optionElement.role = 'menuitem';\n            optionElement.classList.add('option', 'editor-popup-menu-option');\n            optionElement.replaceChildren(option.icon(), document.createTextNode(option.text));\n            optionElement.onclick = (event) => {\n                if (event.defaultPrevented)\n                    return;\n                onOptionSelected(option.key);\n            };\n            contentElement.appendChild(optionElement);\n            if (optionElements.length === 0) {\n                optionElement.autofocus = true;\n            }\n            optionElements.push(optionElement);\n        }\n        menuModal.appendChild(contentElement);\n        menuModal.showModal();\n        // Ensures that the menu is visible even if triggered near the edge of the screen.\n        contentElement.scrollIntoView({ block: 'nearest' });\n    });\n};\nexports[\"default\"] = createMenuOverlay;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/tools/util/createMenuOverlay.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/types.js":
/*!************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/types.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n// Types related to the image editor\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UndoEventType = exports.EditorEventType = void 0;\n/** @see {@link EditorNotifier} */\nvar EditorEventType;\n(function (EditorEventType) {\n    EditorEventType[EditorEventType[\"ToolEnabled\"] = 0] = \"ToolEnabled\";\n    EditorEventType[EditorEventType[\"ToolDisabled\"] = 1] = \"ToolDisabled\";\n    EditorEventType[EditorEventType[\"ToolUpdated\"] = 2] = \"ToolUpdated\";\n    EditorEventType[EditorEventType[\"UndoRedoStackUpdated\"] = 3] = \"UndoRedoStackUpdated\";\n    EditorEventType[EditorEventType[\"CommandDone\"] = 4] = \"CommandDone\";\n    EditorEventType[EditorEventType[\"CommandUndone\"] = 5] = \"CommandUndone\";\n    EditorEventType[EditorEventType[\"ObjectAdded\"] = 6] = \"ObjectAdded\";\n    EditorEventType[EditorEventType[\"ViewportChanged\"] = 7] = \"ViewportChanged\";\n    EditorEventType[EditorEventType[\"DisplayResized\"] = 8] = \"DisplayResized\";\n    EditorEventType[EditorEventType[\"SelectionUpdated\"] = 9] = \"SelectionUpdated\";\n    EditorEventType[EditorEventType[\"ReadOnlyModeToggled\"] = 10] = \"ReadOnlyModeToggled\";\n    /** @internal */\n    EditorEventType[EditorEventType[\"ColorPickerToggled\"] = 11] = \"ColorPickerToggled\";\n    /** @internal */\n    EditorEventType[EditorEventType[\"ColorPickerColorSelected\"] = 12] = \"ColorPickerColorSelected\";\n    /** @deprecated @internal */\n    EditorEventType[EditorEventType[\"ToolbarDropdownShown\"] = 13] = \"ToolbarDropdownShown\";\n})(EditorEventType || (exports.EditorEventType = EditorEventType = {}));\n// Types of `EditorUndoStackUpdated` events.\nvar UndoEventType;\n(function (UndoEventType) {\n    UndoEventType[UndoEventType[\"CommandDone\"] = 0] = \"CommandDone\";\n    UndoEventType[UndoEventType[\"CommandUndone\"] = 1] = \"CommandUndone\";\n    UndoEventType[UndoEventType[\"CommandRedone\"] = 2] = \"CommandRedone\";\n})(UndoEventType || (exports.UndoEventType = UndoEventType = {}));\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/types.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/util/ClipboardHandler.js":
/*!****************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/util/ClipboardHandler.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n/* eslint-disable @typescript-eslint/no-redundant-type-constituents -- Used for clarity */\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar _ClipboardHandler_preferClipboardEvents;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst inputEvents_1 = __webpack_require__(/*! ../inputEvents */ \"./node_modules/js-draw/dist/cjs/inputEvents.js\");\nconst fileToBase64Url_1 = __importDefault(__webpack_require__(/*! ./fileToBase64Url */ \"./node_modules/js-draw/dist/cjs/util/fileToBase64Url.js\"));\nconst isTextMimeType = (mime) => \n// +xml: Handles image/svg+xml\nmime.endsWith('+xml') || mime.startsWith('text/');\n/**\n * Handles conversion between the browser clipboard APIs and internal\n * js-draw clipboard events.\n */\nclass ClipboardHandler {\n    constructor(editor, callbacks) {\n        this.editor = editor;\n        this.callbacks = callbacks;\n        _ClipboardHandler_preferClipboardEvents.set(this, false);\n    }\n    /**\n     * Pastes data from the clipboard into the editor associated with\n     * this handler.\n     *\n     * @param event Optional -- a clipboard/drag event. If not provided,\n     * \t\t\t\t`navigator.clipboard` will be used instead.\n     * @returns true if the paste event was handled by the editor.\n     */\n    paste(event) {\n        const onError = (error) => {\n            if (this.callbacks?.onPasteError) {\n                this.callbacks.onPasteError(error);\n                return Promise.resolve(false);\n            }\n            else {\n                throw error;\n            }\n        };\n        try {\n            // Use .catch rather than `async` to prevent future modifications from\n            // moving clipboard handling logic out of user event handlers.\n            // In the past, `await`s have caused permissions issues in some browsers.\n            return this.pasteInternal(event).catch(onError);\n        }\n        catch (error) {\n            return onError(error);\n        }\n    }\n    async pasteInternal(event) {\n        const editor = this.editor;\n        const clipboardData = event?.dataTransfer ?? event?.clipboardData ?? null;\n        const hasEvent = !!clipboardData;\n        const sendPasteEvent = (mime, data) => {\n            return (data &&\n                editor.toolController.dispatchInputEvent({\n                    kind: inputEvents_1.InputEvtType.PasteEvent,\n                    mime,\n                    data,\n                }));\n        };\n        // Listed in order of precedence\n        const supportedMIMEs = ['image/svg+xml', 'text/html', 'image/png', 'image/jpeg', 'text/plain'];\n        let files = [];\n        const textData = new Map();\n        const editorSettings = editor.getCurrentSettings();\n        if (hasEvent) {\n            // NOTE: On some browsers, .getData and .files must be used before any async operations.\n            files = [...clipboardData.files];\n            for (const mime of supportedMIMEs) {\n                const data = clipboardData.getData(mime);\n                if (data) {\n                    textData.set(mime, data);\n                }\n            }\n        }\n        else if (editorSettings.clipboardApi) {\n            const clipboardData = await editorSettings.clipboardApi.read();\n            for (const [type, data] of clipboardData.entries()) {\n                if (typeof data === 'string') {\n                    textData.set(type, data);\n                }\n                else {\n                    let blob = data;\n                    if (blob.type !== type) {\n                        blob = new Blob([blob], { type });\n                    }\n                    files.push(blob);\n                }\n            }\n        }\n        else {\n            const clipboardData = await navigator.clipboard.read();\n            for (const item of clipboardData) {\n                for (const mime of item.types) {\n                    if (supportedMIMEs.includes(mime)) {\n                        files.push(await item.getType(mime));\n                    }\n                }\n            }\n        }\n        // Returns true if handled\n        const handleMIME = async (mime) => {\n            const isTextFormat = isTextMimeType(mime);\n            if (isTextFormat) {\n                const data = textData.get(mime);\n                if (sendPasteEvent(mime, data)) {\n                    event?.preventDefault();\n                    return true;\n                }\n            }\n            for (const file of files) {\n                const fileType = file?.type?.toLowerCase();\n                if (fileType !== mime) {\n                    continue;\n                }\n                if (isTextFormat) {\n                    const text = await file.text();\n                    if (sendPasteEvent(mime, text)) {\n                        event?.preventDefault();\n                        return true;\n                    }\n                }\n                else {\n                    editor.showLoadingWarning(0);\n                    const onprogress = (evt) => {\n                        editor.showLoadingWarning(evt.loaded / evt.total);\n                    };\n                    try {\n                        const data = await (0, fileToBase64Url_1.default)(file, { onprogress });\n                        if (sendPasteEvent(mime, data)) {\n                            event?.preventDefault();\n                            editor.hideLoadingWarning();\n                            return true;\n                        }\n                    }\n                    catch (e) {\n                        console.error('Error reading image:', e);\n                    }\n                    editor.hideLoadingWarning();\n                }\n            }\n            return false;\n        };\n        for (const mime of supportedMIMEs) {\n            if (await handleMIME(mime)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Copies text from the editor associated with this.\n     *\n     * Even if `event` is provided, the `navigator.clipboard` API may be used if image data\n     * is to be copied. This is done because `ClipboardEvent`s seem to not support attaching\n     * images.\n     */\n    copy(event) {\n        const onError = (error) => {\n            if (this.callbacks?.onCopyError) {\n                this.callbacks.onCopyError(error);\n                return Promise.resolve();\n            }\n            else {\n                throw error;\n            }\n        };\n        try {\n            // As above, use `.catch` to be certain that certain copyInternal\n            // is run now, before returning.\n            return this.copyInternal(event).catch(onError);\n        }\n        catch (error) {\n            return onError(error);\n        }\n    }\n    copyInternal(event) {\n        const mimeToData = new Map();\n        if (this.editor.toolController.dispatchInputEvent({\n            kind: inputEvents_1.InputEvtType.CopyEvent,\n            setData: (mime, data) => {\n                mimeToData.set(mime, data);\n            },\n        })) {\n            event?.preventDefault();\n        }\n        const mimeTypes = [...mimeToData.keys()];\n        const hasNonTextMimeTypes = mimeTypes.some((mime) => !isTextMimeType(mime));\n        const copyToEvent = (reason) => {\n            if (!event) {\n                throw new Error(`Unable to copy -- no event provided${reason ? `. Original error: ${reason}` : ''}`);\n            }\n            for (const [key, value] of mimeToData.entries()) {\n                if (typeof value === 'string') {\n                    if ('clipboardData' in event) {\n                        event.clipboardData?.setData(key, value);\n                    }\n                    else {\n                        event.dataTransfer?.setData(key, value);\n                    }\n                }\n            }\n        };\n        const copyToClipboardApi = () => {\n            const mapInternalDataToBrowserData = (originalMimeToData) => {\n                const mappedMimeToData = Object.create(null);\n                for (const [key, data] of originalMimeToData.entries()) {\n                    if (typeof data === 'string') {\n                        const loadedData = new Blob([new TextEncoder().encode(data)], { type: key });\n                        mappedMimeToData[key] = loadedData;\n                    }\n                    else {\n                        mappedMimeToData[key] = data;\n                    }\n                    // Different platforms have varying support for different clipboard MIME types:\n                    // - As of September 2024, image/svg+xml is unsupported on iOS\n                    // - text/html is unsupported on Chrome/Android (and perhaps Chrome on other platforms).\n                    //    - See https://issues.chromium.org/issues/40851502\n                    if (key === 'image/svg+xml') {\n                        mappedMimeToData['text/html'] ??= mappedMimeToData[key];\n                    }\n                }\n                return mappedMimeToData;\n            };\n            const removeUnsupportedMime = (originalMimeToData) => {\n                const filteredMimeToData = Object.create(null);\n                for (const [key, data] of Object.entries(originalMimeToData)) {\n                    // Browser support for ClipboardItem.supports is limited as of mid 2024. However, some browsers\n                    // that do support `.supports` throw an exception when attempting to copy an unsupported MIME type\n                    // (e.g. Firefox).\n                    const unsupported = 'supports' in ClipboardItem &&\n                        typeof ClipboardItem.supports === 'function' &&\n                        !ClipboardItem.supports(key);\n                    if (!unsupported) {\n                        filteredMimeToData[key] = data;\n                    }\n                }\n                return filteredMimeToData;\n            };\n            const browserMimeToData = removeUnsupportedMime(mapInternalDataToBrowserData(mimeToData));\n            return navigator.clipboard.write([new ClipboardItem(browserMimeToData)]);\n        };\n        const supportsClipboardApi = typeof ClipboardItem !== 'undefined' && typeof navigator?.clipboard?.write !== 'undefined';\n        const prefersClipboardApi = !__classPrivateFieldGet(this, _ClipboardHandler_preferClipboardEvents, \"f\") && supportsClipboardApi && (hasNonTextMimeTypes || !event);\n        const editorSettings = this.editor.getCurrentSettings();\n        if (prefersClipboardApi && editorSettings.clipboardApi) {\n            const writeResult = editorSettings.clipboardApi.write(mimeToData);\n            return writeResult ?? Promise.resolve();\n        }\n        else if (prefersClipboardApi) {\n            let clipboardApiPromise = null;\n            const fallBackToCopyEvent = (reason) => {\n                console.warn('Unable to copy to the clipboard API. Future calls to .copy will use ClipboardEvents if possible.', reason);\n                __classPrivateFieldSet(this, _ClipboardHandler_preferClipboardEvents, true, \"f\");\n                copyToEvent(reason);\n            };\n            try {\n                clipboardApiPromise = copyToClipboardApi();\n            }\n            catch (error) {\n                fallBackToCopyEvent(error);\n            }\n            if (clipboardApiPromise) {\n                return clipboardApiPromise.catch(fallBackToCopyEvent);\n            }\n        }\n        else {\n            copyToEvent();\n        }\n        return Promise.resolve();\n    }\n}\n_ClipboardHandler_preferClipboardEvents = new WeakMap();\nexports[\"default\"] = ClipboardHandler;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/util/ClipboardHandler.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/util/ReactiveValue.js":
/*!*************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/util/ReactiveValue.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _ReactiveValueImpl_value, _ReactiveValueImpl_onUpdateListeners;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MutableReactiveValue = exports.ReactiveValue = void 0;\nconst noOpUpdateListenerResult = {\n    remove() { },\n};\n/**\n * An update listener that does nothing. Useful for reactive values\n * that will never change.\n */\nconst noOpSetUpdateListener = () => {\n    return noOpUpdateListenerResult;\n};\n/**\n * A `ReactiveValue` is a value that\n * - updates periodically,\n * - can fire listeners when it updates,\n * - and can be chanined together with other `ReactiveValue`s.\n *\n * A `ReactiveValue` is a read-only view. See {@link MutableReactiveValue} for a\n * read-write view.\n *\n * Static methods in the `ReactiveValue` and `MutableReactiveValue` classes are\n * constructors (e.g. `fromImmutable`).\n *\n * Avoid extending this class from an external library, as that may not be stable.\n */\nclass ReactiveValue {\n    /** Returns a promise that resolves when this value is next changed. */\n    waitForNextUpdate() {\n        return new Promise((resolve) => {\n            const listener = this.onUpdate((value) => {\n                listener.remove();\n                resolve(value);\n            });\n        });\n    }\n    /** Creates a `ReactiveValue` with an initial value, `initialValue`. */\n    static fromInitialValue(initialValue) {\n        return new ReactiveValueImpl(initialValue);\n    }\n    /** Returns a `ReactiveValue` that is **known** will never change. */\n    static fromImmutable(value) {\n        return {\n            get: () => value,\n            onUpdate: noOpSetUpdateListener,\n            onUpdateAndNow: (callback) => {\n                callback(value);\n                return noOpUpdateListenerResult;\n            },\n            // Never resolves -- immutable.\n            waitForNextUpdate: () => new Promise(() => { }),\n        };\n    }\n    /**\n     * Creates a `ReactiveValue` whose values come from `callback`.\n     *\n     * `callback` is called whenever any of `sourceValues` are updated and initially to\n     * set the initial value of the result.\n     */\n    static fromCallback(callback, sourceValues) {\n        const result = new ReactiveValueImpl(callback());\n        const resultRef = window.WeakRef\n            ? new window.WeakRef(result)\n            : { deref: () => result };\n        for (const value of sourceValues) {\n            const listener = value.onUpdate(() => {\n                // Use resultRef to allow `result` to be garbage collected\n                // despite this listener.\n                const value = resultRef.deref();\n                if (value) {\n                    value.set(callback());\n                }\n                else {\n                    listener.remove();\n                }\n            });\n        }\n        return result;\n    }\n    static map(source, map, inverseMap) {\n        const result = ReactiveValue.fromInitialValue(map(source.get()));\n        let expectedResultValue = result.get();\n        source.onUpdate((newValue) => {\n            expectedResultValue = map(newValue);\n            result.set(expectedResultValue);\n        });\n        if (inverseMap) {\n            result.onUpdate((newValue) => {\n                // Prevent infinite loops if inverseMap is not a true\n                // inverse.\n                if (newValue !== expectedResultValue) {\n                    source.set(inverseMap(newValue));\n                }\n            });\n        }\n        return result;\n    }\n    static union(values) {\n        return ReactiveValue.fromCallback(() => {\n            return values.map((value) => value.get());\n        }, values);\n    }\n}\nexports.ReactiveValue = ReactiveValue;\nclass MutableReactiveValue extends ReactiveValue {\n    static fromProperty(sourceValue, propertyName) {\n        const child = ReactiveValue.fromInitialValue(sourceValue.get()[propertyName]);\n        const childRef = window.WeakRef\n            ? new window.WeakRef(child)\n            : { deref: () => child };\n        // When the source is updated...\n        const sourceListener = sourceValue.onUpdate((newValue) => {\n            const childValue = childRef.deref();\n            if (childValue) {\n                childValue.set(newValue[propertyName]);\n            }\n            else {\n                // TODO: What if `sourceValue` would be dropped before\n                // the child value?\n                sourceListener.remove();\n            }\n        });\n        // When the child is updated, also apply the update to the\n        // parent.\n        child.onUpdate((newValue) => {\n            sourceValue.set({\n                ...sourceValue.get(),\n                [propertyName]: newValue,\n            });\n        });\n        return child;\n    }\n}\nexports.MutableReactiveValue = MutableReactiveValue;\n// @internal\nclass ReactiveValueImpl extends MutableReactiveValue {\n    constructor(initialValue) {\n        super();\n        _ReactiveValueImpl_value.set(this, void 0);\n        _ReactiveValueImpl_onUpdateListeners.set(this, void 0);\n        __classPrivateFieldSet(this, _ReactiveValueImpl_value, initialValue, \"f\");\n        __classPrivateFieldSet(this, _ReactiveValueImpl_onUpdateListeners, [], \"f\");\n    }\n    set(newValue) {\n        if (__classPrivateFieldGet(this, _ReactiveValueImpl_value, \"f\") === newValue) {\n            return;\n        }\n        __classPrivateFieldSet(this, _ReactiveValueImpl_value, newValue, \"f\");\n        for (const listener of __classPrivateFieldGet(this, _ReactiveValueImpl_onUpdateListeners, \"f\")) {\n            listener(newValue);\n        }\n    }\n    get() {\n        return __classPrivateFieldGet(this, _ReactiveValueImpl_value, \"f\");\n    }\n    onUpdate(listener) {\n        // **Note**: If memory is a concern, listeners should avoid referencing this\n        // reactive value directly. Doing so allows the value to be garbage collected when\n        // no longer referenced.\n        __classPrivateFieldGet(this, _ReactiveValueImpl_onUpdateListeners, \"f\").push(listener);\n        return {\n            remove: () => {\n                __classPrivateFieldSet(this, _ReactiveValueImpl_onUpdateListeners, __classPrivateFieldGet(this, _ReactiveValueImpl_onUpdateListeners, \"f\").filter((otherListener) => {\n                    return otherListener !== listener;\n                }), \"f\");\n            },\n        };\n    }\n    onUpdateAndNow(callback) {\n        callback(this.get());\n        return this.onUpdate(callback);\n    }\n}\n_ReactiveValueImpl_value = new WeakMap(), _ReactiveValueImpl_onUpdateListeners = new WeakMap();\nexports[\"default\"] = ReactiveValue;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/util/ReactiveValue.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/util/addLongPressOrHoverCssClasses.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/util/addLongPressOrHoverCssClasses.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst listenForLongPressOrHover_1 = __importDefault(__webpack_require__(/*! ./listenForLongPressOrHover */ \"./node_modules/js-draw/dist/cjs/util/listenForLongPressOrHover.js\"));\n/**\n * When a pointer is inside `element`, after a delay, adds the `has-long-press-or-hover`\n * CSS class to `element`.\n *\n * When no pointers are inside `element`, adds the CSS class `no-long-press-or-hover`.\n */\nconst addLongPressOrHoverCssClasses = (element, options) => {\n    const hasLongPressClass = 'has-long-press-or-hover';\n    const noLongPressClass = 'no-long-press-or-hover';\n    element.classList.add('no-long-press-or-hover');\n    const { removeListeners } = (0, listenForLongPressOrHover_1.default)(element, {\n        onStart() {\n            element.classList.remove(noLongPressClass);\n            element.classList.add(hasLongPressClass);\n        },\n        onEnd() {\n            element.classList.add(noLongPressClass);\n            element.classList.remove(hasLongPressClass);\n        },\n        longPressTimeout: options?.timeout,\n    });\n    return {\n        removeEventListeners: () => {\n            element.classList.remove(noLongPressClass);\n            removeListeners();\n        },\n    };\n};\nexports[\"default\"] = addLongPressOrHoverCssClasses;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/util/addLongPressOrHoverCssClasses.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/util/adjustEditorThemeForContrast.js":
/*!****************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/util/adjustEditorThemeForContrast.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst math_1 = __webpack_require__(/*! @js-draw/math */ \"./node_modules/@js-draw/math/dist/cjs/lib.js\");\n/**\n * Adjusts the current editor theme such that colors have appropriate contrast.\n *\n * As this method overrides CSS variables using the `.style` property,\n * **assumes** all original theme variables are set using CSS and not the `.style` property.\n *\n * If the editor changes theme in response to the system theme, this method should be\n * called whenever the system theme changes (e.g. by using [the `matchMedia`](https://developer.mozilla.org/en-US/docs/Web/API/Window/matchMedia)\n * method).\n *\n * @example\n * ```ts,runnable\n * import { Editor, adjustEditorThemeForContrast } from 'js-draw';\n *\n * const editor = new Editor(document.body);\n * editor.addToolbar();\n *\n * const css = `\n *   :root .imageEditorContainer {\n *     --background-color-1: #ffff77;\n *     --foreground-color-1: #fff;\n *     --background-color-2: #ffff99;\n *     --foreground-color-2: #ffff88;\n *     --background-color-3: #ddffff;\n *     --foreground-color-3: #eeffff;\n *     --selection-background-color: #9f7;\n *     --selection-foreground-color: #98f;\n *   }\n *\n *   @media screen and (prefers-color-scheme: dark) {\n *     :root .imageEditorContainer {\n *       --background-color-1: black;\n *     }\n *   }\n * `;\n * editor.addStyleSheet(css);\n *\n * adjustEditorThemeForContrast(editor);\n *\n * // Because adjustEditorThemeForContrast overrides the current theme, it should be called again\n * // to allow the editor to switch between light/dark themes.\n * window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {\n *   adjustEditorThemeForContrast(editor);\n * });\n *\n * window.matchMedia('print').addEventListener('change', () => {\n *   adjustEditorThemeForContrast(editor);\n * });\n * ```\n */\nconst adjustEditorThemeForContrast = (editor, options) => {\n    const editorElem = editor.getRootElement();\n    // Each set of entries in colorPairs should resolve to colors with sufficient\n    // contrast.\n    const colorPairs = [\n        ['--background-color-1', '--foreground-color-1', true, true],\n        ['--background-color-2', '--foreground-color-2', true, true],\n        ['--background-color-3', '--foreground-color-3', true, true],\n        ['--background-color-2', '--primary-action-foreground-color', false, true],\n        ['--selection-background-color', '--selection-foreground-color', false, true],\n    ];\n    if (!options?.dontClearOverrides) {\n        // Clear any overrides\n        for (const [backgroundVar, foregroundVar] of colorPairs) {\n            editorElem.style.setProperty(backgroundVar, null);\n            editorElem.style.setProperty(foregroundVar, null);\n        }\n    }\n    const styles = getComputedStyle(editorElem);\n    const updatedColors = Object.create(null);\n    const adjustVariablesForContrast = (var1, var2, minContrast, \n    // true if the variable can be updated\n    updateVar1, updateVar2) => {\n        // Fetch from updatedColors if available -- styles isn't updated dynamically.\n        let color1 = updatedColors[var1]\n            ? updatedColors[var1]\n            : math_1.Color4.fromString(styles.getPropertyValue(var1));\n        let color2 = updatedColors[var2]\n            ? updatedColors[var2]\n            : math_1.Color4.fromString(styles.getPropertyValue(var2));\n        // Ensure that color1 has the lesser luminance\n        if (color1.relativeLuminance() < color2.relativeLuminance()) {\n            const tmp = color1;\n            color1 = color2;\n            color2 = tmp;\n            const oldVar2 = var2;\n            var2 = var1;\n            var1 = oldVar2;\n            const oldUpdateVar1 = updateVar1;\n            updateVar1 = updateVar2;\n            updateVar2 = oldUpdateVar1;\n        }\n        let colorsUpdated = false;\n        let currentContrast = math_1.Color4.contrastRatio(color1, color2);\n        let iterations = 0;\n        // Step the brightness of color1 and color2 in different directions while necessary\n        while (currentContrast < minContrast && iterations < 8) {\n            const step = math_1.Vec3.of(0.1, 0.1, 0.1);\n            if (updateVar1) {\n                if (color2.eq(math_1.Color4.white) && !updateVar2) {\n                    color2 = math_1.Color4.black;\n                }\n                color1 = math_1.Color4.fromRGBVector(color1.rgb.plus(step));\n            }\n            if (updateVar2) {\n                if (color2.eq(math_1.Color4.black) && !updateVar1) {\n                    color2 = math_1.Color4.white;\n                }\n                color2 = math_1.Color4.fromRGBVector(color2.rgb.minus(step));\n            }\n            currentContrast = math_1.Color4.contrastRatio(color1, color2);\n            colorsUpdated = true;\n            iterations++;\n        }\n        // Update the CSS variables if necessary\n        if (colorsUpdated) {\n            editorElem.style.setProperty(var1, color1.toHexString());\n            editorElem.style.setProperty(var2, color2.toHexString());\n            updatedColors[var1] = color1;\n            updatedColors[var2] = color2;\n        }\n    };\n    // Also adjust the selection background\n    adjustVariablesForContrast('--selection-background-color', '--background-color-2', 1.29, true, false);\n    for (const [backgroundVar, foregroundVar, updateBackground, updateForeground] of colorPairs) {\n        const minContrast = 4.5;\n        adjustVariablesForContrast(backgroundVar, foregroundVar, minContrast, updateBackground, updateForeground);\n    }\n};\nexports[\"default\"] = adjustEditorThemeForContrast;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/util/adjustEditorThemeForContrast.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/util/assertions.js":
/*!**********************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/util/assertions.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n// Note: Arrow functions cannot be used for type assertions. See\n// https://github.com/microsoft/TypeScript/issues/34523\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.assertUnreachable = assertUnreachable;\nexports.assertIsNumber = assertIsNumber;\nexports.assertIsArray = assertIsArray;\nexports.assertIsNumberArray = assertIsNumberArray;\nexports.assertIsBoolean = assertIsBoolean;\nexports.assertTruthy = assertTruthy;\nexports.assertIsObject = assertIsObject;\n/**\n * Compile-time assertion that a branch of code is unreachable.\n * @internal\n */\nfunction assertUnreachable(key) {\n    // See https://stackoverflow.com/a/39419171/17055750\n    throw new Error(`Should be unreachable. Key: ${key}.`);\n}\n/**\n * Throws an exception if the typeof given value is not a number or `value` is NaN.\n *\n * @example\n * ```ts\n * const foo: unknown = 3;\n * assertIsNumber(foo);\n *\n * assertIsNumber('hello, world'); // throws an Error.\n * ```\n */\nfunction assertIsNumber(value, allowNaN = false) {\n    if (typeof value !== 'number' || (!allowNaN && isNaN(value))) {\n        throw new Error('Given value is not a number');\n    }\n}\nfunction assertIsArray(values) {\n    if (!Array.isArray(values)) {\n        throw new Error('Asserting isArray: Given entity is not an array');\n    }\n}\n/**\n * Throws if any of `values` is not of type number.\n */\nfunction assertIsNumberArray(values, allowNaN = false) {\n    assertIsArray(values);\n    assertIsNumber(values.length);\n    for (const value of values) {\n        assertIsNumber(value, allowNaN);\n    }\n}\n/**\n * Throws an exception if `typeof value` is not a boolean.\n */\nfunction assertIsBoolean(value) {\n    if (typeof value !== 'boolean') {\n        throw new Error('Given value is not a boolean');\n    }\n}\nfunction assertTruthy(value) {\n    if (!value) {\n        throw new Error(`${JSON.stringify(value)} is not truthy`);\n    }\n}\nfunction assertIsObject(value) {\n    if (typeof value !== 'object') {\n        throw new Error(`AssertIsObject: Given entity is not an object (type = ${typeof value})`);\n    }\n}\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/util/assertions.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/util/bytesToSizeString.js":
/*!*****************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/util/bytesToSizeString.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * Returns a size in bytes, KiB, or MiB with units suffix.\n */\nconst bytesToSizeString = (sizeBytes) => {\n    const sizeInKiB = sizeBytes / 1024;\n    const sizeInMiB = sizeInKiB / 1024;\n    const sizeInGiB = sizeInMiB / 1024;\n    let units = 'B';\n    let size = sizeBytes;\n    if (sizeInGiB >= 1) {\n        size = sizeInGiB;\n        units = 'GiB';\n    }\n    else if (sizeInMiB >= 1) {\n        size = sizeInMiB;\n        units = 'MiB';\n    }\n    else if (sizeInKiB >= 1) {\n        size = sizeInKiB;\n        units = 'KiB';\n    }\n    return { size, units };\n};\nexports[\"default\"] = bytesToSizeString;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/util/bytesToSizeString.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/util/cloneElementWithStyles.js":
/*!**********************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/util/cloneElementWithStyles.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * Makes a clone of `element` and recursively applies styles from the original to the\n * clone's children.\n */\nconst cloneElementWithStyles = (element) => {\n    const restyle = (originalElement, clonedElement) => {\n        const originalComputedStyle = getComputedStyle(originalElement);\n        // jsdom doesn't support iterators in CSSStyleDeclarations. Iterate with\n        // an index.\n        for (let index = 0; index < originalComputedStyle.length; index++) {\n            const propertyName = originalComputedStyle.item(index);\n            const propertyValue = originalComputedStyle.getPropertyValue(propertyName);\n            clonedElement.style?.setProperty(propertyName, propertyValue);\n        }\n        for (let i = 0; i < originalElement.children.length; i++) {\n            const originalChild = originalElement.children.item(i);\n            const clonedChild = clonedElement.children.item(i);\n            if (originalChild && clonedChild) {\n                restyle(originalChild, clonedChild);\n            }\n            else {\n                console.warn('CloneElement: Missing child');\n            }\n        }\n    };\n    const elementClone = element.cloneNode(true);\n    restyle(element, elementClone);\n    return elementClone;\n};\nexports[\"default\"] = cloneElementWithStyles;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/util/cloneElementWithStyles.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/util/createElement.js":
/*!*************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/util/createElement.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createSvgPaths = exports.createSvgElements = exports.createSvgElement = exports.ElementNamespace = void 0;\nvar ElementNamespace;\n(function (ElementNamespace) {\n    ElementNamespace[\"Html\"] = \"html\";\n    ElementNamespace[\"Svg\"] = \"svg\";\n})(ElementNamespace || (exports.ElementNamespace = ElementNamespace = {}));\n/**\n * Shorthand for creating an element with `document.createElement`, then assigning properties.\n *\n * Non-HTML elements (e.g. `svg` elements) should use the `elementType` parameter to select\n * the element namespace.\n */\nconst createElement = (tag, props, elementType = ElementNamespace.Html) => {\n    let elem;\n    if (elementType === ElementNamespace.Html) {\n        elem = document.createElement(tag);\n    }\n    else if (elementType === ElementNamespace.Svg) {\n        elem = document.createElementNS('http://www.w3.org/2000/svg', tag);\n    }\n    else {\n        throw new Error(`Unknown element type ${elementType}`);\n    }\n    for (const [key, value] of Object.entries(props)) {\n        if (key === 'children')\n            continue;\n        if (typeof value !== 'string' && typeof value !== 'number') {\n            throw new Error(`Unsupported value type ${typeof value}`);\n        }\n        elem.setAttribute(key, value.toString());\n    }\n    if (props.children) {\n        for (const item of props.children) {\n            elem.appendChild(item);\n        }\n    }\n    return elem;\n};\nconst createSvgElement = (tag, props) => {\n    return createElement(tag, props, ElementNamespace.Svg);\n};\nexports.createSvgElement = createSvgElement;\nconst createSvgElements = (tag, elements) => {\n    return elements.map((props) => (0, exports.createSvgElement)(tag, props));\n};\nexports.createSvgElements = createSvgElements;\nconst createSvgPaths = (...paths) => {\n    return (0, exports.createSvgElements)('path', paths);\n};\nexports.createSvgPaths = createSvgPaths;\nexports[\"default\"] = createElement;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/util/createElement.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/util/fileToBase64Url.js":
/*!***************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/util/fileToBase64Url.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * Converts `file` to a base64 data URL.\n */\nconst fileToBase64Url = async (file, options = {}) => {\n    try {\n        const reader = new FileReader();\n        return await new Promise((resolve, reject) => {\n            reader.onload = () => resolve(reader.result);\n            reader.onerror = reject;\n            reader.onabort = reject;\n            reader.onprogress = (evt) => {\n                options.onprogress?.(evt);\n            };\n            reader.readAsDataURL(file);\n        });\n    }\n    catch (error) {\n        // Files can fail to load with a FileReader in some cases. For example,\n        // in iOS Lockdown mode, where FileReader is unavailable.\n        (options.onWarning ?? console.warn)('Unable to convert file to base64 with a FileReader: ', error);\n        const arrayBuffer = await file.arrayBuffer();\n        const array = new Uint8Array(arrayBuffer);\n        // step: must be divisible by 3 (3 bytes = 4 base64 numerals)\n        //       If too large, this will fail (String.fromCharCode accepts a limited\n        //       number of arguments).\n        const step = 30;\n        const result = [];\n        for (let i = 0; i < array.length; i += step) {\n            // btoa accepts only characters with byte value 0-255 (which can be created\n            // with String.fromCharCode)\n            const stringByteArray = String.fromCharCode(...array.slice(i, i + step));\n            result.push(btoa(stringByteArray));\n        }\n        return `data:${file.type ?? 'image/*'};base64,${result.join('')}`;\n    }\n};\nexports[\"default\"] = fileToBase64Url;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/util/fileToBase64Url.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/util/guessKeyCodeFromKey.js":
/*!*******************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/util/guessKeyCodeFromKey.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// See https://developer.mozilla.org/en-US/docs/Web/API/UI_Events/Keyboard_event_code_values for\n// more\nconst keyToKeyCode = {\n    Control: 'ControlLeft',\n    '=': 'Equal',\n    '-': 'Minus',\n    ';': 'Semicolon',\n    ' ': 'Space',\n};\n/**\n * Attempts to guess the .code value corresponding to the given key.\n *\n * Use this to facilitate testing.\n *\n * If no matching keycode is found, returns `key`.\n */\nconst guessKeyCodeFromKey = (key) => {\n    const upperKey = key.toUpperCase();\n    if ('A' <= upperKey && upperKey <= 'Z') {\n        return `Key${upperKey}`;\n    }\n    if ('0' <= key && key <= '9') {\n        return `Digit${key}`;\n    }\n    if (key in keyToKeyCode) {\n        return keyToKeyCode[key];\n    }\n    return key;\n};\nexports[\"default\"] = guessKeyCodeFromKey;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/util/guessKeyCodeFromKey.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/util/lib.js":
/*!***************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/util/lib.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MutableReactiveValue = exports.ReactiveValue = exports.adjustEditorThemeForContrast = void 0;\nvar adjustEditorThemeForContrast_1 = __webpack_require__(/*! ./adjustEditorThemeForContrast */ \"./node_modules/js-draw/dist/cjs/util/adjustEditorThemeForContrast.js\");\nObject.defineProperty(exports, \"adjustEditorThemeForContrast\", ({ enumerable: true, get: function () { return __importDefault(adjustEditorThemeForContrast_1).default; } }));\nvar ReactiveValue_1 = __webpack_require__(/*! ./ReactiveValue */ \"./node_modules/js-draw/dist/cjs/util/ReactiveValue.js\");\nObject.defineProperty(exports, \"ReactiveValue\", ({ enumerable: true, get: function () { return ReactiveValue_1.ReactiveValue; } }));\nObject.defineProperty(exports, \"MutableReactiveValue\", ({ enumerable: true, get: function () { return ReactiveValue_1.MutableReactiveValue; } }));\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/util/lib.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/util/listPrefixMatch.js":
/*!***************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/util/listPrefixMatch.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * Returns true iff all elements in the shorter list equal (===) the elements\n * in the longer list.\n */\nconst listPrefixMatch = (a, b) => {\n    const shorter = a.length < b.length ? a : b;\n    const longer = shorter === a ? b : a;\n    for (let i = 0; i < shorter.length; i++) {\n        if (shorter[i] !== longer[i]) {\n            return false;\n        }\n    }\n    return true;\n};\nexports[\"default\"] = listPrefixMatch;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/util/listPrefixMatch.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/util/listenForKeyboardEventsFrom.js":
/*!***************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/util/listenForKeyboardEventsFrom.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * Calls `callbacks` when different keys are known to be pressed.\n *\n * `filter` can be used to ignore events.\n *\n * This includes keys that didn't trigger a keydown or keyup event, but did cause\n * shiftKey/altKey/metaKey/etc. properties to change on other events (e.g. mousemove\n * events). Artifical events are created for these changes and sent to `callbacks`.\n */\nconst listenForKeyboardEventsFrom = (elem, callbacks) => {\n    // Track which keys are down so we can release them when the element\n    // loses focus. This is particularly important for keys like Control\n    // that can trigger shortcuts that cause the editor to lose focus before\n    // the keyup event is triggered.\n    let keysDown = [];\n    // Return whether two objects that are similar to keyboard events represent the\n    // same key.\n    const keyEventsMatch = (a, b) => {\n        return a.key === b.key && a.code === b.code;\n    };\n    const isKeyDown = (keyEvent) => {\n        return keysDown.some((other) => keyEventsMatch(other, keyEvent));\n    };\n    const keyEventToRecord = (event) => {\n        return {\n            code: event.code,\n            key: event.key,\n            ctrlKey: event.ctrlKey,\n            altKey: event.altKey,\n            shiftKey: event.shiftKey,\n            metaKey: event.metaKey,\n        };\n    };\n    const handleKeyEvent = (htmlEvent) => {\n        if (htmlEvent.type === 'keydown') {\n            // Add event to the list of keys that are down (so long as it\n            // isn't a duplicate).\n            if (!isKeyDown(htmlEvent)) {\n                // Destructructring, then pushing seems to cause\n                // data loss. Copy properties individually:\n                keysDown.push(keyEventToRecord(htmlEvent));\n            }\n            if (!callbacks.filter(htmlEvent)) {\n                return;\n            }\n            callbacks.handleKeyDown(htmlEvent);\n        }\n        else {\n            // keyup\n            console.assert(htmlEvent.type === 'keyup');\n            // Remove the key from keysDown -- it's no longer down.\n            keysDown = keysDown.filter((event) => {\n                const matches = keyEventsMatch(event, htmlEvent);\n                return !matches;\n            });\n            if (!callbacks.filter(htmlEvent)) {\n                return;\n            }\n            callbacks.handleKeyUp(htmlEvent);\n        }\n    };\n    elem.addEventListener('keydown', (htmlEvent) => {\n        handleKeyEvent(htmlEvent);\n    });\n    elem.addEventListener('keyup', (htmlEvent) => {\n        handleKeyEvent(htmlEvent);\n    });\n    elem.addEventListener('focusout', (focusEvent) => {\n        let stillHasFocus = false;\n        if (focusEvent.relatedTarget) {\n            const relatedTarget = focusEvent.relatedTarget;\n            stillHasFocus =\n                elem.contains(relatedTarget) || callbacks.getHandlesKeyEventsFrom(relatedTarget);\n        }\n        if (!stillHasFocus) {\n            for (const event of keysDown) {\n                callbacks.handleKeyUp(new KeyboardEvent('keyup', {\n                    ...event,\n                }));\n            }\n            keysDown = [];\n        }\n    });\n    const fireArtificalEventsBasedOn = (htmlEvent) => {\n        let wasShiftDown = false;\n        let wasCtrlDown = false;\n        let wasAltDown = false;\n        let wasMetaDown = false;\n        for (const otherEvent of keysDown) {\n            const code = otherEvent.code;\n            wasShiftDown ||= !!code.match(/^Shift(Left|Right)$/);\n            wasCtrlDown ||= !!code.match(/^Control(Left|Right)$/);\n            wasAltDown ||= !!code.match(/^Alt(Left|Right)$/);\n            wasMetaDown ||= !!code.match(/^Meta(Left|Right)$/);\n        }\n        const eventName = (isDown) => {\n            if (isDown) {\n                return 'keydown';\n            }\n            else {\n                return 'keyup';\n            }\n        };\n        const eventInitDefaults = {\n            shiftKey: htmlEvent.shiftKey,\n            altKey: htmlEvent.altKey,\n            metaKey: htmlEvent.metaKey,\n            ctrlKey: htmlEvent.ctrlKey,\n        };\n        if (htmlEvent.shiftKey !== wasShiftDown) {\n            handleKeyEvent(new KeyboardEvent(eventName(htmlEvent.shiftKey), {\n                ...eventInitDefaults,\n                key: 'Shift',\n                code: 'ShiftLeft',\n            }));\n        }\n        if (htmlEvent.altKey !== wasAltDown) {\n            handleKeyEvent(new KeyboardEvent(eventName(htmlEvent.altKey), {\n                ...eventInitDefaults,\n                key: 'Alt',\n                code: 'AltLeft',\n            }));\n        }\n        if (htmlEvent.ctrlKey !== wasCtrlDown) {\n            handleKeyEvent(new KeyboardEvent(eventName(htmlEvent.ctrlKey), {\n                ...eventInitDefaults,\n                key: 'Control',\n                code: 'ControlLeft',\n            }));\n        }\n        if (htmlEvent.metaKey !== wasMetaDown) {\n            handleKeyEvent(new KeyboardEvent(eventName(htmlEvent.metaKey), {\n                ...eventInitDefaults,\n                key: 'Meta',\n                code: 'MetaLeft',\n            }));\n        }\n    };\n    elem.addEventListener('mousedown', (htmlEvent) => {\n        fireArtificalEventsBasedOn(htmlEvent);\n    });\n    elem.addEventListener('mousemove', (htmlEvent) => {\n        fireArtificalEventsBasedOn(htmlEvent);\n    });\n};\nexports[\"default\"] = listenForKeyboardEventsFrom;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/util/listenForKeyboardEventsFrom.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/util/listenForLongPressOrHover.js":
/*!*************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/util/listenForLongPressOrHover.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * Calls `options.onStart` at the start of a long press or hover.\n * Calls `options.onEnd` when no pointers are within the container.\n */\nconst listenForLongPressOrHover = (target, options) => {\n    const pointersInside = new Map();\n    let timeoutId = null;\n    let isLongPressInProgress = false;\n    const updateTimeout = () => {\n        if (pointersInside.size === 0) {\n            if (isLongPressInProgress) {\n                isLongPressInProgress = false;\n                options.onEnd();\n            }\n            else if (timeoutId !== null) {\n                clearTimeout(timeoutId);\n                timeoutId = null;\n            }\n        }\n        else {\n            const nowTime = Date.now();\n            let timeSinceFirstPointer = 0; // ms\n            for (const record of pointersInside.values()) {\n                const timeSince = nowTime - record.timeEnter;\n                timeSinceFirstPointer = Math.max(timeSince, timeSinceFirstPointer);\n            }\n            const longPressTimeout = options.longPressTimeout ?? 700; // ms\n            if (timeoutId !== null) {\n                clearTimeout(timeoutId);\n                timeoutId = null;\n            }\n            const timeLeft = longPressTimeout - timeSinceFirstPointer;\n            if (timeLeft <= 0) {\n                options.onStart();\n                isLongPressInProgress = true;\n            }\n            else {\n                timeoutId = setTimeout(() => {\n                    timeoutId = null;\n                    updateTimeout();\n                }, timeLeft);\n            }\n        }\n    };\n    // Detects long press\n    const pointerEventListener = (event) => {\n        const eventRecord = {\n            timeEnter: Date.now(),\n        };\n        if (event.type === 'pointerenter') {\n            pointersInside.set(event.pointerId, eventRecord);\n        }\n        else if (event.type === 'pointerleave' || event.type === 'pointercancel') {\n            // In some cases (for example, a click with a stylus on Android/Chrome), moving the pen\n            // over the target, clicking, then moving the pen out of the target produces input\n            // similar to this:\n            // - pointerenter (pointerId: 4)\n            // - pointerleave (pointerId: 4)\n            // - pointerenter (pointerId: 6)\n            // - pointerenter (pointerId: 1)\n            // - pointerleave (pointerId: 6)\n            // Observe that no pointerleave event was fired for the pointer with ID 1.\n            pointersInside.clear();\n        }\n        updateTimeout();\n    };\n    target.addEventListener('pointerenter', pointerEventListener);\n    target.addEventListener('pointerleave', pointerEventListener);\n    target.addEventListener('pointercancel', pointerEventListener);\n    return {\n        removeListeners: () => {\n            target.removeEventListener('pointerenter', pointerEventListener);\n            target.removeEventListener('pointerleave', pointerEventListener);\n            target.removeEventListener('pointercancel', pointerEventListener);\n        },\n    };\n};\nexports[\"default\"] = listenForLongPressOrHover;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/util/listenForLongPressOrHover.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/util/mitLicenseAttribution.js":
/*!*********************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/util/mitLicenseAttribution.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst mitLicenseAttribution = (copyright) => {\n    const removeSingleLineBreaks = (text) => text.replace(/([^\\n])[\\n]([^\\n])/g, '$1 $2');\n    return removeSingleLineBreaks(`\nMIT License\n\nCopyright (c) ${copyright}\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.`);\n};\nexports[\"default\"] = mitLicenseAttribution;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/util/mitLicenseAttribution.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/util/stopPropagationOfScrollingWheelEvents.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/util/stopPropagationOfScrollingWheelEvents.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst stopPropagationOfScrollingWheelEvents = (scrollingContainer) => {\n    const scrollsAxis = (delta, clientSize, scrollOffset, scrollSize) => {\n        const hasScroll = clientSize !== scrollSize && delta !== 0;\n        const eventScrollsPastStart = scrollOffset + delta <= 0;\n        const scrollEnd = scrollOffset + clientSize;\n        const eventScrollsPastEnd = scrollEnd + delta > scrollSize;\n        return hasScroll && !eventScrollsPastStart && !eventScrollsPastEnd;\n    };\n    scrollingContainer.onwheel = (event) => {\n        const scrollsX = scrollsAxis(event.deltaX, scrollingContainer.clientWidth, scrollingContainer.scrollLeft, scrollingContainer.scrollWidth);\n        const scrollsY = scrollsAxis(event.deltaY, scrollingContainer.clientHeight, scrollingContainer.scrollTop, scrollingContainer.scrollHeight);\n        // Stop the editor from receiving the event if it will scroll the pen type selector\n        // instead.\n        if (scrollsX || scrollsY) {\n            event.stopPropagation();\n        }\n    };\n};\nexports[\"default\"] = stopPropagationOfScrollingWheelEvents;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/util/stopPropagationOfScrollingWheelEvents.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/util/untilNextAnimationFrame.js":
/*!***********************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/util/untilNextAnimationFrame.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/** @internal */\nconst untilNextAnimationFrame = () => {\n    return new Promise((resolve) => {\n        requestAnimationFrame(() => resolve());\n    });\n};\nexports[\"default\"] = untilNextAnimationFrame;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/util/untilNextAnimationFrame.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/util/waitForAll.js":
/*!**********************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/util/waitForAll.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * Resolves when all given promises have resolved. If no promises are given,\n * does not return a Promise.\n *\n * If all elements of `results` are known to be `Promise`s, use `Promise.all`.\n */\nconst waitForAll = (results) => {\n    // If any are Promises...\n    if (results.some((command) => command && command['then'])) {\n        // Wait for all commands to finish.\n        return (Promise.all(results)\n            // Ensure we return a Promise<void> and not a Promise<void[]>\n            .then(() => { }));\n    }\n    return;\n};\nexports[\"default\"] = waitForAll;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/util/waitForAll.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/util/waitForImageLoaded.js":
/*!******************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/util/waitForImageLoaded.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst waitForImageLoad = async (image) => {\n    if (!image.complete) {\n        await new Promise((resolve, reject) => {\n            image.onload = (event) => resolve(event);\n            // TODO(v2): Return a `new Error(event.message)`\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors -- Forwarding an error-like object.\n            image.onerror = (event) => reject(event);\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors -- Forwarding an error-like object.\n            image.onabort = (event) => reject(event);\n        });\n    }\n};\nexports[\"default\"] = waitForImageLoad;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/util/waitForImageLoaded.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/util/waitForTimeout.js":
/*!**************************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/util/waitForTimeout.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/** Returns a promise that resolves after `timeout` milliseconds. */\nconst waitForTimeout = (timeout) => {\n    return new Promise((resolve) => {\n        setTimeout(() => resolve(), timeout);\n    });\n};\nexports[\"default\"] = waitForTimeout;\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/util/waitForTimeout.js?");

/***/ }),

/***/ "./node_modules/js-draw/dist/cjs/version.js":
/*!**************************************************!*\
  !*** ./node_modules/js-draw/dist/cjs/version.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * Contains the current version of the library -- used\n * internaly (e.g. for documentation).\n * @internal\n */\nexports[\"default\"] = {\n    number: '1.26.0',\n};\n\n\n//# sourceURL=webpack://default/./node_modules/js-draw/dist/cjs/version.js?");

/***/ }),

/***/ "./src/dialog/webview/applyShortcutOverrides.ts":
/*!******************************************************!*\
  !*** ./src/dialog/webview/applyShortcutOverrides.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst js_draw_1 = __webpack_require__(/*! js-draw */ \"./node_modules/js-draw/dist/cjs/lib.js\");\nconst applyShortcutOverrides = (editor, shortcuts) => {\n    for (const id in shortcuts) {\n        try {\n            console.log('apply shortcut override', id, shortcuts[id]);\n            const keybindings = shortcuts[id].map((keybindingString) => js_draw_1.KeyBinding.fromString(keybindingString));\n            editor.shortcuts.overrideShortcut(id, keybindings);\n        }\n        catch (error) {\n            console.error('Invalid keybinding for id', id, '. Error: ', error);\n        }\n    }\n};\nexports[\"default\"] = applyShortcutOverrides;\n\n\n//# sourceURL=webpack://default/./src/dialog/webview/applyShortcutOverrides.ts?");

/***/ }),

/***/ "./src/dialog/webview/makeJsDrawEditor.ts":
/*!************************************************!*\
  !*** ./src/dialog/webview/makeJsDrawEditor.ts ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst material_icons_1 = __webpack_require__(/*! @js-draw/material-icons */ \"./node_modules/@js-draw/material-icons/dist/cjs/lib.js\");\nconst js_draw_1 = __webpack_require__(/*! js-draw */ \"./node_modules/js-draw/dist/cjs/lib.js\");\nconst loadTemplate_1 = __webpack_require__(/*! ./template/loadTemplate */ \"./src/dialog/webview/template/loadTemplate.ts\");\nconst setupToolbar_1 = __webpack_require__(/*! ./setupToolbar */ \"./src/dialog/webview/setupToolbar.ts\");\nconst saveStateAsTemplate_1 = __webpack_require__(/*! ./template/saveStateAsTemplate */ \"./src/dialog/webview/template/saveStateAsTemplate.ts\");\nconst applyShortcutOverrides_1 = __webpack_require__(/*! ./applyShortcutOverrides */ \"./src/dialog/webview/applyShortcutOverrides.ts\");\nconst makeJsDrawEditor = (settingControl, callbacks, \n// For testing (allows running with jsdom)\ndisableRenderer) => __awaiter(void 0, void 0, void 0, function* () {\n    const editor = new js_draw_1.default(document.body, {\n        iconProvider: new material_icons_1.default(),\n        // Disable the renderer to hide jsdom warnings when testing.\n        renderingMode: disableRenderer ? js_draw_1.RenderingMode.DummyRenderer : undefined,\n        image: {\n            showImagePicker: ({ setOnCancelCallback }) => __awaiter(void 0, void 0, void 0, function* () {\n                const imageTask = yield callbacks.showImagePicker();\n                setOnCancelCallback(() => {\n                    imageTask.cancel();\n                    imageTask.cleanUp();\n                });\n                const images = yield imageTask.images;\n                if (!images)\n                    return null;\n                const files = [];\n                for (const image of images) {\n                    const data = yield fetch(image.path);\n                    const buffer = yield data.arrayBuffer();\n                    files.push(new File([buffer], image.name, {\n                        type: image.mime,\n                    }));\n                }\n                imageTask.cleanUp();\n                return files;\n            }),\n        },\n    });\n    editor.focus();\n    yield (0, loadTemplate_1.default)(editor, settingControl);\n    // Zoom to the preview region (loadFromSVG, if called, will zoom to the new region)\n    const addToHistory = false;\n    yield editor.dispatchNoAnnounce(editor.viewport.zoomTo(editor.getImportExportRect()), addToHistory);\n    let prevStyle = null;\n    const applyStyle = (styleName) => {\n        const editorRoot = editor.getRootElement();\n        if (prevStyle) {\n            editorRoot.classList.remove(styleName);\n        }\n        editorRoot.classList.add(styleName);\n        prevStyle = styleName;\n        (0, js_draw_1.adjustEditorThemeForContrast)(editor);\n    };\n    let toolbarControl;\n    const saveDrawing = () => __awaiter(void 0, void 0, void 0, function* () {\n        (0, saveStateAsTemplate_1.default)(editor, settingControl);\n        callbacks.onSave();\n    });\n    const exitEditor = () => {\n        callbacks.onExit();\n    };\n    toolbarControl = (0, setupToolbar_1.default)(editor, {\n        onSavePress: saveDrawing,\n        onExitPress: exitEditor,\n    }, settingControl);\n    return {\n        editor,\n        applyStyle,\n        setToolbarMode: toolbarControl.setToolbarMode,\n        applyShortcutOverrides: (overrides) => {\n            (0, applyShortcutOverrides_1.default)(editor, overrides);\n        },\n        loadInitialImage: (svgData) => __awaiter(void 0, void 0, void 0, function* () {\n            toolbarControl.setLoading(true);\n            // Clear the background\n            const addToHistory = false;\n            yield editor.dispatchNoAnnounce(new js_draw_1.Erase(editor.image.getBackgroundComponents()), addToHistory);\n            yield editor.loadFromSVG(svgData);\n            toolbarControl.setLoading(false);\n            toolbarControl.setSaved();\n        }),\n        hasUnsavedChanges: () => toolbarControl.hasUnsavedChanges(),\n        onSaved: () => toolbarControl.setSaved(),\n    };\n});\nexports[\"default\"] = makeJsDrawEditor;\n\n\n//# sourceURL=webpack://default/./src/dialog/webview/makeJsDrawEditor.ts?");

/***/ }),

/***/ "./src/dialog/webview/screens/showCloseScreen.ts":
/*!*******************************************************!*\
  !*** ./src/dialog/webview/screens/showCloseScreen.ts ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst types_1 = __webpack_require__(/*! ../../../types */ \"./src/types.ts\");\nconst localization_1 = __webpack_require__(/*! ../../../localization */ \"./src/localization.ts\");\nconst showSaveScreen_1 = __webpack_require__(/*! ./showSaveScreen */ \"./src/dialog/webview/screens/showSaveScreen.ts\");\nconst showCloseScreen = (editorControl, postMessageCallback, addSaveCompletedListener) => {\n    if (!editorControl) {\n        return;\n    }\n    const editor = editorControl.editor;\n    postMessageCallback({\n        type: types_1.MessageType.ShowCloseButton,\n        isSaved: !editorControl.hasUnsavedChanges(),\n    });\n    editor.getRootElement().style.display = 'none';\n    const dialogContainer = document.createElement('div');\n    dialogContainer.classList.add('save-or-exit-dialog');\n    const hideExitScreen = () => __awaiter(void 0, void 0, void 0, function* () {\n        editor.getRootElement().style.display = '';\n        dialogContainer.remove();\n        yield postMessageCallback({ type: types_1.MessageType.HideButtons });\n    });\n    const message = document.createElement('div');\n    if (editorControl.hasUnsavedChanges()) {\n        dialogContainer.classList.add('has-unsaved-changes');\n        message.innerText = localization_1.default.discardUnsavedChanges;\n    }\n    else {\n        message.innerText = localization_1.default.exitInstructions;\n    }\n    const resumeEditingBtn = document.createElement('button');\n    resumeEditingBtn.innerText = localization_1.default.resumeEditing;\n    resumeEditingBtn.onclick = () => __awaiter(void 0, void 0, void 0, function* () {\n        yield hideExitScreen();\n        editor.focus();\n    });\n    const saveChangesButton = document.createElement('button');\n    saveChangesButton.innerText = localization_1.default.saveChanges;\n    saveChangesButton.classList.add('save-changes-button');\n    saveChangesButton.onclick = () => __awaiter(void 0, void 0, void 0, function* () {\n        yield hideExitScreen();\n        const saveCompletedListener = new Promise((resolve) => {\n            addSaveCompletedListener(() => resolve());\n        });\n        const saved = yield (0, showSaveScreen_1.default)(editorControl, postMessageCallback);\n        if (saved) {\n            yield saveCompletedListener;\n            showCloseScreen(editorControl, postMessageCallback, addSaveCompletedListener);\n        }\n    });\n    const buttonContainer = document.createElement('div');\n    buttonContainer.classList.add('button-container');\n    buttonContainer.replaceChildren(resumeEditingBtn, saveChangesButton);\n    dialogContainer.replaceChildren(message, buttonContainer);\n    document.body.appendChild(dialogContainer);\n    saveChangesButton.focus();\n};\nexports[\"default\"] = showCloseScreen;\n\n\n//# sourceURL=webpack://default/./src/dialog/webview/screens/showCloseScreen.ts?");

/***/ }),

/***/ "./src/dialog/webview/screens/showSaveScreen.ts":
/*!******************************************************!*\
  !*** ./src/dialog/webview/screens/showSaveScreen.ts ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n// Returns false if save screen is shown, true if saved\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst types_1 = __webpack_require__(/*! ../../../types */ \"./src/types.ts\");\nconst localization_1 = __webpack_require__(/*! ../../../localization */ \"./src/localization.ts\");\nconst svgElementToString_1 = __webpack_require__(/*! ../svgElementToString */ \"./src/dialog/webview/svgElementToString.ts\");\n// without the need for a screen.\nconst showSaveScreen = (editorControl, postMessageCallback) => __awaiter(void 0, void 0, void 0, function* () {\n    if (!editorControl) {\n        return;\n    }\n    const editor = editorControl.editor;\n    const saveMessage = {\n        type: types_1.MessageType.SaveSVG,\n        data: (0, svgElementToString_1.default)(editor.toSVG()),\n    };\n    const response = yield postMessageCallback(Object.assign({}, saveMessage));\n    if (response !== true && response.type === types_1.ResponseType.SaveResponse) {\n        // If already saved, exit!\n        if (!response.waitingForSaveType) {\n            return true;\n        }\n    }\n    else {\n        throw new Error('Invalid response ' + response);\n    }\n    editor.getRootElement().style.display = 'none';\n    const dialogContainer = document.createElement('form');\n    dialogContainer.className = 'save-or-exit-dialog';\n    dialogContainer.name = 'saveOptions';\n    const hideSaveScreen = () => __awaiter(void 0, void 0, void 0, function* () {\n        editor.getRootElement().style.display = '';\n        dialogContainer.remove();\n        yield postMessageCallback({ type: types_1.MessageType.HideButtons });\n    });\n    const resumeEditingButton = document.createElement('button');\n    resumeEditingButton.innerText = localization_1.default.saveAndResumeEditing;\n    resumeEditingButton.onclick = () => __awaiter(void 0, void 0, void 0, function* () {\n        yield hideSaveScreen();\n        yield postMessageCallback(Object.assign({}, saveMessage));\n        editor.focus();\n    });\n    const saveOptionsContainer = document.createElement('div');\n    let idCounter = 0;\n    const addSaveOption = (label, value, checked = false) => {\n        const saveOptionRow = document.createElement('div');\n        const labelElem = document.createElement('label');\n        const inputElem = document.createElement('input');\n        inputElem.name = 'saveOption';\n        inputElem.value = value;\n        inputElem.type = 'radio';\n        inputElem.id = `saveOption-${idCounter++}`;\n        labelElem.setAttribute('for', inputElem.id);\n        inputElem.checked = checked;\n        labelElem.innerText = label;\n        saveOptionRow.replaceChildren(inputElem, labelElem);\n        saveOptionsContainer.appendChild(saveOptionRow);\n        const onUpdate = () => __awaiter(void 0, void 0, void 0, function* () {\n            if (inputElem.checked) {\n                yield postMessageCallback({\n                    type: types_1.MessageType.SetSaveMethod,\n                    method: value,\n                });\n            }\n        });\n        onUpdate();\n        inputElem.oninput = onUpdate;\n    };\n    addSaveOption(localization_1.default.overwriteExisting, types_1.SaveMethod.Overwrite, true);\n    addSaveOption(localization_1.default.saveAsNewDrawing, types_1.SaveMethod.SaveAsNew);\n    const messageElem = document.createElement('div');\n    messageElem.innerText = localization_1.default.clickBelowToContinue;\n    const buttonContainer = document.createElement('div');\n    buttonContainer.classList.add('button-container');\n    buttonContainer.replaceChildren(resumeEditingButton);\n    dialogContainer.replaceChildren(messageElem, saveOptionsContainer, buttonContainer);\n    document.body.appendChild(dialogContainer);\n    return false;\n});\nexports[\"default\"] = showSaveScreen;\n\n\n//# sourceURL=webpack://default/./src/dialog/webview/screens/showSaveScreen.ts?");

/***/ }),

/***/ "./src/dialog/webview/settings/localStorageSettingControl.ts":
/*!*******************************************************************!*\
  !*** ./src/dialog/webview/settings/localStorageSettingControl.ts ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst localStorageSettingControl = {\n    updateSetting(key, value) {\n        localStorage.setItem(key, value);\n    },\n    getSetting(key) {\n        return localStorage.getItem(key);\n    },\n};\nexports[\"default\"] = localStorageSettingControl;\n\n\n//# sourceURL=webpack://default/./src/dialog/webview/settings/localStorageSettingControl.ts?");

/***/ }),

/***/ "./src/dialog/webview/setupToolbar.ts":
/*!********************************************!*\
  !*** ./src/dialog/webview/setupToolbar.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst js_draw_1 = __webpack_require__(/*! js-draw */ \"./node_modules/js-draw/dist/cjs/lib.js\");\nconst types_1 = __webpack_require__(/*! ../../types */ \"./src/types.ts\");\n// Initial toolbar setup\nconst setupToolbar = (editor, callbacks, settings) => {\n    let toolbar = null;\n    let saveButton;\n    let isSaveUpToDate = false;\n    let isLoading = false;\n    const updateSaveButtonDisabled = () => {\n        saveButton.setDisabled(isSaveUpToDate || isLoading);\n    };\n    const toolbarStateKey = 'jsdraw-toolbarState';\n    editor.notifier.on(js_draw_1.EditorEventType.ToolUpdated, () => {\n        if (toolbar) {\n            settings.updateSetting(toolbarStateKey, toolbar.serializeState());\n        }\n    });\n    let lastKind = null;\n    const changeToolbarType = (kind) => {\n        if (kind === lastKind) {\n            return;\n        }\n        lastKind = kind;\n        // Clean up the previous toolbar (if any).\n        toolbar === null || toolbar === void 0 ? void 0 : toolbar.remove();\n        const isEdgeToolbar = kind === types_1.ToolbarType.Default || kind === types_1.ToolbarType.Sidebar;\n        toolbar = isEdgeToolbar ? (0, js_draw_1.makeEdgeToolbar)(editor) : (0, js_draw_1.makeDropdownToolbar)(editor);\n        toolbar.addDefaults();\n        toolbar.addSpacer({ grow: 1, maxSize: '15px' });\n        toolbar.addExitButton(callbacks.onExitPress);\n        toolbar.addSpacer({ grow: 1, maxSize: '15px' });\n        saveButton = toolbar.addSaveButton(callbacks.onSavePress);\n        // Load initial toolbar state (e.g pen color/size)\n        try {\n            const toolbarState = settings.getSetting(toolbarStateKey);\n            if (toolbarState) {\n                toolbar.deserializeState(toolbarState);\n            }\n        }\n        catch (e) {\n            console.warn('Error restoring toolbar state!', e);\n        }\n        updateSaveButtonDisabled();\n    };\n    changeToolbarType(types_1.ToolbarType.Default);\n    editor.notifier.on(js_draw_1.EditorEventType.UndoRedoStackUpdated, () => {\n        isSaveUpToDate = false;\n        updateSaveButtonDisabled();\n    });\n    return {\n        setToolbarMode: changeToolbarType,\n        setSaved: () => {\n            isSaveUpToDate = true;\n            updateSaveButtonDisabled();\n        },\n        setLoading: (loading) => {\n            isLoading = loading;\n            updateSaveButtonDisabled();\n        },\n        hasUnsavedChanges: () => !isSaveUpToDate,\n    };\n};\nexports[\"default\"] = setupToolbar;\n\n\n//# sourceURL=webpack://default/./src/dialog/webview/setupToolbar.ts?");

/***/ }),

/***/ "./src/dialog/webview/startAutosaveLoop.ts":
/*!*************************************************!*\
  !*** ./src/dialog/webview/startAutosaveLoop.ts ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst types_1 = __webpack_require__(/*! ../../types */ \"./src/types.ts\");\nconst svgElementToString_1 = __webpack_require__(/*! ./svgElementToString */ \"./src/dialog/webview/svgElementToString.ts\");\nconst startAutosaveLoop = (editor, delayBetweenInMS, postMessage) => __awaiter(void 0, void 0, void 0, function* () {\n    while (true) {\n        yield new Promise((resolve) => {\n            setTimeout(resolve, delayBetweenInMS);\n        });\n        const savedImage = yield editor.toSVGAsync();\n        yield postMessage({\n            type: types_1.MessageType.AutosaveSVG,\n            data: (0, svgElementToString_1.default)(savedImage),\n        });\n    }\n});\nexports[\"default\"] = startAutosaveLoop;\n\n\n//# sourceURL=webpack://default/./src/dialog/webview/startAutosaveLoop.ts?");

/***/ }),

/***/ "./src/dialog/webview/svgElementToString.ts":
/*!**************************************************!*\
  !*** ./src/dialog/webview/svgElementToString.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst htmlUtil_1 = __webpack_require__(/*! ../../util/htmlUtil */ \"./src/util/htmlUtil.ts\");\nconst svgElementToString = (element) => {\n    // diagrams.io has special requirements for arguments encoding.\n    // Generate the container element with custom code:\n    const svgText = ['<svg'];\n    for (const attr of element.getAttributeNames()) {\n        svgText.push(` ${attr}=\"${(0, htmlUtil_1.escapeHtml)(element.getAttribute(attr))}\"`);\n    }\n    svgText.push('>');\n    svgText.push(element.innerHTML);\n    svgText.push('</svg>');\n    return svgText.join('');\n};\nexports[\"default\"] = svgElementToString;\n\n\n//# sourceURL=webpack://default/./src/dialog/webview/svgElementToString.ts?");

/***/ }),

/***/ "./src/dialog/webview/template/constants.ts":
/*!**************************************************!*\
  !*** ./src/dialog/webview/template/constants.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.defaultTemplate = exports.templateKey = void 0;\nconst js_draw_1 = __webpack_require__(/*! js-draw */ \"./node_modules/js-draw/dist/cjs/lib.js\");\nexports.templateKey = 'jsdraw-image-template';\nexports.defaultTemplate = {\n    imageSize: [500, 500],\n    autoresize: true,\n    backgroundData: {\n        name: 'image-background',\n        zIndex: 0,\n        data: {\n            mainColor: '#ffffff',\n            backgroundType: js_draw_1.BackgroundComponentBackgroundType.SolidColor,\n        },\n    },\n};\n\n\n//# sourceURL=webpack://default/./src/dialog/webview/template/constants.ts?");

/***/ }),

/***/ "./src/dialog/webview/template/loadTemplate.ts":
/*!*****************************************************!*\
  !*** ./src/dialog/webview/template/loadTemplate.ts ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst js_draw_1 = __webpack_require__(/*! js-draw */ \"./node_modules/js-draw/dist/cjs/lib.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"./src/dialog/webview/template/constants.ts\");\n// Initialize the editor's state from the template stored in localStorage.\n// This must be done in a way that can be overwritten by editor.loadFrom.\nconst loadTemplate = (editor, settings) => __awaiter(void 0, void 0, void 0, function* () {\n    try {\n        const savedTemplateString = settings.getSetting(constants_1.templateKey);\n        const data = savedTemplateString ? JSON.parse(savedTemplateString) : constants_1.defaultTemplate;\n        if ('imageSize' in data &&\n            typeof data['imageSize'][0] === 'number' &&\n            typeof data['imageSize'][1] === 'number' &&\n            isFinite(data['imageSize'][0]) &&\n            isFinite(data['imageSize'][1])) {\n            let width = data.imageSize[0];\n            let height = data.imageSize[1];\n            // Don't allow the template to create extremely small or extremely large images.\n            const minDimension = 50;\n            const maxDimension = 5000;\n            width = Math.min(maxDimension, Math.max(minDimension, width));\n            height = Math.min(maxDimension, Math.max(minDimension, height));\n            const imageSize = js_draw_1.Vec2.of(width, height);\n            const importExportRect = new js_draw_1.Rect2(0, 0, imageSize.x, imageSize.y);\n            const addToHistory = false;\n            yield editor.dispatchNoAnnounce(editor.setImportExportRect(importExportRect), addToHistory);\n        }\n        if ('backgroundData' in data) {\n            const background = js_draw_1.AbstractComponent.deserialize(data.backgroundData);\n            const addToHistory = false;\n            yield editor.dispatchNoAnnounce(editor.image.addElement(background), addToHistory);\n        }\n        if ('autoresize' in data && typeof data.autoresize === 'boolean') {\n            yield editor.dispatchNoAnnounce(editor.image.setAutoresizeEnabled(data.autoresize), false);\n        }\n    }\n    catch (e) {\n        console.warn('Error initializing js-draw from template: ', e);\n    }\n});\nexports[\"default\"] = loadTemplate;\n\n\n//# sourceURL=webpack://default/./src/dialog/webview/template/loadTemplate.ts?");

/***/ }),

/***/ "./src/dialog/webview/template/saveStateAsTemplate.ts":
/*!************************************************************!*\
  !*** ./src/dialog/webview/template/saveStateAsTemplate.ts ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst js_draw_1 = __webpack_require__(/*! js-draw */ \"./node_modules/js-draw/dist/cjs/lib.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"./src/dialog/webview/template/constants.ts\");\n// Update the template for new images based on the current state of the editor\nconst saveStateAsTemplate = (editor, settings) => {\n    // Find the topmost background component.\n    let topmostBackgroundComponent = null;\n    for (const elem of editor.image.getBackgroundComponents()) {\n        if (elem instanceof js_draw_1.BackgroundComponent) {\n            topmostBackgroundComponent = elem;\n        }\n    }\n    let editorBackgroundData = {};\n    if (topmostBackgroundComponent) {\n        editorBackgroundData = topmostBackgroundComponent.serialize();\n    }\n    const imageSize = editor.getImportExportRect().size;\n    const template = JSON.stringify({\n        backgroundData: editorBackgroundData,\n        imageSize: [imageSize.x, imageSize.y],\n        autoresize: editor.image.getAutoresizeEnabled(),\n    });\n    settings.updateSetting(constants_1.templateKey, template);\n};\nexports[\"default\"] = saveStateAsTemplate;\n\n\n//# sourceURL=webpack://default/./src/dialog/webview/template/saveStateAsTemplate.ts?");

/***/ }),

/***/ "./src/dialog/webview/webview.ts":
/*!***************************************!*\
  !*** ./src/dialog/webview/webview.ts ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__webpack_require__(/*! js-draw/bundledStyles */ \"./node_modules/js-draw/dist/bundledStyles.js\");\nconst types_1 = __webpack_require__(/*! ../../types */ \"./src/types.ts\");\nconst startAutosaveLoop_1 = __webpack_require__(/*! ./startAutosaveLoop */ \"./src/dialog/webview/startAutosaveLoop.ts\");\nconst makeJsDrawEditor_1 = __webpack_require__(/*! ./makeJsDrawEditor */ \"./src/dialog/webview/makeJsDrawEditor.ts\");\nconst localStorageSettingControl_1 = __webpack_require__(/*! ./settings/localStorageSettingControl */ \"./src/dialog/webview/settings/localStorageSettingControl.ts\");\nconst showSaveScreen_1 = __webpack_require__(/*! ./screens/showSaveScreen */ \"./src/dialog/webview/screens/showSaveScreen.ts\");\nconst showCloseScreen_1 = __webpack_require__(/*! ./screens/showCloseScreen */ \"./src/dialog/webview/screens/showCloseScreen.ts\");\nconst postMessageCallback = (message) => webviewApi.postMessage(message);\nlet haveLoadedFromSvg = false;\nlet saveCompletedListeners = [];\nlet editorControl = null;\nlet editorInitializationData = null;\nconst initializeEditor = (editorControl, initializationData) => {\n    editorControl.setToolbarMode(initializationData.toolbarType);\n    editorControl.applyStyle(initializationData.styleMode);\n    editorControl.applyShortcutOverrides(initializationData.keyboardShortcuts);\n    // If given initial data,\n    if (initializationData.initialData) {\n        // We did load from an SVG\n        haveLoadedFromSvg = true;\n        editorControl.loadInitialImage(initializationData.initialData);\n    }\n    // Set the autosave interval\n    (0, startAutosaveLoop_1.default)(editorControl.editor, initializationData.autosaveIntervalMS, (message) => webviewApi.postMessage(message));\n};\nconst addSaveCompletedListener = (listener) => {\n    saveCompletedListeners.push(listener);\n};\nconst showImagePicker = () => __awaiter(void 0, void 0, void 0, function* () {\n    const response = yield webviewApi.postMessage({ type: types_1.MessageType.ShowImagePicker });\n    if (typeof response !== 'object' || response.type !== types_1.ResponseType.ImagePickerTaskResponse) {\n        throw new Error(`Invalid response or type ${response}`);\n    }\n    const images = (() => __awaiter(void 0, void 0, void 0, function* () {\n        const imagePickerResponse = yield webviewApi.postMessage({\n            type: types_1.MessageType.GetImagePickerResult,\n            taskId: response.taskId,\n        });\n        if (typeof imagePickerResponse !== 'object' ||\n            imagePickerResponse.type !== types_1.ResponseType.ImagePickerResponse) {\n            throw new Error(`Invalid response or type ${imagePickerResponse}`);\n        }\n        return imagePickerResponse.images;\n    }))();\n    return {\n        images,\n        cancel: () => {\n            webviewApi.postMessage({ type: types_1.MessageType.CancelImagePicker, taskId: response.taskId });\n        },\n        cleanUp: () => {\n            webviewApi.postMessage({\n                type: types_1.MessageType.CleanUpImagePickerResult,\n                taskId: response.taskId,\n            });\n        },\n    };\n});\nvoid (() => __awaiter(void 0, void 0, void 0, function* () {\n    editorControl = yield (0, makeJsDrawEditor_1.default)(localStorageSettingControl_1.default, {\n        onSave: () => (0, showSaveScreen_1.default)(editorControl, postMessageCallback),\n        onExit: () => (0, showCloseScreen_1.default)(editorControl, postMessageCallback, addSaveCompletedListener),\n        showImagePicker,\n    });\n    if (editorInitializationData) {\n        initializeEditor(editorControl, editorInitializationData);\n    }\n}))();\nwebviewApi.onMessage(({ message }) => __awaiter(void 0, void 0, void 0, function* () {\n    if (message.type === types_1.MessageType.SaveCompleted) {\n        editorControl === null || editorControl === void 0 ? void 0 : editorControl.onSaved();\n        // After saving as a new drawing once, we should update the new\n        // drawing.\n        webviewApi.postMessage({\n            type: types_1.MessageType.SetSaveMethod,\n            method: types_1.SaveMethod.Overwrite,\n        });\n        for (const listener of saveCompletedListeners) {\n            listener();\n        }\n        saveCompletedListeners = [];\n        return true;\n    }\n    else {\n        console.log('unknown message', message);\n        throw new Error(`Unknown message: ${message}`);\n    }\n}));\n// Get initial data and app settings\nconst loadedMessage = {\n    type: types_1.MessageType.GetInitialData,\n};\nwebviewApi.postMessage(loadedMessage).then((result) => __awaiter(void 0, void 0, void 0, function* () {\n    if (result !== true && result.type === types_1.ResponseType.InitialDataResponse && !haveLoadedFromSvg) {\n        if (editorControl) {\n            initializeEditor(editorControl, result);\n        }\n        else {\n            editorInitializationData = result;\n        }\n    }\n}));\n\n\n//# sourceURL=webpack://default/./src/dialog/webview/webview.ts?");

/***/ }),

/***/ "./src/localization.ts":
/*!*****************************!*\
  !*** ./src/localization.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst defaultStrings = {\n    insertDrawing: 'Insert Drawing',\n    insertDrawingInNewWindow: 'Insert drawing in new window',\n    restoreFromAutosave: 'Restore from autosaved drawing',\n    deleteAutosave: 'Delete all autosaved drawings',\n    noSuchAutosaveExists: 'No autosave exists',\n    discardChanges: 'Discard changes',\n    defaultImageTitle: 'Freehand Drawing',\n    edit: 'Edit',\n    close: 'Close',\n    saveAndClose: 'Save and close',\n    overwriteExisting: 'Overwrite existing',\n    saveAsNewDrawing: 'Save as a new drawing',\n    clickBelowToContinue: 'Done! Click below to continue.',\n    discardUnsavedChanges: 'Discard unsaved changes?',\n    resumeEditing: 'Resume editing',\n    saveAndResumeEditing: 'Save and resume editing',\n    saveChanges: 'Save changes',\n    exitInstructions: 'All changes saved! Click below to exit.',\n    settingsPaneDescription: 'Settings for the Freehand Drawing image editor.',\n    setting__disableFullScreen: 'Dialog mode',\n    setting__disableFullScreenDescription: 'Enabling this setting causes the editor to only partially fill the Joplin window.',\n    setting__autosaveIntervalSettingLabel: 'Autosave interval (minutes)',\n    setting__autosaveIntervalSettingDescription: 'Adjusts how often a backup copy of the current drawing is created. The most recent autosave can be restored by searching for \":restore autosave\" in the command palette (ctrl+shift+p or cmd+shift+p on MacOS) and clicking \"Restore from autosaved drawing\". If this setting is set to zero, autosaves are created every two minutes.',\n    setting__themeLabel: 'Theme',\n    setting__toolbarTypeLabel: 'Toolbar type',\n    setting__toolbarTypeDescription: 'This setting switches between possible toolbar user interfaces for the image editor.',\n    setting__keyboardShortcuts: 'Keyboard shortcuts',\n    toolbarTypeDefault: 'Default',\n    toolbarTypeSidebar: 'Sidebar',\n    toolbarTypeDropdown: 'Dropdown',\n    styleMatchJoplin: 'Match Joplin',\n    styleJsDrawLight: 'Light',\n    styleJsDrawDark: 'Dark',\n    images: 'Images',\n    pdfs: 'PDFs',\n    allFiles: 'All Files',\n    loadLargePdf: (pageCount) => `A selected file is a large PDF (${pageCount} pages). Loading it may take some time and increase the size of the current drawing. Continue?`,\n    notAnEditableImage: (resourceId, resourceType) => `Resource ${resourceId} is not an editable image. Unable to edit resource of type ${resourceType}.`,\n};\nconst localizations = {\n    de: Object.assign(Object.assign({}, defaultStrings), { insertDrawing: 'Zeichnung einfügen', restoreFromAutosave: 'Automatische Sicherung wiederherstellen', deleteAutosave: 'Alle automatischen Sicherungen löschen', noSuchAutosaveExists: 'Keine automatischen Sicherungen vorhanden', discardChanges: 'Änderungen verwerfen', defaultImageTitle: 'Freihand-Zeichnen', edit: 'Bearbeiten', close: 'Schließen', overwriteExisting: 'Existierende Zeichnung überschreiben', saveAsNewDrawing: 'Als neue Zeichnung speichern', clickBelowToContinue: 'Fertig! Klicke auf „Ok“ um fortzufahen.', discardUnsavedChanges: 'Ungespeicherte Änderungen verwerfen?', resumeEditing: 'Bearbeiten fortfahren', notAnEditableImage: (resourceId, resourceType) => `Die Ressource ${resourceId} ist kein bearbeitbares Bild. Ressource vom Typ ${resourceType} kann nicht bearbeitet werden.` }),\n    en: defaultStrings,\n    es: Object.assign(Object.assign({}, defaultStrings), { insertDrawing: 'Añada dibujo', restoreFromAutosave: 'Resturar al autoguardado', deleteAutosave: 'Borrar el autoguardado', noSuchAutosaveExists: 'No autoguardado existe', discardChanges: 'Descartar cambios', defaultImageTitle: 'Dibujo', edit: 'Editar', close: 'Cerrar', saveAndClose: 'Guardar y cerrar', overwriteExisting: 'Sobrescribir existente', saveAsNewDrawing: 'Guardar como dibujo nuevo', clickBelowToContinue: 'Guardado. Ponga «ok» para continuar.', discardUnsavedChanges: '¿Descartar cambios no guardados?', resumeEditing: 'Continuar editando', saveAndResumeEditing: 'Guardar y continuar editando' }),\n};\nlet localization;\nconst languages = [...navigator.languages];\nfor (const language of navigator.languages) {\n    const localeSep = language.indexOf('-');\n    if (localeSep !== -1) {\n        languages.push(language.substring(0, localeSep));\n    }\n}\nfor (const locale of languages) {\n    if (locale in localizations) {\n        localization = localizations[locale];\n        break;\n    }\n}\nif (!localization) {\n    console.log('No supported localization found. Falling back to default.');\n    localization = defaultStrings;\n}\nexports[\"default\"] = localization;\n\n\n//# sourceURL=webpack://default/./src/localization.ts?");

/***/ }),

/***/ "./src/types.ts":
/*!**********************!*\
  !*** ./src/types.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EditorStyle = exports.ToolbarType = exports.ResponseType = exports.SaveMethod = exports.MessageType = void 0;\nvar MessageType;\n(function (MessageType) {\n    MessageType[\"GetInitialData\"] = \"getInitialData\";\n    MessageType[\"SaveSVG\"] = \"saveSVG\";\n    MessageType[\"SaveCompleted\"] = \"saveCompleted\";\n    MessageType[\"AutosaveSVG\"] = \"autosaveSVG\";\n    MessageType[\"SetSaveMethod\"] = \"setSaveMethod\";\n    MessageType[\"ResumeEditing\"] = \"resumeEditing\";\n    MessageType[\"ShowSaveAndCloseButton\"] = \"showSaveAndCloseButton\";\n    MessageType[\"ShowCloseButton\"] = \"showCloseButton\";\n    MessageType[\"HideButtons\"] = \"removeButtons\";\n    MessageType[\"ShowImagePicker\"] = \"showImagePicker\";\n    MessageType[\"GetImagePickerResult\"] = \"getImagePicker\";\n    MessageType[\"CancelImagePicker\"] = \"cancelImagePicker\";\n    MessageType[\"CleanUpImagePickerResult\"] = \"cleanUpImagePicker\";\n})(MessageType || (exports.MessageType = MessageType = {}));\nvar SaveMethod;\n(function (SaveMethod) {\n    SaveMethod[\"SaveAsNew\"] = \"saveAsNew\";\n    SaveMethod[\"Overwrite\"] = \"overwrite\";\n})(SaveMethod || (exports.SaveMethod = SaveMethod = {}));\nvar ResponseType;\n(function (ResponseType) {\n    ResponseType[\"InitialDataResponse\"] = \"initialDataResponse\";\n    ResponseType[\"SaveResponse\"] = \"saveResponse\";\n    ResponseType[\"ImagePickerTaskResponse\"] = \"imagePickerStartedResponse\";\n    ResponseType[\"ImagePickerResponse\"] = \"imagePickerResponse\";\n})(ResponseType || (exports.ResponseType = ResponseType = {}));\nvar ToolbarType;\n(function (ToolbarType) {\n    ToolbarType[ToolbarType[\"Default\"] = 0] = \"Default\";\n    ToolbarType[ToolbarType[\"Sidebar\"] = 1] = \"Sidebar\";\n    ToolbarType[ToolbarType[\"Dropdown\"] = 2] = \"Dropdown\";\n})(ToolbarType || (exports.ToolbarType = ToolbarType = {}));\nvar EditorStyle;\n(function (EditorStyle) {\n    EditorStyle[\"MatchJoplin\"] = \"match-joplin-theme\";\n    EditorStyle[\"JsDrawLight\"] = \"js-draw-default-light\";\n    EditorStyle[\"JsDrawDark\"] = \"js-draw-default-dark\";\n})(EditorStyle || (exports.EditorStyle = EditorStyle = {}));\n\n\n//# sourceURL=webpack://default/./src/types.ts?");

/***/ }),

/***/ "./src/util/htmlUtil.ts":
/*!******************************!*\
  !*** ./src/util/htmlUtil.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.escapeHtml = void 0;\nconst escapeHtml = (html) => {\n    // Reference: https://stackoverflow.com/questions/7381974/which-characters-need-to-be-escaped-in-html\n    return html\n        .replace(/[&]/g, '&amp;')\n        .replace(/[<]/g, '&lt;')\n        .replace(/[>]/g, '&gt;')\n        .replace(/[\"]/g, '&quot;')\n        .replace(/[']/g, '&#39;');\n};\nexports.escapeHtml = escapeHtml;\n\n\n//# sourceURL=webpack://default/./src/util/htmlUtil.ts?");

/***/ }),

/***/ "./node_modules/@melloware/coloris/dist/umd/coloris.js":
/*!*************************************************************!*\
  !*** ./node_modules/@melloware/coloris/dist/umd/coloris.js ***!
  \*************************************************************/
/***/ ((module, exports) => {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // https://github.com/umdjs/umd/blob/master/templates/returnExports.js\n\n// Uses Node, AMD or browser globals to create a module.\n\n// If you want something that will work in other stricter CommonJS environments,\n// or if you need to create a circular dependency, see commonJsStrict.js\n\n// Defines a module \"returnExports\" that depends another module called \"b\".\n// Note that the name of the module is implied by the file name. It is best\n// if the file name and the exported global have matching names.\n\n// If the 'b' module also uses this type of boilerplate, then\n// in the browser, it will create a global .b that is used below.\n\n// If you do not want to support the browser global path, then you\n// can remove the `root` use and the passing `this` as the first arg to\n// the top function.\n\n// if the module has no dependencies, the above pattern can be simplified to\n(function (root, factory) {\n  if (true) {\n    // AMD. Register as an unnamed module.\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else\n  {}\n})(typeof self !== 'undefined' ? self : void 0, function () {\n  // Just return a value to define the module export.\n  // This example returns an object, but the module\n  // can return a function as the exported value.\n  /*!\r\n  * Copyright (c) 2021-2023 Momo Bassit.\r\n  * Licensed under the MIT License (MIT)\r\n  * https://github.com/mdbassit/Coloris\r\n  * Version: 0.21.1\r\n  * NPM: https://github.com/melloware/coloris-npm\r\n  */\n\n  return ((window, document, Math, undefined) => {\n    const ctx = document.createElement('canvas').getContext('2d');\n    const currentColor = { r: 0, g: 0, b: 0, h: 0, s: 0, v: 0, a: 1 };\n    let container,picker,colorArea,colorMarker,colorPreview,colorValue,clearButton,closeButton,\n      hueSlider,hueMarker,alphaSlider,alphaMarker,currentEl,currentFormat,oldColor,keyboardNav,\n      colorAreaDims = {};\n\n    // Default settings\n    const settings = {\n      el: '[data-coloris]',\n      parent: 'body',\n      theme: 'default',\n      themeMode: 'light',\n      rtl: false,\n      wrap: true,\n      margin: 2,\n      format: 'hex',\n      formatToggle: false,\n      swatches: [],\n      swatchesOnly: false,\n      alpha: true,\n      forceAlpha: false,\n      focusInput: true,\n      selectInput: false,\n      inline: false,\n      defaultColor: '#000000',\n      clearButton: false,\n      clearLabel: 'Clear',\n      closeButton: false,\n      closeLabel: 'Close',\n      onChange: () => undefined,\n      a11y: {\n        open: 'Open color picker',\n        close: 'Close color picker',\n        clear: 'Clear the selected color',\n        marker: 'Saturation: {s}. Brightness: {v}.',\n        hueSlider: 'Hue slider',\n        alphaSlider: 'Opacity slider',\n        input: 'Color value field',\n        format: 'Color format',\n        swatch: 'Color swatch',\n        instruction: 'Saturation and brightness selector. Use up, down, left and right arrow keys to select.'\n      }\n    };\n\n    // Virtual instances cache\n    const instances = {};\n    let currentInstanceId = '';\n    let defaultInstance = {};\n    let hasInstance = false;\n\n    /**\r\n     * Configure the color picker.\r\n     * @param {object} options Configuration options.\r\n     */\n    function configure(options) {\n      if (typeof options !== 'object') {\n        return;\n      }\n\n      for (const key in options) {\n        switch (key) {\n          case 'el':\n            bindFields(options.el);\n            if (options.wrap !== false) {\n              wrapFields(options.el);\n            }\n            break;\n          case 'parent':\n            container = document.querySelector(options.parent);\n            if (container) {\n              container.appendChild(picker);\n              settings.parent = options.parent;\n\n              // document.body is special\n              if (container === document.body) {\n                container = undefined;\n              }\n            }\n            break;\n          case 'themeMode':\n            settings.themeMode = options.themeMode;\n            if (options.themeMode === 'auto' && window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {\n              settings.themeMode = 'dark';\n            }\n          // The lack of a break statement is intentional\n          case 'theme':\n            if (options.theme) {\n              settings.theme = options.theme;\n            }\n\n            // Set the theme and color scheme\n            picker.className = `clr-picker clr-${settings.theme} clr-${settings.themeMode}`;\n\n            // Update the color picker's position if inline mode is in use\n            if (settings.inline) {\n              updatePickerPosition();\n            }\n            break;\n          case 'rtl':\n            settings.rtl = !!options.rtl;\n            document.querySelectorAll('.clr-field').forEach((field) => field.classList.toggle('clr-rtl', settings.rtl));\n            break;\n          case 'margin':\n            options.margin *= 1;\n            settings.margin = !isNaN(options.margin) ? options.margin : settings.margin;\n            break;\n          case 'wrap':\n            if (options.el && options.wrap) {\n              wrapFields(options.el);\n            }\n            break;\n          case 'formatToggle':\n            settings.formatToggle = !!options.formatToggle;\n            getEl('clr-format').style.display = settings.formatToggle ? 'block' : 'none';\n            if (settings.formatToggle) {\n              settings.format = 'auto';\n            }\n            break;\n          case 'swatches':\n            if (Array.isArray(options.swatches)) {\n              const swatches = [];\n\n              options.swatches.forEach((swatch, i) => {\n                swatches.push(`<button type=\"button\" id=\"clr-swatch-${i}\" aria-labelledby=\"clr-swatch-label clr-swatch-${i}\" style=\"color: ${swatch};\">${swatch}</button>`);\n              });\n\n              getEl('clr-swatches').innerHTML = swatches.length ? `<div>${swatches.join('')}</div>` : '';\n              settings.swatches = options.swatches.slice();\n            }\n            break;\n          case 'swatchesOnly':\n            settings.swatchesOnly = !!options.swatchesOnly;\n            picker.setAttribute('data-minimal', settings.swatchesOnly);\n            break;\n          case 'alpha':\n            settings.alpha = !!options.alpha;\n            picker.setAttribute('data-alpha', settings.alpha);\n            break;\n          case 'inline':\n            settings.inline = !!options.inline;\n            picker.setAttribute('data-inline', settings.inline);\n\n            if (settings.inline) {\n              const defaultColor = options.defaultColor || settings.defaultColor;\n\n              currentFormat = getColorFormatFromStr(defaultColor);\n              updatePickerPosition();\n              setColorFromStr(defaultColor);\n            }\n            break;\n          case 'clearButton':\n            // Backward compatibility\n            if (typeof options.clearButton === 'object') {\n              if (options.clearButton.label) {\n                settings.clearLabel = options.clearButton.label;\n                clearButton.innerHTML = settings.clearLabel;\n              }\n\n              options.clearButton = options.clearButton.show;\n            }\n\n            settings.clearButton = !!options.clearButton;\n            clearButton.style.display = settings.clearButton ? 'block' : 'none';\n            break;\n          case 'clearLabel':\n            settings.clearLabel = options.clearLabel;\n            clearButton.innerHTML = settings.clearLabel;\n            break;\n          case 'closeButton':\n            settings.closeButton = !!options.closeButton;\n\n            if (settings.closeButton) {\n              picker.insertBefore(closeButton, colorPreview);\n            } else {\n              colorPreview.appendChild(closeButton);\n            }\n\n            break;\n          case 'closeLabel':\n            settings.closeLabel = options.closeLabel;\n            closeButton.innerHTML = settings.closeLabel;\n            break;\n          case 'a11y':\n            const labels = options.a11y;\n            let update = false;\n\n            if (typeof labels === 'object') {\n              for (const label in labels) {\n                if (labels[label] && settings.a11y[label]) {\n                  settings.a11y[label] = labels[label];\n                  update = true;\n                }\n              }\n            }\n\n            if (update) {\n              const openLabel = getEl('clr-open-label');\n              const swatchLabel = getEl('clr-swatch-label');\n\n              openLabel.innerHTML = settings.a11y.open;\n              swatchLabel.innerHTML = settings.a11y.swatch;\n              closeButton.setAttribute('aria-label', settings.a11y.close);\n              clearButton.setAttribute('aria-label', settings.a11y.clear);\n              hueSlider.setAttribute('aria-label', settings.a11y.hueSlider);\n              alphaSlider.setAttribute('aria-label', settings.a11y.alphaSlider);\n              colorValue.setAttribute('aria-label', settings.a11y.input);\n              colorArea.setAttribute('aria-label', settings.a11y.instruction);\n            }\n            break;\n          default:\n            settings[key] = options[key];\n        }\n      }\n    }\n\n    /**\r\n     * Add or update a virtual instance.\r\n     * @param {String} selector The CSS selector of the elements to which the instance is attached.\r\n     * @param {Object} options Per-instance options to apply.\r\n     */\n    function setVirtualInstance(selector, options) {\n      if (typeof selector === 'string' && typeof options === 'object') {\n        instances[selector] = options;\n        hasInstance = true;\n      }\n    }\n\n    /**\r\n     * Remove a virtual instance.\r\n     * @param {String} selector The CSS selector of the elements to which the instance is attached.\r\n     */\n    function removeVirtualInstance(selector) {\n      delete instances[selector];\n\n      if (Object.keys(instances).length === 0) {\n        hasInstance = false;\n\n        if (selector === currentInstanceId) {\n          resetVirtualInstance();\n        }\n      }\n    }\n\n    /**\r\n     * Attach a virtual instance to an element if it matches a selector.\r\n     * @param {Object} element Target element that will receive a virtual instance if applicable.\r\n     */\n    function attachVirtualInstance(element) {\n      if (hasInstance) {\n        // These options can only be set globally, not per instance\n        const unsupportedOptions = ['el', 'wrap', 'rtl', 'inline', 'defaultColor', 'a11y'];\n\n        for (let selector in instances) {\n          const options = instances[selector];\n\n          // If the element matches an instance's CSS selector\n          if (element.matches(selector)) {\n            currentInstanceId = selector;\n            defaultInstance = {};\n\n            // Delete unsupported options\n            unsupportedOptions.forEach((option) => delete options[option]);\n\n            // Back up the default options so we can restore them later\n            for (let option in options) {\n              defaultInstance[option] = Array.isArray(settings[option]) ? settings[option].slice() : settings[option];\n            }\n\n            // Set the instance's options\n            configure(options);\n            break;\n          }\n        }\n      }\n    }\n\n    /**\r\n     * Revert any per-instance options that were previously applied.\r\n     */\n    function resetVirtualInstance() {\n      if (Object.keys(defaultInstance).length > 0) {\n        configure(defaultInstance);\n        currentInstanceId = '';\n        defaultInstance = {};\n      }\n    }\n\n    /**\r\n     * Bind the color picker to input fields that match the selector.\r\n     * @param {string} selector One or more selectors pointing to input fields.\r\n     */\n    function bindFields(selector) {\n      // Show the color picker on click on the input fields that match the selector\n      addListener(document, 'click', selector, (event) => {\n        // Skip if inline mode is in use\n        if (settings.inline) {\n          return;\n        }\n\n        // Apply any per-instance options first\n        attachVirtualInstance(event.target);\n\n        currentEl = event.target;\n        oldColor = currentEl.value;\n        currentFormat = getColorFormatFromStr(oldColor);\n        picker.classList.add('clr-open');\n\n        updatePickerPosition();\n        setColorFromStr(oldColor);\n\n        if (settings.focusInput || settings.selectInput) {\n          colorValue.focus({ preventScroll: true });\n          colorValue.setSelectionRange(currentEl.selectionStart, currentEl.selectionEnd);\n        }\n\n        if (settings.selectInput) {\n          colorValue.select();\n        }\n\n        // Always focus the first element when using keyboard navigation\n        if (keyboardNav || settings.swatchesOnly) {\n          getFocusableElements().shift().focus();\n        }\n\n        // Trigger an \"open\" event\n        currentEl.dispatchEvent(new Event('open', { bubbles: true }));\n      });\n\n      // Update the color preview of the input fields that match the selector\n      addListener(document, 'input', selector, (event) => {\n        const parent = event.target.parentNode;\n\n        // Only update the preview if the field has been previously wrapped\n        if (parent.classList.contains('clr-field')) {\n          parent.style.color = event.target.value;\n        }\n      });\n    }\n\n    /**\r\n     * Update the color picker's position and the color gradient's offset\r\n     */\n    function updatePickerPosition() {\n      if (!picker || !currentEl && !settings.inline) return; //** DO NOT REMOVE: in case called before initialized\n      const parent = container;\n      const scrollY = window.scrollY;\n      const pickerWidth = picker.offsetWidth;\n      const pickerHeight = picker.offsetHeight;\n      const reposition = { left: false, top: false };\n      let parentStyle, parentMarginTop, parentBorderTop;\n      let offset = { x: 0, y: 0 };\n\n      if (parent) {\n        parentStyle = window.getComputedStyle(parent);\n        parentMarginTop = parseFloat(parentStyle.marginTop);\n        parentBorderTop = parseFloat(parentStyle.borderTopWidth);\n\n        offset = parent.getBoundingClientRect();\n        offset.y += parentBorderTop + scrollY;\n      }\n\n      if (!settings.inline) {\n        const coords = currentEl.getBoundingClientRect();\n        let left = coords.x;\n        let top = scrollY + coords.y + coords.height + settings.margin;\n\n        // If the color picker is inside a custom container\n        // set the position relative to it\n        if (parent) {\n          left -= offset.x;\n          top -= offset.y;\n\n          if (left + pickerWidth > parent.clientWidth) {\n            left += coords.width - pickerWidth;\n            reposition.left = true;\n          }\n\n          if (top + pickerHeight > parent.clientHeight - parentMarginTop) {\n            if (pickerHeight + settings.margin <= coords.top - (offset.y - scrollY)) {\n              top -= coords.height + pickerHeight + settings.margin * 2;\n              reposition.top = true;\n            }\n          }\n\n          top += parent.scrollTop;\n\n          // Otherwise set the position relative to the whole document\n        } else {\n          if (left + pickerWidth > document.documentElement.clientWidth) {\n            left += coords.width - pickerWidth;\n            reposition.left = true;\n          }\n\n          if (top + pickerHeight - scrollY > document.documentElement.clientHeight) {\n            if (pickerHeight + settings.margin <= coords.top) {\n              top = scrollY + coords.y - pickerHeight - settings.margin;\n              reposition.top = true;\n            }\n          }\n        }\n\n        picker.classList.toggle('clr-left', reposition.left);\n        picker.classList.toggle('clr-top', reposition.top);\n        picker.style.left = `${left}px`;\n        picker.style.top = `${top}px`;\n        offset.x += picker.offsetLeft;\n        offset.y += picker.offsetTop;\n      }\n\n      colorAreaDims = {\n        width: colorArea.offsetWidth,\n        height: colorArea.offsetHeight,\n        x: colorArea.offsetLeft + offset.x,\n        y: colorArea.offsetTop + offset.y\n      };\n    }\n\n    /**\r\n     * Wrap the linked input fields in a div that adds a color preview.\r\n     * @param {string} selector One or more selectors pointing to input fields.\r\n     */\n    function wrapFields(selector) {\n      document.querySelectorAll(selector).forEach((field) => {\n        const parentNode = field.parentNode;\n\n        if (!parentNode.classList.contains('clr-field')) {\n          const wrapper = document.createElement('div');\n          let classes = 'clr-field';\n\n          if (settings.rtl || field.classList.contains('clr-rtl')) {\n            classes += ' clr-rtl';\n          }\n\n          wrapper.innerHTML = `<button type=\"button\" aria-labelledby=\"clr-open-label\"></button>`;\n          parentNode.insertBefore(wrapper, field);\n          wrapper.setAttribute('class', classes);\n          wrapper.style.color = field.value;\n          wrapper.appendChild(field);\n        }\n      });\n    }\n\n    /**\r\n     * Close the color picker.\r\n     * @param {boolean} [revert] If true, revert the color to the original value.\r\n     */\n    function closePicker(revert) {\n      if (currentEl && !settings.inline) {\n        const prevEl = currentEl;\n\n        // Revert the color to the original value if needed\n        if (revert) {\n          // This will prevent the \"change\" event on the colorValue input to execute its handler\n          currentEl = undefined;\n\n          if (oldColor !== prevEl.value) {\n            prevEl.value = oldColor;\n\n            // Trigger an \"input\" event to force update the thumbnail next to the input field\n            prevEl.dispatchEvent(new Event('input', { bubbles: true }));\n          }\n        }\n\n        // Trigger a \"change\" event if needed\n        setTimeout(() => {// Add this to the end of the event loop\n          if (oldColor !== prevEl.value) {\n            prevEl.dispatchEvent(new Event('change', { bubbles: true }));\n          }\n        });\n\n        // Hide the picker dialog\n        picker.classList.remove('clr-open');\n\n        // Reset any previously set per-instance options\n        if (hasInstance) {\n          resetVirtualInstance();\n        }\n\n        // Trigger a \"close\" event\n        prevEl.dispatchEvent(new Event('close', { bubbles: true }));\n\n        if (settings.focusInput) {\n          prevEl.focus({ preventScroll: true });\n        }\n\n        // This essentially marks the picker as closed\n        currentEl = undefined;\n      }\n    }\n\n    /**\r\n     * Set the active color from a string.\r\n     * @param {string} str String representing a color.\r\n     */\n    function setColorFromStr(str) {\n      const rgba = strToRGBA(str);\n      const hsva = RGBAtoHSVA(rgba);\n\n      updateMarkerA11yLabel(hsva.s, hsva.v);\n      updateColor(rgba, hsva);\n\n      // Update the UI\n      hueSlider.value = hsva.h;\n      picker.style.color = `hsl(${hsva.h}, 100%, 50%)`;\n      hueMarker.style.left = `${hsva.h / 360 * 100}%`;\n\n      colorMarker.style.left = `${colorAreaDims.width * hsva.s / 100}px`;\n      colorMarker.style.top = `${colorAreaDims.height - colorAreaDims.height * hsva.v / 100}px`;\n\n      alphaSlider.value = hsva.a * 100;\n      alphaMarker.style.left = `${hsva.a * 100}%`;\n    }\n\n    /**\r\n     * Guess the color format from a string.\r\n     * @param {string} str String representing a color.\r\n     * @return {string} The color format.\r\n     */\n    function getColorFormatFromStr(str) {\n      const format = str.substring(0, 3).toLowerCase();\n\n      if (format === 'rgb' || format === 'hsl') {\n        return format;\n      }\n\n      return 'hex';\n    }\n\n    /**\r\n     * Copy the active color to the linked input field.\r\n     * @param {number} [color] Color value to override the active color.\r\n     */\n    function pickColor(color) {\n      color = color !== undefined ? color : colorValue.value;\n\n      if (currentEl) {\n        currentEl.value = color;\n        currentEl.dispatchEvent(new Event('input', { bubbles: true }));\n      }\n\n      if (settings.onChange) {\n        settings.onChange.call(window, color, currentEl);\n      }\n\n      document.dispatchEvent(new CustomEvent('coloris:pick', { detail: { color, currentEl } }));\n    }\n\n    /**\r\n     * Set the active color based on a specific point in the color gradient.\r\n     * @param {number} x Left position.\r\n     * @param {number} y Top position.\r\n     */\n    function setColorAtPosition(x, y) {\n      const hsva = {\n        h: hueSlider.value * 1,\n        s: x / colorAreaDims.width * 100,\n        v: 100 - y / colorAreaDims.height * 100,\n        a: alphaSlider.value / 100\n      };\n      const rgba = HSVAtoRGBA(hsva);\n\n      updateMarkerA11yLabel(hsva.s, hsva.v);\n      updateColor(rgba, hsva);\n      pickColor();\n    }\n\n    /**\r\n     * Update the color marker's accessibility label.\r\n     * @param {number} saturation\r\n     * @param {number} value\r\n     */\n    function updateMarkerA11yLabel(saturation, value) {\n      let label = settings.a11y.marker;\n\n      saturation = saturation.toFixed(1) * 1;\n      value = value.toFixed(1) * 1;\n      label = label.replace('{s}', saturation);\n      label = label.replace('{v}', value);\n      colorMarker.setAttribute('aria-label', label);\n    }\n\n    //\n    /**\r\n     * Get the pageX and pageY positions of the pointer.\r\n     * @param {object} event The MouseEvent or TouchEvent object.\r\n     * @return {object} The pageX and pageY positions.\r\n     */\n    function getPointerPosition(event) {\n      return {\n        pageX: event.changedTouches ? event.changedTouches[0].pageX : event.pageX,\n        pageY: event.changedTouches ? event.changedTouches[0].pageY : event.pageY\n      };\n    }\n\n    /**\r\n     * Move the color marker when dragged.\r\n     * @param {object} event The MouseEvent object.\r\n     */\n    function moveMarker(event) {\n      const pointer = getPointerPosition(event);\n      let x = pointer.pageX - colorAreaDims.x;\n      let y = pointer.pageY - colorAreaDims.y;\n\n      if (container) {\n        y += container.scrollTop;\n      }\n\n      setMarkerPosition(x, y);\n\n      // Prevent scrolling while dragging the marker\n      event.preventDefault();\n      event.stopPropagation();\n    }\n\n    /**\r\n     * Move the color marker when the arrow keys are pressed.\r\n     * @param {number} offsetX The horizontal amount to move.\r\n     * @param {number} offsetY The vertical amount to move.\r\n     */\n    function moveMarkerOnKeydown(offsetX, offsetY) {\n      let x = colorMarker.style.left.replace('px', '') * 1 + offsetX;\n      let y = colorMarker.style.top.replace('px', '') * 1 + offsetY;\n\n      setMarkerPosition(x, y);\n    }\n\n    /**\r\n     * Set the color marker's position.\r\n     * @param {number} x Left position.\r\n     * @param {number} y Top position.\r\n     */\n    function setMarkerPosition(x, y) {\n      // Make sure the marker doesn't go out of bounds\n      x = x < 0 ? 0 : x > colorAreaDims.width ? colorAreaDims.width : x;\n      y = y < 0 ? 0 : y > colorAreaDims.height ? colorAreaDims.height : y;\n\n      // Set the position\n      colorMarker.style.left = `${x}px`;\n      colorMarker.style.top = `${y}px`;\n\n      // Update the color\n      setColorAtPosition(x, y);\n\n      // Make sure the marker is focused\n      colorMarker.focus();\n    }\n\n    /**\r\n     * Update the color picker's input field and preview thumb.\r\n     * @param {Object} rgba Red, green, blue and alpha values.\r\n     * @param {Object} [hsva] Hue, saturation, value and alpha values.\r\n     */\n    function updateColor(rgba, hsva) {if (rgba === void 0) {rgba = {};}if (hsva === void 0) {hsva = {};}\n      let format = settings.format;\n\n      for (const key in rgba) {\n        currentColor[key] = rgba[key];\n      }\n\n      for (const key in hsva) {\n        currentColor[key] = hsva[key];\n      }\n\n      const hex = RGBAToHex(currentColor);\n      const opaqueHex = hex.substring(0, 7);\n\n      colorMarker.style.color = opaqueHex;\n      alphaMarker.parentNode.style.color = opaqueHex;\n      alphaMarker.style.color = hex;\n      colorPreview.style.color = hex;\n\n      // Force repaint the color and alpha gradients as a workaround for a Google Chrome bug\n      colorArea.style.display = 'none';\n      colorArea.offsetHeight;\n      colorArea.style.display = '';\n      alphaMarker.nextElementSibling.style.display = 'none';\n      alphaMarker.nextElementSibling.offsetHeight;\n      alphaMarker.nextElementSibling.style.display = '';\n\n      if (format === 'mixed') {\n        format = currentColor.a === 1 ? 'hex' : 'rgb';\n      } else if (format === 'auto') {\n        format = currentFormat;\n      }\n\n      switch (format) {\n        case 'hex':\n          colorValue.value = hex;\n          break;\n        case 'rgb':\n          colorValue.value = RGBAToStr(currentColor);\n          break;\n        case 'hsl':\n          colorValue.value = HSLAToStr(HSVAtoHSLA(currentColor));\n          break;\n      }\n\n      // Select the current format in the format switcher\n      document.querySelector(`.clr-format [value=\"${format}\"]`).checked = true;\n    }\n\n    /**\r\n     * Set the hue when its slider is moved.\r\n     */\n    function setHue() {\n      const hue = hueSlider.value * 1;\n      const x = colorMarker.style.left.replace('px', '') * 1;\n      const y = colorMarker.style.top.replace('px', '') * 1;\n\n      picker.style.color = `hsl(${hue}, 100%, 50%)`;\n      hueMarker.style.left = `${hue / 360 * 100}%`;\n\n      setColorAtPosition(x, y);\n    }\n\n    /**\r\n     * Set the alpha when its slider is moved.\r\n     */\n    function setAlpha() {\n      const alpha = alphaSlider.value / 100;\n\n      alphaMarker.style.left = `${alpha * 100}%`;\n      updateColor({ a: alpha });\n      pickColor();\n    }\n\n    /**\r\n     * Convert HSVA to RGBA.\r\n     * @param {object} hsva Hue, saturation, value and alpha values.\r\n     * @return {object} Red, green, blue and alpha values.\r\n     */\n    function HSVAtoRGBA(hsva) {\n      const saturation = hsva.s / 100;\n      const value = hsva.v / 100;\n      let chroma = saturation * value;\n      let hueBy60 = hsva.h / 60;\n      let x = chroma * (1 - Math.abs(hueBy60 % 2 - 1));\n      let m = value - chroma;\n\n      chroma = chroma + m;\n      x = x + m;\n\n      const index = Math.floor(hueBy60) % 6;\n      const red = [chroma, x, m, m, x, chroma][index];\n      const green = [x, chroma, chroma, x, m, m][index];\n      const blue = [m, m, x, chroma, chroma, x][index];\n\n      return {\n        r: Math.round(red * 255),\n        g: Math.round(green * 255),\n        b: Math.round(blue * 255),\n        a: hsva.a\n      };\n    }\n\n    /**\r\n     * Convert HSVA to HSLA.\r\n     * @param {object} hsva Hue, saturation, value and alpha values.\r\n     * @return {object} Hue, saturation, lightness and alpha values.\r\n     */\n    function HSVAtoHSLA(hsva) {\n      const value = hsva.v / 100;\n      const lightness = value * (1 - hsva.s / 100 / 2);\n      let saturation;\n\n      if (lightness > 0 && lightness < 1) {\n        saturation = Math.round((value - lightness) / Math.min(lightness, 1 - lightness) * 100);\n      }\n\n      return {\n        h: hsva.h,\n        s: saturation || 0,\n        l: Math.round(lightness * 100),\n        a: hsva.a\n      };\n    }\n\n    /**\r\n     * Convert RGBA to HSVA.\r\n     * @param {object} rgba Red, green, blue and alpha values.\r\n     * @return {object} Hue, saturation, value and alpha values.\r\n     */\n    function RGBAtoHSVA(rgba) {\n      const red = rgba.r / 255;\n      const green = rgba.g / 255;\n      const blue = rgba.b / 255;\n      const xmax = Math.max(red, green, blue);\n      const xmin = Math.min(red, green, blue);\n      const chroma = xmax - xmin;\n      const value = xmax;\n      let hue = 0;\n      let saturation = 0;\n\n      if (chroma) {\n        if (xmax === red) {hue = (green - blue) / chroma;}\n        if (xmax === green) {hue = 2 + (blue - red) / chroma;}\n        if (xmax === blue) {hue = 4 + (red - green) / chroma;}\n        if (xmax) {saturation = chroma / xmax;}\n      }\n\n      hue = Math.floor(hue * 60);\n\n      return {\n        h: hue < 0 ? hue + 360 : hue,\n        s: Math.round(saturation * 100),\n        v: Math.round(value * 100),\n        a: rgba.a\n      };\n    }\n\n    /**\r\n     * Parse a string to RGBA.\r\n     * @param {string} str String representing a color.\r\n     * @return {object} Red, green, blue and alpha values.\r\n     */\n    function strToRGBA(str) {\n      const regex = /^((rgba)|rgb)[\\D]+([\\d.]+)[\\D]+([\\d.]+)[\\D]+([\\d.]+)[\\D]*?([\\d.]+|$)/i;\n      let match, rgba;\n\n      // Default to black for invalid color strings\n      ctx.fillStyle = '#000';\n\n      // Use canvas to convert the string to a valid color string\n      ctx.fillStyle = str;\n      match = regex.exec(ctx.fillStyle);\n\n      if (match) {\n        rgba = {\n          r: match[3] * 1,\n          g: match[4] * 1,\n          b: match[5] * 1,\n          a: match[6] * 1\n        };\n\n        // Workaround to mitigate a Chromium bug where the alpha value is rounded incorrectly\n        rgba.a = +rgba.a.toFixed(2);\n\n      } else {\n        match = ctx.fillStyle.replace('#', '').match(/.{2}/g).map((h) => parseInt(h, 16));\n        rgba = {\n          r: match[0],\n          g: match[1],\n          b: match[2],\n          a: 1\n        };\n      }\n\n      return rgba;\n    }\n\n    /**\r\n     * Convert RGBA to Hex.\r\n     * @param {object} rgba Red, green, blue and alpha values.\r\n     * @return {string} Hex color string.\r\n     */\n    function RGBAToHex(rgba) {\n      let R = rgba.r.toString(16);\n      let G = rgba.g.toString(16);\n      let B = rgba.b.toString(16);\n      let A = '';\n\n      if (rgba.r < 16) {\n        R = '0' + R;\n      }\n\n      if (rgba.g < 16) {\n        G = '0' + G;\n      }\n\n      if (rgba.b < 16) {\n        B = '0' + B;\n      }\n\n      if (settings.alpha && (rgba.a < 1 || settings.forceAlpha)) {\n        const alpha = rgba.a * 255 | 0;\n        A = alpha.toString(16);\n\n        if (alpha < 16) {\n          A = '0' + A;\n        }\n      }\n\n      return '#' + R + G + B + A;\n    }\n\n    /**\r\n     * Convert RGBA values to a CSS rgb/rgba string.\r\n     * @param {object} rgba Red, green, blue and alpha values.\r\n     * @return {string} CSS color string.\r\n     */\n    function RGBAToStr(rgba) {\n      if (!settings.alpha || rgba.a === 1 && !settings.forceAlpha) {\n        return `rgb(${rgba.r}, ${rgba.g}, ${rgba.b})`;\n      } else {\n        return `rgba(${rgba.r}, ${rgba.g}, ${rgba.b}, ${rgba.a})`;\n      }\n    }\n\n    /**\r\n     * Convert HSLA values to a CSS hsl/hsla string.\r\n     * @param {object} hsla Hue, saturation, lightness and alpha values.\r\n     * @return {string} CSS color string.\r\n     */\n    function HSLAToStr(hsla) {\n      if (!settings.alpha || hsla.a === 1 && !settings.forceAlpha) {\n        return `hsl(${hsla.h}, ${hsla.s}%, ${hsla.l}%)`;\n      } else {\n        return `hsla(${hsla.h}, ${hsla.s}%, ${hsla.l}%, ${hsla.a})`;\n      }\n    }\n\n    /**\r\n     * Init the color picker.\r\n     */\n    function init() {\n      if (document.getElementById('clr-picker')) return; //** DO NOT REMOVE: Prevent binding events multiple times\n      // Render the UI\n      container = undefined;\n      picker = document.createElement('div');\n      picker.setAttribute('id', 'clr-picker');\n      picker.className = 'clr-picker';\n      picker.innerHTML =\n      `<input id=\"clr-color-value\" name=\"clr-color-value\" class=\"clr-color\" type=\"text\" value=\"\" spellcheck=\"false\" aria-label=\"${settings.a11y.input}\">` +\n      `<div id=\"clr-color-area\" class=\"clr-gradient\" role=\"application\" aria-label=\"${settings.a11y.instruction}\">` +\n      '<div id=\"clr-color-marker\" class=\"clr-marker\" tabindex=\"0\"></div>' +\n      '</div>' +\n      '<div class=\"clr-hue\">' +\n      `<input id=\"clr-hue-slider\" name=\"clr-hue-slider\" type=\"range\" min=\"0\" max=\"360\" step=\"1\" aria-label=\"${settings.a11y.hueSlider}\">` +\n      '<div id=\"clr-hue-marker\"></div>' +\n      '</div>' +\n      '<div class=\"clr-alpha\">' +\n      `<input id=\"clr-alpha-slider\" name=\"clr-alpha-slider\" type=\"range\" min=\"0\" max=\"100\" step=\"1\" aria-label=\"${settings.a11y.alphaSlider}\">` +\n      '<div id=\"clr-alpha-marker\"></div>' +\n      '<span></span>' +\n      '</div>' +\n      '<div id=\"clr-format\" class=\"clr-format\">' +\n      '<fieldset class=\"clr-segmented\">' +\n      `<legend>${settings.a11y.format}</legend>` +\n      '<input id=\"clr-f1\" type=\"radio\" name=\"clr-format\" value=\"hex\">' +\n      '<label for=\"clr-f1\">Hex</label>' +\n      '<input id=\"clr-f2\" type=\"radio\" name=\"clr-format\" value=\"rgb\">' +\n      '<label for=\"clr-f2\">RGB</label>' +\n      '<input id=\"clr-f3\" type=\"radio\" name=\"clr-format\" value=\"hsl\">' +\n      '<label for=\"clr-f3\">HSL</label>' +\n      '<span></span>' +\n      '</fieldset>' +\n      '</div>' +\n      '<div id=\"clr-swatches\" class=\"clr-swatches\"></div>' +\n      `<button type=\"button\" id=\"clr-clear\" class=\"clr-clear\" aria-label=\"${settings.a11y.clear}\">${settings.clearLabel}</button>` +\n      '<div id=\"clr-color-preview\" class=\"clr-preview\">' +\n      `<button type=\"button\" id=\"clr-close\" class=\"clr-close\" aria-label=\"${settings.a11y.close}\">${settings.closeLabel}</button>` +\n      '</div>' +\n      `<span id=\"clr-open-label\" hidden>${settings.a11y.open}</span>` +\n      `<span id=\"clr-swatch-label\" hidden>${settings.a11y.swatch}</span>`;\n\n      // Append the color picker to the DOM\n      document.body.appendChild(picker);\n\n      // Reference the UI elements\n      colorArea = getEl('clr-color-area');\n      colorMarker = getEl('clr-color-marker');\n      clearButton = getEl('clr-clear');\n      closeButton = getEl('clr-close');\n      colorPreview = getEl('clr-color-preview');\n      colorValue = getEl('clr-color-value');\n      hueSlider = getEl('clr-hue-slider');\n      hueMarker = getEl('clr-hue-marker');\n      alphaSlider = getEl('clr-alpha-slider');\n      alphaMarker = getEl('clr-alpha-marker');\n\n      // Bind the picker to the default selector\n      bindFields(settings.el);\n      wrapFields(settings.el);\n\n      addListener(picker, 'mousedown', (event) => {\n        picker.classList.remove('clr-keyboard-nav');\n        event.stopPropagation();\n      });\n\n      addListener(colorArea, 'mousedown', (event) => {\n        addListener(document, 'mousemove', moveMarker);\n      });\n\n      addListener(colorArea, 'touchstart', (event) => {\n        document.addEventListener('touchmove', moveMarker, { passive: false });\n      });\n\n      addListener(colorMarker, 'mousedown', (event) => {\n        addListener(document, 'mousemove', moveMarker);\n      });\n\n      addListener(colorMarker, 'touchstart', (event) => {\n        document.addEventListener('touchmove', moveMarker, { passive: false });\n      });\n\n      addListener(colorValue, 'change', (event) => {\n        const value = colorValue.value;\n\n        if (currentEl || settings.inline) {\n          const color = value === '' ? value : setColorFromStr(value);\n          pickColor(color);\n        }\n      });\n\n      addListener(clearButton, 'click', (event) => {\n        pickColor('');\n        closePicker();\n      });\n\n      addListener(closeButton, 'click', (event) => {\n        pickColor();\n        closePicker();\n      });\n\n      addListener(getEl('clr-format'), 'click', '.clr-format input', (event) => {\n        currentFormat = event.target.value;\n        updateColor();\n        pickColor();\n      });\n\n      addListener(picker, 'click', '.clr-swatches button', (event) => {\n        setColorFromStr(event.target.textContent);\n        pickColor();\n\n        if (settings.swatchesOnly) {\n          closePicker();\n        }\n      });\n\n      addListener(document, 'mouseup', (event) => {\n        document.removeEventListener('mousemove', moveMarker);\n      });\n\n      addListener(document, 'touchend', (event) => {\n        document.removeEventListener('touchmove', moveMarker);\n      });\n\n      addListener(document, 'mousedown', (event) => {\n        keyboardNav = false;\n        picker.classList.remove('clr-keyboard-nav');\n        closePicker();\n      });\n\n      addListener(document, 'keydown', (event) => {\n        const key = event.key;\n        const target = event.target;\n        const shiftKey = event.shiftKey;\n        const navKeys = ['Tab', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'];\n\n        if (key === 'Escape') {\n          closePicker(true);\n\n          // Display focus rings when using the keyboard\n        } else if (navKeys.includes(key)) {\n          keyboardNav = true;\n          picker.classList.add('clr-keyboard-nav');\n        }\n\n        // Trap the focus within the color picker while it's open\n        if (key === 'Tab' && target.matches('.clr-picker *')) {\n          const focusables = getFocusableElements();\n          const firstFocusable = focusables.shift();\n          const lastFocusable = focusables.pop();\n\n          if (shiftKey && target === firstFocusable) {\n            lastFocusable.focus();\n            event.preventDefault();\n          } else if (!shiftKey && target === lastFocusable) {\n            firstFocusable.focus();\n            event.preventDefault();\n          }\n        }\n      });\n\n      addListener(document, 'click', '.clr-field button', (event) => {\n        // Reset any previously set per-instance options\n        if (hasInstance) {\n          resetVirtualInstance();\n        }\n\n        // Open the color picker\n        event.target.nextElementSibling.dispatchEvent(new Event('click', { bubbles: true }));\n      });\n\n      addListener(colorMarker, 'keydown', (event) => {\n        const movements = {\n          ArrowUp: [0, -1],\n          ArrowDown: [0, 1],\n          ArrowLeft: [-1, 0],\n          ArrowRight: [1, 0]\n        };\n\n        if (Object.keys(movements).includes(event.key)) {\n          moveMarkerOnKeydown(...movements[event.key]);\n          event.preventDefault();\n        }\n      });\n\n      addListener(colorArea, 'click', moveMarker);\n      addListener(hueSlider, 'input', setHue);\n      addListener(alphaSlider, 'input', setAlpha);\n    }\n\n    /**\r\n     * Return a list of focusable elements within the color picker.\r\n     * @return {array} The list of focusable DOM elemnts.\r\n     */\n    function getFocusableElements() {\n      const controls = Array.from(picker.querySelectorAll('input, button'));\n      const focusables = controls.filter((node) => !!node.offsetWidth);\n\n      return focusables;\n    }\n\n    /**\r\n     * Shortcut for getElementById to optimize the minified JS.\r\n     * @param {string} id The element id.\r\n     * @return {object} The DOM element with the provided id.\r\n     */\n    function getEl(id) {\n      return document.getElementById(id);\n    }\n\n    /**\r\n     * Shortcut for addEventListener to optimize the minified JS.\r\n     * @param {object} context The context to which the listener is attached.\r\n     * @param {string} type Event type.\r\n     * @param {(string|function)} selector Event target if delegation is used, event handler if not.\r\n     * @param {function} [fn] Event handler if delegation is used.\r\n     */\n    function addListener(context, type, selector, fn) {\n      const matches = Element.prototype.matches || Element.prototype.msMatchesSelector;\n\n      // Delegate event to the target of the selector\n      if (typeof selector === 'string') {\n        context.addEventListener(type, (event) => {\n          if (matches.call(event.target, selector)) {\n            fn.call(event.target, event);\n          }\n        });\n\n        // If the selector is not a string then it's a function\n        // in which case we need a regular event listener\n      } else {\n        fn = selector;\n        context.addEventListener(type, fn);\n      }\n    }\n\n    /**\r\n     * Call a function only when the DOM is ready.\r\n     * @param {function} fn The function to call.\r\n     * @param {array} [args] Arguments to pass to the function.\r\n     */\n    function DOMReady(fn, args) {\n      args = args !== undefined ? args : [];\n\n      if (document.readyState !== 'loading') {\n        fn(...args);\n      } else {\n        document.addEventListener('DOMContentLoaded', () => {\n          fn(...args);\n        });\n      }\n    }\n\n    // Polyfill for Nodelist.forEach\n    if (NodeList !== undefined && NodeList.prototype && !NodeList.prototype.forEach) {\n      NodeList.prototype.forEach = Array.prototype.forEach;\n    }\n\n    //*****************************************************\n    //******* NPM: Custom code starts here ****************\n    //*****************************************************\n\n    /**\r\n     * Copy the active color to the linked input field and set the color.\r\n     * @param {string} [color] Color value to override the active color.\r\n     * @param {HTMLelement} [target] the element setting the color on\r\n     */\n    function setColor(color, target) {\n      currentEl = target;\n      oldColor = currentEl.value;\n      attachVirtualInstance(target);\n      currentFormat = getColorFormatFromStr(color);\n      updatePickerPosition();\n      setColorFromStr(color);\n      pickColor();\n      if (oldColor !== color) {\n        currentEl.dispatchEvent(new Event('change', { bubbles: true }));\n      }\n    }\n\n    // Expose the color picker to the global scope\n    const Coloris = (() => {\n      const methods = {\n        init: init,\n        set: configure,\n        wrap: wrapFields,\n        close: closePicker,\n        setInstance: setVirtualInstance,\n        setColor: setColor,\n        removeInstance: removeVirtualInstance,\n        updatePosition: updatePickerPosition,\n        ready: DOMReady\n      };\n\n      function Coloris(options) {\n        DOMReady(() => {\n          if (options) {\n            if (typeof options === 'string') {\n              bindFields(options);\n            } else {\n              configure(options);\n            }\n          }\n        });\n      }\n\n      for (const key in methods) {\n        Coloris[key] = function () {for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {args[_key] = arguments[_key];}\n          DOMReady(methods[key], args);\n        };\n      }\n\n      // handle window resize events re-aligning the panel\n      DOMReady(() => {\n        window.addEventListener('resize', (event) => {Coloris.updatePosition();});\n        window.addEventListener('scroll', (event) => {Coloris.updatePosition();});\n      });\n\n      return Coloris;\n    })();\n\n    // Ensure init function is available not only as as a default import\n    Coloris.coloris = Coloris;\n\n    // Init the color picker when the DOM is ready\n    return Coloris;\n\n  })(window, document, Math);\n});\n\n//# sourceURL=webpack://default/./node_modules/@melloware/coloris/dist/umd/coloris.js?");

/***/ }),

/***/ "./node_modules/bezier-js/dist/bezier.cjs":
/*!************************************************!*\
  !*** ./node_modules/bezier-js/dist/bezier.cjs ***!
  \************************************************/
/***/ ((module) => {

eval("var __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, copyDefault, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== \"default\"))\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toCommonJS = /* @__PURE__ */ ((cache) => {\n  return (module2, temp) => {\n    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);\n  };\n})(typeof WeakMap !== \"undefined\" ? /* @__PURE__ */ new WeakMap() : 0);\n\n// src/bezier.js\nvar bezier_exports = {};\n__export(bezier_exports, {\n  Bezier: () => Bezier\n});\n\n// src/utils.js\nvar { abs, cos, sin, acos, atan2, sqrt, pow } = Math;\nfunction crt(v) {\n  return v < 0 ? -pow(-v, 1 / 3) : pow(v, 1 / 3);\n}\nvar pi = Math.PI;\nvar tau = 2 * pi;\nvar quart = pi / 2;\nvar epsilon = 1e-6;\nvar nMax = Number.MAX_SAFE_INTEGER || 9007199254740991;\nvar nMin = Number.MIN_SAFE_INTEGER || -9007199254740991;\nvar ZERO = { x: 0, y: 0, z: 0 };\nvar utils = {\n  Tvalues: [\n    -0.06405689286260563,\n    0.06405689286260563,\n    -0.1911188674736163,\n    0.1911188674736163,\n    -0.3150426796961634,\n    0.3150426796961634,\n    -0.4337935076260451,\n    0.4337935076260451,\n    -0.5454214713888396,\n    0.5454214713888396,\n    -0.6480936519369755,\n    0.6480936519369755,\n    -0.7401241915785544,\n    0.7401241915785544,\n    -0.820001985973903,\n    0.820001985973903,\n    -0.8864155270044011,\n    0.8864155270044011,\n    -0.9382745520027328,\n    0.9382745520027328,\n    -0.9747285559713095,\n    0.9747285559713095,\n    -0.9951872199970213,\n    0.9951872199970213\n  ],\n  Cvalues: [\n    0.12793819534675216,\n    0.12793819534675216,\n    0.1258374563468283,\n    0.1258374563468283,\n    0.12167047292780339,\n    0.12167047292780339,\n    0.1155056680537256,\n    0.1155056680537256,\n    0.10744427011596563,\n    0.10744427011596563,\n    0.09761865210411388,\n    0.09761865210411388,\n    0.08619016153195327,\n    0.08619016153195327,\n    0.0733464814110803,\n    0.0733464814110803,\n    0.05929858491543678,\n    0.05929858491543678,\n    0.04427743881741981,\n    0.04427743881741981,\n    0.028531388628933663,\n    0.028531388628933663,\n    0.0123412297999872,\n    0.0123412297999872\n  ],\n  arcfn: function(t2, derivativeFn) {\n    const d = derivativeFn(t2);\n    let l = d.x * d.x + d.y * d.y;\n    if (typeof d.z !== \"undefined\") {\n      l += d.z * d.z;\n    }\n    return sqrt(l);\n  },\n  compute: function(t2, points, _3d) {\n    if (t2 === 0) {\n      points[0].t = 0;\n      return points[0];\n    }\n    const order = points.length - 1;\n    if (t2 === 1) {\n      points[order].t = 1;\n      return points[order];\n    }\n    const mt = 1 - t2;\n    let p = points;\n    if (order === 0) {\n      points[0].t = t2;\n      return points[0];\n    }\n    if (order === 1) {\n      const ret = {\n        x: mt * p[0].x + t2 * p[1].x,\n        y: mt * p[0].y + t2 * p[1].y,\n        t: t2\n      };\n      if (_3d) {\n        ret.z = mt * p[0].z + t2 * p[1].z;\n      }\n      return ret;\n    }\n    if (order < 4) {\n      let mt2 = mt * mt, t22 = t2 * t2, a, b, c, d = 0;\n      if (order === 2) {\n        p = [p[0], p[1], p[2], ZERO];\n        a = mt2;\n        b = mt * t2 * 2;\n        c = t22;\n      } else if (order === 3) {\n        a = mt2 * mt;\n        b = mt2 * t2 * 3;\n        c = mt * t22 * 3;\n        d = t2 * t22;\n      }\n      const ret = {\n        x: a * p[0].x + b * p[1].x + c * p[2].x + d * p[3].x,\n        y: a * p[0].y + b * p[1].y + c * p[2].y + d * p[3].y,\n        t: t2\n      };\n      if (_3d) {\n        ret.z = a * p[0].z + b * p[1].z + c * p[2].z + d * p[3].z;\n      }\n      return ret;\n    }\n    const dCpts = JSON.parse(JSON.stringify(points));\n    while (dCpts.length > 1) {\n      for (let i = 0; i < dCpts.length - 1; i++) {\n        dCpts[i] = {\n          x: dCpts[i].x + (dCpts[i + 1].x - dCpts[i].x) * t2,\n          y: dCpts[i].y + (dCpts[i + 1].y - dCpts[i].y) * t2\n        };\n        if (typeof dCpts[i].z !== \"undefined\") {\n          dCpts[i] = dCpts[i].z + (dCpts[i + 1].z - dCpts[i].z) * t2;\n        }\n      }\n      dCpts.splice(dCpts.length - 1, 1);\n    }\n    dCpts[0].t = t2;\n    return dCpts[0];\n  },\n  computeWithRatios: function(t2, points, ratios, _3d) {\n    const mt = 1 - t2, r = ratios, p = points;\n    let f1 = r[0], f2 = r[1], f3 = r[2], f4 = r[3], d;\n    f1 *= mt;\n    f2 *= t2;\n    if (p.length === 2) {\n      d = f1 + f2;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z) / d,\n        t: t2\n      };\n    }\n    f1 *= mt;\n    f2 *= 2 * mt;\n    f3 *= t2 * t2;\n    if (p.length === 3) {\n      d = f1 + f2 + f3;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z) / d,\n        t: t2\n      };\n    }\n    f1 *= mt;\n    f2 *= 1.5 * mt;\n    f3 *= 3 * mt;\n    f4 *= t2 * t2 * t2;\n    if (p.length === 4) {\n      d = f1 + f2 + f3 + f4;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x + f4 * p[3].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y + f4 * p[3].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z + f4 * p[3].z) / d,\n        t: t2\n      };\n    }\n  },\n  derive: function(points, _3d) {\n    const dpoints = [];\n    for (let p = points, d = p.length, c = d - 1; d > 1; d--, c--) {\n      const list = [];\n      for (let j = 0, dpt; j < c; j++) {\n        dpt = {\n          x: c * (p[j + 1].x - p[j].x),\n          y: c * (p[j + 1].y - p[j].y)\n        };\n        if (_3d) {\n          dpt.z = c * (p[j + 1].z - p[j].z);\n        }\n        list.push(dpt);\n      }\n      dpoints.push(list);\n      p = list;\n    }\n    return dpoints;\n  },\n  between: function(v, m, M) {\n    return m <= v && v <= M || utils.approximately(v, m) || utils.approximately(v, M);\n  },\n  approximately: function(a, b, precision) {\n    return abs(a - b) <= (precision || epsilon);\n  },\n  length: function(derivativeFn) {\n    const z = 0.5, len = utils.Tvalues.length;\n    let sum = 0;\n    for (let i = 0, t2; i < len; i++) {\n      t2 = z * utils.Tvalues[i] + z;\n      sum += utils.Cvalues[i] * utils.arcfn(t2, derivativeFn);\n    }\n    return z * sum;\n  },\n  map: function(v, ds, de, ts, te) {\n    const d1 = de - ds, d2 = te - ts, v2 = v - ds, r = v2 / d1;\n    return ts + d2 * r;\n  },\n  lerp: function(r, v1, v2) {\n    const ret = {\n      x: v1.x + r * (v2.x - v1.x),\n      y: v1.y + r * (v2.y - v1.y)\n    };\n    if (v1.z !== void 0 && v2.z !== void 0) {\n      ret.z = v1.z + r * (v2.z - v1.z);\n    }\n    return ret;\n  },\n  pointToString: function(p) {\n    let s = p.x + \"/\" + p.y;\n    if (typeof p.z !== \"undefined\") {\n      s += \"/\" + p.z;\n    }\n    return s;\n  },\n  pointsToString: function(points) {\n    return \"[\" + points.map(utils.pointToString).join(\", \") + \"]\";\n  },\n  copy: function(obj) {\n    return JSON.parse(JSON.stringify(obj));\n  },\n  angle: function(o, v1, v2) {\n    const dx1 = v1.x - o.x, dy1 = v1.y - o.y, dx2 = v2.x - o.x, dy2 = v2.y - o.y, cross = dx1 * dy2 - dy1 * dx2, dot = dx1 * dx2 + dy1 * dy2;\n    return atan2(cross, dot);\n  },\n  round: function(v, d) {\n    const s = \"\" + v;\n    const pos = s.indexOf(\".\");\n    return parseFloat(s.substring(0, pos + 1 + d));\n  },\n  dist: function(p1, p2) {\n    const dx = p1.x - p2.x, dy = p1.y - p2.y;\n    return sqrt(dx * dx + dy * dy);\n  },\n  closest: function(LUT, point) {\n    let mdist = pow(2, 63), mpos, d;\n    LUT.forEach(function(p, idx) {\n      d = utils.dist(point, p);\n      if (d < mdist) {\n        mdist = d;\n        mpos = idx;\n      }\n    });\n    return { mdist, mpos };\n  },\n  abcratio: function(t2, n) {\n    if (n !== 2 && n !== 3) {\n      return false;\n    }\n    if (typeof t2 === \"undefined\") {\n      t2 = 0.5;\n    } else if (t2 === 0 || t2 === 1) {\n      return t2;\n    }\n    const bottom = pow(t2, n) + pow(1 - t2, n), top = bottom - 1;\n    return abs(top / bottom);\n  },\n  projectionratio: function(t2, n) {\n    if (n !== 2 && n !== 3) {\n      return false;\n    }\n    if (typeof t2 === \"undefined\") {\n      t2 = 0.5;\n    } else if (t2 === 0 || t2 === 1) {\n      return t2;\n    }\n    const top = pow(1 - t2, n), bottom = pow(t2, n) + top;\n    return top / bottom;\n  },\n  lli8: function(x1, y1, x2, y2, x3, y3, x4, y4) {\n    const nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4), ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4), d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n    if (d == 0) {\n      return false;\n    }\n    return { x: nx / d, y: ny / d };\n  },\n  lli4: function(p1, p2, p3, p4) {\n    const x1 = p1.x, y1 = p1.y, x2 = p2.x, y2 = p2.y, x3 = p3.x, y3 = p3.y, x4 = p4.x, y4 = p4.y;\n    return utils.lli8(x1, y1, x2, y2, x3, y3, x4, y4);\n  },\n  lli: function(v1, v2) {\n    return utils.lli4(v1, v1.c, v2, v2.c);\n  },\n  makeline: function(p1, p2) {\n    return new Bezier(p1.x, p1.y, (p1.x + p2.x) / 2, (p1.y + p2.y) / 2, p2.x, p2.y);\n  },\n  findbbox: function(sections) {\n    let mx = nMax, my = nMax, MX = nMin, MY = nMin;\n    sections.forEach(function(s) {\n      const bbox = s.bbox();\n      if (mx > bbox.x.min)\n        mx = bbox.x.min;\n      if (my > bbox.y.min)\n        my = bbox.y.min;\n      if (MX < bbox.x.max)\n        MX = bbox.x.max;\n      if (MY < bbox.y.max)\n        MY = bbox.y.max;\n    });\n    return {\n      x: { min: mx, mid: (mx + MX) / 2, max: MX, size: MX - mx },\n      y: { min: my, mid: (my + MY) / 2, max: MY, size: MY - my }\n    };\n  },\n  shapeintersections: function(s1, bbox1, s2, bbox2, curveIntersectionThreshold) {\n    if (!utils.bboxoverlap(bbox1, bbox2))\n      return [];\n    const intersections = [];\n    const a1 = [s1.startcap, s1.forward, s1.back, s1.endcap];\n    const a2 = [s2.startcap, s2.forward, s2.back, s2.endcap];\n    a1.forEach(function(l1) {\n      if (l1.virtual)\n        return;\n      a2.forEach(function(l2) {\n        if (l2.virtual)\n          return;\n        const iss = l1.intersects(l2, curveIntersectionThreshold);\n        if (iss.length > 0) {\n          iss.c1 = l1;\n          iss.c2 = l2;\n          iss.s1 = s1;\n          iss.s2 = s2;\n          intersections.push(iss);\n        }\n      });\n    });\n    return intersections;\n  },\n  makeshape: function(forward, back, curveIntersectionThreshold) {\n    const bpl = back.points.length;\n    const fpl = forward.points.length;\n    const start = utils.makeline(back.points[bpl - 1], forward.points[0]);\n    const end = utils.makeline(forward.points[fpl - 1], back.points[0]);\n    const shape = {\n      startcap: start,\n      forward,\n      back,\n      endcap: end,\n      bbox: utils.findbbox([start, forward, back, end])\n    };\n    shape.intersections = function(s2) {\n      return utils.shapeintersections(shape, shape.bbox, s2, s2.bbox, curveIntersectionThreshold);\n    };\n    return shape;\n  },\n  getminmax: function(curve, d, list) {\n    if (!list)\n      return { min: 0, max: 0 };\n    let min2 = nMax, max2 = nMin, t2, c;\n    if (list.indexOf(0) === -1) {\n      list = [0].concat(list);\n    }\n    if (list.indexOf(1) === -1) {\n      list.push(1);\n    }\n    for (let i = 0, len = list.length; i < len; i++) {\n      t2 = list[i];\n      c = curve.get(t2);\n      if (c[d] < min2) {\n        min2 = c[d];\n      }\n      if (c[d] > max2) {\n        max2 = c[d];\n      }\n    }\n    return { min: min2, mid: (min2 + max2) / 2, max: max2, size: max2 - min2 };\n  },\n  align: function(points, line) {\n    const tx = line.p1.x, ty = line.p1.y, a = -atan2(line.p2.y - ty, line.p2.x - tx), d = function(v) {\n      return {\n        x: (v.x - tx) * cos(a) - (v.y - ty) * sin(a),\n        y: (v.x - tx) * sin(a) + (v.y - ty) * cos(a)\n      };\n    };\n    return points.map(d);\n  },\n  roots: function(points, line) {\n    line = line || { p1: { x: 0, y: 0 }, p2: { x: 1, y: 0 } };\n    const order = points.length - 1;\n    const aligned = utils.align(points, line);\n    const reduce = function(t2) {\n      return 0 <= t2 && t2 <= 1;\n    };\n    if (order === 2) {\n      const a2 = aligned[0].y, b2 = aligned[1].y, c2 = aligned[2].y, d2 = a2 - 2 * b2 + c2;\n      if (d2 !== 0) {\n        const m1 = -sqrt(b2 * b2 - a2 * c2), m2 = -a2 + b2, v12 = -(m1 + m2) / d2, v2 = -(-m1 + m2) / d2;\n        return [v12, v2].filter(reduce);\n      } else if (b2 !== c2 && d2 === 0) {\n        return [(2 * b2 - c2) / (2 * b2 - 2 * c2)].filter(reduce);\n      }\n      return [];\n    }\n    const pa = aligned[0].y, pb = aligned[1].y, pc = aligned[2].y, pd = aligned[3].y;\n    let d = -pa + 3 * pb - 3 * pc + pd, a = 3 * pa - 6 * pb + 3 * pc, b = -3 * pa + 3 * pb, c = pa;\n    if (utils.approximately(d, 0)) {\n      if (utils.approximately(a, 0)) {\n        if (utils.approximately(b, 0)) {\n          return [];\n        }\n        return [-c / b].filter(reduce);\n      }\n      const q3 = sqrt(b * b - 4 * a * c), a2 = 2 * a;\n      return [(q3 - b) / a2, (-b - q3) / a2].filter(reduce);\n    }\n    a /= d;\n    b /= d;\n    c /= d;\n    const p = (3 * b - a * a) / 3, p3 = p / 3, q = (2 * a * a * a - 9 * a * b + 27 * c) / 27, q2 = q / 2, discriminant = q2 * q2 + p3 * p3 * p3;\n    let u1, v1, x1, x2, x3;\n    if (discriminant < 0) {\n      const mp3 = -p / 3, mp33 = mp3 * mp3 * mp3, r = sqrt(mp33), t2 = -q / (2 * r), cosphi = t2 < -1 ? -1 : t2 > 1 ? 1 : t2, phi = acos(cosphi), crtr = crt(r), t1 = 2 * crtr;\n      x1 = t1 * cos(phi / 3) - a / 3;\n      x2 = t1 * cos((phi + tau) / 3) - a / 3;\n      x3 = t1 * cos((phi + 2 * tau) / 3) - a / 3;\n      return [x1, x2, x3].filter(reduce);\n    } else if (discriminant === 0) {\n      u1 = q2 < 0 ? crt(-q2) : -crt(q2);\n      x1 = 2 * u1 - a / 3;\n      x2 = -u1 - a / 3;\n      return [x1, x2].filter(reduce);\n    } else {\n      const sd = sqrt(discriminant);\n      u1 = crt(-q2 + sd);\n      v1 = crt(q2 + sd);\n      return [u1 - v1 - a / 3].filter(reduce);\n    }\n  },\n  droots: function(p) {\n    if (p.length === 3) {\n      const a = p[0], b = p[1], c = p[2], d = a - 2 * b + c;\n      if (d !== 0) {\n        const m1 = -sqrt(b * b - a * c), m2 = -a + b, v1 = -(m1 + m2) / d, v2 = -(-m1 + m2) / d;\n        return [v1, v2];\n      } else if (b !== c && d === 0) {\n        return [(2 * b - c) / (2 * (b - c))];\n      }\n      return [];\n    }\n    if (p.length === 2) {\n      const a = p[0], b = p[1];\n      if (a !== b) {\n        return [a / (a - b)];\n      }\n      return [];\n    }\n    return [];\n  },\n  curvature: function(t2, d1, d2, _3d, kOnly) {\n    let num, dnm, adk, dk, k = 0, r = 0;\n    const d = utils.compute(t2, d1);\n    const dd = utils.compute(t2, d2);\n    const qdsum = d.x * d.x + d.y * d.y;\n    if (_3d) {\n      num = sqrt(pow(d.y * dd.z - dd.y * d.z, 2) + pow(d.z * dd.x - dd.z * d.x, 2) + pow(d.x * dd.y - dd.x * d.y, 2));\n      dnm = pow(qdsum + d.z * d.z, 3 / 2);\n    } else {\n      num = d.x * dd.y - d.y * dd.x;\n      dnm = pow(qdsum, 3 / 2);\n    }\n    if (num === 0 || dnm === 0) {\n      return { k: 0, r: 0 };\n    }\n    k = num / dnm;\n    r = dnm / num;\n    if (!kOnly) {\n      const pk = utils.curvature(t2 - 1e-3, d1, d2, _3d, true).k;\n      const nk = utils.curvature(t2 + 1e-3, d1, d2, _3d, true).k;\n      dk = (nk - k + (k - pk)) / 2;\n      adk = (abs(nk - k) + abs(k - pk)) / 2;\n    }\n    return { k, r, dk, adk };\n  },\n  inflections: function(points) {\n    if (points.length < 4)\n      return [];\n    const p = utils.align(points, { p1: points[0], p2: points.slice(-1)[0] }), a = p[2].x * p[1].y, b = p[3].x * p[1].y, c = p[1].x * p[2].y, d = p[3].x * p[2].y, v1 = 18 * (-3 * a + 2 * b + 3 * c - d), v2 = 18 * (3 * a - b - 3 * c), v3 = 18 * (c - a);\n    if (utils.approximately(v1, 0)) {\n      if (!utils.approximately(v2, 0)) {\n        let t2 = -v3 / v2;\n        if (0 <= t2 && t2 <= 1)\n          return [t2];\n      }\n      return [];\n    }\n    const d2 = 2 * v1;\n    if (utils.approximately(d2, 0))\n      return [];\n    const trm = v2 * v2 - 4 * v1 * v3;\n    if (trm < 0)\n      return [];\n    const sq = Math.sqrt(trm);\n    return [(sq - v2) / d2, -(v2 + sq) / d2].filter(function(r) {\n      return 0 <= r && r <= 1;\n    });\n  },\n  bboxoverlap: function(b1, b2) {\n    const dims = [\"x\", \"y\"], len = dims.length;\n    for (let i = 0, dim, l, t2, d; i < len; i++) {\n      dim = dims[i];\n      l = b1[dim].mid;\n      t2 = b2[dim].mid;\n      d = (b1[dim].size + b2[dim].size) / 2;\n      if (abs(l - t2) >= d)\n        return false;\n    }\n    return true;\n  },\n  expandbox: function(bbox, _bbox) {\n    if (_bbox.x.min < bbox.x.min) {\n      bbox.x.min = _bbox.x.min;\n    }\n    if (_bbox.y.min < bbox.y.min) {\n      bbox.y.min = _bbox.y.min;\n    }\n    if (_bbox.z && _bbox.z.min < bbox.z.min) {\n      bbox.z.min = _bbox.z.min;\n    }\n    if (_bbox.x.max > bbox.x.max) {\n      bbox.x.max = _bbox.x.max;\n    }\n    if (_bbox.y.max > bbox.y.max) {\n      bbox.y.max = _bbox.y.max;\n    }\n    if (_bbox.z && _bbox.z.max > bbox.z.max) {\n      bbox.z.max = _bbox.z.max;\n    }\n    bbox.x.mid = (bbox.x.min + bbox.x.max) / 2;\n    bbox.y.mid = (bbox.y.min + bbox.y.max) / 2;\n    if (bbox.z) {\n      bbox.z.mid = (bbox.z.min + bbox.z.max) / 2;\n    }\n    bbox.x.size = bbox.x.max - bbox.x.min;\n    bbox.y.size = bbox.y.max - bbox.y.min;\n    if (bbox.z) {\n      bbox.z.size = bbox.z.max - bbox.z.min;\n    }\n  },\n  pairiteration: function(c1, c2, curveIntersectionThreshold) {\n    const c1b = c1.bbox(), c2b = c2.bbox(), r = 1e5, threshold = curveIntersectionThreshold || 0.5;\n    if (c1b.x.size + c1b.y.size < threshold && c2b.x.size + c2b.y.size < threshold) {\n      return [\n        (r * (c1._t1 + c1._t2) / 2 | 0) / r + \"/\" + (r * (c2._t1 + c2._t2) / 2 | 0) / r\n      ];\n    }\n    let cc1 = c1.split(0.5), cc2 = c2.split(0.5), pairs = [\n      { left: cc1.left, right: cc2.left },\n      { left: cc1.left, right: cc2.right },\n      { left: cc1.right, right: cc2.right },\n      { left: cc1.right, right: cc2.left }\n    ];\n    pairs = pairs.filter(function(pair) {\n      return utils.bboxoverlap(pair.left.bbox(), pair.right.bbox());\n    });\n    let results = [];\n    if (pairs.length === 0)\n      return results;\n    pairs.forEach(function(pair) {\n      results = results.concat(utils.pairiteration(pair.left, pair.right, threshold));\n    });\n    results = results.filter(function(v, i) {\n      return results.indexOf(v) === i;\n    });\n    return results;\n  },\n  getccenter: function(p1, p2, p3) {\n    const dx1 = p2.x - p1.x, dy1 = p2.y - p1.y, dx2 = p3.x - p2.x, dy2 = p3.y - p2.y, dx1p = dx1 * cos(quart) - dy1 * sin(quart), dy1p = dx1 * sin(quart) + dy1 * cos(quart), dx2p = dx2 * cos(quart) - dy2 * sin(quart), dy2p = dx2 * sin(quart) + dy2 * cos(quart), mx1 = (p1.x + p2.x) / 2, my1 = (p1.y + p2.y) / 2, mx2 = (p2.x + p3.x) / 2, my2 = (p2.y + p3.y) / 2, mx1n = mx1 + dx1p, my1n = my1 + dy1p, mx2n = mx2 + dx2p, my2n = my2 + dy2p, arc = utils.lli8(mx1, my1, mx1n, my1n, mx2, my2, mx2n, my2n), r = utils.dist(arc, p1);\n    let s = atan2(p1.y - arc.y, p1.x - arc.x), m = atan2(p2.y - arc.y, p2.x - arc.x), e = atan2(p3.y - arc.y, p3.x - arc.x), _;\n    if (s < e) {\n      if (s > m || m > e) {\n        s += tau;\n      }\n      if (s > e) {\n        _ = e;\n        e = s;\n        s = _;\n      }\n    } else {\n      if (e < m && m < s) {\n        _ = e;\n        e = s;\n        s = _;\n      } else {\n        e += tau;\n      }\n    }\n    arc.s = s;\n    arc.e = e;\n    arc.r = r;\n    return arc;\n  },\n  numberSort: function(a, b) {\n    return a - b;\n  }\n};\n\n// src/poly-bezier.js\nvar PolyBezier = class {\n  constructor(curves) {\n    this.curves = [];\n    this._3d = false;\n    if (!!curves) {\n      this.curves = curves;\n      this._3d = this.curves[0]._3d;\n    }\n  }\n  valueOf() {\n    return this.toString();\n  }\n  toString() {\n    return \"[\" + this.curves.map(function(curve) {\n      return utils.pointsToString(curve.points);\n    }).join(\", \") + \"]\";\n  }\n  addCurve(curve) {\n    this.curves.push(curve);\n    this._3d = this._3d || curve._3d;\n  }\n  length() {\n    return this.curves.map(function(v) {\n      return v.length();\n    }).reduce(function(a, b) {\n      return a + b;\n    });\n  }\n  curve(idx) {\n    return this.curves[idx];\n  }\n  bbox() {\n    const c = this.curves;\n    var bbox = c[0].bbox();\n    for (var i = 1; i < c.length; i++) {\n      utils.expandbox(bbox, c[i].bbox());\n    }\n    return bbox;\n  }\n  offset(d) {\n    const offset = [];\n    this.curves.forEach(function(v) {\n      offset.push(...v.offset(d));\n    });\n    return new PolyBezier(offset);\n  }\n};\n\n// src/bezier.js\nvar { abs: abs2, min, max, cos: cos2, sin: sin2, acos: acos2, sqrt: sqrt2 } = Math;\nvar pi2 = Math.PI;\nvar Bezier = class {\n  constructor(coords) {\n    let args = coords && coords.forEach ? coords : Array.from(arguments).slice();\n    let coordlen = false;\n    if (typeof args[0] === \"object\") {\n      coordlen = args.length;\n      const newargs = [];\n      args.forEach(function(point2) {\n        [\"x\", \"y\", \"z\"].forEach(function(d) {\n          if (typeof point2[d] !== \"undefined\") {\n            newargs.push(point2[d]);\n          }\n        });\n      });\n      args = newargs;\n    }\n    let higher = false;\n    const len = args.length;\n    if (coordlen) {\n      if (coordlen > 4) {\n        if (arguments.length !== 1) {\n          throw new Error(\"Only new Bezier(point[]) is accepted for 4th and higher order curves\");\n        }\n        higher = true;\n      }\n    } else {\n      if (len !== 6 && len !== 8 && len !== 9 && len !== 12) {\n        if (arguments.length !== 1) {\n          throw new Error(\"Only new Bezier(point[]) is accepted for 4th and higher order curves\");\n        }\n      }\n    }\n    const _3d = this._3d = !higher && (len === 9 || len === 12) || coords && coords[0] && typeof coords[0].z !== \"undefined\";\n    const points = this.points = [];\n    for (let idx = 0, step = _3d ? 3 : 2; idx < len; idx += step) {\n      var point = {\n        x: args[idx],\n        y: args[idx + 1]\n      };\n      if (_3d) {\n        point.z = args[idx + 2];\n      }\n      points.push(point);\n    }\n    const order = this.order = points.length - 1;\n    const dims = this.dims = [\"x\", \"y\"];\n    if (_3d)\n      dims.push(\"z\");\n    this.dimlen = dims.length;\n    const aligned = utils.align(points, { p1: points[0], p2: points[order] });\n    const baselength = utils.dist(points[0], points[order]);\n    this._linear = aligned.reduce((t2, p) => t2 + abs2(p.y), 0) < baselength / 50;\n    this._lut = [];\n    this._t1 = 0;\n    this._t2 = 1;\n    this.update();\n  }\n  static quadraticFromPoints(p1, p2, p3, t2) {\n    if (typeof t2 === \"undefined\") {\n      t2 = 0.5;\n    }\n    if (t2 === 0) {\n      return new Bezier(p2, p2, p3);\n    }\n    if (t2 === 1) {\n      return new Bezier(p1, p2, p2);\n    }\n    const abc = Bezier.getABC(2, p1, p2, p3, t2);\n    return new Bezier(p1, abc.A, p3);\n  }\n  static cubicFromPoints(S, B, E, t2, d1) {\n    if (typeof t2 === \"undefined\") {\n      t2 = 0.5;\n    }\n    const abc = Bezier.getABC(3, S, B, E, t2);\n    if (typeof d1 === \"undefined\") {\n      d1 = utils.dist(B, abc.C);\n    }\n    const d2 = d1 * (1 - t2) / t2;\n    const selen = utils.dist(S, E), lx = (E.x - S.x) / selen, ly = (E.y - S.y) / selen, bx1 = d1 * lx, by1 = d1 * ly, bx2 = d2 * lx, by2 = d2 * ly;\n    const e1 = { x: B.x - bx1, y: B.y - by1 }, e2 = { x: B.x + bx2, y: B.y + by2 }, A = abc.A, v1 = { x: A.x + (e1.x - A.x) / (1 - t2), y: A.y + (e1.y - A.y) / (1 - t2) }, v2 = { x: A.x + (e2.x - A.x) / t2, y: A.y + (e2.y - A.y) / t2 }, nc1 = { x: S.x + (v1.x - S.x) / t2, y: S.y + (v1.y - S.y) / t2 }, nc2 = {\n      x: E.x + (v2.x - E.x) / (1 - t2),\n      y: E.y + (v2.y - E.y) / (1 - t2)\n    };\n    return new Bezier(S, nc1, nc2, E);\n  }\n  static getUtils() {\n    return utils;\n  }\n  getUtils() {\n    return Bezier.getUtils();\n  }\n  static get PolyBezier() {\n    return PolyBezier;\n  }\n  valueOf() {\n    return this.toString();\n  }\n  toString() {\n    return utils.pointsToString(this.points);\n  }\n  toSVG() {\n    if (this._3d)\n      return false;\n    const p = this.points, x = p[0].x, y = p[0].y, s = [\"M\", x, y, this.order === 2 ? \"Q\" : \"C\"];\n    for (let i = 1, last = p.length; i < last; i++) {\n      s.push(p[i].x);\n      s.push(p[i].y);\n    }\n    return s.join(\" \");\n  }\n  setRatios(ratios) {\n    if (ratios.length !== this.points.length) {\n      throw new Error(\"incorrect number of ratio values\");\n    }\n    this.ratios = ratios;\n    this._lut = [];\n  }\n  verify() {\n    const print = this.coordDigest();\n    if (print !== this._print) {\n      this._print = print;\n      this.update();\n    }\n  }\n  coordDigest() {\n    return this.points.map(function(c, pos) {\n      return \"\" + pos + c.x + c.y + (c.z ? c.z : 0);\n    }).join(\"\");\n  }\n  update() {\n    this._lut = [];\n    this.dpoints = utils.derive(this.points, this._3d);\n    this.computedirection();\n  }\n  computedirection() {\n    const points = this.points;\n    const angle = utils.angle(points[0], points[this.order], points[1]);\n    this.clockwise = angle > 0;\n  }\n  length() {\n    return utils.length(this.derivative.bind(this));\n  }\n  static getABC(order = 2, S, B, E, t2 = 0.5) {\n    const u = utils.projectionratio(t2, order), um = 1 - u, C = {\n      x: u * S.x + um * E.x,\n      y: u * S.y + um * E.y\n    }, s = utils.abcratio(t2, order), A = {\n      x: B.x + (B.x - C.x) / s,\n      y: B.y + (B.y - C.y) / s\n    };\n    return { A, B, C, S, E };\n  }\n  getABC(t2, B) {\n    B = B || this.get(t2);\n    let S = this.points[0];\n    let E = this.points[this.order];\n    return Bezier.getABC(this.order, S, B, E, t2);\n  }\n  getLUT(steps) {\n    this.verify();\n    steps = steps || 100;\n    if (this._lut.length === steps + 1) {\n      return this._lut;\n    }\n    this._lut = [];\n    steps++;\n    this._lut = [];\n    for (let i = 0, p, t2; i < steps; i++) {\n      t2 = i / (steps - 1);\n      p = this.compute(t2);\n      p.t = t2;\n      this._lut.push(p);\n    }\n    return this._lut;\n  }\n  on(point, error) {\n    error = error || 5;\n    const lut = this.getLUT(), hits = [];\n    for (let i = 0, c, t2 = 0; i < lut.length; i++) {\n      c = lut[i];\n      if (utils.dist(c, point) < error) {\n        hits.push(c);\n        t2 += i / lut.length;\n      }\n    }\n    if (!hits.length)\n      return false;\n    return t /= hits.length;\n  }\n  project(point) {\n    const LUT = this.getLUT(), l = LUT.length - 1, closest = utils.closest(LUT, point), mpos = closest.mpos, t1 = (mpos - 1) / l, t2 = (mpos + 1) / l, step = 0.1 / l;\n    let mdist = closest.mdist, t3 = t1, ft = t3, p;\n    mdist += 1;\n    for (let d; t3 < t2 + step; t3 += step) {\n      p = this.compute(t3);\n      d = utils.dist(point, p);\n      if (d < mdist) {\n        mdist = d;\n        ft = t3;\n      }\n    }\n    ft = ft < 0 ? 0 : ft > 1 ? 1 : ft;\n    p = this.compute(ft);\n    p.t = ft;\n    p.d = mdist;\n    return p;\n  }\n  get(t2) {\n    return this.compute(t2);\n  }\n  point(idx) {\n    return this.points[idx];\n  }\n  compute(t2) {\n    if (this.ratios) {\n      return utils.computeWithRatios(t2, this.points, this.ratios, this._3d);\n    }\n    return utils.compute(t2, this.points, this._3d, this.ratios);\n  }\n  raise() {\n    const p = this.points, np = [p[0]], k = p.length;\n    for (let i = 1, pi3, pim; i < k; i++) {\n      pi3 = p[i];\n      pim = p[i - 1];\n      np[i] = {\n        x: (k - i) / k * pi3.x + i / k * pim.x,\n        y: (k - i) / k * pi3.y + i / k * pim.y\n      };\n    }\n    np[k] = p[k - 1];\n    return new Bezier(np);\n  }\n  derivative(t2) {\n    return utils.compute(t2, this.dpoints[0], this._3d);\n  }\n  dderivative(t2) {\n    return utils.compute(t2, this.dpoints[1], this._3d);\n  }\n  align() {\n    let p = this.points;\n    return new Bezier(utils.align(p, { p1: p[0], p2: p[p.length - 1] }));\n  }\n  curvature(t2) {\n    return utils.curvature(t2, this.dpoints[0], this.dpoints[1], this._3d);\n  }\n  inflections() {\n    return utils.inflections(this.points);\n  }\n  normal(t2) {\n    return this._3d ? this.__normal3(t2) : this.__normal2(t2);\n  }\n  __normal2(t2) {\n    const d = this.derivative(t2);\n    const q = sqrt2(d.x * d.x + d.y * d.y);\n    return { t: t2, x: -d.y / q, y: d.x / q };\n  }\n  __normal3(t2) {\n    const r1 = this.derivative(t2), r2 = this.derivative(t2 + 0.01), q1 = sqrt2(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z), q2 = sqrt2(r2.x * r2.x + r2.y * r2.y + r2.z * r2.z);\n    r1.x /= q1;\n    r1.y /= q1;\n    r1.z /= q1;\n    r2.x /= q2;\n    r2.y /= q2;\n    r2.z /= q2;\n    const c = {\n      x: r2.y * r1.z - r2.z * r1.y,\n      y: r2.z * r1.x - r2.x * r1.z,\n      z: r2.x * r1.y - r2.y * r1.x\n    };\n    const m = sqrt2(c.x * c.x + c.y * c.y + c.z * c.z);\n    c.x /= m;\n    c.y /= m;\n    c.z /= m;\n    const R = [\n      c.x * c.x,\n      c.x * c.y - c.z,\n      c.x * c.z + c.y,\n      c.x * c.y + c.z,\n      c.y * c.y,\n      c.y * c.z - c.x,\n      c.x * c.z - c.y,\n      c.y * c.z + c.x,\n      c.z * c.z\n    ];\n    const n = {\n      t: t2,\n      x: R[0] * r1.x + R[1] * r1.y + R[2] * r1.z,\n      y: R[3] * r1.x + R[4] * r1.y + R[5] * r1.z,\n      z: R[6] * r1.x + R[7] * r1.y + R[8] * r1.z\n    };\n    return n;\n  }\n  hull(t2) {\n    let p = this.points, _p = [], q = [], idx = 0;\n    q[idx++] = p[0];\n    q[idx++] = p[1];\n    q[idx++] = p[2];\n    if (this.order === 3) {\n      q[idx++] = p[3];\n    }\n    while (p.length > 1) {\n      _p = [];\n      for (let i = 0, pt, l = p.length - 1; i < l; i++) {\n        pt = utils.lerp(t2, p[i], p[i + 1]);\n        q[idx++] = pt;\n        _p.push(pt);\n      }\n      p = _p;\n    }\n    return q;\n  }\n  split(t1, t2) {\n    if (t1 === 0 && !!t2) {\n      return this.split(t2).left;\n    }\n    if (t2 === 1) {\n      return this.split(t1).right;\n    }\n    const q = this.hull(t1);\n    const result = {\n      left: this.order === 2 ? new Bezier([q[0], q[3], q[5]]) : new Bezier([q[0], q[4], q[7], q[9]]),\n      right: this.order === 2 ? new Bezier([q[5], q[4], q[2]]) : new Bezier([q[9], q[8], q[6], q[3]]),\n      span: q\n    };\n    result.left._t1 = utils.map(0, 0, 1, this._t1, this._t2);\n    result.left._t2 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t1 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t2 = utils.map(1, 0, 1, this._t1, this._t2);\n    if (!t2) {\n      return result;\n    }\n    t2 = utils.map(t2, t1, 1, 0, 1);\n    return result.right.split(t2).left;\n  }\n  extrema() {\n    const result = {};\n    let roots = [];\n    this.dims.forEach(function(dim) {\n      let mfn = function(v) {\n        return v[dim];\n      };\n      let p = this.dpoints[0].map(mfn);\n      result[dim] = utils.droots(p);\n      if (this.order === 3) {\n        p = this.dpoints[1].map(mfn);\n        result[dim] = result[dim].concat(utils.droots(p));\n      }\n      result[dim] = result[dim].filter(function(t2) {\n        return t2 >= 0 && t2 <= 1;\n      });\n      roots = roots.concat(result[dim].sort(utils.numberSort));\n    }.bind(this));\n    result.values = roots.sort(utils.numberSort).filter(function(v, idx) {\n      return roots.indexOf(v) === idx;\n    });\n    return result;\n  }\n  bbox() {\n    const extrema = this.extrema(), result = {};\n    this.dims.forEach(function(d) {\n      result[d] = utils.getminmax(this, d, extrema[d]);\n    }.bind(this));\n    return result;\n  }\n  overlaps(curve) {\n    const lbbox = this.bbox(), tbbox = curve.bbox();\n    return utils.bboxoverlap(lbbox, tbbox);\n  }\n  offset(t2, d) {\n    if (typeof d !== \"undefined\") {\n      const c = this.get(t2), n = this.normal(t2);\n      const ret = {\n        c,\n        n,\n        x: c.x + n.x * d,\n        y: c.y + n.y * d\n      };\n      if (this._3d) {\n        ret.z = c.z + n.z * d;\n      }\n      return ret;\n    }\n    if (this._linear) {\n      const nv = this.normal(0), coords = this.points.map(function(p) {\n        const ret = {\n          x: p.x + t2 * nv.x,\n          y: p.y + t2 * nv.y\n        };\n        if (p.z && nv.z) {\n          ret.z = p.z + t2 * nv.z;\n        }\n        return ret;\n      });\n      return [new Bezier(coords)];\n    }\n    return this.reduce().map(function(s) {\n      if (s._linear) {\n        return s.offset(t2)[0];\n      }\n      return s.scale(t2);\n    });\n  }\n  simple() {\n    if (this.order === 3) {\n      const a1 = utils.angle(this.points[0], this.points[3], this.points[1]);\n      const a2 = utils.angle(this.points[0], this.points[3], this.points[2]);\n      if (a1 > 0 && a2 < 0 || a1 < 0 && a2 > 0)\n        return false;\n    }\n    const n1 = this.normal(0);\n    const n2 = this.normal(1);\n    let s = n1.x * n2.x + n1.y * n2.y;\n    if (this._3d) {\n      s += n1.z * n2.z;\n    }\n    return abs2(acos2(s)) < pi2 / 3;\n  }\n  reduce() {\n    let i, t1 = 0, t2 = 0, step = 0.01, segment, pass1 = [], pass2 = [];\n    let extrema = this.extrema().values;\n    if (extrema.indexOf(0) === -1) {\n      extrema = [0].concat(extrema);\n    }\n    if (extrema.indexOf(1) === -1) {\n      extrema.push(1);\n    }\n    for (t1 = extrema[0], i = 1; i < extrema.length; i++) {\n      t2 = extrema[i];\n      segment = this.split(t1, t2);\n      segment._t1 = t1;\n      segment._t2 = t2;\n      pass1.push(segment);\n      t1 = t2;\n    }\n    pass1.forEach(function(p1) {\n      t1 = 0;\n      t2 = 0;\n      while (t2 <= 1) {\n        for (t2 = t1 + step; t2 <= 1 + step; t2 += step) {\n          segment = p1.split(t1, t2);\n          if (!segment.simple()) {\n            t2 -= step;\n            if (abs2(t1 - t2) < step) {\n              return [];\n            }\n            segment = p1.split(t1, t2);\n            segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n            segment._t2 = utils.map(t2, 0, 1, p1._t1, p1._t2);\n            pass2.push(segment);\n            t1 = t2;\n            break;\n          }\n        }\n      }\n      if (t1 < 1) {\n        segment = p1.split(t1, 1);\n        segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n        segment._t2 = p1._t2;\n        pass2.push(segment);\n      }\n    });\n    return pass2;\n  }\n  translate(v, d1, d2) {\n    d2 = typeof d2 === \"number\" ? d2 : d1;\n    const o = this.order;\n    let d = this.points.map((_, i) => (1 - i / o) * d1 + i / o * d2);\n    return new Bezier(this.points.map((p, i) => ({\n      x: p.x + v.x * d[i],\n      y: p.y + v.y * d[i]\n    })));\n  }\n  scale(d) {\n    const order = this.order;\n    let distanceFn = false;\n    if (typeof d === \"function\") {\n      distanceFn = d;\n    }\n    if (distanceFn && order === 2) {\n      return this.raise().scale(distanceFn);\n    }\n    const clockwise = this.clockwise;\n    const points = this.points;\n    if (this._linear) {\n      return this.translate(this.normal(0), distanceFn ? distanceFn(0) : d, distanceFn ? distanceFn(1) : d);\n    }\n    const r1 = distanceFn ? distanceFn(0) : d;\n    const r2 = distanceFn ? distanceFn(1) : d;\n    const v = [this.offset(0, 10), this.offset(1, 10)];\n    const np = [];\n    const o = utils.lli4(v[0], v[0].c, v[1], v[1].c);\n    if (!o) {\n      throw new Error(\"cannot scale this curve. Try reducing it first.\");\n    }\n    [0, 1].forEach(function(t2) {\n      const p = np[t2 * order] = utils.copy(points[t2 * order]);\n      p.x += (t2 ? r2 : r1) * v[t2].n.x;\n      p.y += (t2 ? r2 : r1) * v[t2].n.y;\n    });\n    if (!distanceFn) {\n      [0, 1].forEach((t2) => {\n        if (order === 2 && !!t2)\n          return;\n        const p = np[t2 * order];\n        const d2 = this.derivative(t2);\n        const p2 = { x: p.x + d2.x, y: p.y + d2.y };\n        np[t2 + 1] = utils.lli4(p, p2, o, points[t2 + 1]);\n      });\n      return new Bezier(np);\n    }\n    [0, 1].forEach(function(t2) {\n      if (order === 2 && !!t2)\n        return;\n      var p = points[t2 + 1];\n      var ov = {\n        x: p.x - o.x,\n        y: p.y - o.y\n      };\n      var rc = distanceFn ? distanceFn((t2 + 1) / order) : d;\n      if (distanceFn && !clockwise)\n        rc = -rc;\n      var m = sqrt2(ov.x * ov.x + ov.y * ov.y);\n      ov.x /= m;\n      ov.y /= m;\n      np[t2 + 1] = {\n        x: p.x + rc * ov.x,\n        y: p.y + rc * ov.y\n      };\n    });\n    return new Bezier(np);\n  }\n  outline(d1, d2, d3, d4) {\n    d2 = d2 === void 0 ? d1 : d2;\n    if (this._linear) {\n      const n = this.normal(0);\n      const start = this.points[0];\n      const end = this.points[this.points.length - 1];\n      let s, mid, e;\n      if (d3 === void 0) {\n        d3 = d1;\n        d4 = d2;\n      }\n      s = { x: start.x + n.x * d1, y: start.y + n.y * d1 };\n      e = { x: end.x + n.x * d3, y: end.y + n.y * d3 };\n      mid = { x: (s.x + e.x) / 2, y: (s.y + e.y) / 2 };\n      const fline = [s, mid, e];\n      s = { x: start.x - n.x * d2, y: start.y - n.y * d2 };\n      e = { x: end.x - n.x * d4, y: end.y - n.y * d4 };\n      mid = { x: (s.x + e.x) / 2, y: (s.y + e.y) / 2 };\n      const bline = [e, mid, s];\n      const ls2 = utils.makeline(bline[2], fline[0]);\n      const le2 = utils.makeline(fline[2], bline[0]);\n      const segments2 = [ls2, new Bezier(fline), le2, new Bezier(bline)];\n      return new PolyBezier(segments2);\n    }\n    const reduced = this.reduce(), len = reduced.length, fcurves = [];\n    let bcurves = [], p, alen = 0, tlen = this.length();\n    const graduated = typeof d3 !== \"undefined\" && typeof d4 !== \"undefined\";\n    function linearDistanceFunction(s, e, tlen2, alen2, slen) {\n      return function(v) {\n        const f1 = alen2 / tlen2, f2 = (alen2 + slen) / tlen2, d = e - s;\n        return utils.map(v, 0, 1, s + f1 * d, s + f2 * d);\n      };\n    }\n    reduced.forEach(function(segment) {\n      const slen = segment.length();\n      if (graduated) {\n        fcurves.push(segment.scale(linearDistanceFunction(d1, d3, tlen, alen, slen)));\n        bcurves.push(segment.scale(linearDistanceFunction(-d2, -d4, tlen, alen, slen)));\n      } else {\n        fcurves.push(segment.scale(d1));\n        bcurves.push(segment.scale(-d2));\n      }\n      alen += slen;\n    });\n    bcurves = bcurves.map(function(s) {\n      p = s.points;\n      if (p[3]) {\n        s.points = [p[3], p[2], p[1], p[0]];\n      } else {\n        s.points = [p[2], p[1], p[0]];\n      }\n      return s;\n    }).reverse();\n    const fs = fcurves[0].points[0], fe = fcurves[len - 1].points[fcurves[len - 1].points.length - 1], bs = bcurves[len - 1].points[bcurves[len - 1].points.length - 1], be = bcurves[0].points[0], ls = utils.makeline(bs, fs), le = utils.makeline(fe, be), segments = [ls].concat(fcurves).concat([le]).concat(bcurves);\n    return new PolyBezier(segments);\n  }\n  outlineshapes(d1, d2, curveIntersectionThreshold) {\n    d2 = d2 || d1;\n    const outline = this.outline(d1, d2).curves;\n    const shapes = [];\n    for (let i = 1, len = outline.length; i < len / 2; i++) {\n      const shape = utils.makeshape(outline[i], outline[len - i], curveIntersectionThreshold);\n      shape.startcap.virtual = i > 1;\n      shape.endcap.virtual = i < len / 2 - 1;\n      shapes.push(shape);\n    }\n    return shapes;\n  }\n  intersects(curve, curveIntersectionThreshold) {\n    if (!curve)\n      return this.selfintersects(curveIntersectionThreshold);\n    if (curve.p1 && curve.p2) {\n      return this.lineIntersects(curve);\n    }\n    if (curve instanceof Bezier) {\n      curve = curve.reduce();\n    }\n    return this.curveintersects(this.reduce(), curve, curveIntersectionThreshold);\n  }\n  lineIntersects(line) {\n    const mx = min(line.p1.x, line.p2.x), my = min(line.p1.y, line.p2.y), MX = max(line.p1.x, line.p2.x), MY = max(line.p1.y, line.p2.y);\n    return utils.roots(this.points, line).filter((t2) => {\n      var p = this.get(t2);\n      return utils.between(p.x, mx, MX) && utils.between(p.y, my, MY);\n    });\n  }\n  selfintersects(curveIntersectionThreshold) {\n    const reduced = this.reduce(), len = reduced.length - 2, results = [];\n    for (let i = 0, result, left, right; i < len; i++) {\n      left = reduced.slice(i, i + 1);\n      right = reduced.slice(i + 2);\n      result = this.curveintersects(left, right, curveIntersectionThreshold);\n      results.push(...result);\n    }\n    return results;\n  }\n  curveintersects(c1, c2, curveIntersectionThreshold) {\n    const pairs = [];\n    c1.forEach(function(l) {\n      c2.forEach(function(r) {\n        if (l.overlaps(r)) {\n          pairs.push({ left: l, right: r });\n        }\n      });\n    });\n    let intersections = [];\n    pairs.forEach(function(pair) {\n      const result = utils.pairiteration(pair.left, pair.right, curveIntersectionThreshold);\n      if (result.length > 0) {\n        intersections = intersections.concat(result);\n      }\n    });\n    return intersections;\n  }\n  arcs(errorThreshold) {\n    errorThreshold = errorThreshold || 0.5;\n    return this._iterate(errorThreshold, []);\n  }\n  _error(pc, np1, s, e) {\n    const q = (e - s) / 4, c1 = this.get(s + q), c2 = this.get(e - q), ref = utils.dist(pc, np1), d1 = utils.dist(pc, c1), d2 = utils.dist(pc, c2);\n    return abs2(d1 - ref) + abs2(d2 - ref);\n  }\n  _iterate(errorThreshold, circles) {\n    let t_s = 0, t_e = 1, safety;\n    do {\n      safety = 0;\n      t_e = 1;\n      let np1 = this.get(t_s), np2, np3, arc, prev_arc;\n      let curr_good = false, prev_good = false, done;\n      let t_m = t_e, prev_e = 1, step = 0;\n      do {\n        prev_good = curr_good;\n        prev_arc = arc;\n        t_m = (t_s + t_e) / 2;\n        step++;\n        np2 = this.get(t_m);\n        np3 = this.get(t_e);\n        arc = utils.getccenter(np1, np2, np3);\n        arc.interval = {\n          start: t_s,\n          end: t_e\n        };\n        let error = this._error(arc, np1, t_s, t_e);\n        curr_good = error <= errorThreshold;\n        done = prev_good && !curr_good;\n        if (!done)\n          prev_e = t_e;\n        if (curr_good) {\n          if (t_e >= 1) {\n            arc.interval.end = prev_e = 1;\n            prev_arc = arc;\n            if (t_e > 1) {\n              let d = {\n                x: arc.x + arc.r * cos2(arc.e),\n                y: arc.y + arc.r * sin2(arc.e)\n              };\n              arc.e += utils.angle({ x: arc.x, y: arc.y }, d, this.get(1));\n            }\n            break;\n          }\n          t_e = t_e + (t_e - t_s) / 2;\n        } else {\n          t_e = t_m;\n        }\n      } while (!done && safety++ < 100);\n      if (safety >= 100) {\n        break;\n      }\n      prev_arc = prev_arc ? prev_arc : arc;\n      circles.push(prev_arc);\n      t_s = prev_e;\n    } while (t_e < 1);\n    return circles;\n  }\n};\nmodule.exports = __toCommonJS(bezier_exports);\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n\n\n//# sourceURL=webpack://default/./node_modules/bezier-js/dist/bezier.cjs?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/dialog/webview/webview.ts");
/******/ 	exports["default"] = __webpack_exports__["default"];
/******/ 	
/******/ })()
;